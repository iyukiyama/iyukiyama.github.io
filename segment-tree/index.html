<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>线段树从入门到急停 | yukiyama</title><meta name="author" content="yukiyama,iyukiyama@outlook.com"><meta name="copyright" content="yukiyama"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="线段树是著名的用于高效求解「区间问题」的数据结构。「区间问题」即对于输入数组 nums ，在其上执行「区间求和」 、「区间修改」等操作，通常还伴随着针对单个元素的「单点查询」、「单点修改」这两种单点操作。">
<meta property="og:type" content="article">
<meta property="og:title" content="线段树从入门到急停">
<meta property="og:url" content="https://iyukiyama.github.io/segment-tree/index.html">
<meta property="og:site_name" content="yukiyama">
<meta property="og:description" content="线段树是著名的用于高效求解「区间问题」的数据结构。「区间问题」即对于输入数组 nums ，在其上执行「区间求和」 、「区间修改」等操作，通常还伴随着针对单个元素的「单点查询」、「单点修改」这两种单点操作。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/iyukiyama/pics/master/hexo-iyukiyama/site_img/posts/algorithms/segment-tree-bg.png">
<meta property="article:published_time" content="2022-07-26T12:18:45.307Z">
<meta property="article:modified_time" content="2022-11-13T05:37:11.389Z">
<meta property="article:author" content="yukiyama">
<meta property="article:tag" content="算法与数据结构">
<meta property="article:tag" content="区间问题">
<meta property="article:tag" content="线段树">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/iyukiyama/pics/master/hexo-iyukiyama/site_img/posts/algorithms/segment-tree-bg.png"><link rel="shortcut icon" href="https://raw.githubusercontent.com/iyukiyama/pics/f64481f5339a9a86561027eda41a81aaf1c3a92b/hexo-iyukiyama/site_img/favicon.svg"><link rel="canonical" href="https://iyukiyama.github.io/segment-tree/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="8txPepZr-K8-G42klmRZPinO36bw-JYKtqBKyT6YLow"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":500},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: yukiyama","link":"链接: ","source":"来源: yukiyama","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '线段树从入门到急停',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-11-13 13:37:11'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/hexo-iyukiyama/site_img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">31</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">45</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-chart-simple"></i><span> 算法</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/binary-search/"><span> 二分查找</span></a></li><li><a class="site-page child" href="/sorting/"><span> 十大排序</span></a></li><li><a class="site-page child" href="/union-find/"><span> 并查集</span></a></li><li><a class="site-page child" href="/graph/"><span> 图论算法</span></a></li><li><a class="site-page child" href="/binary-search-tree/"><span> 二叉查找树</span></a></li><li><a class="site-page child" href="/avl-tree/"><span> AVL树</span></a></li><li><a class="site-page child" href="/splay-tree/"><span> splay树</span></a></li><li><a class="site-page child" href="/binary-indexed-tree/"><span> 树状数组</span></a></li><li><a class="site-page child" href="/segment-tree/"><span> 线段树</span></a></li><li><a class="site-page child" href="/red-black-tree/"><span> 红黑树</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-diagram-project"></i><span> 图论证明</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/dijkstra-proof/"><span> Dijkstra</span></a></li><li><a class="site-page child" href="/prim-proof/"><span> Prim</span></a></li><li><a class="site-page child" href="/bellman-ford-spfa-proof/"><span> Bellman-Ford &amp; SPFA</span></a></li><li><a class="site-page child" href="/floyd-warshall-proof/"><span> Floyd-Warshall</span></a></li><li><a class="site-page child" href="/max-flow-min-cut-proof/"><span> 最大流最小割定理</span></a></li><li><a class="site-page child" href="/edmonds-karp-complexity-proof/"><span> Edmonds-Karp</span></a></li><li><a class="site-page child" href="/dinic-complexity-proof/"><span> Dinic</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="https://iyukiyama.github.io/docsify-leetcode/"><i class="fa-fw fas fa-code"></i><span> LeetCode</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-mug-saucer"></i><span> Java</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/jdbc-in-action/"><span> JDBC</span></a></li><li><a class="site-page child" href="/javaweb-in-action/"><span> Java Web</span></a></li><li><a class="site-page child" href="/spring5-framework-in-action/"><span> Spring Framework</span></a></li><li><a class="site-page child" href="/springmvc-in-action/"><span> SpringMVC</span></a></li><li><a class="site-page child" href="/springboot-in-action/"><span> SpringBoot</span></a></li></ul></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://iyukiyama.gitbook.io/design-pattern/"><i class="fa-fw fas fa-palette"></i><span> 设计模式</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-database"></i><span> Database</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/mysql-in-action/"><span> MySQL</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/git-in-action/"><i class="fa-fw fas fa-code-branch"></i><span> Git</span></a></div><div class="menus_item"><a class="site-page" href="/maven-in-action/"><i class="fa-fw fas fa-feather"></i><span> Maven</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-circle-info"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://raw.githubusercontent.com/iyukiyama/pics/master/hexo-iyukiyama/site_img/posts/algorithms/segment-tree-bg.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">yukiyama</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-chart-simple"></i><span> 算法</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/binary-search/"><span> 二分查找</span></a></li><li><a class="site-page child" href="/sorting/"><span> 十大排序</span></a></li><li><a class="site-page child" href="/union-find/"><span> 并查集</span></a></li><li><a class="site-page child" href="/graph/"><span> 图论算法</span></a></li><li><a class="site-page child" href="/binary-search-tree/"><span> 二叉查找树</span></a></li><li><a class="site-page child" href="/avl-tree/"><span> AVL树</span></a></li><li><a class="site-page child" href="/splay-tree/"><span> splay树</span></a></li><li><a class="site-page child" href="/binary-indexed-tree/"><span> 树状数组</span></a></li><li><a class="site-page child" href="/segment-tree/"><span> 线段树</span></a></li><li><a class="site-page child" href="/red-black-tree/"><span> 红黑树</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-diagram-project"></i><span> 图论证明</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/dijkstra-proof/"><span> Dijkstra</span></a></li><li><a class="site-page child" href="/prim-proof/"><span> Prim</span></a></li><li><a class="site-page child" href="/bellman-ford-spfa-proof/"><span> Bellman-Ford &amp; SPFA</span></a></li><li><a class="site-page child" href="/floyd-warshall-proof/"><span> Floyd-Warshall</span></a></li><li><a class="site-page child" href="/max-flow-min-cut-proof/"><span> 最大流最小割定理</span></a></li><li><a class="site-page child" href="/edmonds-karp-complexity-proof/"><span> Edmonds-Karp</span></a></li><li><a class="site-page child" href="/dinic-complexity-proof/"><span> Dinic</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="https://iyukiyama.github.io/docsify-leetcode/"><i class="fa-fw fas fa-code"></i><span> LeetCode</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-mug-saucer"></i><span> Java</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/jdbc-in-action/"><span> JDBC</span></a></li><li><a class="site-page child" href="/javaweb-in-action/"><span> Java Web</span></a></li><li><a class="site-page child" href="/spring5-framework-in-action/"><span> Spring Framework</span></a></li><li><a class="site-page child" href="/springmvc-in-action/"><span> SpringMVC</span></a></li><li><a class="site-page child" href="/springboot-in-action/"><span> SpringBoot</span></a></li></ul></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://iyukiyama.gitbook.io/design-pattern/"><i class="fa-fw fas fa-palette"></i><span> 设计模式</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-database"></i><span> Database</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/mysql-in-action/"><span> MySQL</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/git-in-action/"><i class="fa-fw fas fa-code-branch"></i><span> Git</span></a></div><div class="menus_item"><a class="site-page" href="/maven-in-action/"><i class="fa-fw fas fa-feather"></i><span> Maven</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-circle-info"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">线段树从入门到急停</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-07-26T12:18:45.307Z" title="发表于 2022-07-26 20:18:45">2022-07-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-11-13T05:37:11.389Z" title="更新于 2022-11-13 13:37:11">2022-11-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">算法与数据结构</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">25.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>107分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="线段树从入门到急停"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>线段树从入门到急停</h1>
<p><strong>感谢官方推荐</strong> 🎉😄。</p>
<blockquote>
<ul>
<li>
<p>可在作者的 <a target="_blank" rel="noopener" href="https://github.com/iyukiyama/leetcode-posts">github仓库</a> 中获取本文和其他文章的 markdown 源文件及相关代码。</p>
</li>
<li>
<p>欢迎评论或仓库 PR 指出文章错漏或与我讨论相关问题，我将长期维护所有文章。</p>
</li>
<li>
<p>所有文章均用 Typora 完成写作，可使用 Typora 打开文章 md 文件，以获得最佳阅读体验。</p>
</li>
</ul>
</blockquote>
<p>⚠️ ⚠️ ⚠️ <strong>谨以此两万五千字文章献给在线段树门前徘徊的朋友。</strong></p>
<p>❗️ <strong>【NEW】最新文章如下</strong> ❗️</p>
<ul>
<li>9-15:  <a target="_blank" rel="noopener" href="https://leetcode.cn/circle/discuss/SwgIJV/">红黑树从入门到看开</a></li>
</ul>
<p>这是小白 yuki 推出的「树ADT」系列文章的第 11 篇 (11/13) 。</p>
<hr>
<blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mi>e</mi><mi>y</mi><mi>w</mi><mi>o</mi><mi>r</mi><mi>d</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">keywords</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal" style="margin-right:0.03588em;">ey</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal" style="margin-right:0.02778em;">or</span><span class="mord mathnormal">d</span><span class="mord mathnormal">s</span></span></span></span> :</p>
<p>完全二叉树下标性质 / 分治算法 / 单点查询 (维护或不维护 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span>) / 单点修改 (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>d</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">add</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">dd</span></span></span></span> &amp; <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mi>p</mi><mi>d</mi><mi>a</mi><mi>t</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">update</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">u</span><span class="mord mathnormal">p</span><span class="mord mathnormal">d</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span></span></span></span>) / (增量式 &amp; 覆盖式) 区间修改 / 区间查询 (求和 &amp; 求最值) / 堆式 (静态) 线段树 / 懒惰标记 / 延迟修改 / 离散化 (松离散 &amp; 紧离散) / 强制在线 / 动态开点 / 结点数组法动态线段树 / 结点指针 (引用) 法动态线段树</p>
</blockquote>
<p><strong>线段树</strong> 是著名的用于高效求解 <strong>「区间问题」</strong> 的数据结构。「区间问题」即对于输入数组 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span> ，在其上执行 <strong>「区间求和」</strong> 、 <strong>「区间修改」</strong> 等操作，通常还伴随着针对单个元素的 <strong>「单点查询」</strong> 、 <strong>「单点修改」</strong> 这两种单点操作。若直接操作 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span> ，则单点操作时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> ，而区间操作为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> ；若采用「前缀和」，则区间操作为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> ，而单点操作为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 。利用完全二叉树下标特点 (静态堆式线段树) 或动态开点操作 (动态线段树)，将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span> 上对任意元素值或任意区间值 (区间求和、区间最值等) 的求解，构建在一棵二叉树上，通过对该二叉树的分治处理 (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>f</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">dfs</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">df</span><span class="mord mathnormal">s</span></span></span></span>) ，<strong>同时实现 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 时间复杂度的单点操作与区间操作</strong> 。</p>
<p>本文行文过程中，我会将线段树与另一种求解区间问题的数据结构 –– 「树状数组」做对比。虽然「线段树」与「树状数组」在原理上差别不小，但 <strong>「区间划分」</strong> 的思想是一致的。「树状数组」的特点是思维难度大，实现简单，「线段树」正好相反，思维难度低，实现相对复杂，且对于区间问题，线段树比树状数组更具普适性。不过我仍然建议你在阅读本文之前先阅读 <a target="_blank" rel="noopener" href="https://leetcode.cn/circle/discuss/qGREiN/">树状数组</a> 一文，即便暂时理解不了树状数组中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><mi>w</mi><mi>b</mi><mi>i</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">lowbit</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">bi</span><span class="mord mathnormal">t</span></span></span></span> 的作用也没关系，有了「树」与「区间问题」相联系的印象后，再学习本文的「线段树」，然后再返回去学习「树状数组」，效果也许更好（主要是我先写了「树状数组」再写的「线段树」😅）。</p>
<p>本文将给出 <strong>十种</strong> 线段树的完整类实现代码 (静态 &amp; 动态)，可应对力扣中出现的 <strong>(几乎) 所有能用线段树解决的题目</strong> 。并在「实战应用」中给出近十道力扣上的线段树题目及详细题解 (持续增加中)。</p>
<p>另外，本文原题 「线段树 (树ADT连载 11/13)」，十分干瘪，不太符合作者的气质，遂改为现标题。<strong>「急停」表示作者的一种希望</strong>，我猜想许多朋友跟作者一样，在求索线段树的路上狼奔豕突，相关文章和题解看了不少，却始终不得其法。现在，作者希望朋友们能够通过本文实现完美急停，此后 <strong>从容吟啸且徐行</strong>。</p>
<hr>
<p>yuki的其他文章如下，欢迎阅读指正！</p>
<blockquote>
<p>如下所有文章同时也在我的 github <a target="_blank" rel="noopener" href="https://github.com/iyukiyama/leetcode-posts">仓库</a> 中维护。</p>
</blockquote>
<table>
<thead>
<tr>
<th>文章</th>
<th>[发布时间] 字数/览/藏/赞 (~2022-10-20)</th>
</tr>
</thead>
<tbody>
<tr>
<td><a target="_blank" rel="noopener" href="https://leetcode.cn/circle/discuss/eBo9UB/">十大排序从入门到入赘</a>  🔥🔥🔥</td>
<td>[20220516]  2.5万字/64.8k览/3.7k藏/937赞</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://leetcode.cn/circle/discuss/ooxfo8/">二分查找从入门到入睡</a> 🔥🔥🔥</td>
<td>[20220509]  2.3万字/38.4k览/2.1k藏/503赞</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://leetcode.cn/circle/discuss/qmjuMW/">并查集从入门到出门</a> 🔥🔥</td>
<td>[20220514]  1.2万字/17.9k览/1.0k藏/321赞</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://leetcode.cn/circle/discuss/FyPTTM/">图论算法从入门到放下</a> 🔥🔥</td>
<td>[20220617]  5.6万字/19.9k览/1.3k藏/365赞</td>
</tr>
<tr>
<td>树ADT系列 (预计13篇)</td>
<td>系列文章，连载中</td>
</tr>
<tr>
<td>3. <a target="_blank" rel="noopener" href="https://leetcode.cn/circle/discuss/wPzlSb/">二叉查找树</a></td>
<td>[20220801]  5千字</td>
</tr>
<tr>
<td>4. <a target="_blank" rel="noopener" href="https://leetcode.cn/circle/discuss/zbwD3p/">AVL树</a></td>
<td>[20220817]  5千字</td>
</tr>
<tr>
<td>5. <a target="_blank" rel="noopener" href="https://leetcode.cn/circle/discuss/BCK17f/">splay树</a></td>
<td>[20220817]  5千字</td>
</tr>
<tr>
<td>6. <a target="_blank" rel="noopener" href="https://leetcode.cn/circle/discuss/SwgIJV/">红黑树从入门到看开</a> 🔥🤯🤯🤯</td>
<td>[20220915]  3万字/5.3k览/269藏/72赞</td>
</tr>
<tr>
<td>10. <a target="_blank" rel="noopener" href="https://leetcode.cn/circle/discuss/qGREiN/">树状数组从入门到下车</a> 🔥🤯</td>
<td>[20220722]  1.4万字/5.8k览/196藏/72赞</td>
</tr>
<tr>
<td>11. <a target="_blank" rel="noopener" href="https://leetcode.cn/circle/discuss/H4aMOn/">线段树从入门到急停</a> 🔥🤯</td>
<td>[20220726]  2.5万字/8.7k览/481藏/138赞</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://leetcode.cn/circle/discuss/GV0JrV/">图论相关证明系列</a></td>
<td>系列文章</td>
</tr>
<tr>
<td>1. <a target="_blank" rel="noopener" href="https://leetcode.cn/circle/discuss/jJQn7V/">Dijkstra正确性证明</a> 🤯</td>
<td>[20220531]</td>
</tr>
<tr>
<td>2. <a target="_blank" rel="noopener" href="https://leetcode.cn/circle/discuss/VVEc8f/">Prim正确性证明</a> 🤯</td>
<td>[20220919]</td>
</tr>
<tr>
<td>3. <a target="_blank" rel="noopener" href="https://leetcode.cn/circle/discuss/xeEwYl/">Bellman-Ford及SPFA正确性证明</a></td>
<td>[20220602]</td>
</tr>
<tr>
<td>4. <a target="_blank" rel="noopener" href="https://leetcode.cn/circle/discuss/Nbzix4/">Floyd正确性证明</a></td>
<td>[20220602]</td>
</tr>
<tr>
<td>5. <a target="_blank" rel="noopener" href="https://leetcode.cn/circle/discuss/tMIy36/">最大流最小割定理证明</a> 🤯🤯</td>
<td>[20220719]</td>
</tr>
<tr>
<td>6. <a target="_blank" rel="noopener" href="https://leetcode.cn/circle/discuss/tN3sZc/">Edmonds-Karp复杂度证明</a> 🤯🤯</td>
<td>[20220515]</td>
</tr>
<tr>
<td>7. <a target="_blank" rel="noopener" href="https://leetcode.cn/circle/discuss/T9Xa1R/">Dinic复杂度证明</a> 🤯🤯</td>
<td>[20220531]</td>
</tr>
</tbody>
</table>
<hr>
<p>[2022-09-23]</p>
<ul>
<li>在「实战应用」中增加 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-increasing-subsequence-ii/">2407. 最长递增子序列 II</a> 的 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-increasing-subsequence-ii/solution/-by-yukiyama-khmm/">题解</a> 。</li>
<li>增加两种以 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 实现区间最值查询的线段树类实现。</li>
</ul>
<p>[2022-09-22]</p>
<ul>
<li>增加了「区间最值查询」小节，替换了一张错误图片，另有若干词句修改。</li>
</ul>
<hr>
<p>[TOC]</p>
<hr>
<h2 id="线段树">线段树</h2>
<p>我们已经知道，针对序列上的「区间操作」，相比普通数组和前缀和数组，基本树状数组 (PURQ BIT) 对「单点修改」及「区间查询」这两种操作实现了平衡，即均为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 时间复杂度。借助差分数组，从 PURQ BIT 发展而来的 RUPQ BIT (区间修改单点查询) 和 RURQ BIT (区间修改区间查询) 还可以实现 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 复杂度区间修改操作，但需要针对不同的需要选择不同版本的树状数组。另外，当我们需要 <strong>将区间内元素修改为同一元素时</strong> ，或者求给定区间的 <strong>区间最大/最小值</strong> 时，三种树状数组均不能以 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 时间复杂度完成该操作。</p>
<p>对于这些需求，线段树都能够以 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 时间复杂度完成 。</p>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Segment_tree">线段树 (Segment Tree)</a>: 线段树是一种用以支持序列区间操作的数据结构，相比基本树状数组，能够支持的操作种类更多，因此对一般的序列区间问题更具 <strong>普适性</strong> 。</p>
<p>在后续内容中，我们先通过 <strong>「完全二叉树下标性质」</strong> 和 <strong>「分治算法」</strong> 来理解基本线段树的工作原理。在掌握了支持「单点修改」和「区间查询」的基本线段树后，引入  <strong>「懒惰标记」</strong> 和 <strong>「延迟修改」</strong> 的概念，用以实现 「区间修改」。在给出带懒惰标记的线段树实现后，我们马上尝试解决  <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/falling-squares/">699. 掉落的方块</a> ，为解决此题需借用在「树状数组」中介绍过的 <strong>「离散化」</strong> 方法，我将给出 <strong>「松离散」</strong> 和 <strong>「紧离散」</strong> 两种离散化实现 (我自己瞎命名的)。接着尝试解决  <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/range-module/">715. Range 模块</a> ，并发现该题具有「<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Online_algorithm">强制在线</a>」的特点，由于无法离散化，这要求我们实现能够 <strong>「动态开点」</strong>  (动态地创建结点) 的线段树。根据是否可以提前估计树的大小，我们将分别介绍  <strong>「结点数组法动态开点线段树」</strong> 以及 <strong>「结点指针 (引用) 法动态开点线段树」</strong> ，在给出它们的完整的类代码后，演示如何将其用于解决 699 题以及 715 题。</p>
<p>在讲解过程中，我会给出十种线段树的完整类代码，基本能够覆盖力扣上的所有线段树题目。</p>
<blockquote>
<p>线段树由 Jon Bentley 于1977年发明。</p>
<p>The segment tree was invented by <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Jon_Bentley_(computer_scientist)">Jon Bentley</a> in 1977; in “Solutions to Klee’s rectangle problems”.[<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Segment_tree#cite_note-Schwarzkopf4-7">7]</a></p>
<p>作者的「线段树」知识，最初学自 OI wiki <a target="_blank" rel="noopener" href="https://oi-wiki.org/ds/seg/">线段树</a> 。</p>
</blockquote>
<br />
<h3 id="基本线段树">基本线段树</h3>
<p>如果我们只要求线段树像基本树状数组 (PURQ BIT) 那样只需支持「单点修改」和「区间查询」，那么我们将得到最基本的线段树。</p>
<p>在「树状数组」中我们从如何提高区间查询的效率这一问题入手，提出了将原数组 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span> 分成若干子区间的想法，且这些子区间构成一棵逻辑树，通过树的结构实现 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 的复杂度。但树状数组的实现太具技巧性，我们会想，除了树状数组利用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><mi>w</mi><mi>b</mi><mi>i</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">lowbit</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">bi</span><span class="mord mathnormal">t</span></span></span></span> 那样巧妙构造树的方法，有没有 <strong>更一般</strong> 的方法能够将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span> 划分为多个子区间，这些子区间作为结点构成一棵树，树上的结点相比树状数组 <strong>更直观</strong> 地组成任意区间 (直接结合而非前缀区间作差)，且仍能通过下标的某些性质来操作结点呢 (目的是通过下标定位到需要的区间和结点) ？</p>
<p>根据树结点下标性质来操作结点这一要求中，我们嗅到了 <strong>「完全二叉树」</strong> 的味道。在完全二叉树中，结点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> (根结点为结点 1) 的左子结点下标为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>∗</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">2*i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> ，右子结点下标为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>∗</mo><mi>i</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2*i+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7429em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 。顺着这个想法，我们尝试将「线段树」构造为一棵「完全二叉树」。</p>
<br />
<h4 id="线段树的形态">线段树的形态</h4>
<p>假设需要在输入数组 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span> 上求解区间问题，我们需要将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span> 处理为一棵「线段树」。下面是我们将「线段树」构造为一棵「完全二叉树」的思考过程。</p>
<ul>
<li>
<p>首先，既然是完全二叉树，那么这棵线段树可以与一个数组对应，数组的一个元素对应一个树的一个结点。树的一个结点代表某个区间的区间和，我们用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo stretchy="false">[</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">tree[]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">ree</span><span class="mopen">[</span><span class="mclose">]</span></span></span></span> 数组表达这棵线段树，其大小暂时未知。</p>
</li>
<li>
<p>更大的区间总是由更小区间构成，因此代表 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span> 中单个元素的结点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">tree[x]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">ree</span><span class="mopen">[</span><span class="mord mathnormal">x</span><span class="mclose">]</span></span></span></span>  <strong>应当在树的最底层</strong> ，即线段树的每一个叶子结点都与 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span> 中的一个值对应 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo>=</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">tree[x] = nums[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">ree</span><span class="mopen">[</span><span class="mord mathnormal">x</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> ，且是从左到右对应的。</p>
</li>
<li>
<p>更大的区间是从叶子结点开始向上构成的，例如代表 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums[0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span> 的叶子结点是一个左子结点，代表 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums[1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 的叶子结点是一个右子结点，那么他们的父节点即为代表区间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 的结点。</p>
</li>
<li>
<p>查询区间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[l,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 的区间和，总是从上到下查询。从根结点开始，为了知道指定区间包含哪些区间结点，需要将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mo separator="true">,</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">l,r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span> 与结点的标号联系起来，也就是将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span> 的下标与 <strong>形如完全二叉树的线段树的结点标号</strong> 相联系，这个「完全二叉树结点下标性质」我们很熟悉，将数组 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span> 看作完全二叉树时，树的结点代表 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span> 中的某个值， 而在线段树中，树的结点代表 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span> 中的某段区间和。</p>
</li>
</ul>
<p>在熟知完全二叉树下标性质的基础上，上述分析是简单的。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">tree[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">ree</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> 表示标号为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 的结点所代表的区间的区间和。令根结点标号为 1。根结点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">tree[1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">ree</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 代表整个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span> 所有元素之和。很自然地，根结点的左右子结点应当代表左右两半区间的区间和，即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo stretchy="false">[</mo><mn>2</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">tree[2]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">ree</span><span class="mopen">[</span><span class="mord">2</span><span class="mclose">]</span></span></span></span> 表示区间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mfrac><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><mn>2</mn></mfrac><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, \frac{n-1}{2}]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">]</span></span></span></span> 的区间和，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo stretchy="false">[</mo><mn>3</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">tree[3]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">ree</span><span class="mopen">[</span><span class="mord">3</span><span class="mclose">]</span></span></span></span> 表示区间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mfrac><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><mn>2</mn></mfrac><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[\frac{n-1}{2}+1, n-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mopen">[</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 的区间和，依次向下， <strong>结点标号总是与该结点代表的区间一一对应</strong> 。</p>
<blockquote>
<p>代表区间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[l,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 的结点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">tree[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">ree</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> ，其左子结点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo stretchy="false">[</mo><mn>2</mn><mo>∗</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">tree[2*i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">ree</span><span class="mopen">[</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> 表示区间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mo separator="true">,</mo><mfrac><mrow><mi>l</mi><mo>+</mo><mi>r</mi></mrow><mn>2</mn></mfrac><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[l,\frac{l+r}{2}]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2251em;vertical-align:-0.345em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mbin mtight">+</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">]</span></span></span></span> 的区间和；其右子结点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo stretchy="false">[</mo><mn>2</mn><mo>∗</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">tree[2*i+1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">ree</span><span class="mopen">[</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7429em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 表示区间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mfrac><mrow><mi>l</mi><mo>+</mo><mi>r</mi></mrow><mn>2</mn></mfrac><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[\frac{l+r}{2}+1,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2251em;vertical-align:-0.345em;"></span><span class="mopen">[</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mbin mtight">+</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 的区间和。</p>
</blockquote>
<p>于是我们很容易得到线段树的一般表示，下图表示大小为 15 的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>=</mo><mo stretchy="false">{</mo><mi>a</mi><mn>0</mn><mo separator="true">,</mo><mi>a</mi><mn>1</mn><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mi>a</mi><mn>14</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">nums=\{a0,a1,...,a14\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">a</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">a</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">a</span><span class="mord">14</span><span class="mclose">}</span></span></span></span> 对应的线段树。可以看到，对于任意区间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo>∈</mo><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[l,r], l,r∈[0,n-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> ，我们都可以由 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span> 的若干个子区间组合得到，这一点是线段树与树状数组的显著区别 (树状数组通过两个前缀区间作差得到)。</p>
<p><img src="https://pic.leetcode-cn.com/1658564316-ptpqfb-image.png" alt="image.png"></p>
<p>了解了线段树的区间划分、结点所代表的具体区间与结点下标的关系后，接下来我们给出基本线段树的「初始化」、「单点修改」以及「区间查询」实现。在这之前先简单分析线段树的大小。</p>
<br />
<h4 id="线段树的大小">线段树的大小</h4>
<p>对于长度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 的输入数组 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span> ，初始化它所对应的线段树前 (即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo stretchy="false">[</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">tree[]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">ree</span><span class="mopen">[</span><span class="mclose">]</span></span></span></span> 数组)，我们需要知道 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo stretchy="false">[</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">tree[]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">ree</span><span class="mopen">[</span><span class="mclose">]</span></span></span></span> 的大小。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 对应的是线段树叶子结点数，我们设总结点数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> ，可以 <strong>根据线段树为一棵完全二叉树的特点来寻找 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 与 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 的关系</strong> 。证明见 <a target="_blank" rel="noopener" href="https://oi-wiki.org/ds/seg/">oi-wiki 线段树</a> ，作者未完全看懂 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 最大时为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>=</mo><mn>4</mn><mo>∗</mo><mi>n</mi><mo>−</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">m=4*n-5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">5</span></span></span></span> 的证明过程。<strong>如果读者能提供易懂的数学证明，盼赐教</strong>。</p>
<p>总之，在实际使用时，我们总是不精确地令 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>=</mo><mn>4</mn><mo>∗</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">m=4*n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 。</p>
<br />
<h4 id="初始化">初始化</h4>
<p>如果读者熟悉归并排序和快速排序这类 <strong>分治算法</strong> 的「对原问题域递归地划分为左右子问题域」的操作，那么线段树的主要方法都将是简单的。我们直接给出如下线段树类 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>e</mi><mi>g</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>T</mi><mi>r</mi><mi>e</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">SegmentTree</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.13889em;">tT</span><span class="mord mathnormal">ree</span></span></span></span> 的构造器代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SegmentTree</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] nums, tree;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SegmentTree</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.nums = nums;</span><br><span class="line">        <span class="built_in">this</span>.n = nums.length;</span><br><span class="line">        <span class="built_in">this</span>.tree = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span> * n]; <span class="comment">// 线段树结点数不超过 4*n</span></span><br><span class="line">        build(<span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123; <span class="comment">// 构建线段树(tree数组), i: 当前区间结点下标</span></span><br><span class="line">        <span class="keyword">if</span>(s == t) &#123; <span class="comment">// s: start,nums当前区间左界，t: terminal,nums当前结点区间右界</span></span><br><span class="line">            tree[i] = nums[s];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        build(s, c, i * <span class="number">2</span>);</span><br><span class="line">        build(c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        tree[i] = tree[i * <span class="number">2</span>] + tree[i * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造器通过 <code>build(0, n - 1, 1)</code> 完成线段树的构建 (初始化 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo stretchy="false">[</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">tree[]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">ree</span><span class="mopen">[</span><span class="mclose">]</span></span></span></span>)。在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mi>u</mi><mi>i</mi><mi>l</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">build</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal">u</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">d</span></span></span></span> 中，自根结点往下，按照我们在「线段树的形态」中所说的那样，递归地将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span> 分为左右两半，直到叶子结点，每次递归， <strong>区间和结点的下标总是和该区间的左右界一起被传入</strong> 。该写法实际上就是大家十分熟悉的二叉树的「后序遍历」写法。</p>
<p>递归的基准情形是根据 <code>s == t</code> 判断到达叶子结点后，令 <code>tree[i] = nums[s]</code> ，使得每个叶子结点从左到右对应 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span> 的每个元素值。在回溯过程中通过 <code>tree[i] = tree[i * 2] + tree[i * 2 + 1]</code>  自底向上地初始化所有区间结点的区间和。这行语句在线段树的实现中较常用，我们可以将它封装为一个辅助方法 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>u</mi><mi>s</mi><mi>h</mi><mi>U</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">pushUp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal">u</span><span class="mord mathnormal">s</span><span class="mord mathnormal">h</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord mathnormal">p</span></span></span></span> 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更新 tree[i]</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pushUp</span><span class="params">(<span class="type">int</span> i)</span>&#123; </span><br><span class="line">    tree[i] = tree[i * <span class="number">2</span>] + tree[i * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后面我们将看到，线段树的所有主要方法的执行过程，都是类似这样的 <strong>二叉树后序遍历的递归过程</strong> ，读者一定会感到线段树不同方法的写法如出一辙，简单得令人惊讶。</p>
<br />
<h4 id="单点修改">单点修改</h4>
<p>单点修改有两种，<strong>增量式修改，即加上某值</strong> (记为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>d</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">add</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">dd</span></span></span></span> 方法) <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>+</mo><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">nums[i]+=x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mord">+</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>  或 <strong>覆盖式修改，即改为某值</strong> (记为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mi>p</mi><mi>d</mi><mi>a</mi><mi>t</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">update</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">u</span><span class="mord mathnormal">p</span><span class="mord mathnormal">d</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span></span></span></span> 方法) <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">nums[i]=x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>。如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单点修改(驱动): nums[i] += x</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> x)</span>&#123; </span><br><span class="line">    add(i, x, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 单点修改(驱动): nums[i] = x</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> x)</span>&#123;</span><br><span class="line">    update(i, x, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 单点修改: nums[idx] += x</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> x, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == t) &#123;</span><br><span class="line">        tree[i] += x; <span class="comment">// 增量更新</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(idx &lt;= c) add(idx, x, s, c, i * <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">else</span> add(idx, x, c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">    pushUp(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 单点修改: nums[idx] = x</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> x, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == t) &#123;</span><br><span class="line">        tree[i] = x; <span class="comment">// 覆盖更新</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(idx &lt;= c) update(idx, x, s, c, i * <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">else</span> update(idx, x, c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">    pushUp(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>d</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">add</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">dd</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mi>p</mi><mi>d</mi><mi>a</mi><mi>t</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">update</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">u</span><span class="mord mathnormal">p</span><span class="mord mathnormal">d</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span></span></span></span> 均采用上述写法时，可以不用维护 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span> ，由于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span> 不可用，单点查询可实现如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单点查询 (驱动): 查询 nums[i]</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> i)</span>&#123; </span><br><span class="line">    <span class="keyword">return</span> query(i, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 单点查询 (具体): 查询 nums[i]，尾递归</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == t) <span class="keyword">return</span> tree[i];</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(idx &lt;= c) <span class="keyword">return</span> query(idx, s, c, i * <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> query(idx, c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然我们也可以实时地维护 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span> ，那么 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>d</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">add</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">dd</span></span></span></span> 写法不变， <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mi>p</mi><mi>d</mi><mi>a</mi><mi>t</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">update</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">u</span><span class="mord mathnormal">p</span><span class="mord mathnormal">d</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span></span></span></span> 可借助 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>d</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">add</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">dd</span></span></span></span> 实现。由于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> 是实时维护的，单点查询时直接返回 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> 即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单点修改(驱动): nums[i] = x</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> x)</span>&#123; </span><br><span class="line">    add(i, x - nums[i], <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    nums[i] = x; <span class="comment">// 实时维护 nums[i]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> i)</span>&#123; <span class="comment">// 单点查询: 查询 nums[i]</span></span><br><span class="line">    <span class="keyword">return</span> nums[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上，由于单点查询和单点修改都可以视作区间长度为 1 的区间查询和区间修改。上述方法也可以由区间查询和区间修改代替。</p>
<br />
<h4 id="区间查询">区间查询</h4>
<p>区间查询 (求和) 也是简单的。与单点操作不同的是，区间和需要累积，因此 <code>if(l &lt;= c)</code> 与 <code>if(r &gt; c)</code> 是并列关系。递归的基准情形为 <code>if(l &lt;= s &amp;&amp; t &lt;= r)</code> ，表示当前递进到的区间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>s</mi><mo separator="true">,</mo><mi>t</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[s,t]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">t</span><span class="mclose">]</span></span></span></span> 在所求区间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[l,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 之内，返回该区间的区间和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">tree[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">ree</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> 用于累计。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 区间查询(驱动): nums[l]~nums[r]之和</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span>&#123; </span><br><span class="line">    <span class="keyword">return</span> sum(l, r, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 区间查询: nums[l]~nums[r]之和</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= s &amp;&amp; t &lt;= r) <span class="keyword">return</span> tree[i]; <span class="comment">// 当前结点区间在所求范围之间</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= c) sum += sum(l, r, s, c, i * <span class="number">2</span>); <span class="comment">// 递归累加目标区间落在c左侧(含c)的区间和</span></span><br><span class="line">    <span class="keyword">if</span>(r &gt; c) sum += sum(l, r, c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>); <span class="comment">// 递归累加目标区间落在c右侧的区间和</span></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以查询区间最值，以区间最小值为例，如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 区间查询 (驱动): 查询[l,r]中的最小值</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span>&#123; </span><br><span class="line">    <span class="keyword">return</span> min(l, r, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 区间查询: 查询[l,r]中的最小值</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == t) <span class="keyword">return</span> tree[i]; <span class="comment">// 叶子结点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>, lmin = Integer.MAX_VALUE, rmin = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= c) lmin = min(l, r, s, c, i * <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; c) rmin = min(l, r, c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> Math.min(lmin, rmin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br />
<h5 id="区间最值查询">区间最值查询</h5>
<p><strong>需要注意的是</strong>，对于「区间最值查询」，上面给出的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">min</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">min</span></span></span></span> 方法建立在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo stretchy="false">[</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">tree[]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">ree</span><span class="mopen">[</span><span class="mclose">]</span></span></span></span> 的定义为「区间和」基础之上。在这个定义下，由于缺乏子区间最值的记录，为了找到最值， <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">min</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">min</span></span></span></span> , <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">max</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span></span></span></span> 方法最终会递进到区间内的每一个叶子结点，如果查询的是整个问题区间上的最值，那就相当于经历一次完整的树的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>f</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">dfs</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">df</span><span class="mord mathnormal">s</span></span></span></span> 遍历，所以平均时间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 。若要实现 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 复杂度的「区间最值查询」，做法是令 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo stretchy="false">[</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">tree[]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">ree</span><span class="mopen">[</span><span class="mclose">]</span></span></span></span>  <strong>记录区间最值</strong> 而不是区间和。以 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo stretchy="false">[</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">tree[]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">ree</span><span class="mopen">[</span><span class="mclose">]</span></span></span></span> 记录区间最值的典型线段树题目是 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/falling-squares/">699. 掉落的方块</a> 一题，详细做法请参考 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/falling-squares/solution/-by-yukiyama-lxtu/">题解</a> 。其中求区间最大值的代码如下，可以看到，与 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo stretchy="false">[</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">tree[]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">ree</span><span class="mopen">[</span><span class="mclose">]</span></span></span></span> 定义为「区间和」时的「区间求和查询」的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span></span></span></span> 方法十分类似。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tree[] 定义为区间最大值时，可实现 O(logn) 时间复杂度的区间最值查询。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 区间查询 (驱动): 查询[l,r]中的最大值</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span>&#123; </span><br><span class="line">    <span class="keyword">return</span> max(l, r, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 区间查询: 查询[l,r]中的最大值</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(l &lt;= s &amp;&amp; t &lt;= r) <span class="keyword">return</span> tree[i]; <span class="comment">// 当前区间是否包含在所求区间中</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>, lmax = <span class="number">0</span>, rmax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(lazy[i] != <span class="number">0</span>) pushDown(s, c, t, i);</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= c) lmax = max(l, r, s, c, i * <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; c) rmax = max(l, r, c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> Math.max(lmax, rmax);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外要注意由于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo stretchy="false">[</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">tree[]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">ree</span><span class="mopen">[</span><span class="mclose">]</span></span></span></span> 的意义是区间最值，因此 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>u</mi><mi>s</mi><mi>h</mi><mi>U</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">pushUp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal">u</span><span class="mord mathnormal">s</span><span class="mord mathnormal">h</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord mathnormal">p</span></span></span></span> 方法也与之前不同，应如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pushup: 更新 tree[i]</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pushUp</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">    tree[i] = Math.max(tree[i * <span class="number">2</span>], tree[i * <span class="number">2</span> + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于后续其他版本的线段树，只需将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo stretchy="false">[</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">tree[]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">ree</span><span class="mopen">[</span><span class="mclose">]</span></span></span></span> 定义为记录「区间最大值」，相应地完成上述两处修改，即可得到以 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 时间复杂度完成「区间最大值查询」的线段树。同样地，若想得到以 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 时间复杂度完成「区间最小值查询」的线段树，就将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo stretchy="false">[</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">tree[]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">ree</span><span class="mopen">[</span><span class="mclose">]</span></span></span></span> 定义为记录「区间最小值」。但是要注意，因为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo stretchy="false">[</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">tree[]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">ree</span><span class="mopen">[</span><span class="mclose">]</span></span></span></span> 不再记录「区间和」，则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span></span></span></span> 方法求区间和需要递进到每一个叶子结点，此时 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span></span></span></span> 方法的时间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 。</p>
<p>我们看到，无论 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo stretchy="false">[</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">tree[]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">ree</span><span class="mopen">[</span><span class="mclose">]</span></span></span></span> 的定义是什么，当需要单个叶子结点信息时，基准情形应写为 <code>if(s == t) return tree[i];</code> ，当需要包含于所求区间的当前区间信息时，基准情形为 <code>if(l &lt;= s &amp;&amp; t &lt;= r) return tree[i];</code> 。</p>
<p>在下面的「类的实现代码」中，只展示「不维护 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span> 的以 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 时间复杂度完成区间最大值查询的基本静态线段树」的完整类代码，其他版本读者可以自己写出。</p>
<p>若要求线段树以 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 时间复杂度同时支持「区间和查询」、「区间最大值查询」以及「区间最小值查询」，只需要同时维护三个树结点值数组即可，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mi>S</mi><mi>u</mi><mi>m</mi><mo stretchy="false">[</mo><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mi>M</mi><mi>a</mi><mi>x</mi><mo stretchy="false">[</mo><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mi>M</mi><mi>i</mi><mi>n</mi><mo stretchy="false">[</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">treeSum[],treeMax[],treeMin[]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">ree</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mopen">[</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">ree</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mopen">[</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">ree</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal">in</span><span class="mopen">[</span><span class="mclose">]</span></span></span></span> 分别用来记录区间和、区间最大值以及区间最小值，并简单修改相关代码即可。完整实现是「类的实现代码」中的「区间查询扩展版本」。</p>
<br />
<h4 id="类的实现代码">类的实现代码</h4>
<p>将前述方法的实现代码组合起来即可 (实时维护 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span> 或不维护 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span> 两个版本)，见后。</p>
<p>不过，我们在一开始说过线段树能很好地支持「区间修改」操作，为什么还没提供相关方法就在这里给出类的代码呢？这是因为，与树状数组 (RUPQ/RURQ BIT) 区间修改时只需要在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>d</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">add</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">dd</span></span></span></span> 中沿着父链修改 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 次不同， <strong>线段树修改一段区间自上而下涉及到一个或多个子树空间内所有结点的修改</strong> 。例如若修改整个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span> ，那么就要从根结点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>f</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">dfs</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">df</span><span class="mord mathnormal">s</span></span></span></span> 整棵树，修改涉及 <strong>所有结点</strong> ，时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 。对于随机区间来说，平均时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> ，且由于所有区间结点的数量大于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> (通常设置为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mi>n</mi></mrow><annotation encoding="application/x-tex">4n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span><span class="mord mathnormal">n</span></span></span></span>)，这样的操作甚至劣于直接遍历 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span> 逐个修改。</p>
<p>为了解决这个问题，我们不是直接 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>f</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">dfs</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">df</span><span class="mord mathnormal">s</span></span></span></span> 修改，而是通过一种称为 <strong>「懒惰标记」</strong> 的技巧，使子树中的修改操作 <strong>延迟</strong> 到后续修改和查询操作中，此技巧使得区间修改的时间复杂度仍为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 。</p>
<p>为了更稳固地学习后续内容，建议读者先基于目前为止讲解的内容尝试解决 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/range-sum-query-mutable/">307. 区域和检索 - 数组可修改</a> ，代码可参考「实战应用」一节给出的题解。</p>
<br />
<h5 id="实时维护nums的版本">实时维护nums的版本</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基本线段树1 (无懒标记，无区间修改方法，实时维护 nums[i])</span></span><br><span class="line"><span class="comment"> * 支持：单点修改 / 单点查询 / 区间查询</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SegmentTreeBasic1</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] nums, tree;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SegmentTreeBasic1</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.nums = nums;</span><br><span class="line">        <span class="built_in">this</span>.n = nums.length;</span><br><span class="line">        <span class="built_in">this</span>.tree = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span> * n];</span><br><span class="line">        build(<span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> x)</span>&#123; <span class="comment">// 单点修改(驱动): nums[i] += x</span></span><br><span class="line">        add(i, x, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> x)</span>&#123; <span class="comment">// 单点修改(驱动): nums[i] = x</span></span><br><span class="line">        add(i, x - nums[i], <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        nums[i] = x; <span class="comment">// 实时维护 nums[i]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> i)</span>&#123; <span class="comment">// 单点查询: 查询 nums[i]</span></span><br><span class="line">        <span class="keyword">return</span> nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span>&#123; <span class="comment">// 区间查询(驱动): nums[l]~nums[r]之和</span></span><br><span class="line">        <span class="keyword">return</span> sum(l, r, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span>&#123; <span class="comment">// 区间查询 (驱动): 查询[l,r]中的最小值</span></span><br><span class="line">        <span class="keyword">return</span> min(l, r, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span>&#123; <span class="comment">// 区间查询 (驱动): 查询[l,r]中的最大值</span></span><br><span class="line">        <span class="keyword">return</span> max(l, r, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单点修改: nums[idx] += x</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> x, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) &#123;</span><br><span class="line">            tree[i] += x; <span class="comment">// 增量更新</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(idx &lt;= c) add(idx, x, s, c, i * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">else</span> add(idx, x, c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        pushUp(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区间查询: nums[l]~nums[r]之和</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= s &amp;&amp; t &lt;= r) <span class="keyword">return</span> tree[i]; <span class="comment">// 当前结点区间在所求范围之间</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= c) sum += sum(l, r, s, c, i * <span class="number">2</span>); <span class="comment">// 递归累加目标区间落在c左侧(含c)的区间和</span></span><br><span class="line">        <span class="keyword">if</span>(r &gt; c) sum += sum(l, r, c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>); <span class="comment">// 递归累加目标区间落在c右侧的区间和</span></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区间查询: 查询[l,r]中的最小值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) <span class="keyword">return</span> tree[i]; <span class="comment">// 叶子结点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>, lmin = Integer.MAX_VALUE, rmin = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= c) lmin = min(l, r, s, c, i * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(r &gt; c) rmin = min(l, r, c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> Math.min(lmin, rmin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区间查询: 查询[l,r]中的最大值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) <span class="keyword">return</span> tree[i];</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>, lmax = Integer.MIN_VALUE, rmax = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= c) lmax = max(l, r, s, c, i * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(r &gt; c) rmax = max(l, r, c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> Math.max(lmax, rmax);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构建线段树(tree数组)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) &#123; <span class="comment">// s: start,nums当前区间起点下标，t: terminal,nums当前结点区间末尾下标</span></span><br><span class="line">            tree[i] = nums[s];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        build(s, c, i * <span class="number">2</span>);</span><br><span class="line">        build(c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        pushUp(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// pushup: 更新 tree[i]</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pushUp</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        tree[i] = tree[i * <span class="number">2</span>] + tree[i * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br />
<h5 id="不维护nums的版本">不维护nums的版本</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基本线段树2 (无懒标记，无区间修改方法，不维护 nums[i])</span></span><br><span class="line"><span class="comment"> * 支持：单点修改 / 单点查询 / 区间查询</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SegmentTreeBasic2</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] nums, tree;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SegmentTreeBasic2</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.nums = nums;</span><br><span class="line">        <span class="built_in">this</span>.n = nums.length;</span><br><span class="line">        <span class="built_in">this</span>.tree = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span> * n];</span><br><span class="line">        build(<span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> x)</span>&#123; <span class="comment">// 单点修改(驱动): nums[i] += x</span></span><br><span class="line">        add(i, x, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> x)</span>&#123;<span class="comment">// 单点修改(驱动): nums[i] = x</span></span><br><span class="line">        update(i, x, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> i)</span>&#123; <span class="comment">// 单点查询 (驱动): 查询 nums[i]</span></span><br><span class="line">        <span class="keyword">return</span> query(i, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span>&#123; <span class="comment">// 区间查询(驱动): nums[l]~nums[r]之和</span></span><br><span class="line">        <span class="keyword">return</span> sum(l, r, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span>&#123; <span class="comment">// 区间查询 (驱动): 查询[l,r]中的最小值</span></span><br><span class="line">        <span class="keyword">return</span> min(l, r, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span>&#123; <span class="comment">// 区间查询 (驱动): 查询[l,r]中的最大值</span></span><br><span class="line">        <span class="keyword">return</span> max(l, r, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单点查询 (具体): 查询 nums[i]，尾递归</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) <span class="keyword">return</span> tree[i];</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(idx &lt;= c) <span class="keyword">return</span> query(idx, s, c, i * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> query(idx, c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单点修改: nums[idx] += x</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> x, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) &#123;</span><br><span class="line">            tree[i] += x; <span class="comment">// 增量更新</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(idx &lt;= c) add(idx, x, s, c, i * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">else</span> add(idx, x, c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        pushUp(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单点修改: nums[idx] = x</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> x, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) &#123;</span><br><span class="line">            tree[i] = x; <span class="comment">// 覆盖更新</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(idx &lt;= c) update(idx, x, s, c, i * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">else</span> update(idx, x, c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        pushUp(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区间查询: nums[l]~nums[r]之和</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= s &amp;&amp; t &lt;= r) <span class="keyword">return</span> tree[i]; <span class="comment">// 当前结点区间在所求范围之间</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= c) sum += sum(l, r, s, c, i * <span class="number">2</span>); <span class="comment">// 递归累加目标区间落在c左侧(含c)的区间和</span></span><br><span class="line">        <span class="keyword">if</span>(r &gt; c) sum += sum(l, r, c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>); <span class="comment">// 递归累加目标区间落在c右侧的区间和</span></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区间查询: 查询[l,r]中的最小值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) <span class="keyword">return</span> tree[i]; <span class="comment">// 叶子结点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>, lmin = Integer.MAX_VALUE, rmin = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= c) lmin = min(l, r, s, c, i * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(r &gt; c) rmin = min(l, r, c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> Math.min(lmin, rmin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区间查询: 查询[l,r]中的最大值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) <span class="keyword">return</span> tree[i];</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>, lmax = Integer.MIN_VALUE, rmax = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= c) lmax = max(l, r, s, c, i * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(r &gt; c) rmax = max(l, r, c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> Math.max(lmax, rmax);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构建线段树(tree数组)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) &#123; <span class="comment">// s: start,nums当前区间起点下标，t: terminal,nums当前结点区间末尾下标</span></span><br><span class="line">            tree[i] = nums[s];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        build(s, c, i * <span class="number">2</span>);</span><br><span class="line">        build(c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        pushUp(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// pushup: 更新 tree[i]</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pushUp</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        tree[i] = tree[i * <span class="number">2</span>] + tree[i * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br />
<h5 id="O-logn-时间求区间最大值版本">O(logn)时间求区间最大值版本</h5>
<p>以下是不维护 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span> 的以 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 时间复杂度完成 「区间最大值查询」 的基本静态线段树类实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 区间最大值基本线段树 (无懒标记，无区间修改方法，不维护 nums[i])</span></span><br><span class="line"><span class="comment"> * 支持：单点修改 / 单点查询 / 区间查询最大值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SegmentTreeBasicRangeMax</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] nums, tree;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SegmentTreeBasicRangeMax</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.nums = nums;</span><br><span class="line">        <span class="built_in">this</span>.n = nums.length;</span><br><span class="line">        <span class="built_in">this</span>.tree = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span> * n];</span><br><span class="line">        build(<span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> x)</span>&#123; <span class="comment">// 单点修改(驱动): nums[i] += x</span></span><br><span class="line">        add(i, x, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> x)</span>&#123;<span class="comment">// 单点修改(驱动): nums[i] = x</span></span><br><span class="line">        update(i, x, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> i)</span>&#123; <span class="comment">// 单点查询 (驱动): 查询 nums[i]</span></span><br><span class="line">        <span class="keyword">return</span> query(i, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span>&#123; <span class="comment">// 区间查询(驱动): nums[l]~nums[r]之和</span></span><br><span class="line">        <span class="keyword">return</span> sum(l, r, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span>&#123; <span class="comment">// 区间查询 (驱动): 查询[l,r]中的最大值</span></span><br><span class="line">        <span class="keyword">return</span> max(l, r, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单点查询 (具体): 查询 nums[i]，尾递归</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) <span class="keyword">return</span> tree[i];</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(idx &lt;= c) <span class="keyword">return</span> query(idx, s, c, i * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> query(idx, c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单点修改: nums[idx] += x</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> x, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) &#123;</span><br><span class="line">            tree[i] += x; <span class="comment">// 增量更新</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(idx &lt;= c) add(idx, x, s, c, i * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">else</span> add(idx, x, c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        pushUp(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单点修改: nums[idx] = x</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> x, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) &#123;</span><br><span class="line">            tree[i] = x; <span class="comment">// 覆盖更新</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(idx &lt;= c) update(idx, x, s, c, i * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">else</span> update(idx, x, c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        pushUp(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区间查询: nums[l]~nums[r]之和</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) <span class="keyword">return</span> tree[i]; <span class="comment">// 返回所求范围内的叶子结点的值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= c) sum += sum(l, r, s, c, i * <span class="number">2</span>); <span class="comment">// 递归累加目标区间落在c左侧(含c)的区间和</span></span><br><span class="line">        <span class="keyword">if</span>(r &gt; c) sum += sum(l, r, c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>); <span class="comment">// 递归累加目标区间落在c右侧的区间和</span></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区间查询: 查询[l,r]中的最大值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= s &amp;&amp; t &lt;= r) <span class="keyword">return</span> tree[i];</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>, lmax = Integer.MIN_VALUE, rmax = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= c) lmax = max(l, r, s, c, i * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(r &gt; c) rmax = max(l, r, c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> Math.max(lmax, rmax);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构建线段树(tree数组)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) &#123; <span class="comment">// s: start,nums当前区间起点下标，t: terminal,nums当前结点区间末尾下标</span></span><br><span class="line">            tree[i] = nums[s];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        build(s, c, i * <span class="number">2</span>);</span><br><span class="line">        build(c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        pushUp(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// pushup: 更新 tree[i]</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pushUp</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        tree[i] = Math.max(tree[i * <span class="number">2</span>], tree[i * <span class="number">2</span> + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br />
<h5 id="区间查询扩展版本">区间查询扩展版本</h5>
<p>以 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 时间复杂度同时支持「区间和查询」、「区间最大值查询」以及「区间最小值查询」的基本静态线段树类实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基本线段树 (无懒标记，无区间修改方法，不维护 nums[i])</span></span><br><span class="line"><span class="comment"> * 支持：单点修改 / 单点查询 / 区间查询 (同时支持 O(logn) 时间的区间和，区间最大值，区间最小值查询)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SegmentTreeBasic</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] nums, treeSum, treeMin,treeMax;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SegmentTreeBasic</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.nums = nums;</span><br><span class="line">        <span class="built_in">this</span>.n = nums.length;</span><br><span class="line">        <span class="built_in">this</span>.treeSum = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span> * n];</span><br><span class="line">        <span class="built_in">this</span>.treeMin = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span> * n];</span><br><span class="line">        <span class="built_in">this</span>.treeMax = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span> * n];</span><br><span class="line">        build(<span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> x)</span>&#123; <span class="comment">// 单点修改(驱动): nums[i] += x</span></span><br><span class="line">        add(i, x, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> x)</span>&#123;<span class="comment">// 单点修改(驱动): nums[i] = x</span></span><br><span class="line">        update(i, x, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> i)</span>&#123; <span class="comment">// 单点查询 (驱动): 查询 nums[i]</span></span><br><span class="line">        <span class="keyword">return</span> query(i, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span>&#123; <span class="comment">// 区间查询(驱动): nums[l]~nums[r]之和</span></span><br><span class="line">        <span class="keyword">return</span> sum(l, r, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span>&#123; <span class="comment">// 区间查询 (驱动): 查询[l,r]中的最小值</span></span><br><span class="line">        <span class="keyword">return</span> min(l, r, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span>&#123; <span class="comment">// 区间查询 (驱动): 查询[l,r]中的最大值</span></span><br><span class="line">        <span class="keyword">return</span> max(l, r, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单点查询 (具体): 查询 nums[i]，尾递归</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) <span class="keyword">return</span> treeSum[i];</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(idx &lt;= c) <span class="keyword">return</span> query(idx, s, c, i * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> query(idx, c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单点修改: nums[idx] += x</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> x, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) &#123;</span><br><span class="line">            treeSum[i] += x; <span class="comment">// 增量更新</span></span><br><span class="line">            treeMin[i] += x; <span class="comment">// 增量更新</span></span><br><span class="line">            treeMax[i] += x; <span class="comment">// 增量更新</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(idx &lt;= c) add(idx, x, s, c, i * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">else</span> add(idx, x, c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        pushUpSum(i);</span><br><span class="line">        pushUpMin(i);</span><br><span class="line">        pushUpMax(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单点修改: nums[idx] = x</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> x, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) &#123;</span><br><span class="line">            treeSum[i] = x; <span class="comment">// 覆盖更新</span></span><br><span class="line">            treeMin[i] = x; <span class="comment">// 覆盖更新</span></span><br><span class="line">            treeMax[i] = x; <span class="comment">// 覆盖更新</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(idx &lt;= c) update(idx, x, s, c, i * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">else</span> update(idx, x, c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        pushUpSum(i);</span><br><span class="line">        pushUpMin(i);</span><br><span class="line">        pushUpMax(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区间查询: nums[l]~nums[r]之和</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= s &amp;&amp; t &lt;= r) <span class="keyword">return</span> treeSum[i]; </span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= c) sum += sum(l, r, s, c, i * <span class="number">2</span>); <span class="comment">// 递归累加目标区间落在c左侧(含c)的区间和</span></span><br><span class="line">        <span class="keyword">if</span>(r &gt; c) sum += sum(l, r, c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>); <span class="comment">// 递归累加目标区间落在c右侧的区间和</span></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区间查询: 查询[l,r]中的最小值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= s &amp;&amp; t &lt;= r) <span class="keyword">return</span> treeMin[i];</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>, lmin = Integer.MAX_VALUE, rmin = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= c) lmin = min(l, r, s, c, i * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(r &gt; c) rmin = min(l, r, c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> Math.min(lmin, rmin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区间查询: 查询[l,r]中的最大值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= s &amp;&amp; t &lt;= r) <span class="keyword">return</span> treeMax[i];</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>, lmax = Integer.MIN_VALUE, rmax = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= c) lmax = max(l, r, s, c, i * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(r &gt; c) rmax = max(l, r, c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> Math.max(lmax, rmax);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构建线段树(tree数组)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) &#123; <span class="comment">// s: start,nums当前区间起点下标，t: terminal,nums当前结点区间末尾下标</span></span><br><span class="line">            treeSum[i] = nums[s];</span><br><span class="line">            treeMin[i] = nums[s];</span><br><span class="line">            treeMax[i] = nums[s];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        build(s, c, i * <span class="number">2</span>);</span><br><span class="line">        build(c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        pushUpSum(i);</span><br><span class="line">        pushUpMin(i);</span><br><span class="line">        pushUpMax(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// pushUpSum: 更新 treeSum[i]</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pushUpSum</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        treeSum[i] = treeSum[i * <span class="number">2</span>] + treeSum[i * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// pushUpMin: 更新 treeMin[i]</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pushUpMin</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        treeMin[i] = Math.min(treeMin[i * <span class="number">2</span>], treeMin[i * <span class="number">2</span> + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// pushUpMax: 更新 treeMax[i]</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pushUpMax</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        treeMax[i] = Math.max(treeMax[i * <span class="number">2</span>], treeMax[i * <span class="number">2</span> + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br />
<h3 id="懒惰标记">懒惰标记</h3>
<p>回顾一下前述 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span></span></span></span> 方法，给定区间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[l,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> ，当方法递归到一个完全位于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[l,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>s</mi><mo separator="true">,</mo><mi>t</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[s,t]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">t</span><span class="mclose">]</span></span></span></span> 区间 (即 <code>l &lt;= s &amp;&amp; t &lt;= r</code> ) 时，我们直接累积该区间的区间和。可见，区间查询时，只要当前区间完全处于查询区间之内，我们就不需要知道此区间以下的区间的信息。因此对于区间查询 (求和) 操作，时间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> ，那么「区间修改」该如何实现呢？思考与区间查询类似的做法，区间修改方法从根结点递进到一个 <strong>包含于修改区间之内的区间</strong> 时，是否可以 <strong>只修改代表该区间的区间和</strong> ，而不必继续深入修改它的子区间的区间和呢？因为若修改区间下的子区间 (子树空间) 都要修改的话，相当于树的遍历，时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> ，而我们想要实现时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 的区间修改。下面我们仔细分析这一做法。</p>
<p>因为递归方法总是同时传入结点下标 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 及该结点代表区间的左右界 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>s</mi><mo separator="true">,</mo><mi>t</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[s,t]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">t</span><span class="mclose">]</span></span></span></span> ，因此可以通过 <code>if(l &lt;= s &amp;&amp; t &lt;= r)</code> 来判断当前结点代表的区间是否完全包含于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[l,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 的区间内，若包含，由于知道左右界信息，因此可以直接更新 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">tree[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">ree</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> 。此后查询包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>s</mi><mo separator="true">,</mo><mi>t</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[s,t]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">t</span><span class="mclose">]</span></span></span></span> 的区间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[l,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> ，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>f</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">dfs</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">df</span><span class="mord mathnormal">s</span></span></span></span> 递进到代表 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>s</mi><mo separator="true">,</mo><mi>t</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[s,t]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">t</span><span class="mclose">]</span></span></span></span> 区间的结点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">tree[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">ree</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> 时，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">tree[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">ree</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> 总是正确的。但如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[l,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 值只覆盖了一部分 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>s</mi><mo separator="true">,</mo><mi>t</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[s,t]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">t</span><span class="mclose">]</span></span></span></span> ，就必须从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">tree[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">ree</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> 结点继续向下访问 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>s</mi><mo separator="true">,</mo><mi>t</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[s,t]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">t</span><span class="mclose">]</span></span></span></span> 的子区间，而先前我们并没有将区间修改进行到子区间，因此查询将得不到正确结果。</p>
<p>解决办法是在前一次修改 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>s</mi><mo separator="true">,</mo><mi>t</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[s,t]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">t</span><span class="mclose">]</span></span></span></span> 的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">tree[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">ree</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> 值时，另外使用一个与 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo stretchy="false">[</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">tree[]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">ree</span><span class="mopen">[</span><span class="mclose">]</span></span></span></span> 等大的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>a</mi><mi>z</mi><mi>y</mi><mo stretchy="false">[</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">lazy[]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.03588em;">zy</span><span class="mopen">[</span><span class="mclose">]</span></span></span></span> 数组标记此时的修改 (修改 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>a</mi><mi>z</mi><mi>y</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">lazy[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.03588em;">zy</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> )，以便于下次查询到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">tree[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">ree</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> 时 <strong>将这个修改传递给子区间</strong> 。我们将这个动作称为 <strong>「延迟修改」</strong> ，将这个标记形象地称作 <strong>「懒惰标记」</strong> 。不好理解？没关系，我们马上结合示意图与代码来跟踪相关操作。</p>
<br />
<h4 id="区间修改-增量式">区间修改 (增量式)</h4>
<p>我们先分析 <strong>为区间内所有元素增加同一值的「增量式区间修改」</strong> 操作。</p>
<p>如下图，执行 <code>add(6, 11, 2)</code> 为区间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>6</mn><mo separator="true">,</mo><mn>11</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[6,11]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">11</span><span class="mclose">]</span></span></span></span> 的每个元素都加上 2 。 递归调用到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo stretchy="false">[</mo><mn>6</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">tree[6]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">ree</span><span class="mopen">[</span><span class="mord">6</span><span class="mclose">]</span></span></span></span> 以及 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo stretchy="false">[</mo><mn>11</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">tree[11]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">ree</span><span class="mopen">[</span><span class="mord">11</span><span class="mclose">]</span></span></span></span> 时 (暂时忽略递进到此处之前的操作)，会分别执行 <code>tree[6] += (11 - 8 + 1) * 2</code> 和 <code>tree[11] += (7 - 6 + 1) * 2</code> 。同时，增量 2 也会被 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>a</mi><mi>z</mi><mi>y</mi><mo stretchy="false">[</mo><mn>6</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">lazy[6]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.03588em;">zy</span><span class="mopen">[</span><span class="mord">6</span><span class="mclose">]</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>a</mi><mi>z</mi><mi>y</mi><mo stretchy="false">[</mo><mn>11</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">lazy[11]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.03588em;">zy</span><span class="mopen">[</span><span class="mord">11</span><span class="mclose">]</span></span></span></span> 记录。由于 <strong>标记可能还记录了前面的修改，而修改是增量式的，因此需累加</strong> ，即 <code>lazy[6] += 2</code> 及 <code>lazy[11] += 2</code>。</p>
<p><img src="https://pic.leetcode-cn.com/1663821361-KyUNOS-image.png" alt="image.png"></p>
<p>接着，我们查询 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>6</mn><mo separator="true">,</mo><mn>9</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[6,9]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">9</span><span class="mclose">]</span></span></span></span> 的区间和 ( <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mo stretchy="false">(</mo><mn>6</mn><mo separator="true">,</mo><mn>9</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">sum(6,9)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mopen">(</span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">9</span><span class="mclose">)</span></span></span></span> )，递进访问到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo stretchy="false">[</mo><mn>6</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">tree[6]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">ree</span><span class="mopen">[</span><span class="mord">6</span><span class="mclose">]</span></span></span></span> 结点时，要将懒标记记录的修改量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>a</mi><mi>z</mi><mi>y</mi><mo stretchy="false">[</mo><mn>6</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">lazy[6]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.03588em;">zy</span><span class="mopen">[</span><span class="mord">6</span><span class="mclose">]</span></span></span></span> 传递给 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo stretchy="false">[</mo><mn>12</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">tree[12]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">ree</span><span class="mopen">[</span><span class="mord">12</span><span class="mclose">]</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo stretchy="false">[</mo><mn>13</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">tree[13]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">ree</span><span class="mopen">[</span><span class="mord">13</span><span class="mclose">]</span></span></span></span> 。同样地，访问到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo stretchy="false">[</mo><mn>11</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">tree[11]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">ree</span><span class="mopen">[</span><span class="mord">11</span><span class="mclose">]</span></span></span></span> 结点时，要将懒标记记录的修改量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>a</mi><mi>z</mi><mi>y</mi><mo stretchy="false">[</mo><mn>11</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">lazy[11]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.03588em;">zy</span><span class="mopen">[</span><span class="mord">11</span><span class="mclose">]</span></span></span></span> 传递给 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo stretchy="false">[</mo><mn>22</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">tree[22]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">ree</span><span class="mopen">[</span><span class="mord">22</span><span class="mclose">]</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo stretchy="false">[</mo><mn>23</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">tree[23]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">ree</span><span class="mopen">[</span><span class="mord">23</span><span class="mclose">]</span></span></span></span> 。 <strong>「推送」</strong> 指的是通过 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>u</mi><mi>s</mi><mi>h</mi><mi>D</mi><mi>o</mi><mi>w</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">pushDown</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal">u</span><span class="mord mathnormal">s</span><span class="mord mathnormal">h</span><span class="mord mathnormal">Do</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">n</span></span></span></span> 方法完成 <strong>当前区间以及它的两个子结点区间的区间和以及懒标记的更新</strong> 。</p>
<p><img src="https://pic.leetcode-cn.com/1658588970-kOwQAr-image.png" alt="image.png"></p>
<p>现在我们很容易理解下面的实现代码。<code>private void add</code> 方法中，当递进到所代表的区间完全包含于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[l,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 内的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">tree[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">ree</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> 结点时 (代表区间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>s</mi><mo separator="true">,</mo><mi>t</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[s,t]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">t</span><span class="mclose">]</span></span></span></span> )，我们执行 <code>tree[i] += (t - s + 1) * x</code> 语句更新 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">tree[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">ree</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> ，接着执行 <code>if(s != t) lazy[i] += x</code>  后返回。懒标记更新前的判断使得 <strong>叶子结点不会被标记</strong> ，因为 <strong>叶子结点之下不再有需要推送标记的结点</strong> 。当然也可以不用判断，因为无论是查询还是修改，到达叶子结点时一定会进入方法开始的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>f</mi></mrow><annotation encoding="application/x-tex">if</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> 语句后通过 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>e</mi><mi>t</mi><mi>u</mi><mi>r</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">return</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">re</span><span class="mord mathnormal">t</span><span class="mord mathnormal">u</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">n</span></span></span></span> 返回，叶子结点没有向下推送的机会。</p>
<p><code>if(lazy[i] != 0) pushDown(s, c, t, i)</code> 表示在递归进入左右子结点前，检查当前 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">tree[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">ree</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> 顶点值是否要向下推送标记，<code>lazy[i] != 0</code> 说明当前 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">tree[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">ree</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> 有 <strong>尚未推送的修改</strong> ，需要在这个时候推送到下一层，否则递归进入左右子结点时，左右子结点的区间和是旧的。</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>u</mi><mi>s</mi><mi>h</mi><mi>D</mi><mi>o</mi><mi>w</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">pushDown</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal">u</span><span class="mord mathnormal">s</span><span class="mord mathnormal">h</span><span class="mord mathnormal">Do</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">n</span></span></span></span> 方法传入 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo separator="true">,</mo><mi>c</mi><mo separator="true">,</mo><mi>t</mi><mo separator="true">,</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">s,c,t,i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">c</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">i</span></span></span></span> ，用于更新 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">tree[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">ree</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> 的左子结点区间和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo stretchy="false">[</mo><mn>2</mn><mo>∗</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">tree[2*i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">ree</span><span class="mopen">[</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> 、右子结点区间和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo stretchy="false">[</mo><mn>2</mn><mo>∗</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">tree[2*i+1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">ree</span><span class="mopen">[</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7429em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>  以及它们的懒标记。更新结束后 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">tree[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">ree</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> 结点的「推送修改量」的任务就完成了，需要将其懒标记设置为 0 ，即 <code>lazy[i] = 0</code> ，否则下次修改或查询再经过 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">tree[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">ree</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> 时，会重复推送。</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>d</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">add</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">dd</span></span></span></span> 方法的最后一行调用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>u</mi><mi>s</mi><mi>h</mi><mi>U</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">pushUp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal">u</span><span class="mord mathnormal">s</span><span class="mord mathnormal">h</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord mathnormal">p</span></span></span></span> 方法，这是递归的 <strong>「后序」</strong> 动作，回溯过程中自底向上更新递进路径上的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">tree[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">ree</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 区间修改(驱动): [l,r]区间所有元素加上x</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span>&#123; </span><br><span class="line">    add(l, r, x, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 区间修改: 增量式 [l,r] 区间所有元素加上x</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(l &lt;= s &amp;&amp; t &lt;= r)&#123; <span class="comment">// 当前结点代表的区间在所求区间之内</span></span><br><span class="line">        tree[i] += (t - s + <span class="number">1</span>) * x; <span class="comment">// 结点i的区间和加上t-s+1个x</span></span><br><span class="line">        <span class="keyword">if</span>(s != t) lazy[i] += x; <span class="comment">// 结点i不是叶子结点，懒标记值加上x</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(lazy[i] != <span class="number">0</span>) pushDown(s, c, t, i); <span class="comment">// 当前结点懒惰标记不为0，推送标记</span></span><br><span class="line">    <span class="keyword">if</span>(l &lt;= c) add(l, r, x, s, c, i * <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; c) add(l, r, x, c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">    pushUp(i); <span class="comment">// 后序动作，自底向上更新结点区间和 tree[i]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 更新结点i左右子结点的区间和以及懒惰标记值，最后重置结点i的懒惰标记值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pushDown</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> c, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123; </span><br><span class="line">    tree[i * <span class="number">2</span>] += (c - s + <span class="number">1</span>) * lazy[i]; <span class="comment">// 更新其左子结点的区间和</span></span><br><span class="line">    lazy[i * <span class="number">2</span>] += lazy[i]; <span class="comment">// 传递懒标记(增量标记)</span></span><br><span class="line">    tree[i * <span class="number">2</span> + <span class="number">1</span>] += (t - c) * lazy[i];</span><br><span class="line">    lazy[i * <span class="number">2</span> + <span class="number">1</span>] += lazy[i];</span><br><span class="line">    lazy[i] = <span class="number">0</span>; <span class="comment">// 重置当前结点懒惰标记值（增量标记置0）</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 更新 tree[i]</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pushUp</span><span class="params">(<span class="type">int</span> i)</span>&#123; </span><br><span class="line">    tree[i] = tree[i * <span class="number">2</span>] + tree[i * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br />
<h4 id="区间修改-覆盖式">区间修改 (覆盖式)</h4>
<p>接着分析 <strong>将区间内所有元素修改为同一值的「覆盖式区间修改」</strong> 操作。与单点覆盖式修改方法可以通过调用单点增量式修改方法来实现不同，由于 <strong>涉及多个值的修改</strong> ，区间覆盖式修改不能通过调用区间增量式方法来实现。且覆盖式修改可能将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span> 的原元素值改为 0，因此不能再以 <code>lazy[i] != 0</code> 来作为推送标记的标志。我们可以创建一个新的 <code>boolean updated[]</code> 数组来记录结点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 当前的修改状态，若 <code>updated[i] == true</code> 说明结点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 的 <strong>覆盖式修改未推送</strong> 。需注意的是， <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>u</mi><mi>s</mi><mi>h</mi><mi>D</mi><mi>o</mi><mi>w</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">pushDown</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal">u</span><span class="mord mathnormal">s</span><span class="mord mathnormal">h</span><span class="mord mathnormal">Do</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">n</span></span></span></span> 方法也需要若干调整。如下是区间覆盖式修改的相关代码实现，与增量式区间修改代码的区别仅仅是用 <code>if(updated[i])</code> 代替了 <code>if(lazy[i] != 0)</code> ，以及将「增量赋值」的 <code>+=</code> 改为「覆盖赋值」 <code>=</code> ，以及相应的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mi>p</mi><mi>d</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>d</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">updated[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">u</span><span class="mord mathnormal">p</span><span class="mord mathnormal">d</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">d</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> 的设置和更新。</p>
<p>如果我们能确定覆盖式区间修改不会将元素值改为 0 的话，那 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mi>p</mi><mi>d</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>d</mi><mo stretchy="false">[</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">updated[]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">u</span><span class="mord mathnormal">p</span><span class="mord mathnormal">d</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">d</span><span class="mopen">[</span><span class="mclose">]</span></span></span></span> 数组不是必须的，仍可用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>a</mi><mi>z</mi><mi>y</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">lazy[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.03588em;">zy</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> 是否为 0 作为判断条件，这种情况下增量式与覆盖式的代码将十分相似，几乎只有 <code>+=</code> 和 <code>=</code> 的区别。例如 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/falling-squares/">699. 掉落的方块</a> 一题，需要实现覆盖式区间修改，但题目保证了修改值不会是 0 ，实现代码就不需要另外使用 <code>boolean updated[]</code> ，具体请看「实战应用」中该题 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/falling-squares/solution/-by-yukiyama-lxtu/">题解</a>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 区间修改(驱动): 覆盖式 [l,r] 区间所有元素改为x</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span>&#123; </span><br><span class="line">    update(l, r, x, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 区间修改: 覆盖式 [l,r] 区间所有元素改为x</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(l &lt;= s &amp;&amp; t &lt;= r)&#123; <span class="comment">// 当前结点代表的区间在所求区间之内</span></span><br><span class="line">        tree[i] = (t - s + <span class="number">1</span>) * x; <span class="comment">// 结点i的区间和等于t-s+1个x</span></span><br><span class="line">        <span class="keyword">if</span>(s != t) &#123; <span class="comment">// 结点i不是叶子结点</span></span><br><span class="line">            lazy[i] = x; <span class="comment">// 懒标记值等于x</span></span><br><span class="line">            updated[i] = <span class="literal">true</span>; <span class="comment">// updated[i]置于为为true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(updated[i]) pushDown(s, c, t, i); <span class="comment">// 当前结点updated为true，推送标记</span></span><br><span class="line">    <span class="keyword">if</span>(l &lt;= c) update(l, r, x, s, c, i * <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; c) update(l, r, x, c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">    pushUp(i); <span class="comment">// 后序动作，自底向上更新结点区间和 tree[i]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 更新结点i左右子结点的区间和/懒惰标记值/updated[i]，最后重置懒惰标记值/updated[i]</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pushDown</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> c, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123; </span><br><span class="line">    tree[i * <span class="number">2</span>] = (c - s + <span class="number">1</span>) * lazy[i]; <span class="comment">// 更新其左子结点的区间和</span></span><br><span class="line">    lazy[i * <span class="number">2</span>] = lazy[i]; <span class="comment">// 传递懒标记(覆盖式标记)</span></span><br><span class="line">    updated[i * <span class="number">2</span>] = <span class="literal">true</span>;</span><br><span class="line">    tree[i * <span class="number">2</span> + <span class="number">1</span>] = (t - c) * lazy[i];</span><br><span class="line">    lazy[i * <span class="number">2</span> + <span class="number">1</span>] = lazy[i];</span><br><span class="line">    updated[i * <span class="number">2</span> + <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    lazy[i] = <span class="number">0</span>; <span class="comment">// 重置当前结点懒惰标记值（覆盖式标记置0）</span></span><br><span class="line">    updated[i] = <span class="literal">false</span>; <span class="comment">// 重置当前结点updated[i]为false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br />
<h4 id="类的实现代码-2">类的实现代码</h4>
<h5 id="增量式区间修改版">增量式区间修改版</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 静态线段树 (带懒标记，增量式区间修改)</span></span><br><span class="line"><span class="comment"> * 支持：单点修改 / 单点查询 / 区间求和 / 增量式区间修改</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SegmentTreeAdd</span>&#123;</span><br><span class="line">    <span class="type">int</span>[] nums, tree, lazy;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SegmentTreeAdd</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.nums = nums;</span><br><span class="line">        <span class="built_in">this</span>.n = nums.length;</span><br><span class="line">        <span class="built_in">this</span>.tree = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span> * n];</span><br><span class="line">        <span class="built_in">this</span>.lazy = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span> * n];</span><br><span class="line">        build(<span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> x)</span>&#123; <span class="comment">// 单点修改(驱动): 增量式 nums[i] += x</span></span><br><span class="line">        add(i, x, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> x)</span>&#123; <span class="comment">// 单点修改(驱动): 覆盖式 nums[i] = x</span></span><br><span class="line">        update(i, x, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> i)</span>&#123; <span class="comment">// 单点查询 (驱动): 查询 nums[i]</span></span><br><span class="line">        <span class="keyword">return</span> query(i, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span>&#123; <span class="comment">// 区间修改(驱动): 增量式 [l,r] 区间所有元素加上x</span></span><br><span class="line">        add(l, r, x, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span>&#123; <span class="comment">// 区间查询(驱动): nums[l]~nums[r]之和</span></span><br><span class="line">        <span class="keyword">return</span> sum(l, r, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span>&#123; <span class="comment">// 区间查询 (驱动): 查询[l,r]中的最小值</span></span><br><span class="line">        <span class="keyword">return</span> min(l, r, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span>&#123; <span class="comment">// 区间查询 (驱动): 查询[l,r]中的最大值</span></span><br><span class="line">        <span class="keyword">return</span> max(l, r, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单点修改: 增量式 令nums[idx] += x。修改叶子结点，无关标记。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> x, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) &#123;</span><br><span class="line">            tree[i] += x; <span class="comment">// 增量更新</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(lazy[i] != <span class="number">0</span>) pushDown(s, c, t, i); <span class="comment">// 是否推送标记</span></span><br><span class="line">        <span class="keyword">if</span>(idx &lt;= c) add(idx, x, s, c, i * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">else</span> add(idx, x, c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        pushUp(i); <span class="comment">// 后序动作，自底向上更新结点区间和 tree[i]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单点修改: 覆盖式 令nums[idx] = x。修改叶子结点，无关标记。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> x, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) &#123;</span><br><span class="line">            tree[i] = x; <span class="comment">// 覆盖更新</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(lazy[i] != <span class="number">0</span>) pushDown(s, c, t, i); <span class="comment">// 是否推送标记</span></span><br><span class="line">        <span class="keyword">if</span>(idx &lt;= c) update(idx, x, s, c, i * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">else</span> update(idx, x, c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        pushUp(i);  <span class="comment">// 后序动作，自底向上更新结点区间和 tree[i]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单点查询 (具体): 查询 nums[i]，尾递归</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) <span class="keyword">return</span> tree[i];</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(lazy[i] != <span class="number">0</span>) pushDown(s, c, t, i); <span class="comment">// 是否推送标记</span></span><br><span class="line">        <span class="keyword">if</span>(idx &lt;= c) <span class="keyword">return</span> query(idx, s, c, i * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> query(idx, c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区间修改: 增量式 [l,r] 区间所有元素加上x</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= s &amp;&amp; t &lt;= r)&#123; <span class="comment">// 当前结点代表的区间在所求区间之内</span></span><br><span class="line">            tree[i] += (t - s + <span class="number">1</span>) * x; <span class="comment">// 结点i的区间和加上t-s+1个x</span></span><br><span class="line">            <span class="keyword">if</span>(s != t) lazy[i] += x; <span class="comment">// 结点i不是叶子结点，懒标记值加上x</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(lazy[i] != <span class="number">0</span>) pushDown(s, c, t, i); <span class="comment">// 是否推送标记</span></span><br><span class="line">        <span class="keyword">if</span>(l &lt;= c) add(l, r, x, s, c, i * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(r &gt; c) add(l, r, x, c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        pushUp(i); <span class="comment">// 后序动作，自底向上更新结点区间和 tree[i]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区间查询: 求 nums[l]~nums[r]之和</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= s &amp;&amp; t &lt;= r) <span class="keyword">return</span> tree[i]; <span class="comment">// 当前结点代表的区间在所求区间之内</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(lazy[i] != <span class="number">0</span>) pushDown(s, c, t, i); <span class="comment">// 是否推送标记</span></span><br><span class="line">        <span class="keyword">if</span>(l &lt;= c) sum += sum(l, r, s, c, i * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(r &gt; c) sum += sum(l, r, c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区间查询: 查询[l,r]中的最小值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) <span class="keyword">return</span> tree[i]; <span class="comment">// 叶子结点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>, lmin = Integer.MAX_VALUE, rmin = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">if</span>(lazy[i] != <span class="number">0</span>) pushDown(s, c, t, i); <span class="comment">// 是否推送标记</span></span><br><span class="line">        <span class="keyword">if</span>(l &lt;= c) lmin = min(l, r, s, c, i * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(r &gt; c) rmin = min(l, r, c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> Math.min(lmin, rmin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区间查询: 查询[l,r]中的最大值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) <span class="keyword">return</span> tree[i];</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>, lmax = Integer.MIN_VALUE, rmax = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">if</span>(lazy[i] != <span class="number">0</span>) pushDown(s, c, t, i);</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= c) lmax = max(l, r, s, c, i * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(r &gt; c) rmax = max(l, r, c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> Math.max(lmax, rmax);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构建线段树(tree数组)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) &#123; <span class="comment">// s: start,nums当前结点区间起点下标，t: terminal,nums当前结点区间末尾下标</span></span><br><span class="line">            tree[i] = nums[s];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        build(s, c, i * <span class="number">2</span>);</span><br><span class="line">        build(c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        pushUp(i);  <span class="comment">// 后序动作，自底向上更新结点区间和 tree[i]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// pushup: 更新 tree[i]</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pushUp</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        tree[i] = tree[i * <span class="number">2</span>] + tree[i * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// pushdown: 更新当前结点及其左右子结点的懒标记</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pushDown</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> c, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        tree[i * <span class="number">2</span>] += (c - s + <span class="number">1</span>) * lazy[i]; <span class="comment">// 更新其左子结点的区间和</span></span><br><span class="line">        lazy[i * <span class="number">2</span>] += lazy[i]; <span class="comment">// 传递懒标记(增量标记)</span></span><br><span class="line">        tree[i * <span class="number">2</span> + <span class="number">1</span>] += (t - c) * lazy[i];</span><br><span class="line">        lazy[i * <span class="number">2</span> + <span class="number">1</span>] += lazy[i];</span><br><span class="line">        lazy[i] = <span class="number">0</span>; <span class="comment">// 重置当前结点懒惰标记值（增量标记置0）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br />
<h5 id="覆盖式区间修改版">覆盖式区间修改版</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 静态线段树 (带懒标记，覆盖式区间修改为)</span></span><br><span class="line"><span class="comment"> * 支持：单点修改 / 单点查询 / 区间求和 / 覆盖式区间修改</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SegmentTreeUpdate</span>&#123;</span><br><span class="line">    <span class="type">int</span>[] nums, tree, lazy;</span><br><span class="line">    <span class="type">boolean</span>[] updated;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SegmentTreeUpdate</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.nums = nums;</span><br><span class="line">        <span class="built_in">this</span>.n = nums.length;</span><br><span class="line">        <span class="built_in">this</span>.tree = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span> * n];</span><br><span class="line">        <span class="built_in">this</span>.lazy = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span> * n];</span><br><span class="line">        <span class="built_in">this</span>.updated = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">4</span> * n];</span><br><span class="line">        build(<span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> x)</span>&#123; <span class="comment">// 单点修改(驱动): 增量式 nums[i] += x</span></span><br><span class="line">        add(i, x, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> x)</span>&#123; <span class="comment">// 单点修改(驱动): 覆盖式 nums[i] = x</span></span><br><span class="line">        update(i, x, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> i)</span>&#123; <span class="comment">// 单点查询 (驱动): 查询 nums[i]</span></span><br><span class="line">        <span class="keyword">return</span> query(i, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span>&#123; <span class="comment">// 区间修改(驱动): 覆盖式 [l,r] 区间所有元素改为x</span></span><br><span class="line">        update(l, r, x, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span>&#123; <span class="comment">// 区间查询(驱动): nums[l]~nums[r]之和</span></span><br><span class="line">        <span class="keyword">return</span> sum(l, r, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span>&#123; <span class="comment">// 区间查询 (驱动): 查询[l,r]中的最小值</span></span><br><span class="line">        <span class="keyword">return</span> min(l, r, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span>&#123; <span class="comment">// 区间查询 (驱动): 查询[l,r]中的最大值</span></span><br><span class="line">        <span class="keyword">return</span> max(l, r, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单点修改: 增量式 令nums[idx] += x。修改叶子结点，无关标记。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> x, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) &#123;</span><br><span class="line">            tree[i] += x; <span class="comment">// 增量更新</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(updated[i]) pushDown(s, c, t, i); <span class="comment">// 是否推送标记</span></span><br><span class="line">        <span class="keyword">if</span>(idx &lt;= c) add(idx, x, s, c, i * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">else</span> add(idx, x, c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        pushUp(i); <span class="comment">// 后序动作，自底向上更新结点区间和 tree[i]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单点修改: 覆盖式 令nums[idx] = x。修改叶子结点，无关标记。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> x, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) &#123;</span><br><span class="line">            tree[i] = x; <span class="comment">// 覆盖更新</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(updated[i]) pushDown(s, c, t, i); <span class="comment">// 是否推送标记</span></span><br><span class="line">        <span class="keyword">if</span>(idx &lt;= c) update(idx, x, s, c, i * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">else</span> update(idx, x, c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        pushUp(i);  <span class="comment">// 后序动作，自底向上更新结点区间和 tree[i]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单点查询 (具体): 查询 nums[i]，尾递归</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) <span class="keyword">return</span> tree[i];</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(updated[i]) pushDown(s, c, t, i); <span class="comment">// 当前结点懒惰标记不为0</span></span><br><span class="line">        <span class="keyword">if</span>(idx &lt;= c) <span class="keyword">return</span> query(idx, s, c, i * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> query(idx, c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区间修改: 覆盖式 [l,r] 区间所有元素改为x</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= s &amp;&amp; t &lt;= r)&#123; <span class="comment">// 当前结点代表的区间在所求区间之内</span></span><br><span class="line">            tree[i] = (t - s + <span class="number">1</span>) * x; <span class="comment">// 结点i的区间和等于t-s+1个x</span></span><br><span class="line">            <span class="keyword">if</span>(s != t) &#123; <span class="comment">// 结点i不是叶子结点</span></span><br><span class="line">                lazy[i] = x; <span class="comment">// 更新懒标记</span></span><br><span class="line">                updated[i] = <span class="literal">true</span>; <span class="comment">// 更新updated</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(updated[i]) pushDown(s, c, t, i); <span class="comment">// 是否推送标记</span></span><br><span class="line">        <span class="keyword">if</span>(l &lt;= c) update(l, r, x, s, c, i * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(r &gt; c) update(l, r, x, c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        pushUp(i); <span class="comment">// 后序动作，自底向上更新结点区间和 tree[i]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区间查询: 求 nums[l]~nums[r]之和</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= s &amp;&amp; t &lt;= r) <span class="keyword">return</span> tree[i]; <span class="comment">// 当前结点代表的区间在所要求的区间之内</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(updated[i]) pushDown(s, c, t, i); <span class="comment">// 是否推送标记</span></span><br><span class="line">        <span class="keyword">if</span>(l &lt;= c) sum += sum(l, r, s, c, i * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(r &gt; c) sum += sum(l, r, c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区间查询: 查询[l,r]中的最小值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) <span class="keyword">return</span> tree[i]; <span class="comment">// 叶子结点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>, lmin = Integer.MAX_VALUE, rmin = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">if</span>(updated[i]) pushDown(s, c, t, i); <span class="comment">// 是否推送标记</span></span><br><span class="line">        <span class="keyword">if</span>(l &lt;= c) lmin = min(l, r, s, c, i * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(r &gt; c) rmin = min(l, r, c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> Math.min(lmin, rmin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区间查询: 查询[l,r]中的最大值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) <span class="keyword">return</span> tree[i];</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>, lmax = Integer.MIN_VALUE, rmax = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">if</span>(updated[i]) pushDown(s, c, t, i);</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= c) lmax = max(l, r, s, c, i * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(r &gt; c) rmax = max(l, r, c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> Math.max(lmax, rmax);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构建线段树(tree数组)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) &#123; <span class="comment">// s: start,nums当前结点区间起点下标，t: terminal,nums当前结点区间末尾下标</span></span><br><span class="line">            tree[i] = nums[s];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        build(s, c, i * <span class="number">2</span>);</span><br><span class="line">        build(c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        pushUp(i);  <span class="comment">// 后序动作，自底向上更新结点区间和 tree[i]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// pushup: 更新 tree[i]</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pushUp</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        tree[i] = tree[i * <span class="number">2</span>] + tree[i * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// pushdown: 更新当前结点及其左右子结点的懒标记和updated</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pushDown</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> c, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        tree[i * <span class="number">2</span>] = (c - s + <span class="number">1</span>) * lazy[i]; <span class="comment">// 更新其左子结点的区间和</span></span><br><span class="line">        lazy[i * <span class="number">2</span>] = lazy[i]; <span class="comment">// 传递懒标记(覆盖式标记)</span></span><br><span class="line">        updated[i * <span class="number">2</span>] = <span class="literal">true</span>;</span><br><span class="line">        tree[i * <span class="number">2</span> + <span class="number">1</span>] = (t - c) * lazy[i];</span><br><span class="line">        lazy[i * <span class="number">2</span> + <span class="number">1</span>] = lazy[i];</span><br><span class="line">        updated[i * <span class="number">2</span> + <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">        lazy[i] = <span class="number">0</span>; <span class="comment">// 重置当前结点懒惰标记值</span></span><br><span class="line">        updated[i] = <span class="literal">false</span>; <span class="comment">// 重置当前结点updated[i]为false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br />
<h4 id="小结">小结</h4>
<p>学会了带懒惰标记的线段树后，对于「区间问题」，我们终于掌握了一个比「树状数组」更强大的工具。对于大小为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 的序列 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span> ，带懒惰标记的线段树，同时以 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>  时间复杂度支持 <strong>「单点修改」、「单点查询」、「区间修改」和「区间查询」</strong> 。其中，「区间修改」支持增量式或覆盖式，「区间查询」除了能求区间和，也可以求区间最值，但是要注意 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo stretchy="false">[</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">tree[]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">ree</span><span class="mopen">[</span><span class="mclose">]</span></span></span></span> 定义为「区间和」或「区间最值」时，求区间最值的方法时间复杂度不同，这一点我们在「区间最值查询」小节中已作讨论。</p>
<p>实际上线段树经过一些调整，能够实现更多的区间运算。</p>
<br />
<h3 id="离散化">离散化</h3>
<p>当我们满怀信心带着已掌握的工具试图求解线段树题目时，我们马上会遇到一个难题 ── <strong>空间爆炸</strong>！仍以 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/falling-squares/">699. 掉落的方块</a> 为例，题意不难理解，实际上就是要实现「覆盖式区间修改」和「区间最大值查询」操作。根据题目的数据范围提示，求解区间从 1 到 <strong>最右边方块的右界</strong> 为止，这个值是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mn>1</mn><msup><mn>0</mn><mn>8</mn></msup><mo>+</mo><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup></mrow><annotation encoding="application/x-tex">n=10^8+10^6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span> 。按照我们目前为止讲解的堆式线段树的做法，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo stretchy="false">[</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">tree[]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">ree</span><span class="mopen">[</span><span class="mclose">]</span></span></span></span> 的大小将达到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mo>∗</mo><mi>n</mi><mo>=</mo><mn>4</mn><mo>∗</mo><mo stretchy="false">(</mo><mn>1</mn><msup><mn>0</mn><mn>8</mn></msup><mo>+</mo><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">4*n=4*(10^8+10^6)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> ，会 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi>L</mi><mi>E</mi></mrow><annotation encoding="application/x-tex">MLE</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span> 。</p>
<p>解决该问题的办法我们实际上已在「<a target="_blank" rel="noopener" href="https://leetcode.cn/circle/discuss/qGREiN/">树状数组</a>」中介绍过，那就是在不影响求解的情况下，先将求解区间离散化。以 699 题为例，方块 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mo separator="true">,</mo><mi>l</mi><mo>+</mo><mi>h</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[l,l+h]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class="mclose">]</span></span></span></span> 掉落时，我们首先在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mo separator="true">,</mo><mi>l</mi><mo>+</mo><mi>h</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[l,l+h-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 区间内查询最大高度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">height</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">h</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span></span></span></span> ，然后将此区间修改为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo>+</mo><mi>h</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">h + height</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">h</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span></span></span></span> 。我们发现，只要保证所有方块的左右界的前后关系 (大小关系) 保持不变， 则像下图那样将所有方块的左右界一起离散化后，原问题的解不变。具体求解过程和代码可参考 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/falling-squares/solution/-by-yukiyama-lxtu/">题解</a> 。</p>
<p><img src="https://pic.leetcode-cn.com/1658738555-GFbSIZ-image.png" alt="image.png"></p>
<p>离散化主要分为紧离散和松离散，它们都基于排序，二者的区别已在「<a target="_blank" rel="noopener" href="https://leetcode.cn/circle/discuss/qGREiN/">树状数组</a>」中讲解过。</p>
<br />
<h4 id="紧离散">紧离散</h4>
<p>借助 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>e</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">set</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">se</span><span class="mord mathnormal">t</span></span></span></span> 去重，使得离散化后的有效数字更少，取值范围更小。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 紧离散</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;Integer, Integer&gt; <span class="title function_">discrete</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123; </span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> num : nums) set.add(num);</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(set);</span><br><span class="line">    Collections.sort(list);</span><br><span class="line">    <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> num : list) map.put(num, ++idx);</span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br />
<h4 id="松离散">松离散</h4>
<p>不借助 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>e</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">set</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">se</span><span class="mord mathnormal">t</span></span></span></span> 去重，离散化后的有效数字更多 (存在相同的数字)，取值范围更大。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 松离散</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">discrete</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123; </span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span>[] tmp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    System.arraycopy(nums, <span class="number">0</span>, tmp, <span class="number">0</span>, n);</span><br><span class="line">    Arrays.sort(tmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        nums[i] = Arrays.binarySearch(tmp, nums[i]) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br />
<p>举例而言，对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>=</mo><mo stretchy="false">{</mo><mn>2</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>6</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">nums=\{2,4,4,6\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">6</span><span class="mclose">}</span></span></span></span> ，松离散得到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>=</mo><mo stretchy="false">{</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>4</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">nums=\{1,2,2,4\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">4</span><span class="mclose">}</span></span></span></span>，离散化后的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span> 大小与原来相同；紧离散得到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><mi>p</mi><mo>=</mo><mo stretchy="false">{</mo><mo stretchy="false">(</mo><mn>2</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><mn>4</mn><mo separator="true">,</mo><mn>2</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><mn>6</mn><mo separator="true">,</mo><mn>3</mn><mo stretchy="false">)</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">map=\{(2,1),(4,2),(6,3)\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{(</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">(</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">(</span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">3</span><span class="mclose">)}</span></span></span></span> ， <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mi>e</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">key</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal" style="margin-right:0.03588em;">ey</span></span></span></span> 为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span> 中的元素，对应的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">value</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span></span></span></span> 为其离散化值，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">value</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span></span></span></span>  一定是从 1 开始的没有重复的连续正整数。</p>
<p>两种方式离散化后虽然有效数字不同，取值范围也不同，但通常都是有效的。松离散无需哈希计算，通常速度更快，但有的题目可能更适合返回 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">map</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">p</span></span></span></span> 的紧离散，可根据实际情况选取合适的离散化方式。</p>
<br />
<h3 id="动态开点">动态开点</h3>
<p>现在，有了「离散化」这一工具，我们重新出发。在用「离散化」锤掉 699 题之后，继续尝试解决 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/range-module/">715. Range 模块</a> 一题。按如下理解题意，不难看出这也是一道非常典型的线段树题目。可用支持覆盖式「区间修改」和「区间查询 (求和)」的线段树实现。</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>d</mi><mi>d</mi><mi>R</mi><mi>a</mi><mi>n</mi><mi>g</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">addRange</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">dd</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">an</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">e</span></span></span></span> 方法即覆盖式「区间修改」，我们可以视作将区间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo separator="true">,</mo><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[left,right-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 的每个元素修改为 1。</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mi>u</mi><mi>e</mi><mi>r</mi><mi>y</mi><mi>R</mi><mi>a</mi><mi>n</mi><mi>g</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">queryRange</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mord mathnormal">u</span><span class="mord mathnormal" style="margin-right:0.03588em;">ery</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">an</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">e</span></span></span></span> 方法即「区间查询」，对区间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo separator="true">,</mo><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[left,right-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 求和，若 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mo>=</mo><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo>−</mo><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">sum = right-left</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">t</span></span></span></span>  返回 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>u</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">true</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span></span></span></span> ，否则返回 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>a</mi><mi>l</mi><mi>s</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">false</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">se</span></span></span></span> 。</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>e</mi><mi>m</mi><mi>o</mi><mi>v</mi><mi>e</mi><mi>R</mi><mi>a</mi><mi>n</mi><mi>g</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">removeRange</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">re</span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">an</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">e</span></span></span></span> 方法也是覆盖式「区间修改」，将区间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo separator="true">,</mo><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[left,right-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 的每个元素修改为 0。</li>
</ul>
<p>根据题目给出的取值范围，我们看到「区间」范围为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1,10^9]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span> ，直接用堆式线段树则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo stretchy="false">[</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">tree[]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">ree</span><span class="mopen">[</span><span class="mclose">]</span></span></span></span> 数组大小达到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mo>∗</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">4*10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span> ，会 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi>L</mi><mi>E</mi></mrow><annotation encoding="application/x-tex">MLE</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span> 。当我们打算通过「离散化」来缩小区间时，发现本题是 <strong><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Online_algorithm">强制在线</a></strong> 的，也就是并未提前告诉我们所有涉及询问和修改的区间范围，因此无法离散化。</p>
<p>※ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mn>4</mn><mo>∗</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo stretchy="false">)</mo><mo>&gt;</mo><mn>31</mn><mtext>，</mtext><msup><mn>2</mn><mn>31</mn></msup><mo>=</mo><mn>2</mn><mi>G</mi><mi>b</mi><mi>i</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">log(4*10^9) &gt; 31 ，2^{31} = 2Gbit</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">31</span><span class="mord cjk_fallback">，</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">31</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord">2</span><span class="mord mathnormal">G</span><span class="mord mathnormal">bi</span><span class="mord mathnormal">t</span></span></span></span>  ，因此要创建大小为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mo>∗</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">4*10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span> 的数组，就需要超过 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>G</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">2Gb</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord">2</span><span class="mord mathnormal">G</span><span class="mord mathnormal">b</span></span></span></span> 的空间。</p>
<p>现在请看向本小节的标题 —— <strong>「动态开点」</strong> ，如果你此前有瞥过一些线段树的文章，你应该没少看到过这个词。总之你大概知道既然不能在程序开始时就完成初始「线段树」的构建的话，那就在区间查询或区间修改时，根据届时传入的区间信息来「动态地」创建结点，那么如何做到呢？</p>
<p>为了引出如何动态创建结点，我们先回顾「堆式线段树」的操作。每个结点代表一个确定的区间，当我们需要查询或修改区间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[l,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 时，就要找到代表 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[l,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 的若干结点，操作它们的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">tree[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">ree</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> 值和相应的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>a</mi><mi>z</mi><mi>y</mi><mi mathvariant="normal">/</mi><mi>u</mi><mi>p</mi><mi>d</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">lazy/updated</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.03588em;">zy</span><span class="mord">/</span><span class="mord mathnormal">u</span><span class="mord mathnormal">p</span><span class="mord mathnormal">d</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">d</span></span></span></span> (如果有的话)。我们需要知道搜索过程中结点代表的区间范围 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>s</mi><mo separator="true">,</mo><mi>t</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[s,t]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">t</span><span class="mclose">]</span></span></span></span> ，通过与 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[l,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 的比较来确定是否是目标区间，同时也要知道这个结点的下标 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 使得我们能够操作 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">tree[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">ree</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> ，因此 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo separator="true">,</mo><mi>t</mi><mo separator="true">,</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">s,t,i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">i</span></span></span></span> 三者是绑定的。总之，查找目标区间的关键是:</p>
<blockquote>
<p><strong>方法执行过程中保证结点值 (指 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">tree[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">ree</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span>，一般为区间和 ) 和该结点代表的区间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>s</mi><mo separator="true">,</mo><mi>t</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[s,t]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">t</span><span class="mclose">]</span></span></span></span> 是同时获知的</strong>。</p>
</blockquote>
<p>堆式线段树通过 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo separator="true">,</mo><mn>2</mn><mo>∗</mo><mi>i</mi><mo separator="true">,</mo><mn>2</mn><mo>∗</mo><mi>i</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i, 2*i, 2*i+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7429em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 下标关系实现了这一点。但只要我们能实现以上描述，线段树不必是「堆式」的。</p>
<p>一个直接的想法是不再由 <code>int[] tree</code> 来存储结点值信息，而是以 <code>Node[] tree</code> 来维护结点信息，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mi>o</mi><mi>d</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">Node</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span></span></span></span> 可以作为线段树类中的嵌套类，它持有结点的值信息 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mi>a</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">val</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span> (一般为区间和) ，此外还持有它的左右孩子的下标 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>I</mi><mi>d</mi><mi>x</mi><mo separator="true">,</mo><mi>r</mi><mi>I</mi><mi>d</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">lIdx, rIdx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal">d</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal">d</span><span class="mord mathnormal">x</span></span></span></span> ，这样当我们要递归进入左右孩子结点 (左右子区间) 时，就可以直接从当前结点读取下标，将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo stretchy="false">[</mo><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mi mathvariant="normal">.</mi><mi>l</mi><mi>I</mi><mi>d</mi><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">tree[tree[i].lIdx]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">ree</span><span class="mopen">[</span><span class="mord mathnormal">t</span><span class="mord mathnormal">ree</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal">d</span><span class="mord mathnormal">x</span><span class="mclose">]</span></span></span></span> 或 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo stretchy="false">[</mo><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mi mathvariant="normal">.</mi><mi>r</mi><mi>I</mi><mi>d</mi><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">tree[tree[i].rIdx]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">ree</span><span class="mopen">[</span><span class="mord mathnormal">t</span><span class="mord mathnormal">ree</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal">d</span><span class="mord mathnormal">x</span><span class="mclose">]</span></span></span></span> 传入方法中，实现结点信息 (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo stretchy="false">[</mo><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mi mathvariant="normal">.</mi><mi>l</mi><mi>I</mi><mi>d</mi><mi>x</mi><mo stretchy="false">]</mo><mi mathvariant="normal">.</mi><mi>v</mi><mi>a</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">tree[tree[i].lIdx].val</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">ree</span><span class="mopen">[</span><span class="mord mathnormal">t</span><span class="mord mathnormal">ree</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal">d</span><span class="mord mathnormal">x</span><span class="mclose">]</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span> 或 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo stretchy="false">[</mo><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mi mathvariant="normal">.</mi><mi>r</mi><mi>I</mi><mi>d</mi><mi>x</mi><mo stretchy="false">]</mo><mi mathvariant="normal">.</mi><mi>v</mi><mi>a</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">tree[tree[i].rIdx].val</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">ree</span><span class="mopen">[</span><span class="mord mathnormal">t</span><span class="mord mathnormal">ree</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal">d</span><span class="mord mathnormal">x</span><span class="mclose">]</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span>) 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>s</mi><mo separator="true">,</mo><mi>t</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[s,t]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">t</span><span class="mclose">]</span></span></span></span> 的同时获知。</p>
<p>到这里，我们实际上已经给出了「动态开点线段树」的第一种实现方式 —— 结点数组法。</p>
<br />
<h4 id="结点数组法">结点数组法</h4>
<p>我们直接给出如下包含了构造器和区间修改 (增量式) 的代码，结合后图分析 <strong>「结点数组法动态线段树」</strong> 是如何「动态开点」的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DynamicSegmentTreeArrayAdd</span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        <span class="type">int</span> lIdx, rIdx, lazy, val;</span><br><span class="line">    &#125;</span><br><span class="line">    Node[] tree;</span><br><span class="line">    <span class="type">int</span> n, count;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DynamicSegmentTreeArrayAdd</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">        <span class="built_in">this</span>.count = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">this</span>.tree = <span class="keyword">new</span> <span class="title class_">Node</span>[m];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span>&#123; <span class="comment">// 区间修改(驱动): 增量式 [l,r] 区间所有元素加上x</span></span><br><span class="line">        add(l, r, x, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">// 区间修改: 增量式 [l,r] 区间所有元素加上x</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= s &amp;&amp; t &lt;= r)&#123; <span class="comment">// 当前结点代表的区间在所求区间之内</span></span><br><span class="line">            tree[i].val += (t - s + <span class="number">1</span>) * x; <span class="comment">// 结点i的区间和加上t-s+1个x</span></span><br><span class="line">            <span class="keyword">if</span>(s != t) tree[i].lazy += x; <span class="comment">// 结点i不是叶子结点，懒标记值加上x</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        addNode(i); <span class="comment">// 动态开点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(tree[i].lazy != <span class="number">0</span>) pushDown(s, c, t, i); <span class="comment">// 是否推送标记</span></span><br><span class="line">        <span class="keyword">if</span>(l &lt;= c) add(l, r, x, s, c, tree[i].lIdx);</span><br><span class="line">        <span class="keyword">if</span>(r &gt; c) add(l, r, x, c + <span class="number">1</span>, t, tree[i].rIdx);</span><br><span class="line">        pushUp(i); <span class="comment">// 后序动作，自底向上更新结点区间和 tree[i]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 动态开点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addNode</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tree[i] == <span class="literal">null</span>) tree[i] = <span class="keyword">new</span> <span class="title class_">Node</span>(); <span class="comment">// 当前结点未建，创建之</span></span><br><span class="line">        <span class="keyword">if</span>(tree[i].lIdx == <span class="number">0</span>) &#123; <span class="comment">// 若 tree[i] 结点无左孩子，添加之</span></span><br><span class="line">            tree[i].lIdx = ++count; <span class="comment">// 赋予结点标号</span></span><br><span class="line">            tree[tree[i].lIdx] = <span class="keyword">new</span> <span class="title class_">Node</span>(); <span class="comment">// 开辟实例</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tree[i].rIdx == <span class="number">0</span>) &#123; <span class="comment">// 若 tree[i] 结点无右孩子，添加之</span></span><br><span class="line">            tree[i].rIdx = ++count;</span><br><span class="line">            tree[tree[i].rIdx] = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先看构造器。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 是输入区间的大小，它的范围是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,n-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 。 <strong>整个区间的范围是必须知道的</strong> ，因为我们要从输入区间开始不断划分左右区间，因此要传入 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 。 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">tree</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">ree</span></span></span></span> 的大小，因为在这个实现中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo stretchy="false">[</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">tree[]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">ree</span><span class="mopen">[</span><span class="mclose">]</span></span></span></span> 是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mi>o</mi><mi>d</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">Node</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span></span></span></span> 数组，初始化它必须要给出数组大小。在堆式线段树中，这个大小是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mo>∗</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">4*n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> ，但前面已经说过 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 特别大，且由于「强制在线」而无法离散化，因此这个大小需要 <strong>「估计」</strong> ，估计方法后述。</p>
<p>接着看区间修改的驱动方法和具体的区间修改方法，它们与我们前面给出的堆式线段树的写法几乎相同，区别只在于多了一行 <code>addNode(i)</code> 。 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>d</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">add</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">dd</span></span></span></span> 运行到此处时，之后会划分当前区间为左右子区间，然后带着区间信息和左右子结点的信息递归调用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>d</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">add</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">dd</span></span></span></span> (递进到左右子结点中) 。但是我们 <strong>尚未创建左右子结点，甚至当前结点也可能尚未创建</strong> ，因此必须执行 <code>addNode(i)</code> ，根据方法中的判断结果来决定是否要创建当前结点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">tree[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">ree</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> 、左子结点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo stretchy="false">[</mo><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mi mathvariant="normal">.</mi><mi>l</mi><mi>I</mi><mi>d</mi><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">tree[tree[i].lIdx]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">ree</span><span class="mopen">[</span><span class="mord mathnormal">t</span><span class="mord mathnormal">ree</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal">d</span><span class="mord mathnormal">x</span><span class="mclose">]</span></span></span></span>  或右子结点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo stretchy="false">[</mo><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mi mathvariant="normal">.</mi><mi>r</mi><mi>I</mi><mi>d</mi><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">tree[tree[i].rIdx]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">ree</span><span class="mopen">[</span><span class="mord mathnormal">t</span><span class="mord mathnormal">ree</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal">d</span><span class="mord mathnormal">x</span><span class="mclose">]</span></span></span></span> 。我们注意到结点编号是从 1 开始递增的，因此判断是否存在子结点时， 可以不必像判断当前结点是否存在那样执行 <code>tree[tree[i].lIdx] == null</code> 而是通过 <code>tree[i].lIdx == 0</code> 来判断即可。</p>
<p>同样地，对于其他查询或修改方法，与堆式线段树的实现的区别都只是是在方法中多了 <code>addNode(i)</code> 这一行「开点」语句，如此就实现了 <strong>只在查询或修改时按需动态地创建结点</strong> 这一目标。 完整的类实现我们放在稍后的「类的实现代码」中。如下 ①~⑨ 是在区间为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>14</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,14]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">14</span><span class="mclose">]</span></span></span></span> 的输入序列上修改区间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>3</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1,3]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">3</span><span class="mclose">]</span></span></span></span> 时依次动态创建的结点，注意结点标号是从 1 开始递增的。</p>
<p><img src="https://pic.leetcode-cn.com/1658817308-RgfxZv-image.png" alt="image.png"></p>
<br />
<h5 id="预估结点数">预估结点数</h5>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo stretchy="false">[</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">tree[]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">ree</span><span class="mopen">[</span><span class="mclose">]</span></span></span></span> 的大小 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 需要预估。从上图过程中我们看到，每次查询或修改操作的「开点」次数与树高有关，我们知道树高 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">h</span></span></span></span> 与叶子结点数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> (即我们必须知道的区间大小) 的关系，因此只要能够提前知道操作总次数 (查询和修改) ，并假设查询或修改的区间 <strong>不太大</strong>，我们就能估计经过所有操作后创建的总的结点数，即线段树的大小 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span>。 如下：</p>
<ol>
<li>整棵线段树的结点数不会超过 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mo>∗</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">4*n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 。</li>
<li>每次查询从根结点往下，在假设查询或修改的区间 <strong>只有一个值</strong> ，则每次操作从根结点到表示该值的叶子结点的路径上，每一层只会经过一个区间，开两个点。于是开点次数为树高 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo>=</mo><mo stretchy="false">⌈</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mn>4</mn><mo>∗</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">⌉</mo><mo>−</mo><mn>1</mn><mo>=</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mn>4</mn><mo>∗</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h = \lceil log_{2}(4*n) \rceil -1=log_{2}(4*n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌈</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)⌉</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>  (根结点高 0)，每次开两个点，一次查询最多新建 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>∗</mo><mi>h</mi></mrow><annotation encoding="application/x-tex">2*h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">h</span></span></span></span> 个结点。但平均而言操作的区间当然不会只有一个值，因此这里我们要适当放大倍数，根据经验可放大到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>6</mn><mo>∗</mo><mi>h</mi></mrow><annotation encoding="application/x-tex">6*h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">6</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">h</span></span></span></span> 。</li>
<li>假设有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 次操作，则有估计 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>=</mo><mn>6</mn><mo>∗</mo><mi>k</mi><mo>∗</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mn>4</mn><mo>∗</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">m=6*k*log_{2}(4*n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">6</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> ，省略 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>6</mn><mo>∗</mo><mi>k</mi><mo>∗</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">6*k*2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">6</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span> 后得到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>=</mo><mn>6</mn><mo>∗</mo><mi>k</mi><mo>∗</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">m = 6*k*logn</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">6</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span></span></span></span>  。</li>
</ol>
<p>现在，在参考「类的实现代码」中「结点数组法」版本的代码以及 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/range-module/solution/yukiyama-by-yukiyama-lyg5/">题解</a> 的基础上，应当很容易写出「结点数组法动态线段树」解决  <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/range-module/">715. Range 模块</a> 。</p>
<p>应用结点数组法动态线段树解决 715题 时，我们会感到  <strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 的预估相对麻烦</strong> ，估计偏小时还可能出现数组越界的错误。让我们考虑更严格的情况。假设操作次数也未知，那么我们将无法估计 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> ，也就无法很好地使用结点上数组法来实现动态线段树，除非像 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>r</mi><mi>r</mi><mi>a</mi><mi>y</mi><mi>L</mi><mi>i</mi><mi>s</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">ArrayList</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.02778em;">rr</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord mathnormal">L</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span></span></span></span> 内部动态扩展数组那样，当空间不够时再将当前 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo stretchy="false">[</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">tree[]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">ree</span><span class="mopen">[</span><span class="mclose">]</span></span></span></span> 拷贝到新申请的更大的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mi>o</mi><mi>d</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">Node</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span></span></span></span> 数组中，但如此一来单次查询或修改的时间复杂度就不保证是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 了。</p>
<p>避免数组大小预估的思考引出下面的 <strong>「结点指针 (引用)」法动态线段树」</strong> 。</p>
<br />
<h4 id="结点指针-引用-法">结点指针 (引用) 法</h4>
<p>避免数组大小预估的办法很简单。我们不再通过数组来保存结点信息，而是在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mi>o</mi><mi>d</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">Node</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span></span></span></span> 中持有同样是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mi>o</mi><mi>d</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">Node</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span></span></span></span> 类型的左子结点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>C</mi><mi>h</mi><mi>i</mi><mi>l</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">lChild</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">lC</span><span class="mord mathnormal">hi</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">d</span></span></span></span> 和右子结点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>C</mi><mi>h</mi><mi>i</mi><mi>l</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">rChild</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">hi</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">d</span></span></span></span> 。如此一来，在处理到代表区间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[l,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 的当前结点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>u</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">cur</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">u</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span>  时，我们总是能够将左右子区间分别与 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>u</mi><mi>r</mi><mi mathvariant="normal">.</mi><mi>l</mi><mi>C</mi><mi>h</mi><mi>i</mi><mi>l</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">cur.lChild</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">u</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.07153em;">lC</span><span class="mord mathnormal">hi</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">d</span></span></span></span> 或 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>u</mi><mi>r</mi><mi mathvariant="normal">.</mi><mi>r</mi><mi>C</mi><mi>h</mi><mi>i</mi><mi>l</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">cur.rChild</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">u</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">hi</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">d</span></span></span></span> 「绑定」起来。其实只要读者熟悉二叉树的一些操作，该方法反而比结点数组法要更容易想到。</p>
<p>结点指针法实现的动态线段树是简单的。我们直接给出如下包含了构造器和区间修改 (增量式) 的代码，对比「结点数组」法的代码，主要区别为：</p>
<ul>
<li>指针法的查询或修改方法，直接传入当前结点 <code>Node cur</code> 。</li>
<li>指针法的线段树类维护根结点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>o</mi><mi>o</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">root</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">roo</span><span class="mord mathnormal">t</span></span></span></span> 。</li>
<li>动态开点方法 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>d</mi><mi>d</mi><mi>N</mi><mi>o</mi><mi>d</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">addNode</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">dd</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span></span></span></span> 不同。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DynamicSegmentTreePointerAdd</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        <span class="type">int</span> lazy, val;</span><br><span class="line">        Node lChild, rChild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    Node root;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DynamicSegmentTreePointerAdd</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">        <span class="built_in">this</span>.root = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span>&#123; <span class="comment">// 区间修改(驱动): 增量式 [l,r] 区间所有元素加上x</span></span><br><span class="line">        add(l, r, x, <span class="number">0</span>, n - <span class="number">1</span>, root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单点修改: 增量式 令nums[idx] += x。修改叶子结点，无关标记。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> x, <span class="type">int</span> s, <span class="type">int</span> t, Node cur)</span>&#123; </span><br><span class="line">        <span class="keyword">if</span>(s == t) &#123;</span><br><span class="line">            cur.val += x; <span class="comment">// 增量更新</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        addNode(cur); <span class="comment">// 动态开点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur.lazy != <span class="number">0</span>) pushDown(s, c, t, cur); <span class="comment">// 当前结点懒惰标记不为0，推送标记</span></span><br><span class="line">        <span class="keyword">if</span>(idx &lt;= c) add(idx, x, s, c, cur.lChild);</span><br><span class="line">        <span class="keyword">else</span> add(idx, x, c + <span class="number">1</span>, t, cur.rChild);</span><br><span class="line">        pushUp(cur); <span class="comment">// 后序动作，自底向上更新结点区间和 tree[i]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 动态开点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addNode</span><span class="params">(Node node)</span>&#123; </span><br><span class="line">        <span class="keyword">if</span>(node.lChild == <span class="literal">null</span>) node.lChild = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        <span class="keyword">if</span>(node.rChild == <span class="literal">null</span>) node.rChild = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整实现请参考「类的实现代码」。</p>
<p>从前面一步步看到这里，我们明显感到动态开点的线段树并不复杂，相比静态线段树，实现上的区别不过是引入了一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>d</mi><mi>d</mi><mi>N</mi><mi>o</mi><mi>d</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">addNode</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">dd</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span></span></span></span> 方法，并在查询和修改方法的适当位置调用该方法动态地创建结点而已。</p>
<p>现在，在参考「类的实现代码」中「结点指针 (引用) 法」版本的代码以及 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/range-module/solution/yukiyama-by-yukiyama-lyg5/">题解</a> 的基础上，应当很容易写出「结点指针 (引用) 法动态线段树」解决  <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/range-module/">715. Range 模块</a> 。</p>
<br />
<h4 id="类的实现代码-3">类的实现代码</h4>
<h5 id="结点数组法-2">结点数组法</h5>
<h6 id="增量式区间修改版-2">增量式区间修改版</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态开点线段树数组版 (带懒标记，覆盖式区间修改)</span></span><br><span class="line"><span class="comment"> * 支持：单点修改 / 单点查询 / 区间求和 / 覆盖式区间修改</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DynamicSegmentTreeArrayAdd</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        <span class="type">int</span> lIdx, rIdx, lazy, val;</span><br><span class="line">    &#125;</span><br><span class="line">    Node[] tree;</span><br><span class="line">    <span class="type">int</span> n, count;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DynamicSegmentTreeArrayAdd</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">        <span class="built_in">this</span>.count = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">this</span>.tree = <span class="keyword">new</span> <span class="title class_">Node</span>[m];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> x)</span>&#123; <span class="comment">// 单点修改(驱动): 增量式 nums[i] += x</span></span><br><span class="line">        add(i, x, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> x)</span>&#123; <span class="comment">// 单点修改(驱动): 覆盖式 nums[i] = x</span></span><br><span class="line">        update(i, x, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> i)</span>&#123; <span class="comment">// 单点查询 (驱动): 查询 nums[i]</span></span><br><span class="line">        <span class="keyword">return</span> query(i, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span>&#123; <span class="comment">// 区间修改(驱动): 增量式 [l,r] 区间所有元素加上x</span></span><br><span class="line">        add(l, r, x, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span>&#123; <span class="comment">// 区间查询(驱动): nums[l]~nums[r]之和</span></span><br><span class="line">        <span class="keyword">return</span> sum(l, r, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span>&#123; <span class="comment">// 区间查询 (驱动): 查询[l,r]中的最小值</span></span><br><span class="line">        <span class="keyword">return</span> min(l, r, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span>&#123; <span class="comment">// 区间查询 (驱动): 查询[l,r]中的最小值</span></span><br><span class="line">        <span class="keyword">return</span> max(l, r, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单点修改: 增量式 令nums[idx] += x。修改叶子结点，无关标记。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> x, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) &#123;</span><br><span class="line">            tree[i].val += x; <span class="comment">// 增量更新</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        addNode(i); <span class="comment">// 动态开点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(tree[i].lazy != <span class="number">0</span>) pushDown(s, c, t, i); <span class="comment">// 是否推送标记</span></span><br><span class="line">        <span class="keyword">if</span>(idx &lt;= c) add(idx, x, s, c, tree[i].lIdx);</span><br><span class="line">        <span class="keyword">else</span> add(idx, x, c + <span class="number">1</span>, t, tree[i].rIdx);</span><br><span class="line">        pushUp(i); <span class="comment">// 后序动作，自底向上更新结点区间和 tree[i]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单点修改: 覆盖式 令nums[idx] = x。修改叶子结点，无关标记。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> x, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) &#123;</span><br><span class="line">            tree[i].val = x; <span class="comment">// 覆盖更新</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        addNode(i); <span class="comment">// 动态开点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(tree[i].lazy != <span class="number">0</span>) pushDown(s, c, t, i); <span class="comment">// 是否推送标记</span></span><br><span class="line">        <span class="keyword">if</span>(idx &lt;= c) update(idx, x, s, c, tree[i].lIdx);</span><br><span class="line">        <span class="keyword">else</span> update(idx, x, c + <span class="number">1</span>, t, tree[i].rIdx);</span><br><span class="line">        pushUp(i);  <span class="comment">// 后序动作，自底向上更新结点值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单点查询 (具体): 查询 nums[i]，尾递归</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) <span class="keyword">return</span> tree[i].val;</span><br><span class="line">        addNode(i); <span class="comment">// 动态开点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(tree[i].lazy != <span class="number">0</span>) pushDown(s, c, t, i); <span class="comment">// 是否推送标记</span></span><br><span class="line">        <span class="keyword">if</span>(idx &lt;= c) <span class="keyword">return</span> query(idx, s, c, tree[i].lIdx);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> query(idx, c + <span class="number">1</span>, t, tree[i].rIdx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区间修改: 增量式 [l,r] 区间所有元素加上x</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= s &amp;&amp; t &lt;= r)&#123; <span class="comment">// 当前结点代表的区间在所求区间之内</span></span><br><span class="line">            tree[i].val += (t - s + <span class="number">1</span>) * x; <span class="comment">// 结点i的区间和加上t-s+1个x</span></span><br><span class="line">            <span class="keyword">if</span>(s != t) tree[i].lazy += x; <span class="comment">// 结点i不是叶子结点，懒标记值加上x</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        addNode(i); <span class="comment">// 动态开点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(tree[i].lazy != <span class="number">0</span>) pushDown(s, c, t, i); <span class="comment">// 是否推送标记</span></span><br><span class="line">        <span class="keyword">if</span>(l &lt;= c) add(l, r, x, s, c, tree[i].lIdx);</span><br><span class="line">        <span class="keyword">if</span>(r &gt; c) add(l, r, x, c + <span class="number">1</span>, t, tree[i].rIdx);</span><br><span class="line">        pushUp(i); <span class="comment">// 后序动作，自底向上更新结点区间和 tree[i]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区间查询: 求 nums[l]~nums[r]之和</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= s &amp;&amp; t &lt;= r) <span class="keyword">return</span> tree[i].val; <span class="comment">// 当前结点代表的区间在所求区间之内</span></span><br><span class="line">        addNode(i); <span class="comment">// 动态开点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(tree[i].lazy != <span class="number">0</span>) pushDown(s, c, t, i); <span class="comment">// 是否推送标记</span></span><br><span class="line">        <span class="keyword">if</span>(l &lt;= c) sum += sum(l, r, s, c, tree[i].lIdx);</span><br><span class="line">        <span class="keyword">if</span>(r &gt; c) sum += sum(l, r, c + <span class="number">1</span>, t, tree[i].rIdx);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区间查询: 查询[l,r]中的最小值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) <span class="keyword">return</span> tree[i].val; <span class="comment">// 叶子结点</span></span><br><span class="line">        addNode(i); <span class="comment">// 动态开点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>, lmin = Integer.MAX_VALUE, rmin = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">if</span>(tree[i].lazy != <span class="number">0</span>) pushDown(s, c, t, i); <span class="comment">// 是否推送标记</span></span><br><span class="line">        <span class="keyword">if</span>(l &lt;= c) lmin = min(l, r, s, c, tree[i].lIdx);</span><br><span class="line">        <span class="keyword">if</span>(r &gt; c) rmin = min(l, r, c + <span class="number">1</span>, t, tree[i].rIdx);</span><br><span class="line">        <span class="keyword">return</span> Math.min(lmin, rmin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区间查询: 查询[l,r]中的最大值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) <span class="keyword">return</span> tree[i].val;</span><br><span class="line">        addNode(i); <span class="comment">// 动态开点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>, lmax = Integer.MIN_VALUE, rmax = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">if</span>(tree[i].lazy != <span class="number">0</span>) pushDown(s, c, t, i);</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= c) lmax = max(l, r, s, c, tree[i].lIdx);</span><br><span class="line">        <span class="keyword">if</span>(r &gt; c) rmax = max(l, r, c + <span class="number">1</span>, t, tree[i].rIdx);</span><br><span class="line">        <span class="keyword">return</span> Math.max(lmax, rmax);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// pushup: 更新 cur.val</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pushUp</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> tree[i], lChild = tree[cur.lIdx], rChild = tree[cur.rIdx];</span><br><span class="line">        cur.val = lChild.val + rChild.val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// pushdown: 更新当前结点及其左右子结点的懒标记</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pushDown</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> c, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> tree[i], lChild = tree[cur.lIdx], rChild = tree[cur.rIdx];</span><br><span class="line">        lChild.val += (c - s + <span class="number">1</span>) * cur.lazy; <span class="comment">// 更新其左子结点的区间和</span></span><br><span class="line">        lChild.lazy += cur.lazy; <span class="comment">// 传递懒标记</span></span><br><span class="line">        rChild.val += (t - c) * cur.lazy;</span><br><span class="line">        rChild.lazy += cur.lazy;</span><br><span class="line">        cur.lazy = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 动态开点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addNode</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tree[i] == <span class="literal">null</span>) tree[i] = <span class="keyword">new</span> <span class="title class_">Node</span>(); <span class="comment">// 当前结点未建，创建之</span></span><br><span class="line">        <span class="keyword">if</span>(tree[i].lIdx == <span class="number">0</span>) &#123; <span class="comment">// 若 tree[i] 结点无左孩子，添加之</span></span><br><span class="line">            tree[i].lIdx = ++count; <span class="comment">// 赋予结点标号</span></span><br><span class="line">            tree[tree[i].lIdx] = <span class="keyword">new</span> <span class="title class_">Node</span>(); <span class="comment">// 开辟实例</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tree[i].rIdx == <span class="number">0</span>) &#123; <span class="comment">// 若 tree[i] 结点无右孩子，添加之</span></span><br><span class="line">            tree[i].rIdx = ++count;</span><br><span class="line">            tree[tree[i].rIdx] = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br />
<h6 id="覆盖式区间修改版-2">覆盖式区间修改版</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态开点线段树数组版 (带懒标记，覆盖式区间修改为)</span></span><br><span class="line"><span class="comment"> * 支持：单点修改 / 单点查询 / 区间求和 / 覆盖式区间修改</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DynamicSegmentTreeArrayUpdate</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        <span class="type">int</span> lIdx, rIdx, lazy, val;</span><br><span class="line">        <span class="type">boolean</span> updated;</span><br><span class="line">    &#125;</span><br><span class="line">    Node[] tree;</span><br><span class="line">    <span class="type">int</span> n, count;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DynamicSegmentTreeArrayUpdate</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">        <span class="built_in">this</span>.count = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">this</span>.tree = <span class="keyword">new</span> <span class="title class_">Node</span>[m];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> x)</span>&#123; <span class="comment">// 单点修改(驱动): 增量式 nums[i] += x</span></span><br><span class="line">        add(i, x, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> x)</span>&#123; <span class="comment">// 单点修改(驱动): 覆盖式 nums[i] = x</span></span><br><span class="line">        update(i, x, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> i)</span>&#123; <span class="comment">// 单点查询 (驱动): 查询 nums[i]</span></span><br><span class="line">        <span class="keyword">return</span> query(i, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span>&#123; <span class="comment">// 区间修改(驱动): 覆盖式 [l,r] 区间所有元素改为x</span></span><br><span class="line">        update(l, r, x, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span>&#123; <span class="comment">// 区间查询(驱动): nums[l]~nums[r]之和</span></span><br><span class="line">        <span class="keyword">return</span> sum(l, r, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span>&#123; <span class="comment">// 区间查询 (驱动): 查询[l,r]中的最小值</span></span><br><span class="line">        <span class="keyword">return</span> min(l, r, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span>&#123; <span class="comment">// 区间查询 (驱动): 查询[l,r]中的最大值</span></span><br><span class="line">        <span class="keyword">return</span> max(l, r, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单点修改: 增量式 令nums[idx] += x。修改叶子结点，无关标记。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> x, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) &#123;</span><br><span class="line">            tree[i].val += x; <span class="comment">// 增量更新</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        addNode(i); <span class="comment">// 动态开点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(tree[i].updated) pushDown(s, c, t, i); <span class="comment">// 是否推送标记</span></span><br><span class="line">        <span class="keyword">if</span>(idx &lt;= c) add(idx, x, s, c, tree[i].lIdx);</span><br><span class="line">        <span class="keyword">else</span> add(idx, x, c + <span class="number">1</span>, t, tree[i].rIdx);</span><br><span class="line">        pushUp(i); <span class="comment">// 后序动作，自底向上更新结点区间和 tree[i]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单点修改: 覆盖式 令nums[idx] = x。修改叶子结点，无关标记。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> x, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) &#123;</span><br><span class="line">            tree[i].val = x; <span class="comment">// 覆盖更新</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        addNode(i); <span class="comment">// 动态开点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(tree[i].updated) pushDown(s, c, t, i); <span class="comment">// 是否推送标记</span></span><br><span class="line">        <span class="keyword">if</span>(idx &lt;= c) update(idx, x, s, c, tree[i].lIdx);</span><br><span class="line">        <span class="keyword">else</span> update(idx, x, c + <span class="number">1</span>, t, tree[i].rIdx);</span><br><span class="line">        pushUp(i);  <span class="comment">// 后序动作，自底向上更新结点区间和 tree[i]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单点查询 (具体): 查询 nums[i]，尾递归</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) <span class="keyword">return</span> tree[i].val;</span><br><span class="line">        addNode(i); <span class="comment">// 动态开点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(tree[i].updated) pushDown(s, c, t, i); <span class="comment">// 是否推送标记</span></span><br><span class="line">        <span class="keyword">if</span>(idx &lt;= c) <span class="keyword">return</span> query(idx, s, c, tree[i].lIdx);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> query(idx, c + <span class="number">1</span>, t, tree[i].rIdx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区间修改: 覆盖式 [l,r] 区间所有元素改为x</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= s &amp;&amp; t &lt;= r)&#123; <span class="comment">// 当前结点代表的区间在所求区间之内</span></span><br><span class="line">            tree[i].val = (t - s + <span class="number">1</span>) * x; <span class="comment">// 结点i的区间和等于t-s+1个x</span></span><br><span class="line">            <span class="keyword">if</span>(s != t) &#123;</span><br><span class="line">                tree[i].lazy = x; <span class="comment">// 更新懒标记</span></span><br><span class="line">                tree[i].updated = <span class="literal">true</span>; <span class="comment">// 更新updated</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        addNode(i); <span class="comment">// 动态开点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(tree[i].updated) pushDown(s, c, t, i); <span class="comment">// 是否推送标记</span></span><br><span class="line">        <span class="keyword">if</span>(l &lt;= c) update(l, r, x, s, c, tree[i].lIdx);</span><br><span class="line">        <span class="keyword">if</span>(r &gt; c) update(l, r, x, c + <span class="number">1</span>, t, tree[i].rIdx);</span><br><span class="line">        pushUp(i); <span class="comment">// 后序动作，自底向上更新结点值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区间查询: 求 nums[l]~nums[r]之和</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= s &amp;&amp; t &lt;= r) <span class="keyword">return</span> tree[i].val; <span class="comment">// 当前结点代表的区间在所求区间之内</span></span><br><span class="line">        addNode(i); <span class="comment">// 动态开点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(tree[i].updated) pushDown(s, c, t, i); <span class="comment">// 是否推送标记</span></span><br><span class="line">        <span class="keyword">if</span>(l &lt;= c) sum += sum(l, r, s, c, tree[i].lIdx);</span><br><span class="line">        <span class="keyword">if</span>(r &gt; c) sum += sum(l, r, c + <span class="number">1</span>, t, tree[i].rIdx);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区间查询: 查询[l,r]中的最小值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) <span class="keyword">return</span> tree[i].val; <span class="comment">// 叶子结点</span></span><br><span class="line">        addNode(i); <span class="comment">// 动态开点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>, lmin = Integer.MAX_VALUE, rmin = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">if</span>(tree[i].updated) pushDown(s, c, t, i); <span class="comment">// 是否推送标记</span></span><br><span class="line">        <span class="keyword">if</span>(l &lt;= c) lmin = min(l, r, s, c, tree[i].lIdx);</span><br><span class="line">        <span class="keyword">if</span>(r &gt; c) rmin = min(l, r, c + <span class="number">1</span>, t, tree[i].rIdx);</span><br><span class="line">        <span class="keyword">return</span> Math.min(lmin, rmin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区间查询: 查询[l,r]中的最大值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) <span class="keyword">return</span> tree[i].val;</span><br><span class="line">        addNode(i); <span class="comment">// 动态开点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>, lmax = Integer.MIN_VALUE, rmax = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">if</span>(tree[i].updated) pushDown(s, c, t, i); <span class="comment">// 是否推送标记</span></span><br><span class="line">        <span class="keyword">if</span>(l &lt;= c) lmax = max(l, r, s, c, tree[i].lIdx);</span><br><span class="line">        <span class="keyword">if</span>(r &gt; c) rmax = max(l, r, c + <span class="number">1</span>, t, tree[i].rIdx);</span><br><span class="line">        <span class="keyword">return</span> Math.max(lmax, rmax);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新 cur.val</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pushUp</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> tree[i], lChild = tree[cur.lIdx], rChild = tree[cur.rIdx];</span><br><span class="line">        cur.val = lChild.val + rChild.val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// pushdown: 更新当前结点及其左右子结点的懒标记和updated</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pushDown</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> c, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> tree[i], lChild = tree[cur.lIdx], rChild = tree[cur.rIdx];</span><br><span class="line">        lChild.val = (c - s + <span class="number">1</span>) * cur.lazy; <span class="comment">// 更新左子结点的区间和</span></span><br><span class="line">        lChild.lazy = cur.lazy; <span class="comment">// 传递懒标记(增量标记)到左子结点中</span></span><br><span class="line">        lChild.updated = <span class="literal">true</span>; <span class="comment">// 更新左子结点updated</span></span><br><span class="line">        rChild.val = (t - c) * cur.lazy;</span><br><span class="line">        rChild.lazy = cur.lazy;</span><br><span class="line">        rChild.updated = <span class="literal">true</span>;</span><br><span class="line">        cur.lazy = <span class="number">0</span>; <span class="comment">// 重置当前结点懒惰标记值</span></span><br><span class="line">        cur.updated = <span class="literal">false</span>; <span class="comment">// 更新updated</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 动态开点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addNode</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tree[i] == <span class="literal">null</span>) tree[i] = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        <span class="keyword">if</span>(tree[i].lIdx == <span class="number">0</span>) &#123; <span class="comment">// 若 tree[i] 结点无左孩子，添加之</span></span><br><span class="line">            tree[i].lIdx = ++count; <span class="comment">// 赋予结点标号</span></span><br><span class="line">            tree[tree[i].lIdx] = <span class="keyword">new</span> <span class="title class_">Node</span>(); <span class="comment">// 开辟实例</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tree[i].rIdx == <span class="number">0</span>) &#123; <span class="comment">// 若 tree[i] 结点无右孩子，添加之</span></span><br><span class="line">            tree[i].rIdx = ++count;</span><br><span class="line">            tree[tree[i].rIdx] = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br />
<h5 id="结点指针-引用-法-2">结点指针 (引用) 法</h5>
<h6 id="增量式区间修改版-3">增量式区间修改版</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态开点线段树指针版 (带懒标记，增量式区间修改)</span></span><br><span class="line"><span class="comment"> * 支持：单点修改 / 单点查询 / 区间求和 / 增量式区间修改</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DynamicSegmentTreePointerAdd</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        <span class="type">int</span> lazy, val;</span><br><span class="line">        Node lChild, rChild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    Node root;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DynamicSegmentTreePointerAdd</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">        <span class="built_in">this</span>.root = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> x)</span>&#123; <span class="comment">// 单点修改(驱动): 增量式 nums[i] += x</span></span><br><span class="line">        add(i, x, <span class="number">0</span>, n - <span class="number">1</span>, root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> x)</span>&#123; <span class="comment">// 单点修改(驱动): 覆盖式 nums[i] = x</span></span><br><span class="line">        update(i, x, <span class="number">0</span>, n - <span class="number">1</span>, root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> i)</span>&#123; <span class="comment">// 单点查询 (驱动): 查询 nums[i]</span></span><br><span class="line">        <span class="keyword">return</span> query(i, <span class="number">0</span>, n - <span class="number">1</span>, root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span>&#123; <span class="comment">// 区间修改(驱动): 增量式 [l,r] 区间所有元素加上x</span></span><br><span class="line">        add(l, r, x, <span class="number">0</span>, n - <span class="number">1</span>, root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span>&#123; <span class="comment">// 区间查询(驱动): nums[l]~nums[r]之和</span></span><br><span class="line">        <span class="keyword">return</span> sum(l, r, <span class="number">0</span>, n - <span class="number">1</span>, root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span>&#123; <span class="comment">// 区间查询 (驱动): 查询[l,r]中的最小值</span></span><br><span class="line">        <span class="keyword">return</span> min(l, r, <span class="number">0</span>, n - <span class="number">1</span>, root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span>&#123; <span class="comment">// 区间查询 (驱动): 查询[l,r]中的最大值</span></span><br><span class="line">        <span class="keyword">return</span> max(l, r, <span class="number">0</span>, n - <span class="number">1</span>, root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单点修改: 增量式 令nums[idx] += x。修改叶子结点，无关标记。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> x, <span class="type">int</span> s, <span class="type">int</span> t, Node cur)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) &#123;</span><br><span class="line">            cur.val += x; <span class="comment">// 增量更新</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        addNode(cur); <span class="comment">// 动态开点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur.lazy != <span class="number">0</span>) pushDown(s, c, t, cur); <span class="comment">// 是否推送标记</span></span><br><span class="line">        <span class="keyword">if</span>(idx &lt;= c) add(idx, x, s, c, cur.lChild);</span><br><span class="line">        <span class="keyword">else</span> add(idx, x, c + <span class="number">1</span>, t, cur.rChild);</span><br><span class="line">        pushUp(cur); <span class="comment">// 后序动作，自底向上更新结点区间和 tree[i]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单点修改: 覆盖式 令nums[idx] = x。修改叶子结点，无关标记。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> x, <span class="type">int</span> s, <span class="type">int</span> t, Node cur)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) &#123;</span><br><span class="line">            cur.val = x; <span class="comment">// 覆盖更新</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        addNode(cur); <span class="comment">// 动态开点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur.lazy != <span class="number">0</span>) pushDown(s, c, t, cur); <span class="comment">// 是否推送标记</span></span><br><span class="line">        <span class="keyword">if</span>(idx &lt;= c) update(idx, x, s, c, cur.lChild);</span><br><span class="line">        <span class="keyword">else</span> update(idx, x, c + <span class="number">1</span>, t, cur.rChild);</span><br><span class="line">        pushUp(cur);  <span class="comment">// 后序动作，自底向上更新结点区间和 tree[i]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单点查询: 查询 nums[i]，尾递归</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> s, <span class="type">int</span> t, Node cur)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) <span class="keyword">return</span> cur.val;</span><br><span class="line">        addNode(cur); <span class="comment">// 动态开点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur.lazy != <span class="number">0</span>) pushDown(s, c, t, cur); <span class="comment">// 是否推送标记</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt;= c) <span class="keyword">return</span> query(i, s, c, cur.lChild);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> query(i, c + <span class="number">1</span>, t, cur.rChild);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区间修改: 增量式 [l,r] 区间所有元素加上x</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> s, <span class="type">int</span> t, Node cur)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= s &amp;&amp; t &lt;= r)&#123; <span class="comment">// 当前结点代表的区间在所求区间之内</span></span><br><span class="line">            cur.val += (t - s + <span class="number">1</span>) * x; <span class="comment">// 结点i的区间和加上t-s+1个x</span></span><br><span class="line">            <span class="keyword">if</span>(s != t) cur.lazy += x; <span class="comment">// 结点i不是叶子结点，懒标记值加上x</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        addNode(cur); <span class="comment">// 动态开点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur.lazy != <span class="number">0</span>) pushDown(s, c, t, cur); <span class="comment">// 是否推送标记</span></span><br><span class="line">        <span class="keyword">if</span>(l &lt;= c) add(l, r, x, s, c, cur.lChild);</span><br><span class="line">        <span class="keyword">if</span>(r &gt; c) add(l, r, x, c + <span class="number">1</span>, t, cur.rChild);</span><br><span class="line">        pushUp(cur); <span class="comment">// 后序动作，自底向上更新结点区间和 tree[i]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区间查询: 求 nums[l]~nums[r]之和</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> s, <span class="type">int</span> t, Node cur)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= s &amp;&amp; t &lt;= r) <span class="keyword">return</span> cur.val; <span class="comment">// 当前结点代表的区间在所求区间之内</span></span><br><span class="line">        addNode(cur); <span class="comment">// 动态开点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur.lazy != <span class="number">0</span>) pushDown(s, c, t, cur); <span class="comment">// 是否推送标记</span></span><br><span class="line">        <span class="keyword">if</span>(l &lt;= c) sum += sum(l, r, s, c, cur.lChild);</span><br><span class="line">        <span class="keyword">if</span>(r &gt; c) sum += sum(l, r, c + <span class="number">1</span>, t, cur.rChild);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区间查询: 查询[l,r]中的最小值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> s, <span class="type">int</span> t, Node cur)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) <span class="keyword">return</span> cur.val; <span class="comment">// 叶子结点</span></span><br><span class="line">        addNode(cur); <span class="comment">// 动态开点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>, lmin = Integer.MAX_VALUE, rmin = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">if</span>(cur.lazy != <span class="number">0</span>) pushDown(s, c, t, cur); <span class="comment">// 是否推送标记</span></span><br><span class="line">        <span class="keyword">if</span>(l &lt;= c) lmin = min(l, r, s, c, cur.lChild);</span><br><span class="line">        <span class="keyword">if</span>(r &gt; c) rmin = min(l, r, c + <span class="number">1</span>, t, cur.rChild);</span><br><span class="line">        <span class="keyword">return</span> Math.min(lmin, rmin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区间查询: 查询[l,r]中的最大值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> s, <span class="type">int</span> t, Node cur)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) <span class="keyword">return</span> cur.val;</span><br><span class="line">        addNode(cur);</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>, lmax = Integer.MIN_VALUE, rmax = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">if</span>(cur.lazy != <span class="number">0</span>) pushDown(s, c, t, cur);</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= c) lmax = max(l, r, s, c, cur.lChild);</span><br><span class="line">        <span class="keyword">if</span>(r &gt; c) rmax = max(l, r, c + <span class="number">1</span>, t, cur.rChild);</span><br><span class="line">        <span class="keyword">return</span> Math.max(lmax, rmax);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// pushup: 更新 cur.val</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pushUp</span><span class="params">(Node cur)</span>&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">lChild</span> <span class="operator">=</span> cur.lChild, rChild = cur.rChild;</span><br><span class="line">        cur.val = lChild.val + rChild.val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// pushdown: 更新当前结点及其左右子结点的懒标记</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pushDown</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> c, <span class="type">int</span> t, Node cur)</span>&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">lChild</span> <span class="operator">=</span> cur.lChild, rChild = cur.rChild;</span><br><span class="line">        lChild.val += (c - s + <span class="number">1</span>) * cur.lazy; <span class="comment">// 更新其左子结点的区间和</span></span><br><span class="line">        lChild.lazy += cur.lazy; <span class="comment">// 传递懒标记</span></span><br><span class="line">        rChild.val += (t - c) * cur.lazy;</span><br><span class="line">        rChild.lazy += cur.lazy;</span><br><span class="line">        cur.lazy = <span class="number">0</span>; <span class="comment">// 重置当前结点懒惰标记值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 动态开点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addNode</span><span class="params">(Node node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node.lChild == <span class="literal">null</span>) node.lChild = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        <span class="keyword">if</span>(node.rChild == <span class="literal">null</span>) node.rChild = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br />
<h6 id="覆盖式区间修改版-3">覆盖式区间修改版</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态开点线段树指针版 (带懒标记，覆盖式区间修改)</span></span><br><span class="line"><span class="comment"> * 支持：单点修改 / 单点查询 / 区间查询 / 覆盖式区间修改</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DynamicSegmentTreePointerUpdate</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        <span class="type">int</span> lazy, val;</span><br><span class="line">        <span class="type">boolean</span> updated;</span><br><span class="line">        Node lChild, rChild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    Node root;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DynamicSegmentTreePointerUpdate</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">        <span class="built_in">this</span>.root = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> x)</span>&#123; <span class="comment">// 单点修改(驱动): 增量式 nums[i] += x</span></span><br><span class="line">        add(i, x, <span class="number">0</span>, n - <span class="number">1</span>, root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> x)</span>&#123; <span class="comment">// 单点修改(驱动): 覆盖式 nums[i] = x</span></span><br><span class="line">        update(i, x, <span class="number">0</span>, n - <span class="number">1</span>, root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> i)</span>&#123; <span class="comment">// 单点查询(驱动): 查询 nums[i]</span></span><br><span class="line">        <span class="keyword">return</span> query(i, <span class="number">0</span>, n - <span class="number">1</span>, root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span>&#123; <span class="comment">// 区间修改(驱动): 增量式 [l,r] 区间所有元素加上x</span></span><br><span class="line">        update(l, r, x, <span class="number">0</span>, n - <span class="number">1</span>, root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span>&#123; <span class="comment">// 区间查询(驱动): nums[l]~nums[r]之和</span></span><br><span class="line">        <span class="keyword">return</span> sum(l, r, <span class="number">0</span>, n - <span class="number">1</span>, root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span>&#123; <span class="comment">// 区间查询(驱动): 查询[l,r]中的最小值</span></span><br><span class="line">        <span class="keyword">return</span> min(l, r, <span class="number">0</span>, n - <span class="number">1</span>, root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span>&#123; <span class="comment">// 区间查询(驱动): 查询[l,r]中的最大值</span></span><br><span class="line">        <span class="keyword">return</span> max(l, r, <span class="number">0</span>, n - <span class="number">1</span>, root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单点修改: 增量式 令nums[idx] += x。修改叶子结点，无关标记。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> x, <span class="type">int</span> s, <span class="type">int</span> t, Node cur)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) &#123;</span><br><span class="line">            cur.val += x; <span class="comment">// 增量更新</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        addNode(cur); <span class="comment">// 动态开点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur.updated) pushDown(s, c, t, cur); <span class="comment">// 是否推送标记</span></span><br><span class="line">        <span class="keyword">if</span>(idx &lt;= c) add(idx, x, s, c, cur.lChild);</span><br><span class="line">        <span class="keyword">else</span> add(idx, x, c + <span class="number">1</span>, t, cur.rChild);</span><br><span class="line">        pushUp(cur); <span class="comment">// 后序动作，自底向上更新结点区间和 tree[i]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单点修改: 覆盖式 令nums[idx] = x。修改叶子结点，无关标记。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> x, <span class="type">int</span> s, <span class="type">int</span> t, Node cur)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) &#123;</span><br><span class="line">            cur.val = x; <span class="comment">// 覆盖更新</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        addNode(cur); <span class="comment">// 动态开点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur.updated) pushDown(s, c, t, cur); <span class="comment">// 是否推送标记</span></span><br><span class="line">        <span class="keyword">if</span>(idx &lt;= c) update(idx, x, s, c, cur.lChild);</span><br><span class="line">        <span class="keyword">else</span> update(idx, x, c + <span class="number">1</span>, t, cur.rChild);</span><br><span class="line">        pushUp(cur);  <span class="comment">// 后序动作，自底向上更新结点区间和 tree[i]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单点查询: 查询 nums[i]，尾递归</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> s, <span class="type">int</span> t, Node cur)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) <span class="keyword">return</span> cur.val;</span><br><span class="line">        addNode(cur); <span class="comment">// 动态开点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur.updated) pushDown(s, c, t, cur); <span class="comment">// 是否推送标记</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt;= c) <span class="keyword">return</span> query(i, s, c, cur.lChild);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> query(i, c + <span class="number">1</span>, t, cur.rChild);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区间修改: 覆盖式 [l,r] 区间所有元素改为x</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> s, <span class="type">int</span> t, Node cur)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= s &amp;&amp; t &lt;= r)&#123; <span class="comment">// 当前结点代表的区间在所求区间之内</span></span><br><span class="line">            cur.val = (t - s + <span class="number">1</span>) * x; <span class="comment">// 结点i的区间和等于t-s+1个x</span></span><br><span class="line">            <span class="keyword">if</span>(s != t) &#123; <span class="comment">// 结点i不是叶子结点</span></span><br><span class="line">                cur.lazy = x; <span class="comment">// 更新懒标记</span></span><br><span class="line">                cur.updated = <span class="literal">true</span>; <span class="comment">// 更新updated</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        addNode(cur); <span class="comment">// 动态开点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur.updated) pushDown(s, c, t, cur); <span class="comment">// 是否推送标记</span></span><br><span class="line">        <span class="keyword">if</span>(l &lt;= c) update(l, r, x, s, c, cur.lChild);</span><br><span class="line">        <span class="keyword">if</span>(r &gt; c) update(l, r, x, c + <span class="number">1</span>, t, cur.rChild);</span><br><span class="line">        pushUp(cur); <span class="comment">// 后序动作，自底向上更新结点区间和 tree[i]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区间查询: 求 nums[l]~nums[r]之和</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> s, <span class="type">int</span> t, Node cur)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= s &amp;&amp; t &lt;= r) <span class="keyword">return</span> cur.val; <span class="comment">// 当前结点代表的区间在所求区间之内</span></span><br><span class="line">        addNode(cur); <span class="comment">// 动态开点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur.updated) pushDown(s, c, t, cur); <span class="comment">// 是否推送标记</span></span><br><span class="line">        <span class="keyword">if</span>(l &lt;= c) sum += sum(l, r, s, c, cur.lChild);</span><br><span class="line">        <span class="keyword">if</span>(r &gt; c) sum += sum(l, r, c + <span class="number">1</span>, t, cur.rChild);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区间查询: 查询[l,r]中的最小值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> s, <span class="type">int</span> t, Node cur)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) <span class="keyword">return</span> cur.val; <span class="comment">// 叶子结点</span></span><br><span class="line">        addNode(cur); <span class="comment">// 动态开点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>, lmin = Integer.MAX_VALUE, rmin = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">if</span>(cur.updated) pushDown(s, c, t, cur); <span class="comment">// 是否推送标记</span></span><br><span class="line">        <span class="keyword">if</span>(l &lt;= c) lmin = min(l, r, s, c, cur.lChild);</span><br><span class="line">        <span class="keyword">if</span>(r &gt; c) rmin = min(l, r, c + <span class="number">1</span>, t, cur.rChild);</span><br><span class="line">        <span class="keyword">return</span> Math.min(lmin, rmin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区间查询: 查询[l,r]中的最大值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> s, <span class="type">int</span> t, Node cur)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) <span class="keyword">return</span> cur.val;</span><br><span class="line">        addNode(cur);</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>, lmax = Integer.MIN_VALUE, rmax = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">if</span>(cur.updated) pushDown(s, c, t, cur);</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= c) lmax = max(l, r, s, c, cur.lChild);</span><br><span class="line">        <span class="keyword">if</span>(r &gt; c) rmax = max(l, r, c + <span class="number">1</span>, t, cur.rChild);</span><br><span class="line">        <span class="keyword">return</span> Math.max(lmax, rmax);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// pushup: 更新 cur.val</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pushUp</span><span class="params">(Node cur)</span>&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">lChild</span> <span class="operator">=</span> cur.lChild, rChild = cur.rChild;</span><br><span class="line">        cur.val = lChild.val + rChild.val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// pushdown: 更新当前结点及其左右子结点的懒标记和updated</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pushDown</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> c, <span class="type">int</span> t, Node cur)</span>&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">lChild</span> <span class="operator">=</span> cur.lChild, rChild = cur.rChild;</span><br><span class="line">        lChild.val = (c - s + <span class="number">1</span>) * cur.lazy; <span class="comment">// 更新其左子结点的区间和</span></span><br><span class="line">        lChild.lazy = cur.lazy; <span class="comment">// 传递懒标记(增量标记)</span></span><br><span class="line">        lChild.updated = <span class="literal">true</span>;</span><br><span class="line">        rChild.val = (t - c) * cur.lazy;</span><br><span class="line">        rChild.lazy = cur.lazy;</span><br><span class="line">        rChild.updated = <span class="literal">true</span>;</span><br><span class="line">        cur.lazy = <span class="number">0</span>; <span class="comment">// 重置当前结点懒惰标记值（增量标记置0）</span></span><br><span class="line">        cur.updated = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 动态开点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addNode</span><span class="params">(Node node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node.lChild == <span class="literal">null</span>) node.lChild = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        <span class="keyword">if</span>(node.rChild == <span class="literal">null</span>) node.rChild = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br />
<h3 id="总结">总结</h3>
<p>本文从基本的静态线段树到动态线段树，介绍了如下内容。</p>
<ul>
<li><strong>基本原理：</strong> 通过 <strong>「完全二叉树下标性质」</strong> 和 <strong>「分治算法」</strong> 来理解基本线段树的工作原理。</li>
<li><strong>基本 (静态) 线段树：</strong> 首先实现了支持「单点修改」和「区间查询」的基本线段树，可解决 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/range-sum-query-mutable/">307. 区域和检索 - 数组可修改</a> 。</li>
<li><strong>懒惰标记：</strong> 引入 <strong>「懒惰标记」</strong> 和 <strong>「延迟修改」</strong> 的概念，用以实现 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 时间复杂度的 「区间修改」。</li>
<li><strong>离散化：</strong> 当区间问题与区间元素的绝对位置无关而只与它们的相对位置有关时，可以采用 <strong>「离散化」</strong> 压缩区间范围，典型题目如 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/falling-squares/">699. 掉落的方块</a> 。具体的离散化方法包括 <strong>「紧离散」</strong> 和 <strong>「松离散」</strong> 。</li>
<li><strong>动态开点：</strong> 当区间问题具有「<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Online_algorithm">强制在线</a>」的特点时，由于无法离散化，迫使我们思考能否实现 <strong>「动态开点」</strong>  (动态地创建结点) 的线段树。典型题目如 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/range-module/">715. Range 模块</a> 。
<ul>
<li>
<p><strong>数组法动态线段树：</strong> 若能提前估计树的大小，可用  <strong>「结点数组法」</strong> 实现动态开点线段树。给出结点数估计方法。</p>
<ul>
<li><strong>结点数估计</strong>: 在已知操作次数上限的情况下可以预估结点数，以便于初始化「结点数组」。</li>
</ul>
</li>
<li>
<p><strong>指针法动态线段树：</strong> 通过 <strong>「结点指针 (引用) 法」</strong> 实现的动态开点线段树，无需预估树的大小。</p>
</li>
</ul>
</li>
</ul>
<p>文中我们给出了如下十种线段树的完整的类代码。</p>
<table>
<thead>
<tr>
<th>线段树类</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1. <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>e</mi><mi>g</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>T</mi><mi>r</mi><mi>e</mi><mi>e</mi><mi>B</mi><mi>a</mi><mi>s</mi><mi>i</mi><mi>c</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">SegmentTreeBasic1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.13889em;">tT</span><span class="mord mathnormal">ree</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord mathnormal">a</span><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mord mathnormal">c</span><span class="mord">1</span></span></span></span></td>
<td>基本静态线段树，不带懒惰标记，只支持单点修改和区间查询，实时维护 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span></td>
</tr>
<tr>
<td>2. <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>e</mi><mi>g</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>T</mi><mi>r</mi><mi>e</mi><mi>e</mi><mi>B</mi><mi>a</mi><mi>s</mi><mi>i</mi><mi>c</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">SegmentTreeBasic2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.13889em;">tT</span><span class="mord mathnormal">ree</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord mathnormal">a</span><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mord mathnormal">c</span><span class="mord">2</span></span></span></span></td>
<td>基本静态线段树，不带懒惰标记，只支持单点修改和区间查询，不维护 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span></td>
</tr>
<tr>
<td>3. <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>e</mi><mi>g</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>T</mi><mi>r</mi><mi>e</mi><mi>e</mi><mi>A</mi><mi>d</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">SegmentTreeAdd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.13889em;">tT</span><span class="mord mathnormal">ree</span><span class="mord mathnormal">A</span><span class="mord mathnormal">dd</span></span></span></span></td>
<td>静态线段树，带懒惰标记，支持单点修改/单点查询/增量式区间修改/区间查询</td>
</tr>
<tr>
<td>4. <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>e</mi><mi>g</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>T</mi><mi>r</mi><mi>e</mi><mi>e</mi><mi>U</mi><mi>p</mi><mi>d</mi><mi>a</mi><mi>t</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">SegmentTreeUpdate</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.13889em;">tT</span><span class="mord mathnormal">ree</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord mathnormal">p</span><span class="mord mathnormal">d</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span></span></span></span></td>
<td>静态线段树，带懒惰标记，支持单点修改/单点查询/覆盖式区间修改/区间查询</td>
</tr>
<tr>
<td>5. <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mi>y</mi><mi>n</mi><mi>a</mi><mi>m</mi><mi>i</mi><mi>c</mi><mi>S</mi><mi>e</mi><mi>g</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>T</mi><mi>r</mi><mi>e</mi><mi>e</mi><mi>A</mi><mi>r</mi><mi>r</mi><mi>a</mi><mi>y</mi><mi>A</mi><mi>d</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">DynamicSegmentTreeArrayAdd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">Dy</span><span class="mord mathnormal">nami</span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.13889em;">tT</span><span class="mord mathnormal">ree</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.02778em;">rr</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord mathnormal">A</span><span class="mord mathnormal">dd</span></span></span></span></td>
<td>结点数组法动态线段树，带懒惰标记，支持单点修改/单点查询/增量式区间修改/区间查询</td>
</tr>
<tr>
<td>6. <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mi>y</mi><mi>n</mi><mi>a</mi><mi>m</mi><mi>i</mi><mi>c</mi><mi>S</mi><mi>e</mi><mi>g</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>T</mi><mi>r</mi><mi>e</mi><mi>e</mi><mi>A</mi><mi>r</mi><mi>r</mi><mi>a</mi><mi>y</mi><mi>U</mi><mi>p</mi><mi>d</mi><mi>a</mi><mi>t</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">DynamicSegmentTreeArrayUpdate</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">Dy</span><span class="mord mathnormal">nami</span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.13889em;">tT</span><span class="mord mathnormal">ree</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.02778em;">rr</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord mathnormal">p</span><span class="mord mathnormal">d</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span></span></span></span></td>
<td>结点数组法动态线段树，带懒惰标记，支持单点修改/单点查询/覆盖式区间修改/区间查询</td>
</tr>
<tr>
<td>7. <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mi>y</mi><mi>n</mi><mi>a</mi><mi>m</mi><mi>i</mi><mi>c</mi><mi>S</mi><mi>e</mi><mi>g</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>T</mi><mi>r</mi><mi>e</mi><mi>e</mi><mi>P</mi><mi>o</mi><mi>i</mi><mi>n</mi><mi>t</mi><mi>e</mi><mi>r</mi><mi>A</mi><mi>d</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">DynamicSegmentTreePointerAdd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">Dy</span><span class="mord mathnormal">nami</span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.13889em;">tT</span><span class="mord mathnormal">ree</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal">o</span><span class="mord mathnormal">in</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">er</span><span class="mord mathnormal">A</span><span class="mord mathnormal">dd</span></span></span></span></td>
<td>结点指针法动态线段树，带懒惰标记，支持单点修改/单点查询/增量式区间修改/区间查询</td>
</tr>
<tr>
<td>8. <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mi>y</mi><mi>n</mi><mi>a</mi><mi>m</mi><mi>i</mi><mi>c</mi><mi>S</mi><mi>e</mi><mi>g</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>T</mi><mi>r</mi><mi>e</mi><mi>e</mi><mi>P</mi><mi>o</mi><mi>i</mi><mi>n</mi><mi>t</mi><mi>e</mi><mi>r</mi><mi>U</mi><mi>p</mi><mi>d</mi><mi>a</mi><mi>t</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">DynamicSegmentTreePointerUpdate</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">Dy</span><span class="mord mathnormal">nami</span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.13889em;">tT</span><span class="mord mathnormal">ree</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal">o</span><span class="mord mathnormal">in</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">er</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord mathnormal">p</span><span class="mord mathnormal">d</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span></span></span></span></td>
<td>结点指针法动态线段树，带懒惰标记，支持单点修改/单点查询/覆盖式区间修改/区间查询</td>
</tr>
<tr>
<td>9. <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>e</mi><mi>g</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>T</mi><mi>r</mi><mi>e</mi><mi>e</mi><mi>B</mi><mi>a</mi><mi>s</mi><mi>i</mi><mi>c</mi><mi>R</mi><mi>a</mi><mi>n</mi><mi>g</mi><mi>e</mi><mi>M</mi><mi>a</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">SegmentTreeBasicRangeMax</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.13889em;">tT</span><span class="mord mathnormal">ree</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord mathnormal">a</span><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">an</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span></span></span></span></td>
<td>区间最大值基本静态线段树，无懒标记，不维护 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span>，支持单点修改/单点查询/区间查询</td>
</tr>
<tr>
<td>10. <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>e</mi><mi>g</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>T</mi><mi>r</mi><mi>e</mi><mi>e</mi><mi>B</mi><mi>a</mi><mi>s</mi><mi>i</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">SegmentTreeBasic</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.13889em;">tT</span><span class="mord mathnormal">ree</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord mathnormal">a</span><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mord mathnormal">c</span></span></span></span></td>
<td>扩展区间查询基本静态线段树，无懒标记，不维护 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span>，支持单点修改/单点查询/区间查询</td>
</tr>
</tbody>
</table>
<p>注意，1~8 的实现中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo stretchy="false">[</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">tree[]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">ree</span><span class="mopen">[</span><span class="mclose">]</span></span></span></span> 记录的是「区间和」，9记录的「最大值」，10以三个线段树数组同时记录「区间和」、「区间最大值」以及「区间最小值」。总之，将 1~8 中的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo stretchy="false">[</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">tree[]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">ree</span><span class="mopen">[</span><span class="mclose">]</span></span></span></span> 用于记录「区间最值」，经过我们在「区间最值查询」小节中的调整，即可得到相应的以 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 时间复杂度实现区间最值查询的线段树版本。</p>
<p>线段树的应用是十分灵活而强大的，本文只讲解了作者所知的最基本的一些内容，更多的应用已然超出了作者的水平。好在这些内容已基本足够求解力扣上几乎所有线段树题目。</p>
<p>※ 推荐清华大学张昆玮写的一份 101 页的 ppt 材料 <a target="_blank" rel="noopener" href="https://github.com/tiankonguse/lab/blob/master/acm/paper/%E7%BB%9F%E8%AE%A1%E7%9A%84%E5%8A%9B%E9%87%8F%E2%80%94%E2%80%94%E7%BA%BF%E6%AE%B5%E6%A0%91%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B.pdf">统计的力量 —— 线段树全接触</a> ，可作为线段树应用的总览材料。</p>
<br />
<h3 id="实战应用">实战应用</h3>
<table>
<thead>
<tr>
<th>题目</th>
<th>难度</th>
<th>题解</th>
</tr>
</thead>
<tbody>
<tr>
<td><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/range-sum-query-mutable/">307. 区域和检索 - 数组可修改</a></td>
<td>中等</td>
<td><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/range-sum-query-mutable/solution/yukiyama-by-yukiyama-euo5/">题解</a></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/falling-squares/">699. 掉落的方块</a></td>
<td>困难</td>
<td><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/falling-squares/solution/-by-yukiyama-lxtu/">题解</a></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/range-module/">715. Range 模块</a></td>
<td>困难</td>
<td><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/range-module/solution/yukiyama-by-yukiyama-lyg5/">题解</a></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/the-skyline-problem/">218. 天际线问题</a></td>
<td>困难</td>
<td><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/the-skyline-problem/solution/by-yukiyama-l4rc/">题解</a></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/my-calendar-i/">729. 我的日程安排表 I</a></td>
<td>中等</td>
<td><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/my-calendar-i/solution/by-yukiyama-kddx/">题解</a></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/my-calendar-ii/">731. 我的日程安排表 II</a></td>
<td>中等</td>
<td><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/my-calendar-ii/solution/yukiyama-by-yukiyama-uuvj/">题解</a></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/my-calendar-iii/">732. 我的日程安排表 III</a></td>
<td>困难</td>
<td><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/my-calendar-iii/solution/by-yukiyama-7zz5/">题解</a></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/meeting-rooms-ii/">253. 会议室 II</a></td>
<td>中等</td>
<td><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/meeting-rooms-ii/solution/yukiyama-by-yukiyama-9cml/">题解</a></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-increasing-subsequence-ii/">2407. 最长递增子序列 II</a></td>
<td>困难</td>
<td><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-increasing-subsequence-ii/solution/-by-yukiyama-khmm/">题解</a></td>
</tr>
<tr>
<td>==== 更多题目追加中 ====</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<br />
<hr>
<p><strong>文章更新日志</strong></p>
<p>[2022-09-18]</p>
<ul>
<li>增加了少量内容，说明 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo stretchy="false">[</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">tree[]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">ree</span><span class="mopen">[</span><span class="mclose">]</span></span></span></span> 代表「区间和」和「区间最值」时，求最值的方法 (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">max</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span></span></span></span> , <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">min</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">min</span></span></span></span>) 的时间复杂度的区别。即当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo stretchy="false">[</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">tree[]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">ree</span><span class="mopen">[</span><span class="mclose">]</span></span></span></span> 代表「区间和」时，求最值的方法的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> ，代表「区间最值」时，为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 。</li>
</ul>
<p>[2022-08-03]</p>
<ul>
<li>在「实战应用」中增加 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/meeting-rooms-ii/">253. 会议室 II</a> 的 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/meeting-rooms-ii/solution/yukiyama-by-yukiyama-9cml/">题解</a> 。</li>
</ul>
<hr>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://iyukiyama.github.io">yukiyama</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://iyukiyama.github.io/segment-tree/">https://iyukiyama.github.io/segment-tree/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://iyukiyama.github.io" target="_blank">yukiyama</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">算法与数据结构</a><a class="post-meta__tags" href="/tags/%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/">区间问题</a><a class="post-meta__tags" href="/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/">线段树</a></div><div class="post_share"><div class="social-share" data-image="https://raw.githubusercontent.com/iyukiyama/pics/master/hexo-iyukiyama/site_img/posts/algorithms/segment-tree-bg.png" data-sites="wechat,weibo,twitter,facebook,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/binary-indexed-tree/"><img class="prev-cover" src="https://raw.githubusercontent.com/iyukiyama/pics/master/hexo-iyukiyama/site_img/posts/algorithms/fenwick-bg.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">树状数组从入门到下车</div></div></a></div><div class="next-post pull-right"><a href="/graph/"><img class="next-cover" src="https://raw.githubusercontent.com/iyukiyama/pics/master/hexo-iyukiyama/site_img/posts/algorithms/graph-bg.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">图论算法从入门到放下</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/binary-indexed-tree/" title="树状数组从入门到下车"><img class="cover" src="https://raw.githubusercontent.com/iyukiyama/pics/master/hexo-iyukiyama/site_img/posts/algorithms/fenwick-bg.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-26</div><div class="title">树状数组从入门到下车</div></div></a></div><div><a href="/binary-search-tree/" title="二叉查找树"><img class="cover" src="https://raw.githubusercontent.com/iyukiyama/pics/master/hexo-iyukiyama/site_img/posts/algorithms/bst-bg.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-01</div><div class="title">二叉查找树</div></div></a></div><div><a href="/union-find/" title="并查集从入门到出门"><img class="cover" src="https://raw.githubusercontent.com/iyukiyama/pics/master/hexo-iyukiyama/site_img/posts/algorithms/union-find-bg.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-10</div><div class="title">并查集从入门到出门</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/hexo-iyukiyama/site_img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">yukiyama</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">31</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">45</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/iyukiyama"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/iyukiyama" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://www.zhihu.com/people/yukiyamama" target="_blank" title="zhihu"><i class="fab fa-zhihu"></i></a><a class="social-icon" href="mailto:iyukiyama@outlook.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">线段树从入门到急停</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="toc-number">1.1.</span> <span class="toc-text">线段树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="toc-number">1.1.1.</span> <span class="toc-text">基本线段树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%9A%84%E5%BD%A2%E6%80%81"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">线段树的形态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">线段树的大小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E7%82%B9%E4%BF%AE%E6%94%B9"><span class="toc-number">1.1.1.4.</span> <span class="toc-text">单点修改</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BA%E9%97%B4%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.1.1.5.</span> <span class="toc-text">区间查询</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8C%BA%E9%97%B4%E6%9C%80%E5%80%BC%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.1.1.5.1.</span> <span class="toc-text">区间最值查询</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81"><span class="toc-number">1.1.1.6.</span> <span class="toc-text">类的实现代码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E6%97%B6%E7%BB%B4%E6%8A%A4nums%E7%9A%84%E7%89%88%E6%9C%AC"><span class="toc-number">1.1.1.6.1.</span> <span class="toc-text">实时维护nums的版本</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8D%E7%BB%B4%E6%8A%A4nums%E7%9A%84%E7%89%88%E6%9C%AC"><span class="toc-number">1.1.1.6.2.</span> <span class="toc-text">不维护nums的版本</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#O-logn-%E6%97%B6%E9%97%B4%E6%B1%82%E5%8C%BA%E9%97%B4%E6%9C%80%E5%A4%A7%E5%80%BC%E7%89%88%E6%9C%AC"><span class="toc-number">1.1.1.6.3.</span> <span class="toc-text">O(logn)时间求区间最大值版本</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8C%BA%E9%97%B4%E6%9F%A5%E8%AF%A2%E6%89%A9%E5%B1%95%E7%89%88%E6%9C%AC"><span class="toc-number">1.1.1.6.4.</span> <span class="toc-text">区间查询扩展版本</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%87%92%E6%83%B0%E6%A0%87%E8%AE%B0"><span class="toc-number">1.1.2.</span> <span class="toc-text">懒惰标记</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BA%E9%97%B4%E4%BF%AE%E6%94%B9-%E5%A2%9E%E9%87%8F%E5%BC%8F"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">区间修改 (增量式)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BA%E9%97%B4%E4%BF%AE%E6%94%B9-%E8%A6%86%E7%9B%96%E5%BC%8F"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">区间修改 (覆盖式)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81-2"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">类的实现代码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A2%9E%E9%87%8F%E5%BC%8F%E5%8C%BA%E9%97%B4%E4%BF%AE%E6%94%B9%E7%89%88"><span class="toc-number">1.1.2.3.1.</span> <span class="toc-text">增量式区间修改版</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E5%BC%8F%E5%8C%BA%E9%97%B4%E4%BF%AE%E6%94%B9%E7%89%88"><span class="toc-number">1.1.2.3.2.</span> <span class="toc-text">覆盖式区间修改版</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">1.1.2.4.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A6%BB%E6%95%A3%E5%8C%96"><span class="toc-number">1.1.3.</span> <span class="toc-text">离散化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A7%E7%A6%BB%E6%95%A3"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">紧离散</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%BE%E7%A6%BB%E6%95%A3"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">松离散</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%BC%80%E7%82%B9"><span class="toc-number">1.1.4.</span> <span class="toc-text">动态开点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E7%82%B9%E6%95%B0%E7%BB%84%E6%B3%95"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">结点数组法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A2%84%E4%BC%B0%E7%BB%93%E7%82%B9%E6%95%B0"><span class="toc-number">1.1.4.1.1.</span> <span class="toc-text">预估结点数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E7%82%B9%E6%8C%87%E9%92%88-%E5%BC%95%E7%94%A8-%E6%B3%95"><span class="toc-number">1.1.4.2.</span> <span class="toc-text">结点指针 (引用) 法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81-3"><span class="toc-number">1.1.4.3.</span> <span class="toc-text">类的实现代码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%93%E7%82%B9%E6%95%B0%E7%BB%84%E6%B3%95-2"><span class="toc-number">1.1.4.3.1.</span> <span class="toc-text">结点数组法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%A2%9E%E9%87%8F%E5%BC%8F%E5%8C%BA%E9%97%B4%E4%BF%AE%E6%94%B9%E7%89%88-2"><span class="toc-number">1.1.4.3.1.1.</span> <span class="toc-text">增量式区间修改版</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E5%BC%8F%E5%8C%BA%E9%97%B4%E4%BF%AE%E6%94%B9%E7%89%88-2"><span class="toc-number">1.1.4.3.1.2.</span> <span class="toc-text">覆盖式区间修改版</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%93%E7%82%B9%E6%8C%87%E9%92%88-%E5%BC%95%E7%94%A8-%E6%B3%95-2"><span class="toc-number">1.1.4.3.2.</span> <span class="toc-text">结点指针 (引用) 法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%A2%9E%E9%87%8F%E5%BC%8F%E5%8C%BA%E9%97%B4%E4%BF%AE%E6%94%B9%E7%89%88-3"><span class="toc-number">1.1.4.3.2.1.</span> <span class="toc-text">增量式区间修改版</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E5%BC%8F%E5%8C%BA%E9%97%B4%E4%BF%AE%E6%94%B9%E7%89%88-3"><span class="toc-number">1.1.4.3.2.2.</span> <span class="toc-text">覆盖式区间修改版</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.1.5.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8"><span class="toc-number">1.1.6.</span> <span class="toc-text">实战应用</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/0/" title="无题"><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/hexo-iyukiyama/site_img/takaoyama-landscape.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/0/" title="无题">无题</a><time datetime="2022-11-16T14:09:13.490Z" title="发表于 2022-11-16 22:09:13">2022-11-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/1a42bdeb/" title="Maven学习实战"><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/hexo-iyukiyama/site_img/posts/maven-bg.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Maven学习实战"/></a><div class="content"><a class="title" href="/1a42bdeb/" title="Maven学习实战">Maven学习实战</a><time datetime="2022-11-11T20:15:14.000Z" title="发表于 2022-11-12 04:15:14">2022-11-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/5d078f6/" title="JDBC学习实战"><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/hexo-iyukiyama/site_img/posts/jdbc-bg.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JDBC学习实战"/></a><div class="content"><a class="title" href="/5d078f6/" title="JDBC学习实战">JDBC学习实战</a><time datetime="2022-11-11T20:15:08.000Z" title="发表于 2022-11-12 04:15:08">2022-11-12</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 By yukiyama</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://iyukiyama.github.io/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo4hexo.vercel.app/',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo4hexo.vercel.app/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    GLOBAL_CONFIG_SITE.isPost && getCount()
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>