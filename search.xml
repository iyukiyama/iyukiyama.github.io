<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SpringBoot学习实战</title>
      <link href="/2022/11/07/SpringBoot%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98_yukiyama/"/>
      <url>/2022/11/07/SpringBoot%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98_yukiyama/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringBoot学习实战-yukiyama"><a href="#SpringBoot学习实战-yukiyama" class="headerlink" title="SpringBoot学习实战_yukiyama"></a>SpringBoot学习实战_yukiyama</h1><blockquote><p>学习自: <a href="https://www.bilibili.com/video/BV19K4y1L7MT/?spm_id_from=333.999.0.0">【尚硅谷】SpringBoot2零基础入门教程（spring boot2干货满满）</a> 。</p><p>本文是基于上述视频教程的文字总结，大幅修改了原视频配套文档，并在其基础上及新增部分内容。本文所有代码及其他实验演示素材均存放于 <a href="https://github.com/iyukiyama/springmvc_in_action">springmvc_in_action</a> 仓库中。</p><p>建议先克隆该仓库到本地，一边阅读本文，一边对照每一份代码进行学习。</p></blockquote><br /><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>SpringBoot 是整合 Spring 技术栈的一站式框架，可极大地简化 Web 开发。</p><p>在 SpringBoot <a href="https://spring.io/projects/spring-boot">官方介绍页</a> 中有如下描述。</p><blockquote><p>Spring Boot makes it easy to create stand-alone, production-grade Spring based Applications that you can “just run”.</p></blockquote><p>官方介绍的 SpringBoot 的特点</p><table><thead><tr><th>特点</th><th>英文原文描述</th></tr></thead><tbody><tr><td>创建独立 Spring 应用</td><td>Create stand-alone Spring applications.</td></tr><tr><td>内嵌 web 服务器</td><td>Embed Tomcat, Jetty or Undertow directly (no need to deploy WAR files).</td></tr><tr><td>自动starter依赖，简化构建配置</td><td>Provide opinionated ‘starter’ dependencies to simplify your build configuration.</td></tr><tr><td>自动配置 Spring 以及第三方功能</td><td>Automatically configure Spring and 3rd party libraries whenever possible.</td></tr><tr><td>提供生产级别的监控、健康检查及外部化配置</td><td>Provide production-ready features such as metrics, health checks, and externalized configuration.</td></tr><tr><td>无代码生成、无需编写XML</td><td>Absolutely no code generation and no requirement for XML configuration.</td></tr></tbody></table><br /><h2 id="入门示例"><a href="#入门示例" class="headerlink" title="入门示例"></a>入门示例</h2><p>本节展示如何利用 SpringBoot 创建并运行一个 HelloWorld 项目，演示浏览器发送 <code>/hello</code> 请求，页面上响应 <code>Hello, Spring Boot 2!</code> 。</p><p>构建和运行环境如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IDE：IntelliJ IDEA 2022.2.1 (Ultimate Edition)</span><br><span class="line">项目构建工具：apache-maven-3.8.5</span><br><span class="line">SpringBoot2: 2.3.4</span><br><span class="line">浏览器：Chrome</span><br></pre></td></tr></table></figure><br /><h3 id="创建maven工程"><a href="#创建maven工程" class="headerlink" title="创建maven工程"></a>创建maven工程</h3><p>在 idea 中创建普通工程 <code>springboot_in_action</code> ，接着在该工程下创建 maven 模块 <code>springboot-helloworld</code> ，archetype 选择<code>maven-archetype-quickstart</code> 。</p><p>※ Maven 的使用以及父子工程间依赖继承相关的知识可参考 <a href="https://github.com/iyukiyama/maven_in_action">该仓库</a> 的 <a href="https://github.com/iyukiyama/maven_in_action/blob/master/Maven%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98_yukiyama.md">Maven学习实战_yukiyama</a> 教程。</p><p>在 <code>springboot-helloworld</code> 的 <code>pom.xml</code> 中添加如下内容。其中 <code>&lt;parent&gt;</code> 标签是关键，通过该标签指定了该模块的父工程为 <code>spring-boot-starter-parent</code> ，而 <code>&lt;dependencies&gt;</code> 标签中依赖了一个 web 场景的 springboot starter 。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>借助 Maven 中依赖的的传递性，由上述依赖即可导入所有所需依赖。可以看到 Spring、SpringMVC、内嵌的 Tomcat、日志、Jackson等依赖均已引入。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[INFO] com.yukiyama.springboot:springboot-helloworld:jar:1.0-SNAPSHOT</span><br><span class="line">[INFO] \- org.springframework.boot:spring-boot-starter-web:jar:2.3.4.RELEASE:compile</span><br><span class="line">[INFO]    +- org.springframework.boot:spring-boot-starter:jar:2.3.4.RELEASE:compile</span><br><span class="line">[INFO]    |  +- org.springframework.boot:spring-boot:jar:2.3.4.RELEASE:compile</span><br><span class="line">[INFO]    |  +- org.springframework.boot:spring-boot-autoconfigure:jar:2.3.4.RELEASE:compile</span><br><span class="line">[INFO]    |  +- org.springframework.boot:spring-boot-starter-logging:jar:2.3.4.RELEASE:compile</span><br><span class="line">[INFO]    |  |  +- ch.qos.logback:logback-classic:jar:1.2.3:compile</span><br><span class="line">[INFO]    |  |  |  +- ch.qos.logback:logback-core:jar:1.2.3:compile</span><br><span class="line">[INFO]    |  |  |  \- org.slf4j:slf4j-api:jar:1.7.30:compile</span><br><span class="line">[INFO]    |  |  +- org.apache.logging.log4j:log4j-to-slf4j:jar:2.13.3:compile</span><br><span class="line">[INFO]    |  |  |  \- org.apache.logging.log4j:log4j-api:jar:2.13.3:compile</span><br><span class="line">[INFO]    |  |  \- org.slf4j:jul-to-slf4j:jar:1.7.30:compile</span><br><span class="line">[INFO]    |  +- jakarta.annotation:jakarta.annotation-api:jar:1.3.5:compile</span><br><span class="line">[INFO]    |  +- org.springframework:spring-core:jar:5.2.9.RELEASE:compile</span><br><span class="line">[INFO]    |  |  \- org.springframework:spring-jcl:jar:5.2.9.RELEASE:compile</span><br><span class="line">[INFO]    |  \- org.yaml:snakeyaml:jar:1.26:compile</span><br><span class="line">[INFO]    +- org.springframework.boot:spring-boot-starter-json:jar:2.3.4.RELEASE:compile</span><br><span class="line">[INFO]    |  +- com.fasterxml.jackson.core:jackson-databind:jar:2.11.2:compile</span><br><span class="line">[INFO]    |  |  +- com.fasterxml.jackson.core:jackson-annotations:jar:2.11.2:compile</span><br><span class="line">[INFO]    |  |  \- com.fasterxml.jackson.core:jackson-core:jar:2.11.2:compile</span><br><span class="line">[INFO]    |  +- com.fasterxml.jackson.datatype:jackson-datatype-jdk8:jar:2.11.2:compile</span><br><span class="line">[INFO]    |  +- com.fasterxml.jackson.datatype:jackson-datatype-jsr310:jar:2.11.2:compile</span><br><span class="line">[INFO]    |  \- com.fasterxml.jackson.module:jackson-module-parameter-names:jar:2.11.2:compile</span><br><span class="line">[INFO]    +- org.springframework.boot:spring-boot-starter-tomcat:jar:2.3.4.RELEASE:compile</span><br><span class="line">[INFO]    |  +- org.apache.tomcat.embed:tomcat-embed-core:jar:9.0.38:compile</span><br><span class="line">[INFO]    |  +- org.glassfish:jakarta.el:jar:3.0.3:compile</span><br><span class="line">[INFO]    |  \- org.apache.tomcat.embed:tomcat-embed-websocket:jar:9.0.38:compile</span><br><span class="line">[INFO]    +- org.springframework:spring-web:jar:5.2.9.RELEASE:compile</span><br><span class="line">[INFO]    |  \- org.springframework:spring-beans:jar:5.2.9.RELEASE:compile</span><br><span class="line">[INFO]    \- org.springframework:spring-webmvc:jar:5.2.9.RELEASE:compile</span><br><span class="line">[INFO]       +- org.springframework:spring-aop:jar:5.2.9.RELEASE:compile</span><br><span class="line">[INFO]       +- org.springframework:spring-context:jar:5.2.9.RELEASE:compile</span><br><span class="line">[INFO]       \- org.springframework:spring-expression:jar:5.2.9.RELEASE:compile</span><br></pre></td></tr></table></figure><br /><h3 id="创建应用类"><a href="#创建应用类" class="headerlink" title="创建应用类"></a>创建应用类</h3><p>创建如下名为 <code>MainApplication</code> (名字自取) 的类，在其上以 <code>@SpringBootApplication</code> 标识，即表示该类为一个 springboot 应用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MainApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br /><h3 id="创建请求控制器"><a href="#创建请求控制器" class="headerlink" title="创建请求控制器"></a>创建请求控制器</h3><p>与使用 SpringMVC 类似，编写如下 <code>HelloController</code> 控制器。可以使用 <code>@RestController</code> 来替代 <code>@Controller</code> 和 <code>@ResponseBody</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukiyama.springboot.controllers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="comment">//@Controller</span></span><br><span class="line"><span class="comment">//@ResponseBody</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, Spring Boot 2!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>运行 <code>MainApplication</code> 类，可以看到 Tomcat 启动、DispatcherServlet、Servlet 初始化的过程。</p><p><img src="/Users/lixueshan/Library/Mobile%20Documents/com~apple~CloudDocs/pics/springboot_in_action/helloworld.png" alt="helloworld"></p><p>在浏览器中输入 <code>http://localhost:8080/hello</code> ，成功响应 <code>Hello, Spring Boot 2!</code> 。</p><p><img src="/Users/lixueshan/Library/Mobile%20Documents/com~apple~CloudDocs/pics/springboot_in_action/helloworld-page.png" alt="helloworld-page"></p><br /><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>在 <code>springboot-helloworld</code> 工程的 <code>src/main</code> 下新建一个<code>resource</code> 文件夹 (将其设置为 Resources Root)，在 <code>resources</code> 中创建 <code>application.properties</code> 文件 (<a href="https://docs.spring.io/spring-boot/docs/2.3.7.RELEASE/reference/html/appendix-application-properties.html#common-application-properties">更多配置信息</a>) ，可统一在该文件中完成应用相关的所有配置。</p><p>例如按如下修改服务器端口号后，重新运行 <code>MainApplication</code> ，就需要通过 <code>http://localhost:8888/hello</code> 来访问了。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置端口号</span></span><br><span class="line"><span class="attr">server.port</span>=<span class="string">8888</span></span><br></pre></td></tr></table></figure><br /><h3 id="打包部署"><a href="#打包部署" class="headerlink" title="打包部署"></a>打包部署</h3><p>在 <code>pom.xml</code> 中添加如下内容。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 IDEA 的 Maven 插件上点击运行 clean 、package，把 helloworld 工程项目的打包成 jar 包。打包好的 jar 包被生成在 helloworld 工程项目的 target 文件夹内。</p><p>用 cmd 运行 <code>java -jar springboot-helloworld-1.0-SNAPSHOT.jar</code> ，即可以运行该项目。</p><p><img src="/Users/lixueshan/Library/Mobile%20Documents/com~apple~CloudDocs/pics/springboot_in_action/package.png" alt="package"></p><p>在浏览器中输入 <code>http://localhost:8080/hello</code> ，成功响应 <code>Hello, Spring Boot 2!</code> 。</p><p><img src="/Users/lixueshan/Library/Mobile%20Documents/com~apple~CloudDocs/pics/springboot_in_action/helloworld-page.png" alt="helloworld-page"></p><br /><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总结 SpringBoot 处理请求的主要过程如下。</p><ol><li>创建 maven 工程，并在 <code>pom.xml</code> 中添加 <code>&lt;parent&gt;</code> 标签来使用 springboot ，添加 <code>&lt;dependency&gt;</code> 来指定场景 starter 。</li><li>创建应用类，并使用 <code>@SpringBootApplication</code> 注解标识。</li><li>创建请求控制器，像利用 SpringMVC 那样编写具体的业务。</li><li>通过 <code>resources</code> 中的 <code>application.properties</code> 来定制配置。</li></ol><br /><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><ul><li>引入场景依赖</li><li>查看自动配置了哪些（选做）<ul><li>自己分析，引入场景对应的自动配置一般都生效了</li><li>配置文件中 debug&#x3D;true 开启自动配置报告。<ul><li>Negative（不生效）</li><li>Positive（生效）</li></ul></li></ul></li><li>是否需要修改<ul><li>参照文档修改配置项<ul><li><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/appendix-application-properties.html#common-application-properties">官方文档</a></li><li>自己分析。xxxxProperties 绑定了配置文件的哪些。</li></ul></li><li>自定义加入或者替换组件<ul><li>@Bean、@Component…</li></ul></li><li>自定义器  XXXXXCustomizer；</li><li>……</li></ul></li></ul><br /><h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><p>springboot 应用的 <code>pom.xml</code> 文件均需将 <code>spring-boot-starter-parent</code> 作为 <code>&lt;parent&gt;</code> ，该父项目的父项目为 <code>spring-boot-dependencies</code>  (可在 idea 中查看) 。后者声明了几乎所有开发中常用的依赖及其版本号。</p><br /><h3 id="starter"><a href="#starter" class="headerlink" title="starter"></a>starter</h3><p>不同场景的 <a href="https://docs.spring.io/spring-boot/docs/2.3.7.RELEASE/reference/html/using-spring-boot.html#using-boot-starter">starter</a> 包含了该场景开发所需的几乎所有依赖，官方对 starter 的描述如下。</p><blockquote><p>Starters are a set of convenient dependency descriptors that you can include in your application. You get a one-stop shop for all the Spring and related technologies that you need without having to hunt through sample code and copy-paste loads of dependency descriptors. For example, if you want to get started using Spring and JPA for database access, include the <code>spring-boot-starter-data-jpa</code> dependency in your project.</p></blockquote><p>官方提供了不同场景下的 <a href="https://docs.spring.io/spring-boot/docs/2.3.7.RELEASE/reference/html/using-spring-boot.html#using-boot-starter">starter</a> ，以 <code>spring-boot-starter-*</code> 形式命名，<code>*</code> 表示场景名，例如前面我们所使用的 web 场景的<code>spring-boot-starter-web</code> 。而第三方的启动器常以 <code>*-spring-boot-starter</code> 形式命名。</p><p>如下是所有场景启动器最底层的依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>由于父工程配置了所管理依赖的版本号，若使用其规定版本依赖，引入依赖时不必书写版本信息 (<code>&lt;version&gt;</code>) ，但若引入其他版本，则需要写明版本号。具体操作为：</p><ul><li>查看 <code>spring-boot-dependencies</code> 中依赖的版本用的 key (即 <code>&lt;properties&gt;</code> 标签中表示依赖的标签) 。</li><li>在项目 <code>pom.xml</code> 文件中的 <code>&lt;properties&gt;</code> 中指定版本。</li></ul><p>如下，在 <code>&lt;dependencies&gt;</code> 中不带版本号引入 <code>mysql-connector-java</code> 之后，在 <code>&lt;properties&gt;</code> 中设置 <code>&lt;mysql.version&gt;5.1.43&lt;/mysql.version&gt;</code> 。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mysql.version</span>&gt;</span>5.1.43<span class="tag">&lt;/<span class="name">mysql.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><br /><h2 id="自动配置"><a href="#自动配置" class="headerlink" title="自动配置"></a>自动配置</h2><h3 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h3><p>通过父工程引入了 Tomcat 依赖，可在 <code>spring-boot-dependencies</code> 父工程中查看到如下依赖。并且 springboot 还完成了 Tomcat 的配置。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><br /><h3 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h3><p>同样地，springboot 引入了 springmvc 相关依赖，并引入 springmvc 的全套组件。可通过如下方式从 IoC 容器中打印组件名。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 返回 IoC 容器</span></span><br><span class="line">    <span class="type">ConfigurableApplicationContext</span> <span class="variable">run</span> <span class="operator">=</span> SpringApplication.run(MainApplication.class, args);</span><br><span class="line">    <span class="comment">// 2. 打印组件名</span></span><br><span class="line">    String[] names = run.getBeanDefinitionNames();</span><br><span class="line">    <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 <code>dispatcherServlet</code> 、<code>characterEncodingFilter</code> 、<code>multipartResolver</code> 等组件均已在 IoC 容器中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.context.annotation.internalConfigurationAnnotationProcessor</span><br><span class="line">org.springframework.context.annotation.internalAutowiredAnnotationProcessor</span><br><span class="line">org.springframework.context.annotation.internalCommonAnnotationProcessor</span><br><span class="line">org.springframework.context.event.internalEventListenerProcessor</span><br><span class="line">org.springframework.context.event.internalEventListenerFactory</span><br><span class="line">mainApplication</span><br><span class="line">org.springframework.boot.autoconfigure.internalCachingMetadataReaderFactory</span><br><span class="line">helloController</span><br><span class="line">org.springframework.boot.autoconfigure.AutoConfigurationPackages</span><br><span class="line">org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration</span><br><span class="line">propertySourcesPlaceholderConfigurer</span><br><span class="line">org.springframework.boot.autoconfigure.websocket.servlet.WebSocketServletAutoConfiguration$TomcatWebSocketConfiguration</span><br><span class="line">websocketServletWebServerCustomizer</span><br><span class="line">org.springframework.boot.autoconfigure.websocket.servlet.WebSocketServletAutoConfiguration</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryConfiguration$EmbeddedTomcat</span><br><span class="line">tomcatServletWebServerFactory</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryAutoConfiguration</span><br><span class="line">servletWebServerFactoryCustomizer</span><br><span class="line">tomcatServletWebServerFactoryCustomizer</span><br><span class="line">org.springframework.boot.context.properties.ConfigurationPropertiesBindingPostProcessor</span><br><span class="line">org.springframework.boot.context.internalConfigurationPropertiesBinderFactory</span><br><span class="line">org.springframework.boot.context.internalConfigurationPropertiesBinder</span><br><span class="line">org.springframework.boot.context.properties.BoundConfigurationProperties</span><br><span class="line">org.springframework.boot.context.properties.ConfigurationBeanFactoryMetadata</span><br><span class="line">server-org.springframework.boot.autoconfigure.web.ServerProperties</span><br><span class="line">webServerFactoryCustomizerBeanPostProcessor</span><br><span class="line">errorPageRegistrarBeanPostProcessor</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration$DispatcherServletConfiguration</span><br><span class="line">dispatcherServlet</span><br><span class="line">spring.mvc-org.springframework.boot.autoconfigure.web.servlet.WebMvcProperties</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration$DispatcherServletRegistrationConfiguration</span><br><span class="line">dispatcherServletRegistration</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration</span><br><span class="line">org.springframework.boot.autoconfigure.task.TaskExecutionAutoConfiguration</span><br><span class="line">taskExecutorBuilder</span><br><span class="line">applicationTaskExecutor</span><br><span class="line">spring.task.execution-org.springframework.boot.autoconfigure.task.TaskExecutionProperties</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguration$WhitelabelErrorViewConfiguration</span><br><span class="line">error</span><br><span class="line">beanNameViewResolver</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguration$DefaultErrorViewResolverConfiguration</span><br><span class="line">conventionErrorViewResolver</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguration</span><br><span class="line">errorAttributes</span><br><span class="line">basicErrorController</span><br><span class="line">errorPageCustomizer</span><br><span class="line">preserveErrorControllerTargetClassPostProcessor</span><br><span class="line">spring.resources-org.springframework.boot.autoconfigure.web.ResourceProperties</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration$EnableWebMvcConfiguration</span><br><span class="line">requestMappingHandlerAdapter</span><br><span class="line">requestMappingHandlerMapping</span><br><span class="line">welcomePageHandlerMapping</span><br><span class="line">mvcConversionService</span><br><span class="line">mvcValidator</span><br><span class="line">mvcContentNegotiationManager</span><br><span class="line">mvcPathMatcher</span><br><span class="line">mvcUrlPathHelper</span><br><span class="line">viewControllerHandlerMapping</span><br><span class="line">beanNameHandlerMapping</span><br><span class="line">routerFunctionMapping</span><br><span class="line">resourceHandlerMapping</span><br><span class="line">mvcResourceUrlProvider</span><br><span class="line">defaultServletHandlerMapping</span><br><span class="line">handlerFunctionAdapter</span><br><span class="line">mvcUriComponentsContributor</span><br><span class="line">httpRequestHandlerAdapter</span><br><span class="line">simpleControllerHandlerAdapter</span><br><span class="line">handlerExceptionResolver</span><br><span class="line">mvcViewResolver</span><br><span class="line">mvcHandlerMappingIntrospector</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration$WebMvcAutoConfigurationAdapter</span><br><span class="line">defaultViewResolver</span><br><span class="line">viewResolver</span><br><span class="line">requestContextFilter</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration</span><br><span class="line">formContentFilter</span><br><span class="line">org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration</span><br><span class="line">mbeanExporter</span><br><span class="line">objectNamingStrategy</span><br><span class="line">mbeanServer</span><br><span class="line">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration</span><br><span class="line">springApplicationAdminRegistrar</span><br><span class="line">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration$ClassProxyingConfiguration</span><br><span class="line">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration</span><br><span class="line">org.springframework.boot.autoconfigure.availability.ApplicationAvailabilityAutoConfiguration</span><br><span class="line">applicationAvailability</span><br><span class="line">org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration</span><br><span class="line">org.springframework.boot.autoconfigure.context.LifecycleAutoConfiguration</span><br><span class="line">lifecycleProcessor</span><br><span class="line">spring.lifecycle-org.springframework.boot.autoconfigure.context.LifecycleProperties</span><br><span class="line">org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration$Jackson2ObjectMapperBuilderCustomizerConfiguration</span><br><span class="line">standardJacksonObjectMapperBuilderCustomizer</span><br><span class="line">spring.jackson-org.springframework.boot.autoconfigure.jackson.JacksonProperties</span><br><span class="line">org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration$JacksonObjectMapperBuilderConfiguration</span><br><span class="line">jacksonObjectMapperBuilder</span><br><span class="line">org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration$ParameterNamesModuleConfiguration</span><br><span class="line">parameterNamesModule</span><br><span class="line">org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration$JacksonObjectMapperConfiguration</span><br><span class="line">jacksonObjectMapper</span><br><span class="line">org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration</span><br><span class="line">jsonComponentModule</span><br><span class="line">org.springframework.boot.autoconfigure.http.HttpMessageConvertersAutoConfiguration$StringHttpMessageConverterConfiguration</span><br><span class="line">stringHttpMessageConverter</span><br><span class="line">org.springframework.boot.autoconfigure.http.JacksonHttpMessageConvertersConfiguration$MappingJackson2HttpMessageConverterConfiguration</span><br><span class="line">mappingJackson2HttpMessageConverter</span><br><span class="line">org.springframework.boot.autoconfigure.http.JacksonHttpMessageConvertersConfiguration</span><br><span class="line">org.springframework.boot.autoconfigure.http.HttpMessageConvertersAutoConfiguration</span><br><span class="line">messageConverters</span><br><span class="line">org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration</span><br><span class="line">spring.info-org.springframework.boot.autoconfigure.info.ProjectInfoProperties</span><br><span class="line">org.springframework.boot.autoconfigure.task.TaskSchedulingAutoConfiguration</span><br><span class="line">taskSchedulerBuilder</span><br><span class="line">spring.task.scheduling-org.springframework.boot.autoconfigure.task.TaskSchedulingProperties</span><br><span class="line">org.springframework.boot.autoconfigure.web.client.RestTemplateAutoConfiguration</span><br><span class="line">restTemplateBuilder</span><br><span class="line">org.springframework.boot.autoconfigure.web.embedded.EmbeddedWebServerFactoryCustomizerAutoConfiguration$TomcatWebServerFactoryCustomizerConfiguration</span><br><span class="line">tomcatWebServerFactoryCustomizer</span><br><span class="line">org.springframework.boot.autoconfigure.web.embedded.EmbeddedWebServerFactoryCustomizerAutoConfiguration</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.HttpEncodingAutoConfiguration</span><br><span class="line">characterEncodingFilter</span><br><span class="line">localeCharsetMappingsCustomizer</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.MultipartAutoConfiguration</span><br><span class="line">multipartConfigElement</span><br><span class="line">multipartResolver</span><br><span class="line">spring.servlet.multipart-org.springframework.boot.autoconfigure.web.servlet.MultipartProperties</span><br><span class="line">org.springframework.aop.config.internalAutoProxyCreator</span><br></pre></td></tr></table></figure><br /><h3 id="默认包结构"><a href="#默认包结构" class="headerlink" title="默认包结构"></a>默认包结构</h3><p>基于 <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#using.structuring-your-code">默认的包扫描规则</a>，主程序 (即前面例子中的 <code>MainApplication</code> ) 所在包及其下所有子包中的组件都会被扫描，因此无需像使用 SpringMVC 那样配置包扫描。如下是官方文档中的推荐实践，主程序 <code>MyApplication</code> 所在包 <code>example</code>  及其子包中的组件都会被扫描。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">com</span><br><span class="line"> +- example</span><br><span class="line">     +- myapplication</span><br><span class="line">         +- MyApplication.java</span><br><span class="line">         |</span><br><span class="line">         +- customer</span><br><span class="line">         |   +- Customer.java</span><br><span class="line">         |   +- CustomerController.java</span><br><span class="line">         |   +- CustomerService.java</span><br><span class="line">         |   +- CustomerRepository.java</span><br><span class="line">         |</span><br><span class="line">         +- order</span><br><span class="line">             +- Order.java</span><br><span class="line">             +- OrderController.java</span><br><span class="line">             +- OrderService.java</span><br><span class="line">             +- OrderRepository.java</span><br></pre></td></tr></table></figure><p>若想要改变扫描路径，可在 <code>@SpringBootApplication</code> 注解中添加 <code>scanBasePackages</code> 属性指定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication(scanBasePackages=&quot;com.lun&quot;)</span></span><br><span class="line">等同于</span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.lun&quot;)</span></span><br></pre></td></tr></table></figure><br /><h3 id="默认配置"><a href="#默认配置" class="headerlink" title="默认配置"></a>默认配置</h3><p>各种配置都具有默认值。在 <code>application.properties</code> 中输入某个配置，可以根据提示方便地查看当前的默认配置，需要修改时只需要按 <code>key=value</code> 的方式设置即可。</p><p><img src="/Users/lixueshan/Library/Mobile%20Documents/com~apple~CloudDocs/pics/springboot_in_action/default-properties.png" alt="default-properties"></p><p>实际上，默认配置最终都是映射到某个类上，如 <code>server.port</code> 是通过<code>ServerProperties</code> 类设置的。配置文件的值最终会绑定每个类上，这个类会在容器中创建对象。此外，自动配置是按需加载的，引入了哪些场景这个场景的自动配置才会开启，SpringBoot 所有的自动配置功能都在 <code>spring-boot-autoconfigure</code> 包确定。</p><br /><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>SpringBoot 中的常用注解。</p><table><thead><tr><th>注解</th><th>描述</th></tr></thead><tbody><tr><td>@Configuration</td><td></td></tr><tr><td>@ComponentScan</td><td></td></tr><tr><td>@Bean</td><td></td></tr><tr><td>@Component</td><td></td></tr><tr><td>@Controller</td><td></td></tr><tr><td>@Service</td><td></td></tr><tr><td>@Repository</td><td></td></tr><tr><td>@Import</td><td></td></tr><tr><td>@Conditional</td><td></td></tr><tr><td>@ImportResource</td><td></td></tr><tr><td>@ConfigurationProperties</td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table><br /><h3 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h3><p>类注解，其所标注的类为配置类，其作用相当于只使用 Spring 时的 xml 配置文件。</p><ul><li>在配置类中使用 <code>@Bean</code> 标注方法为容器注册 bean 组件</li><li>配置类本身也是 IoC 容器组件。</li><li><code>@Configuration</code> 中的 <code>proxyBeanMethods</code> 属性，表示是否代理 <code>@Bean</code> 标注的方法。<ul><li>Full 模式: <code>proxyBeanMethods = true</code>，bean 为单例（默认）。</li><li>Lite 模式:  <code>proxyBeanMethods = false</code>，每次调用 <code>@Bean</code> 标注的方法都会返回新的实例。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukiyama.springboot.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.yukiyama.springboot.beans.Pet;</span><br><span class="line"><span class="keyword">import</span> com.yukiyama.springboot.beans.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为 IoC 容器中添加 bean，方法名为 bean 的 id，也可自定义 value 值为 id</span></span><br><span class="line">    <span class="comment">// 返回的对象即放在容器中的实例</span></span><br><span class="line">    <span class="meta">@Bean</span> <span class="comment">// 该 bean 的 id 为 user01</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">user01</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">zhangsan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        <span class="comment">// User 依赖 Pet</span></span><br><span class="line">        zhangsan.setPet(tomcatPet());</span><br><span class="line">        <span class="keyword">return</span> zhangsan;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean(&quot;tom&quot;)</span> <span class="comment">// &quot;tom&quot; 为该 bean 的 id</span></span><br><span class="line">    <span class="keyword">public</span> Pet <span class="title function_">tomcatPet</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Pet</span>(<span class="string">&quot;tomcat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最佳实践：</p><ul><li>配置类组件之间 <strong>无依赖关系</strong> 时用 Lite 模式加速容器启动过程，减少判断。</li><li>配置类组件之间 <strong>有依赖关系</strong> 时要用单例模式，使用 Full 模式 (默认) 。</li></ul><br /><h3 id="Import"><a href="#Import" class="headerlink" title="@Import"></a>@Import</h3><p>例如 <code>@Import(&#123;User.class, DBHelper.class&#125;)</code> 给容器中 <strong>自动创建出指定的两个类型的组件</strong> ，默认组件名为全类名。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import(&#123;User.class, DBHelper.class&#125;)</span></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以在 <code>MyApplication</code> 的 <code>main</code> 方法中按如下测试。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ConfigurableApplicationContext</span> <span class="variable">run</span> <span class="operator">=</span> SpringApplication.run(MainApplication.class, args);</span><br><span class="line"></span><br><span class="line">String[] beanNamesForType = run.getBeanNamesForType(User.class);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String s : beanNamesForType) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">DBHelper</span> <span class="variable">bean1</span> <span class="operator">=</span> run.getBean(DBHelper.class);</span><br><span class="line">System.out.println(bean1);</span><br></pre></td></tr></table></figure><br /><h3 id="Conditional"><a href="#Conditional" class="headerlink" title="@Conditional"></a>@Conditional</h3><p>类和方法注解，根据该组件属性所指定的条件装配或不装配，该注解有许多派生注解。</p><ul><li>作为类注解时：满足 <code>Conditional</code> 指定的条件时才注入其标注的类中被 <code>@Bean</code> 注解所标注的组件。</li><li>作为方法注解时：满足 <code>Conditional</code> 指定的条件时才注入 <code>@Bean</code> 注解所标注的组件。</li></ul><p><img src="/Users/lixueshan/Library/Mobile%20Documents/com~apple~CloudDocs/pics/springboot_in_action/conditianal.png" alt="conditianal"></p><p>用 <code>@ConditionalOnMissingBean</code> 举例说明。</p><p>作为方法注解时。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfig</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 没有 tom 名字的 Bean 时，User 才会被注入 IoC 容器</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean(name = &quot;tom&quot;)</span> </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">user01</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">zhangsan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        zhangsan.setPet(tomcatPet());</span><br><span class="line">        <span class="keyword">return</span> zhangsan;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;tom22&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Pet <span class="title function_">tomcatPet</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Pet</span>(<span class="string">&quot;tomcat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作为类注解时。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="comment">//没有 tom 名字的 Bean 时，MyConfig 类的 Bean 才会被注入 IoC 容器</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(name = &quot;tom&quot;)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">user01</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">zhangsan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        zhangsan.setPet(tomcatPet());</span><br><span class="line">        <span class="keyword">return</span> zhangsan;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;tom22&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Pet <span class="title function_">tomcatPet</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Pet</span>(<span class="string">&quot;tomcat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以在 <code>MyApplication</code> 中按如下测试。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="type">ConfigurableApplicationContext</span> <span class="variable">run</span> <span class="operator">=</span> SpringApplication.run(MainApplication.class, args);</span><br><span class="line"></span><br><span class="line">    String[] names = run.getBeanDefinitionNames();</span><br><span class="line">    <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">tom</span> <span class="operator">=</span> run.containsBean(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;容器中Tom组件：&quot;</span>+tom);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">user01</span> <span class="operator">=</span> run.containsBean(<span class="string">&quot;user01&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;容器中user01组件：&quot;</span>+user01);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">tom22</span> <span class="operator">=</span> run.containsBean(<span class="string">&quot;tom22&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;容器中tom22组件：&quot;</span>+tom22);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h3 id="ImportResource"><a href="#ImportResource" class="headerlink" title="@ImportResource"></a>@ImportResource</h3><p>在 SpringBoot 之前，我们通过 <code>beans.xml</code> 、<code>springmvc.xml</code> 等配置文件实现 bean 注入。但 SpringBoot 无需配置文件，如果仍需使用配置文件，可利用 <code>@ImportResource</code> 标注配置类导入指定的配置文件。</p><p>例如在 <code>resources</code> 中有 <code>beans.xml</code> 文件，可通过如下方式使其生效，则该文件中声明的 bean 即可存在与 IoC 容器中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ImportResource(&quot;classpath:beans.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfig</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h3 id="ConfigurationProperties"><a href="#ConfigurationProperties" class="headerlink" title="@ConfigurationProperties"></a>@ConfigurationProperties</h3><p><code>@ConfigurationProperties</code> 即「配置绑定」注解，可将 properties 文件中的内容封装到 bean 中，简化获取 properties 键值的过程。</p><p>有两种方式可完成「配置属性」功能。</p><ul><li>方式一：<code>@ConfigurationProperties</code> + <code>@Component</code></li><li>方式二：<code>@EnableConfigurationProperties</code> + <code>@ConfigurationProperties</code></li></ul><p>以下演示这两种方式，首先在配置文件 <code>application.properties</code> 中添加如下配置。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mycar.brand</span>=<span class="string">BYD</span></span><br><span class="line"><span class="attr">mycar.price</span>=<span class="string">100000</span></span><br></pre></td></tr></table></figure><p><strong>方式一</strong></p><p><code>@ConfigurationProperties</code> + <code>@Component</code></p><p>新建 <code>Car</code> bean 如下，以 <code>@ConfigurationProperties</code> 和 <code>@Component</code> 标注。<code>Car</code> 作为 IoC 容器中的 bean 后，在 <code>@ConfigurationProperties</code> 注解的作用下 properties 中以 <code>mycar</code> 为前缀的键值会被获取到装配到 IoC 容器的 <code>Car</code> 实例中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukiyama.springboot.beans;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(&quot;mycar&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String brand;</span><br><span class="line">    <span class="keyword">private</span> Integer price;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Car</span><span class="params">(String brand, Integer price)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.brand = brand;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Car</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getBrand</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> brand;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBrand</span><span class="params">(String brand)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.brand = brand;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getPrice</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPrice</span><span class="params">(Integer price)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Car&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;brand=&#x27;&quot;</span> + brand + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, price=&quot;</span> + price +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>HelloControlle</code> 中添加如下内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">Car car;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/car&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Car <span class="title function_">car</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> car;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行，可以看到 properties 中以 <code>mycar</code> 为前缀的键值对写入到了 <code>Car</code> 对象对应的字段中。</p><p><img src="/Users/lixueshan/Library/Mobile%20Documents/com~apple~CloudDocs/pics/springboot_in_action/ConfigurationProperties.png" alt="ConfigurationProperties"></p><p><strong>方式二</strong></p><p><code>@EnableConfigurationProperties</code> + <code>@ConfigurationProperties</code></p><p>此方式中的 <code>@EnableConfigurationProperties</code> 注解要标注在配置类上，并指定要作用的 bean，此时不需要方式一中 <code>Car</code> 上的 <code>@Component</code> 注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableConfigurationProperties(Car.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfig</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;mycar&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>※  prefix 是 <code>@ConfigurationProperties</code> 注解 value 属性的别名。</p><br /><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="自动包规则"><a href="#自动包规则" class="headerlink" title="自动包规则"></a>自动包规则</h4><p>Spring Boot应用的启动类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MainApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析下<code>@SpringBootApplication</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(</span></span><br><span class="line"><span class="meta">    excludeFilters = &#123;@Filter(</span></span><br><span class="line"><span class="meta">    type = FilterType.CUSTOM,</span></span><br><span class="line"><span class="meta">    classes = &#123;TypeExcludeFilter.class&#125;</span></span><br><span class="line"><span class="meta">), @Filter(</span></span><br><span class="line"><span class="meta">    type = FilterType.CUSTOM,</span></span><br><span class="line"><span class="meta">    classes = &#123;AutoConfigurationExcludeFilter.class&#125;</span></span><br><span class="line"><span class="meta">)&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点分析<code>@SpringBootConfiguration</code>，<code>@EnableAutoConfiguration</code>，<code>@ComponentScan</code>。</p><br /><h4 id="SpringBootConfiguration"><a href="#SpringBootConfiguration" class="headerlink" title="@SpringBootConfiguration"></a>@SpringBootConfiguration</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootConfiguration &#123;</span><br><span class="line">    <span class="meta">@AliasFor(</span></span><br><span class="line"><span class="meta">        annotation = Configuration.class</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">proxyBeanMethods</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@Configuration</code>代表当前是一个配置类。</p><br /><h4 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h4><p>指定扫描哪些Spring注解。</p><p>@ComponentScan 在<a href="#">07、基础入门-SpringBoot-自动配置特性</a>有用例。</p><br /><h4 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import(AutoConfigurationImportSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">ENABLED_OVERRIDE_PROPERTY</span> <span class="operator">=</span> <span class="string">&quot;spring.boot.enableautoconfiguration&quot;</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点分析<code>@AutoConfigurationPackage</code>，<code>@Import(AutoConfigurationImportSelector.class)</code>。</p><h4 id="AutoConfigurationPackage"><a href="#AutoConfigurationPackage" class="headerlink" title="@AutoConfigurationPackage"></a>@AutoConfigurationPackage</h4><p>标签名直译为：自动配置包，指定了默认的包规则。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Import(AutoConfigurationPackages.Registrar.class)</span><span class="comment">//给容器中导入一个组件</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AutoConfigurationPackage &#123;</span><br><span class="line">    String[] basePackages() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] basePackageClasses() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>利用Registrar给容器中导入一系列组件</li><li>将指定的一个包下的所有组件导入进MainApplication所在包下。</li></ol><h4 id="初始加载自动配置类"><a href="#初始加载自动配置类" class="headerlink" title="初始加载自动配置类"></a>初始加载自动配置类</h4><h5 id="Import-AutoConfigurationImportSelector-class"><a href="#Import-AutoConfigurationImportSelector-class" class="headerlink" title="@Import(AutoConfigurationImportSelector.class)"></a>@Import(AutoConfigurationImportSelector.class)</h5><ol><li>利用<code>getAutoConfigurationEntry(annotationMetadata);</code>给容器中批量导入一些组件</li><li>调用<code>List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes)</code>获取到所有需要导入到容器中的配置类</li><li>利用工厂加载 <code>Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(@Nullable ClassLoader classLoader);</code>得到所有的组件</li><li>从<code>META-INF/spring.factories</code>位置来加载一个文件。<ul><li>默认扫描我们当前系统里面所有<code>META-INF/spring.factories</code>位置的文件</li><li><code>spring-boot-autoconfigure-2.3.4.RELEASE.jar</code>包里面也有<code>META-INF/spring.factories</code></li></ul></li></ol><p><img src="/Users/lixueshan/Library/Mobile%252520Documents/com~apple~CloudDocs/study/tech/springboot/SpringBoot2%2525E5%2525AD%2525A6%2525E4%2525B9%2525A0%2525E7%2525AC%252594%2525E8%2525AE%2525B0/image/20210205005536620.png" alt="在这里插入图片描述"></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文件里面写死了spring-boot一启动就要给容器中加载的所有配置类</span></span><br><span class="line"><span class="comment"># spring-boot-autoconfigure-2.3.4.RELEASE.jar/META-INF/spring.factories</span></span><br><span class="line"><span class="comment"># Auto Configure</span></span><br><span class="line"><span class="attr">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="string">\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure><p>虽然我们127个场景的所有自动配置启动的时候默认全部加载，但是<code>xxxxAutoConfiguration</code>按照条件装配规则（<code>@Conditional</code>），最终会按需配置。</p><p>如<code>AopAutoConfiguration</code>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(</span></span><br><span class="line"><span class="meta">    proxyBeanMethods = false</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(</span></span><br><span class="line"><span class="meta">    prefix = &quot;spring.aop&quot;,</span></span><br><span class="line"><span class="meta">    name = &quot;auto&quot;,</span></span><br><span class="line"><span class="meta">    havingValue = &quot;true&quot;,</span></span><br><span class="line"><span class="meta">    matchIfMissing = true</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AopAutoConfiguration</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AopAutoConfiguration</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="自动配置【源码分析】-自动配置流程"><a href="#自动配置【源码分析】-自动配置流程" class="headerlink" title="自动配置【源码分析】-自动配置流程"></a>自动配置【源码分析】-自动配置流程</h4><p>以<code>DispatcherServletAutoConfiguration</code>的内部类<code>DispatcherServletConfiguration</code>为例子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnBean(MultipartResolver.class)</span>  <span class="comment">//容器中有这个类型组件</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(name = DispatcherServlet.MULTIPART_RESOLVER_BEAN_NAME)</span> <span class="comment">//容器中没有这个名字 multipartResolver 的组件</span></span><br><span class="line"><span class="keyword">public</span> MultipartResolver <span class="title function_">multipartResolver</span><span class="params">(MultipartResolver resolver)</span> &#123;</span><br><span class="line"><span class="comment">//给@Bean标注的方法传入了对象参数，这个参数的值就会从容器中找。</span></span><br><span class="line"><span class="comment">//SpringMVC multipartResolver。防止有些用户配置的文件上传解析器不符合规范</span></span><br><span class="line"><span class="comment">// Detect if the user has created a MultipartResolver but named it incorrectly</span></span><br><span class="line"><span class="keyword">return</span> resolver;<span class="comment">//给容器中加入了文件上传解析器；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SpringBoot默认会在底层配好所有的组件，但是<strong>如果用户自己配置了以用户的优先</strong>。</p><p><strong>总结</strong>：</p><ul><li>SpringBoot先加载所有的自动配置类  xxxxxAutoConfiguration</li><li>每个自动配置类按照条件进行生效，默认都会绑定配置文件指定的值。（xxxxProperties里面读取，xxxProperties和配置文件进行了绑定）</li><li>生效的配置类就会给容器中装配很多组件</li><li>只要容器中有这些组件，相当于这些功能就有了</li><li>定制化配置<ul><li>用户直接自己@Bean替换底层的组件</li><li>用户去看这个组件是获取的配置文件什么值就去修改。</li></ul></li></ul><p><strong>xxxxxAutoConfiguration —&gt; 组件 —&gt; xxxxProperties里面拿值  —-&gt; application.properties</strong></p><h2 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h2><h3 id="Lombok"><a href="#Lombok" class="headerlink" title="Lombok"></a>Lombok</h3><p><a href="https://projectlombok.org/">Lombok</a> 提供一组注解来代替 bean 类中的构造器、getter&#x2F;setter、toString() 这样的样板代码，以减少 bean 类的代码冗余。如下是该项目官网中的介绍。</p><blockquote><p>Project Lombok is a java library that automatically plugs into your editor and build tools, spicing up your java.<br>Never write another getter or equals method again, with one annotation your class has a fully featured builder, Automate your logging variables, and much more.</p></blockquote><p>有意思的是，类似于 Java &#x2F; Jakarta 等名字的来源，Lombok 也是一个地名，而且也与印尼有关，它是印尼的一个小岛的名称。使用地名，尤其是岛屿名称作为项目或计算机语言名似乎已经形成了一种传统，可参考这篇 <a href="https://www.david-merrick.com/2018/08/18/java-convention-of-naming-things-after-islands/">趣文</a>。</p><p>如下地图中集齐了 Java, Jakarta 以及 Lombok。</p><p><img src="/Users/lixueshan/Library/Mobile%20Documents/com~apple~CloudDocs/pics/springboot_in_action/lombok-island.png" alt="lombok-island"></p><p>要使用 Lombok ，首先要引入该依赖。springboot 已经管理 Lombok。在 <code>springboot-helloworld</code> 的 <code>pom.xml</code> 文件中引入如下依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接着在 idea 中搜索并安装 Lombok 插件。</p><p>Lombok 主要注解。</p><blockquote><p><a href="https://www.bilibili.com/video/BV1qJ411G7Dv/?spm_id_from=333.999.0.0&vd_source=c56ec421dded765a52ade50885eaab60">参考</a></p></blockquote><table><thead><tr><th>注解</th><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>@Getter</td><td>AccessLevel</td><td>作为类注解时，生成所有字段的 getter<br />作为字段注解时，生成该字段的 getter<br />对 static 修饰的字段无效<br />对 final 修饰的字段有效</td></tr><tr><td>@Setter</td><td>AccessLevel</td><td>作为类注解时，生成所有字段的 setter<br />作为字段注解时，生成该字段的 setter<br />对 static 或 final 修饰的字段均无效</td></tr><tr><td>@ToString</td><td>exclude<br />of</td><td>类注解。重写 toString 。</td></tr><tr><td>@NoArgsConstructor</td><td></td><td>类注解。生成无参构造器。</td></tr><tr><td>@RequiredArgsConstructor</td><td></td><td>类注解。生成带参构造器，参数为如下：<br />被 final 修饰的且未赋值的字段<br />被 @NonNull 标注的字段</td></tr><tr><td>@AllArgsConstructor</td><td></td><td>类注解。生成全参构造器。</td></tr><tr><td>@EqualsAndHashCode</td><td>exclude<br />of</td><td>类注解。重写 equals &#x2F; hashcode 方法。</td></tr><tr><td>@Data</td><td></td><td>类注解。如下注解的集合 <br />@Getter <br />@Setter <br />@RequiredArgsConstructor <br />@ToString <br />@EqualsAndHashCode</td></tr><tr><td>@NonNull</td><td></td><td>作为参数注解时，不允许参数为 null，若为 null 则抛出 <code>NullPoiterException</code> <br />作为字段注解时，不允许字段为 null</td></tr><tr><td>@Log</td><td></td><td>类注解。注入日志类 <code>Logger</code> 实例 (字段名 <code>log</code>) 。</td></tr><tr><td>@Slf4j</td><td></td><td>类注解。注入日志类 <code>Slf4j</code> 实例 (字段名 <code>log</code>) 。</td></tr><tr><td>@Builder</td><td></td><td>类注解。在其所标注的类中生成静态方法 <code>build()</code> 和内部建造者类，使得创建类对象时，参数可通过建造者模式写入。</td></tr><tr><td>@Cleanup</td><td></td><td>局部变量注解。对于 <code>InputStream</code>, <code>OutputStream</code> 这样需要关闭资源的局部变量，自动生成 try-finally 代码。</td></tr><tr><td>val</td><td></td><td>作用类似于 Java 10 推出的类型推导新特性 <a href="https://developer.oracle.com/learn/technical-articles/jdk-10-local-variable-type-inference">var</a> 。</td></tr></tbody></table><br /><h3 id="dev-tools"><a href="#dev-tools" class="headerlink" title="dev-tools"></a>dev-tools</h3><blockquote><p>Spring Boot includes an additional set of tools that can make the application development experience a little more pleasant. The <code>spring-boot-devtools</code> module can be included in any project to provide additional development-time features.</p><p>Applications that use <code>spring-boot-devtools</code> automatically restart whenever files on the classpath change. This can be a useful feature when working in an IDE, as it gives a very fast feedback loop for code changes. By default, any entry on the classpath that points to a directory is monitored for changes. Note that certain resources, such as static assets and view templates, <a href="https://docs.spring.io/spring-boot/docs/2.3.8.RELEASE/reference/html/using-spring-boot.html#using-boot-devtools-restart-exclude">do not need to restart the application</a>.</p><p>Triggering a restart</p><p>As DevTools monitors classpath resources, the only way to trigger a restart is to update the classpath. The way in which you cause the classpath to be updated depends on the IDE that you are using:</p><ul><li>In Eclipse, saving a modified file causes the classpath to be updated and triggers a restart.</li><li>In IntelliJ IDEA, building the project (<code>Build -&gt; Build Project</code>) (shortcut: Ctrl+F9) has the same effect.</li></ul></blockquote><p>添加依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在IDEA中，项目或者页面修改以后：Ctrl &#x2F; Command+F9。</p><br /><h3 id="Spring-Initailizr"><a href="#Spring-Initailizr" class="headerlink" title="Spring Initailizr"></a>Spring Initailizr</h3><p><a href="https://start.spring.io/">Spring Initailizr</a> 是创建 SpringBoot 工程的向导工具，在 IDEA 中可使用它来方便地创建 SpringBoot 工程。以在 IDEA 中创建 <code>springboot-web-01</code> Module 为例。</p><p>如下，在侧边栏的 Generators 下选择 Spring Initializr ，填入信息，Next 。</p><p><img src="/Users/lixueshan/Library/Mobile%20Documents/com~apple~CloudDocs/pics/springboot_in_action/initializr1.png" alt="initializr1"></p><p>接着选择 SpringBoot 版本以及需要的依赖，Create 。</p><p><img src="/Users/lixueshan/Library/Mobile%20Documents/com~apple~CloudDocs/pics/springboot_in_action/initializr2.png" alt="initializr2"></p><p>创建后可删除一些不需要的文件。</p><p>※ <code>mvnw</code>, <code>.mvn</code> 的作用可参考 <a href="https://maven.apache.org/wrapper/">Maven 官方说明</a> 。</p><p><img src="/Users/lixueshan/Library/Mobile%20Documents/com~apple~CloudDocs/pics/springboot_in_action/uselessfiles.png" alt="uselessfiles"></p><p>由 SpringBoot Initializr 创建的工程目录结构如下。</p><p><img src="/Users/lixueshan/Library/Mobile%20Documents/com~apple~CloudDocs/pics/springboot_in_action/project-structure.png" alt="project-structure"></p><p>可在 <code>resources</code> 下新建 <code>application.yml</code> 作为配置文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><br /><h2 id="yaml"><a href="#yaml" class="headerlink" title="yaml"></a>yaml</h2><p>最初 YAML 的意思是 “Yet Another Markup Language” (仍是一种标记语言) 。后来表达为递归缩写， “YAML Ain’t Markup Language” (YAML 不是一种标记语言) 。YAML 非常适合用来做以数据为中心的配置文件。</p><p><strong>基本语法</strong></p><ul><li>key: value；<code>:</code> 后有空格</li><li>大小写敏感</li><li>使用缩进表示层级关系</li><li>缩进不允许使用 tab，只允许空格</li><li>缩进的空格数不重要，只要相同层级的元素左对齐即可</li><li><code>#</code> 表示注释</li><li>字符串无需加引号，如果要加，单引号 <code>&#39;&#39;</code> 中的字符串内容会被转义，而双引号 <code>&quot;&quot;</code> 不转义 (例如 <code>&quot;\n&quot;</code> 表示换行，而 <code>&#39;\n&#39;</code> 会被转义为 <code>\\n</code> )</li></ul><p><strong>数据类型</strong></p><ul><li><p>字面量：单个的、不可再分的值。date、boolean、string、number、null 。</p></li><li><p>对象：键值对的集合。map、hash、set、object 。</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># map 行内写法：  </span></span><br><span class="line"></span><br><span class="line"><span class="attr">k:</span> &#123;<span class="string">k1:v1</span>,<span class="string">k2:v2</span>,<span class="string">k3:v3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line"></span><br><span class="line"><span class="attr">k:</span> </span><br><span class="line">  <span class="attr">k1:</span> <span class="string">v1</span></span><br><span class="line">  <span class="attr">k2:</span> <span class="string">v2</span></span><br><span class="line">  <span class="attr">k3:</span> <span class="string">v3</span></span><br></pre></td></tr></table></figure><ul><li>数组：一组按次序排列的值。array、list、queue</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数组行内写法：  </span></span><br><span class="line"></span><br><span class="line"><span class="attr">k:</span> [<span class="string">v1</span>,<span class="string">v2</span>,<span class="string">v3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"></span><br><span class="line"><span class="attr">k:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">v1</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">v2</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">v3</span></span><br></pre></td></tr></table></figure><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> Boolean boss;</span><br><span class="line">    <span class="keyword">private</span> Date birth;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Pet pet;</span><br><span class="line">    <span class="keyword">private</span> String[] interests;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; animal;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; score;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;Double&gt; salarys;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, List&lt;Pet&gt;&gt; allPets;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pet</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Double weight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用yaml表示以上对象</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">person:</span></span><br><span class="line">  <span class="attr">userName:</span> <span class="string">zhangsan</span></span><br><span class="line">  <span class="attr">boss:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">birth:</span> <span class="number">2019</span><span class="string">/12/12</span> <span class="number">20</span><span class="string">:12:33</span></span><br><span class="line">  <span class="attr">age:</span> <span class="number">18</span></span><br><span class="line">  <span class="attr">pet:</span> </span><br><span class="line">    <span class="attr">name:</span> <span class="string">tomcat</span></span><br><span class="line">    <span class="attr">weight:</span> <span class="number">23.4</span></span><br><span class="line">  <span class="attr">interests:</span> [<span class="string">篮球</span>,<span class="string">游泳</span>]</span><br><span class="line">  <span class="attr">animal:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="string">jerry</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">mario</span></span><br><span class="line">  <span class="attr">score:</span></span><br><span class="line">    <span class="attr">english:</span> </span><br><span class="line">      <span class="attr">first:</span> <span class="number">30</span></span><br><span class="line">      <span class="attr">second:</span> <span class="number">40</span></span><br><span class="line">      <span class="attr">third:</span> <span class="number">50</span></span><br><span class="line">    <span class="attr">math:</span> [<span class="number">131</span>,<span class="number">140</span>,<span class="number">148</span>]</span><br><span class="line">    <span class="attr">chinese:</span> &#123;<span class="attr">first:</span> <span class="number">128</span>,<span class="attr">second:</span> <span class="number">136</span>&#125;</span><br><span class="line">  <span class="attr">salarys:</span> [<span class="number">3999</span>,<span class="number">4999.98</span>,<span class="number">5999.99</span>]</span><br><span class="line">  <span class="attr">allPets:</span></span><br><span class="line">    <span class="attr">sick:</span></span><br><span class="line">      <span class="bullet">-</span> &#123;<span class="attr">name:</span> <span class="string">tom</span>&#125;</span><br><span class="line">      <span class="bullet">-</span> &#123;<span class="attr">name:</span> <span class="string">jerry</span>,<span class="attr">weight:</span> <span class="number">47</span>&#125;</span><br><span class="line">    <span class="attr">health:</span> [&#123;<span class="attr">name:</span> <span class="string">mario</span>,<span class="attr">weight:</span> <span class="number">47</span>&#125;]</span><br></pre></td></tr></table></figure><br /><h3 id="配置提示"><a href="#配置提示" class="headerlink" title="配置提示"></a>配置提示</h3><p>在 <code>application.yaml</code> 中配置参数时，<a href="https://docs.spring.io/spring-boot/docs/2.4.2/reference/htmlsingle/#configuration-metadata-annotation-processor">官方文档参考</a> 。</p><blockquote><p>You can easily generate your own configuration metadata file from items annotated with <code>@ConfigurationProperties</code> by using the <code>spring-boot-configuration-processor</code> jar. The jar includes a Java annotation processor which is invoked as your project is compiled.</p></blockquote><p>添加如下依赖到 <code>pom.xml</code> 中，可以在配置参数时提示参数名。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但打包工程时不应打包上述依赖，可通过如下，在打包工程时将 <code>spring-boot-configuration-processor</code> 排除在外。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">exclude</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><br />]]></content>
      
      
      <categories>
          
          <category> Spring系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> Spring全家桶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC学习实战</title>
      <link href="/2022/10/20/SpringMVC%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98_yukiyama/"/>
      <url>/2022/10/20/SpringMVC%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98_yukiyama/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringMVC学习实战-yukiyama"><a href="#SpringMVC学习实战-yukiyama" class="headerlink" title="SpringMVC学习实战_yukiyama"></a>SpringMVC学习实战_yukiyama</h1><blockquote><p>学习自: <a href="https://www.bilibili.com/video/BV1Ry4y1574R?spm_id_from=333.999.0.0">【尚硅谷】SpringMVC教程丨一套快速上手spring mvc</a> 。</p><p>本文是基于上述视频教程的文字总结，大幅修改了原视频配套文档，并在其基础上及新增部分内容。本文所有代码及其他实验演示素材均存放于 <a href="https://github.com/iyukiyama/springmvc_in_action">springmvc_in_action</a> 仓库中。</p><p>建议先克隆该仓库到本地，一边阅读本文，一边对照每一份代码进行学习。</p></blockquote><p>SpringMVC 是 Spring 家族中用于构建 Web 应用程序的框架，其实现遵循 Model-View-Controller 架构。SpringMVC 以 Spring 框架为基础，因此可利用 Spring 框架中实现的 IoC 容器。</p><br /><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><p>MVC 是一种软件应用架构思想，将软件应用按照 <strong>模型、视图、控制器</strong> 来划分。</p><ul><li><p>M：Model，模型层，指工程中的 JavaBean，作用是处理数据。JavaBean 分为两类。</p><ul><li><p>一类称为实体类 Bean：专门存储业务数据的，如 Student、User 等</p></li><li><p>一类称为业务处理 Bean：指 Service 或 Dao 对象，专门用于处理业务逻辑和数据访问。</p></li></ul></li><li><p>V：View，视图层，指工程中的 html 或 jsp 等页面，作用是与用户进行交互，展示数据。</p></li><li><p>C：Controller，控制层，指工程中的 servlet，作用是接收请求和响应浏览器。</p></li></ul><p>MVC 的工作流程：<br>用户通过视图层发送请求到服务器，在服务器中请求被 Controller 接收，Controller 调用相应的 Model 层处理请求，处理完毕将结果返回到 Controller，Controller 再根据请求处理的结果找到相应的 View 视图，渲染数据后最终响应给浏览器。</p><br /><h3 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h3><p>SpringMVC 是 Spring 的子项目，是 Spring 为表述层开发提供的一整套完备的解决方案。在表述层框架历经 Strust、WebWork、Strust2 等诸多产品的历代更迭之后，目前业界普遍选择了 SpringMVC 作为 JavaEE 项目 <strong>表述层</strong> 开发的首选方案。</p><blockquote><p>注：三层架构分为表述层（或表示层）、业务逻辑层、数据访问层，<strong>表述层表示前台页面和后台 servlet</strong> 。</p></blockquote><p>SpringMVC 具有以下特点。</p><ul><li><strong>Spring 家族原生产品</strong>，与 IOC 容器等基础设施无缝对接。</li><li><strong>基于原生的 Servlet</strong>，通过了功能强大的 <strong>前端控制器 DispatcherServlet</strong>，对请求和响应进行统一处理。</li><li>表述层各细分领域需要解决的问题 <strong>全方位覆盖</strong>，提供 <strong>全面解决方案</strong> 。</li><li><strong>代码清新简洁</strong> ，大幅度提升开发效率。</li><li>内部组件化程度高，可插拔式组件 <strong>即插即用</strong> ，想要什么功能配置相应组件即可。</li><li><strong>性能卓著</strong> ，尤其适合现代大型、超大型互联网项目要求。</li></ul><br /><h2 id="入门示例"><a href="#入门示例" class="headerlink" title="入门示例"></a>入门示例</h2><p>本节展示如何利用 SpringMVC 创建并运行一个 Web 项目。构建和运行环境如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IDE：IntelliJ IDEA 2022.2.1 (Ultimate Edition)</span><br><span class="line">项目构建工具：apache-maven-3.8.5</span><br><span class="line">服务器：apache-tomcat-8.5.82</span><br><span class="line">SpringMVC 版本：5.3.1</span><br><span class="line">浏览器：Chrome</span><br></pre></td></tr></table></figure><br /><h3 id="创建maven工程"><a href="#创建maven工程" class="headerlink" title="创建maven工程"></a>创建maven工程</h3><p>在 idea 中创建 maven 工程 <code>springmvc_in_action</code> ，archetype 选择<code>maven-archetype-quickstart</code> (将其建为 maven 工程是为了方便统一管理后续子工程的依赖)。接着在该工程下创建模块 <code>springmvc-demo1</code> ，archetype 选择 <code>maven-archetype-webapp</code> 。创建后手动删除 <code>index.jsp</code> 和 <code>web.xml</code> 文件 (稍后手动添加 <code>web.xml</code>) 。通过 File &gt; Project Structure &gt; Modules 菜单添加 <code>Development Descriptors</code> ，即 <code>web.xml</code> 。</p><p>※ Maven 的使用以及父子工程间依赖继承相关的知识可参考 <a href="https://github.com/iyukiyama/maven_in_action">该仓库</a> 的 <a href="https://github.com/iyukiyama/maven_in_action/blob/master/Maven%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98_yukiyama.md">Maven学习实战_yukiyama</a> 教程。</p><p>在 <code>springmvc_in_action</code> 的 <code>pom.xml</code> 中添加如下如下依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.13.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- SpringMVC --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- 日志 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- ServletAPI --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- Thymeleaf --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.thymeleaf<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>thymeleaf-spring5<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.12.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对应地，在 <code>springmvc-demo1</code> 的 <code>pom.xml</code> 中继承上述依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- SpringMVC --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 日志 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- ServletAPI --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Thymeleaf --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.thymeleaf<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>thymeleaf-spring5<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>借助 Maven 中依赖的的传递性，由上述依赖即可导入所有所需依赖。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[INFO] --- maven-dependency-plugin:2.8:tree (default-cli) @ springmvc-demo1 ---</span><br><span class="line">[INFO] com.yukiyama.mvc:springmvc-demo1:war:1.0-SNAPSHOT</span><br><span class="line">[INFO] +- junit:junit:jar:4.13.2:test</span><br><span class="line">[INFO] |  \- org.hamcrest:hamcrest-core:jar:1.3:test</span><br><span class="line">[INFO] +- org.springframework:spring-webmvc:jar:5.3.1:compile</span><br><span class="line">[INFO] |  +- org.springframework:spring-aop:jar:5.3.1:compile</span><br><span class="line">[INFO] |  +- org.springframework:spring-beans:jar:5.3.1:compile</span><br><span class="line">[INFO] |  +- org.springframework:spring-context:jar:5.3.1:compile</span><br><span class="line">[INFO] |  +- org.springframework:spring-core:jar:5.3.1:compile</span><br><span class="line">[INFO] |  |  \- org.springframework:spring-jcl:jar:5.3.1:compile</span><br><span class="line">[INFO] |  +- org.springframework:spring-expression:jar:5.3.1:compile</span><br><span class="line">[INFO] |  \- org.springframework:spring-web:jar:5.3.1:compile</span><br><span class="line">[INFO] +- ch.qos.logback:logback-classic:jar:1.2.3:compile</span><br><span class="line">[INFO] |  +- ch.qos.logback:logback-core:jar:1.2.3:compile</span><br><span class="line">[INFO] |  \- org.slf4j:slf4j-api:jar:1.7.25:compile</span><br><span class="line">[INFO] +- javax.servlet:javax.servlet-api:jar:3.1.0:provided</span><br><span class="line">[INFO] \- org.thymeleaf:thymeleaf-spring5:jar:3.0.12.RELEASE:compile</span><br><span class="line">[INFO]    \- org.thymeleaf:thymeleaf:jar:3.0.12.RELEASE:compile</span><br><span class="line">[INFO]       +- org.attoparser:attoparser:jar:2.0.5.RELEASE:compile</span><br><span class="line">[INFO]       \- org.unbescape:unbescape:jar:1.1.6.RELEASE:compile</span><br></pre></td></tr></table></figure><p>通过 idea 的 maven 工具界面还能看到依赖被排除的重复依赖。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/springmvc_in_action/dependencies.png" alt="dependencies"></p><br /><h3 id="web-xml配置"><a href="#web-xml配置" class="headerlink" title="web.xml配置"></a>web.xml配置</h3><p>注册 SpringMVC 的前端控制器 DispatcherServlet 。根据是否要自定义 SpringMVC 配置文件的名称及位置，可分为默认配置方式和扩展配置方式。</p><p><strong>默认配置方式</strong></p><p>此配置下 (不使用 <code>&lt;init-param&gt;</code> 标签) ，SpringMVC 的配置文件默认位于 WEB-INF 下，默认名称为 <code>&lt;servlet-name&gt;-servlet.xml</code> ，例如，以下配置所对应 SpringMVC 的配置文件位于 WEB-INF下，文件名为 <code>springMVC-servlet.xml</code> 。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置SpringMVC的前端控制器，对浏览器发送的请求统一进行处理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        设置springMVC的核心控制器所能处理的请求的请求路径</span></span><br><span class="line"><span class="comment">        /所匹配的请求可以是/login或.html或.js或.css方式的请求路径</span></span><br><span class="line"><span class="comment">        但是/不能匹配.jsp请求路径的请求</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>扩展配置方式</strong></p><p>可通过 <code>init-param</code> 标签设置 SpringMVC 配置文件的位置和名称，通过 <code>load-on-startup</code> 标签设置 SpringMVC 前端控制器 DispatcherServlet 的初始化时机。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置SpringMVC的前端控制器，对浏览器发送的请求统一进行处理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 通过初始化参数指定SpringMVC配置文件的位置和名称 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- contextConfigLocation为固定值 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 使用classpath:表示从类路径查找配置文件，例如maven工程中的src/main/resources --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springMVC.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment"> 作为框架的核心组件，在启动过程中有大量的初始化操作要做</span></span><br><span class="line"><span class="comment">而这些操作放在第一次请求时才执行会严重影响访问速度</span></span><br><span class="line"><span class="comment">因此需要通过此标签将启动控制DispatcherServlet的初始化时间提前到服务器启动时</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        设置springMVC的核心控制器所能处理的请求的请求路径</span></span><br><span class="line"><span class="comment">        /所匹配的请求可以是/login或.html或.js或.css方式的请求路径</span></span><br><span class="line"><span class="comment">        但是/不能匹配.jsp请求路径的请求</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>※ <code>&lt;url-pattern&gt;</code> 标签中使用 <code>/</code> 和 <code>/*</code> 的区别：<code>/</code> 所匹配的请求可以是 <code>/login</code> 或 <code>.html</code> 或 <code>.js</code> 或 <code>.css</code> 方式的请求路径，但是不能匹配 <code>.jsp</code> 请求路径的请求。因此可以避免在访问 <code>.jsp</code> 页面时，被 DispatcherServlet 处理，导致找不到相应的页面。<code>/*</code> 能够匹配所有请求，例如在使用过滤器时，若需要对所有请求进行过滤，就需要使用 <code>/*</code> 的写法。</p><br /><h3 id="springMVC-xml配置"><a href="#springMVC-xml配置" class="headerlink" title="springMVC.xml配置"></a>springMVC.xml配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 自动扫描包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.atguigu.mvc.controller&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置Thymeleaf视图解析器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;viewResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.thymeleaf.spring5.view.ThymeleafViewResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;order&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;characterEncoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;templateEngine&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.thymeleaf.spring5.SpringTemplateEngine&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;templateResolver&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">                    <span class="comment">&lt;!-- 视图前缀 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/templates/&quot;</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">                    <span class="comment">&lt;!-- 视图后缀 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.html&quot;</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;templateMode&quot;</span> <span class="attr">value</span>=<span class="string">&quot;HTML5&quot;</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;characterEncoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">   处理静态资源，例如 html、js、css、jpg</span></span><br><span class="line"><span class="comment">  若只设置该标签，则只能访问静态资源，其他请求则无法访问</span></span><br><span class="line"><span class="comment">  此时必须设置 &lt;mvc:annotation-driven/&gt; 解决问题</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 开启mvc注解驱动 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 处理响应中文内容乱码 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultCharset&quot;</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;supportedMediaTypes&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">value</span>&gt;</span>text/html<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">value</span>&gt;</span>application/json<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure><br /><h3 id="编写HTML页面"><a href="#编写HTML页面" class="headerlink" title="编写HTML页面"></a>编写HTML页面</h3><p>首先编写项目主页 <code>index.html</code> ，在该页中有一链接可跳转到 <code>target.html</code> 页面。</p><p><code>index.html</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thyemleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/target&#125;&quot;</span>&gt;</span>访问目标页面 target.html<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>target.html</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">HelloWorld</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><br /><h3 id="创建请求控制器"><a href="#创建请求控制器" class="headerlink" title="创建请求控制器"></a>创建请求控制器</h3><p>前端控制器对浏览器发送的请求进行了统一的处理，将具体的请求交给不同的 <strong>请求控制器</strong> 处理。请求控制器中每一个处理请求的方法称为 <strong>控制器方法</strong> 。</p><p>因为 SpringMVC 的控制器由 POJO 担任，因此需要通过 <code>@Controller</code> 注解将其标识为一个 <strong>控制层组件</strong> ，交给 Spring 的 IoC 容器管理，此时 SpringMVC 才能够识别控制器的存在。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;&#125;</span><br></pre></td></tr></table></figure><br /><p><strong>访问页面</strong></p><p>在请求控制器中类 <code>HelloController</code> 中创建处理请求的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @RequestMapping 注解：处理请求和控制器方法之间的映射关系</span></span><br><span class="line"><span class="comment">// @RequestMapping 注解的 value 属性 通过请求地址匹配请求，&quot;/&quot; 表示的当前工程的上下文路径</span></span><br><span class="line"><span class="comment">// localhost:8080/springMVC/</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">index</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//设置视图名称</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><p><strong>页面跳转</strong></p><p>在请求控制器类中创建处理请求的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">HelloWorld</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;target&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>在 Tomcat 中部署 <code>springmvc-demo1</code> 应用。浏览器打开 <code>http://localhost:8080/springmvc/</code> ，点击其中的超链接后可以跳转到相应页面。</p><p>※ Tomcat 部署应用的设置方法请参考 <a href="https://github.com/iyukiyama/javaweb_in_action">该仓库</a> 的 <a href="https://github.com/iyukiyama/javaweb_in_action/blob/master/JavaWeb%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98_yukiyama.md">JavaWeb学习实战_yukiyama.md</a> 教程的「Tomcat」一节。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/springmvc_in_action/helloworld.png" alt="helloworld"></p><p>总结 SpringMVC 处理请求的主要过程如下。</p><ol><li>Web 服务器 (Tomcat) 启动时创建 <code>DispatcherServlet</code> 实例 (通常在 <code>web.xml</code> 中通过 <code>&lt;load-on-startup&gt;</code> 标签将其设置为随 Web 服务器启动而创建) 。</li><li>浏览器发送请求，若请求地址符合前端控制器的 <code>url-pattern</code> ，该请求就会被前端控制器 <code>DispatcherServlet</code> 处理。</li><li>前端控制器会读取 SpringMVC 的核心配置文件，通过扫描组件找到控制器。</li><li>控制器匹配请求地址与 <code>@RequestMapping</code> 注解的 <code>value</code> 属性值，若匹配成功，该注解所标识的控制器方法就是处理请求的方法。处理请求的方法返回字符串类型的视图名称。</li><li>控制器方法返回的视图名称由视图解析器解析，加上前缀和后缀组成视图的路径，通过 Thymeleaf 对视图进行渲染，最终转发到视图所对应页面。</li></ol><br /><h2 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h2><p><code>@RequestMapping</code> ，「请求映射」注解，用于关联请求与处理请求的控制器方法。SpringMVC 接收到指定的请求后，根据关联关系找到对应的控制器方法来处理该请求。<code>@RequestMapping</code> 可作为类注解或方法注解，作用分别为。</p><ul><li>作为类注解时：设置映射请求的请求路径的初始路径段。</li><li>作为方法注解时：设置映射请求请求路径的具体路径段。</li></ul><p>本节我们创建 <code>springMVC-demo2</code> 子项目演示如何使用 <code>@RequestMapping</code> 注解。</p><p>首先在该项目下新建 <code>TestController.java</code> 控制器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukiyama.mvc.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">index</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着编写 <code>web.xml</code> 、<code>springMVC.xml</code> ，内容与「入门示例」相同。</p><p>最后编写如下 <code>index.html</code> 页面。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thyemleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>与「入门示例」一样，运行该项目后通过 <code>http://localhost:8080/springmvc/</code> 能够正常打开 <code>index.html</code> 页面。</p><br /><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p><code>@RequestMapping</code> 作为方法注解时，主要有如下属性。</p><table><thead><tr><th>@RequestMapping 方法注解属性</th><th>描述</th></tr></thead><tbody><tr><td>value</td><td>默认属性，必须设置。类型为 <code>String[]</code> 数组，表示匹配该数组指定请求地址的请求。</td></tr><tr><td>method</td><td>类型为 <code>RequestMethod[]</code> 数组，表示匹配该数组指定的请求类型的请求。不设置该属性时可匹配所有类型请求。</td></tr><tr><td>params</td><td>类型为 <code>String[]</code> 数组，表示匹配的请求中的参数要符合该属性指定的参数规则。</td></tr><tr><td>headers</td><td>类型为 <code>String[]</code> 数组，表示匹配的请求的 Headers 要符合该属性指定的 Headers 规则。</td></tr></tbody></table><p>在 <code>springMVC-demo2</code> 中创建 <code>RequestMappingController.java</code> 控制器，在其中编写不同的控制器方法观察不同属性的作用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukiyama.mvc.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestMappingController</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h4 id="value"><a href="#value" class="headerlink" title="value"></a>value</h4><p><code>@RequestMapping</code> 注解的默认属性为 value 。value 为字符串类型数组，表示其注解的方法能够匹配 value 数组指定的多个请求地址。在 <code>RequestMappingController</code> 类添加如下方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">index</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行项目后发现页面出现 500 错误。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/springmvc_in_action/mapping-error.png" alt="mapping-error"></p><p>控制台打印的错误信息中可看到如下描述，原因是当前有两个控制器 <code>TestController</code> 和 <code>RequestMappingController</code> ，均有一个匹配 <code>/</code> 路径的 <code>index</code> 方法。这说明所有控制器的控制器方法所映射的请求地址必须是唯一的，也就是对于一个请求地址，要保证只有一个控制器方法来处理。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">to &#123; [/]&#125;: There is already &#x27;requestMappingController&#x27; bean method</span><br><span class="line">com.yukiyama.mvc.controller.RequestMappingController#index() mapped.</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>将 value 中的请求地址修改为其他即可。如下给出本例的控制器和 <code>index.html</code>, <code>success.html</code> 。</p><p><code>RequestMappingController.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukiyama.mvc.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestMappingController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/testRequestMapping&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">success</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>index.html</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thyemleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/hello/testRequestMapping&#125;&quot;</span>&gt;</span>测试RequestMapping注解的位置<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>success.html</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thyemleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>success<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>项目运行后打开 <code>index.html</code> ，点击链接能够跳转到 <code>success.html</code> 页面。该页面路径中的 <code>/hello</code> 即控制器类注解 <code>@RequestMapping</code> 中设置的属性值，而 <code>/testRequestMapping</code> 是方法注解 <code>@RequestMapping</code> 中设置的属性值。</p><p>由此可以看到，类注解 <code>@RequestMapping</code> 属性中设置的路径段可视作该控制器对应的请求路径的统一前缀。例如响应注册操作的注册控制器的类注解 <code>@RequestMapping</code> 的属性可为 <code>/register</code> ，则所有与注册相关的请求路径信息都是形如 <code>http://localhost:8080/register/...</code> 这样的形式。</p><p>假设还有用户控制器，且注册控制器和用户控制器中都存在 <code>add</code> 方法分别用于处理 <code>http://.../register/add</code> 和  <code>http://.../user/add</code> 请求，则类注解的路径段就可以提前区别是哪个功能模块的请求，不同控制器内就可以有相同子路径段的控制器方法了。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/springmvc_in_action/RequestMapping-value.png" alt="RequestMapping-value"></p><p>value  为字符串数组类型，可支持多个不同的路径段，使同一个控制器方法对应多个不同的请求路径。如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(</span></span><br><span class="line"><span class="meta">        value = &#123;&quot;/testRequestMapping&quot;, &quot;/testRequestMapping1&quot;, &quot;/testRequestMapping2&quot;&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">success</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>index.html</code> 的 <code>&lt;body&gt;</code> 标签中新增两条对应 <code>/testRequestMapping1</code>和 <code>/testRequestMapping2</code> 的链接。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/hello/testRequestMapping&#125;&quot;</span>&gt;</span>测试RequestMapping注解的位置<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/hello/testRequestMapping1&#125;&quot;</span>&gt;</span>测试RequestMapping注解value属性，匹配 /testRequestMapping1 路径<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/hello/testRequestMapping2&#125;&quot;</span>&gt;</span>测试RequestMapping注解value属性，匹配 /testRequestMapping2 路径<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行项目，可以看到控制器方法中 value 属性的多个路径段值，确实使该方法映射到了相应的不同请求路径。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/springmvc_in_action/RequestMapping-value-multiple.png" alt="RequestMapping-value-multiple"></p><br /><h5 id="ant风格路径"><a href="#ant风格路径" class="headerlink" title="ant风格路径"></a>ant风格路径</h5><p>value 属性值可写为 ant 风格的模糊匹配形式，主要匹配规则如下。</p><table><thead><tr><th>通配符</th><th>描述</th></tr></thead><tbody><tr><td><code>?</code></td><td>表示任意的单个字符，但不支持 <code>/</code> 和 <code>?</code> 。</td></tr><tr><td><code>*</code></td><td>表示任意的 0 个或多个字符，但不支持 <code>/</code> 和 <code>?</code> 。</td></tr><tr><td><code>**</code></td><td>以 <code>/**/xxx/</code> 的形式，表示 0 层或多层目录。</td></tr></tbody></table><br /><h6 id="通配符"><a href="#通配符" class="headerlink" title="通配符?"></a>通配符?</h6><p>表示任意的单个字符，但不支持 <code>/</code> 和 <code>?</code> 。</p><p>在 <code>RequestMappingController</code> 中增加如下方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/a?t/testAnt&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testAnt</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>index.html</code> 的 <code>&lt;body&gt;</code> 标签中新增如下链接。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/hello/ant/testAnt&#125;&quot;</span>&gt;</span>测试RequestMapping注解value属性的ant风格路径 --&gt; /a?t/testAnt<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行项目，可以看到 <code>/a?t</code> 中的 <code>?</code> 可替换为除少数在路径中的特殊字符外的任意单个字符，都能匹配。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/springmvc_in_action/RequestMapping-value-ant.png" alt="RequestMapping-value-ant"></p><br /><h6 id="通配符-1"><a href="#通配符-1" class="headerlink" title="通配符*"></a>通配符*</h6><p>表示任意的 0 个或多个字符，但不支持 <code>/</code> 和 <code>?</code> 。与 <code>?</code> 用法类似，示例略。</p><br /><h6 id="通配符-2"><a href="#通配符-2" class="headerlink" title="通配符**"></a>通配符**</h6><p>以 <code>/**/xxx/</code> 的形式，表示任意的一层或多层目录。</p><p>修改 value 属性为 <code>@RequestMapping(&quot;/**/testAnt&quot;)</code> ，在 <code>index.html</code> 的 <code>&lt;body&gt;</code> 标签中新增如下链接。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/hello/ant/testAnt&#125;&quot;</span>&gt;</span>测试RequestMapping注解value属性的ant风格路径 --&gt; /**/testAnt<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行项目后，效果如下。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/springmvc_in_action/RequestMapping-value-ant-starstar.png" alt="RequestMapping-value-ant-starstar"></p><br /><h5 id="路径中的占位符"><a href="#路径中的占位符" class="headerlink" title="路径中的占位符"></a>路径中的占位符</h5><p>路径传参的原始方式 <code>/deleteUser?id=1</code> ，Restful 风格为 <code>/deleteUser/1</code> 。SpringMVC 路径中的占位符常用于 RESTful 风格中，将请求路径中将某些数据通过路径的方式传输到服务器中，可以在相应的 @RequestMapping 注解的 value 属性中通过占位符 <code>&#123;&#125;</code> 表示传输的数据，再配合参数注解 <code>@PathVariable</code> 将占位符所表示的数据赋值给控制器方法的形参。</p><p>在 <code>RequestMappingController</code> 中增加如下方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testPath/&#123;id&#125;/&#123;username&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testPath</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id,</span></span><br><span class="line"><span class="params">                       <span class="meta">@PathVariable(&quot;username&quot;)</span> String username)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;id = &quot;</span> + id + <span class="string">&quot;, username = &quot;</span> + username);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>index.html</code> 的 <code>&lt;body&gt;</code> 标签中新增如下链接。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/hello/testPath/1/yukiyama&#125;&quot;</span>&gt;</span>测试RequestMapping注解支持路径中的占位符 --&gt; /testPath<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行项目后，打开链接后控制台输出 <code>id = 1, username = yukiyama</code> 。尝试在 URL 中删除 <code>yukiyama</code> 再请求，将返回 404 错误，这说明占位符不可为空。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/springmvc_in_action/RequestMapping-value-placeholder.png" alt="RequestMapping-value-placeholder"></p><br /><h4 id="method"><a href="#method" class="headerlink" title="method"></a>method</h4><p><code>@RequestMapping</code> 方法注解的 method 属性用于匹配请求类型。设置该属性时，首先请求路径要与其所注解的控制器方法的 value 属性向匹配，接着要匹配该属性设置的请求类型值，设置多个时只需匹配其中之一即可，若全部不匹配，则返回 错误。不设置该属性时，匹配所有请求类型。</p><p>method 属性为如下枚举类型 <code>RequestMethod</code> ，可以看到其中支持的请求类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.web.bind.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">RequestMethod</span> &#123;</span><br><span class="line">    GET,</span><br><span class="line">    HEAD,</span><br><span class="line">    POST,</span><br><span class="line">    PUT,</span><br><span class="line">    PATCH,</span><br><span class="line">    DELETE,</span><br><span class="line">    OPTIONS,</span><br><span class="line">    TRACE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">RequestMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>RequestMappingController</code> 的 <code>success</code> 方法注解 <code>@RequestMapping</code> 中加入 method 属性，如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(</span></span><br><span class="line"><span class="meta">        value = &#123;&quot;/testRequestMapping&quot;, &quot;/testRequestMapping1&quot;, &quot;/testRequestMapping2&quot;, &quot;/testMethod&quot;&#125;,</span></span><br><span class="line"><span class="meta">        method = &#123;RequestMethod.GET&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">success</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>index.html</code> 的 <code>&lt;body&gt;</code> 标签中增加 <code>POST</code> 类型的表单。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/hello/testMethod&#125;&quot;</span>&gt;</span>测试RequestMapping注解method属性<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/hello/testMethod&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;测试RequestMapping注解的method属性 --&gt; POST&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>※ 需要注意 form 表单中的 method 只支持 post 与 get，若写为其他类型，如 put ，则按照默认的 get 处理。</p><p>由于表单中的请求类型为 <code>POST</code> ，与 method 属性中指定的请求类型 <code>GET</code> 不一致，运行项目，在 <code>index.html</code> 页面上点击 submit 按钮会出现 405 错误。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/springmvc_in_action/RequestMapping-method-not-match.png" alt="RequestMapping-method-not-match"></p><p>需要在 method 属性中增加对 <code>POST</code> 类型请求的匹配即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(</span></span><br><span class="line"><span class="meta">        value = &#123;&quot;/testRequestMapping&quot;, &quot;/testRequestMapping1&quot;, &quot;/testRequestMapping2&quot;, &quot;/testMethod&quot;&#125;,</span></span><br><span class="line"><span class="meta">        method = &#123;RequestMethod.GET, RequestMethod.POST&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">success</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调整后可正常跳转。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/springmvc_in_action/RequestMapping-method-matched.png" alt="RequestMapping-method-matched"></p><br /><h5 id="XxxMapping"><a href="#XxxMapping" class="headerlink" title="@XxxMapping"></a>@XxxMapping</h5><p>当明确了要匹配的请求类型时，可以使用如下指定了请求类型的 <strong>请求映射方法注解</strong> 来替代 <code>@RequestMapping</code> 方法注解。由该注解标注的方法所匹配的请求，必须是该注解指定的请求类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping</span><br><span class="line">@PostMapping</span><br><span class="line">@DeleteMapping</span><br><span class="line">@PutMapping</span><br></pre></td></tr></table></figure><p>在 <code>RequestMappingController</code>  中添加如下方法测试 <code>@GetMapping</code> 的效果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/testGetMapping&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testGetMapping</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>index.html</code> 的 <code>&lt;body&gt;</code> 标签内增加如下内容。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/hello/testGetMapping&#125;&quot;</span>&gt;</span>测试GetMapping注解 --&gt; /testGetMapping<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行并点击相应的超链接，由于超链接为 <code>Get</code> 请求，与 <code>@GetMapping</code> 相匹配，可正常跳转。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/springmvc_in_action/GetMapping.png" alt="GetMapping"></p><br /><h4 id="params"><a href="#params" class="headerlink" title="params"></a>params</h4><p><code>params</code> 属性类型为 <code>String[]</code> 数组，表示匹配的请求中的参数要符合该属性指定的参数规则。</p><table><thead><tr><th>参数匹配规则</th><th>描述</th></tr></thead><tbody><tr><td><code>param</code></td><td>要求请求映射所匹配的请求必须携带 <code>param</code> 请求参数。</td></tr><tr><td><code>!param</code></td><td>要求请求映射所匹配的请求不能携带 <code>param</code> 请求参数。</td></tr><tr><td><code>param=value</code></td><td>要求请求映射所匹配的请求必须携带 <code>param</code> 请求参数且 <code>param=value</code> 。</td></tr><tr><td><code>param!=value</code></td><td>要求请求映射所匹配的请求必须携带 <code>param</code> 请求参数且 <code>param!=value </code> 。</td></tr></tbody></table><p>在 <code>RequestMappingController</code> 中新建 <code>testParamsAndHeaders</code> 方法如下，其中 <code>@RequestMapping</code> 注解中加入属性 <code>params</code> 并设置一个 <code>usename</code> 表示匹配的请求需携带该参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(</span></span><br><span class="line"><span class="meta">        value = &#123;&quot;/testParamsAndHeaders&quot;&#125;,</span></span><br><span class="line"><span class="meta">        params = &#123;&quot;username&quot;&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testParamsAndHeaders</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>index.html</code> 的 <code>&lt;body&gt;</code> 中新增如下超链接。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/hello/testParamsAndHeaders&#125;&quot;</span>&gt;</span>测试RequestMapping注解的params属性 --&gt; /testParamsAndHeaders<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行应用，点击上述超链接后出现 400 错误。从错误 message 中可以看到未匹配到指定参数导致请求失败。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/springmvc_in_action/RequestMapping-params-failed.png" alt="RequestMapping-params-failed"></p><p>修改 <code>index.html</code> 中前述超链接如下，加入所需参数。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/hello/testParamsAndHeaders(username=&#x27;admin&#x27;&#125;&quot;</span>&gt;</span>测试RequestMapping注解的params属性 --&gt; /testParamsAndHeaders<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改后重新运行应用，可正常跳转。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/springmvc_in_action/RequestMapping-params.png" alt="RequestMapping-params"></p><p>若将 <code>@RequestMapping</code> 中的 <code>params</code> 改为 <code>params = &#123;&quot;!username&quot;&#125;</code> ，则出现如下 400 错误。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/springmvc_in_action/RequestMapping-params-not-matched.png" alt="RequestMapping-params-not-matched"></p><p><code>params</code> 可以配置多个参数。例如将 <code>index.html</code> 的前述超链接改为如下。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/hello/testParamsAndHeaders(username=&#x27;admin&#x27;,password=12345)&#125;&quot;</span>&gt;</span>测试RequestMapping注解的params属性 --&gt; /testParamsAndHeaders<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>params</code> 改为 <code>params = &#123;&quot;username&quot;, &quot;password=12345&quot;&#125;</code> ，可成功匹配。</p><br /><h4 id="headers"><a href="#headers" class="headerlink" title="headers"></a>headers</h4><p>与 <code>params</code> 属性用法类似，但匹配的是请求头部信息。</p><table><thead><tr><th>参数匹配规则</th><th>描述</th></tr></thead><tbody><tr><td><code>param</code></td><td>要求请求映射所匹配的请求的 Headers 中必须携带 <code>param</code> 参数。</td></tr><tr><td><code>!param</code></td><td>要求请求映射所匹配的请求的 Headers 中不能携带 <code>param</code> 参数。</td></tr><tr><td><code>param=value</code></td><td>要求请求映射所匹配的请求的 Headers 中必须携带 <code>param</code> 参数且 <code>param=value</code> 。</td></tr><tr><td><code>param!=value</code></td><td>要求请求映射所匹配的请求的 Headers 中必须携带 <code>param</code> 参数且 <code>param!=value </code> 。</td></tr></tbody></table><p>在 <code>RequestMappingController</code> 的 <code>testParamsAndHeaders</code> 方法的 <code>@RequestMapping</code> 注解中加入属性 <code>headers</code> 并设置一个 <code>Host</code> 表示匹配的请求的头部信息中需携带该参数且其值必须为 <code>localhost:8081</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(</span></span><br><span class="line"><span class="meta">        value = &#123;&quot;/testParamsAndHeaders&quot;&#125;,</span></span><br><span class="line"><span class="meta">        params = &#123;&quot;username&quot;, &quot;password=12345&quot;&#125;,</span></span><br><span class="line"><span class="meta">        headers = &#123;&quot;Host=localhost:8081&quot;&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testParamsAndHeaders</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 Tomcat 默认端口为 8080，因此运行项目，点击相应超链接后出现如下 404 错误。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/springmvc_in_action/RequestMapping-params-not-matched.png" alt="RequestMapping-params-not-matched"></p><p>改为 <code>headers = &#123;&quot;Host=localhost:8080&quot;&#125;</code> 后即可正常访问。</p><br /><h2 id="获取请求参数"><a href="#获取请求参数" class="headerlink" title="获取请求参数"></a>获取请求参数</h2><p>当请求匹配到控制器方法后，有多种方法可获取到该请求的请求参数。</p><p>首先在 <code>TestController</code> 中加入如下方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/param&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">param</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;test_param&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建 <code>test_param.html</code> 页面。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>测试请求参数<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>测试请求参数<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>新建 <code>ParamController.java</code> 控制器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukiyama.mvc.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ParamController</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后续在 <code>http://localhost:8080/springMVC/param</code> 页面中通过点击不同链接完成本节测试。</p><br /><h3 id="通过ServletAPI"><a href="#通过ServletAPI" class="headerlink" title="通过ServletAPI"></a>通过ServletAPI</h3><p>将 <code>HttpServletRequest request</code> 作为控制器方法的形参，此时 <code>request</code> 为封装了当前请求的请求报文的对象。</p><p>在 <code>ParamController</code> 中新建 <code>testServletAPI</code> 方法如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testServletAPI&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testServletAPI</span><span class="params">(HttpServletRequest request)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;username = &quot;</span> + username + <span class="string">&quot;, password = &quot;</span> + password);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>test_param.html</code> 的 <code>&lt;body&gt;</code> 中新增如下超链接。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/testServletAPI(username=&#x27;admin&#x27;,password=12345)&#125;&quot;</span>&gt;</span>测试使用 Servlet API 来获取请求参数<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行项目，访问 <code>http://localhost:8080/springMVC/param</code> ，可以访问上述链接，且控制台打印 <code>username = admin, password = 12345</code> ，表明获取到了指定的参数。 </p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/springmvc_in_action/request-param-servletAPI.png" alt="request-param-servletAPI"></p><br /><h3 id="通过控制器方法形参"><a href="#通过控制器方法形参" class="headerlink" title="通过控制器方法形参"></a>通过控制器方法形参</h3><p>在控制器方法的形参位置，设置 <strong>与请求参数同名的形参</strong> ，当浏览器发送请求，匹配到请求映射时，DispatcherServlet 就会将请求参数赋值给相应的形参。</p><p>在 <code>ParamController</code> 中新建 <code>testParam</code> 方法如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testParam&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testParam</span><span class="params">(String username, String password)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;username = &quot;</span> + username + <span class="string">&quot;, password = &quot;</span> + password);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>test_param.html</code> 的 <code>&lt;body&gt;</code> 中新增如下超链接。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/testParam(username=&#x27;admin&#x27;,password=12345)&#125;&quot;</span>&gt;</span>测试通过控制器方法形参获取请求参数 -- &gt; /testParam<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行项目，访问 <code>http://localhost:8080/springMVC/param</code> ，可以访问上述链接，且控制台打印 <code>username = admin, password = 12345</code> ，表明获取到了指定的参数。 </p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/springmvc_in_action/request-param-method-args.png" alt="request-param-method-args"></p><br /><h4 id="多个同名参数"><a href="#多个同名参数" class="headerlink" title="多个同名参数"></a>多个同名参数</h4><p>当请求参数中有多个同名参数时 (例如 checkbox 元素) ，若控制器方法对应形参为 <code>String</code> 类型，则得到这些同名参数以 <code>,</code> 分隔的拼接字符串；若为 <code>String[]</code> 类型，则这些同名参数值为数组中的元素。</p><p>在 <code>ParamController</code> 中修改 <code>testParam</code> 方法如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testParam&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testParam</span><span class="params">(String username, String password, String hobby)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;username = &quot;</span> + username + <span class="string">&quot;, password = &quot;</span> + password + <span class="string">&quot;, hobby = &quot;</span> + hobby);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>test_param.html</code> 的 <code>&lt;body&gt;</code> 中新增如下表单。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/testParam&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;get&quot;</span>&gt;</span></span><br><span class="line">    用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    爱好：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span> <span class="attr">value</span>=<span class="string">&quot;a&quot;</span>&gt;</span>a</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span> <span class="attr">value</span>=<span class="string">&quot;b&quot;</span>&gt;</span>b</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span> <span class="attr">value</span>=<span class="string">&quot;c&quot;</span>&gt;</span>c<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;测试通过控制器方法形参获取请求参数&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行项目，访问 <code>http://localhost:8080/springMVC/param</code> ，填写表单并点击 <code>测试通过控制器方法形参获取请求参数</code> 提交，可成功跳转，且控制台打印 <code>username = admin, password = 123, hobby = a,b,c</code> ，表明获取到了指定的参数且 hobby 的值为三个同参数名参数值的拼接结果。</p><p> <img src="https://raw.githubusercontent.com/iyukiyama/pics/master/springmvc_in_action/request-param-checkbox.png" alt="request-param-checkbox"></p><p>将 <code>testParam</code> 方法中的 <code>hobby</code> 改为 <code>String[]</code> 类型，如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testParam&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testParam</span><span class="params">(String username, String password, String[] hobby)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;username = &quot;</span> + username + <span class="string">&quot;, password = &quot;</span> + password + <span class="string">&quot;, hobby = &quot;</span> + Arrays.toString(hobby));</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次运行项目，填入表单点击提交按钮，跳转成功，且控制台打印 <code>username = admin, password = 123, hobby = [a, b, c]</code> 。可以看到 hobby 为字符串数组。</p><br /><h4 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h4><p>通过控制器方法形参获取请求参数，默认情况下要求控制器方法形参要与请求参数的参数名一致，不一致则无法获取 (为 null) 。例如在前述项目保持运行的情况下，访问如下 URL (username 改为了 user_name) ，则控制台输出 <code>username = null, password = 123, hobby = a,b,c</code> 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/springmvc/testParam?user_name=admin&amp;password=123&amp;hobby=a&amp;hobby=b&amp;hobby=c</span><br></pre></td></tr></table></figure><p>可使用 SpringMVC 提供的 <code>@RequestParam</code> 参数注解将请求参数名映射到控制器方法形参名。</p><br /><h5 id="value属性"><a href="#value属性" class="headerlink" title="value属性"></a>value属性</h5><p>在 <code>ParamController</code> 中修改 <code>testParam</code> 方法如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testParam&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testParam</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(&quot;user_name&quot;)</span> String username,</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(&quot;pw&quot;)</span>String password,</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(&quot;interest&quot;)</span> String[] hobby)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;username = &quot;</span> + username + <span class="string">&quot;, password = &quot;</span> + password + <span class="string">&quot;, hobby = &quot;</span> + Arrays.toString(hobby));</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>test_param.html</code> 的 <code>&lt;body&gt;</code> 中修改表单如下。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/testParam&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;get&quot;</span>&gt;</span></span><br><span class="line">    用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;user_name&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;pw&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    爱好：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;interest&quot;</span> <span class="attr">value</span>=<span class="string">&quot;a&quot;</span>&gt;</span>a</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;interest&quot;</span> <span class="attr">value</span>=<span class="string">&quot;b&quot;</span>&gt;</span>b</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;interest&quot;</span> <span class="attr">value</span>=<span class="string">&quot;c&quot;</span>&gt;</span>c<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;测试通过控制器方法形参获取请求参数&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行项目，访问 <code>http://localhost:8080/springMVC/param</code> ，填写表单并点击 <code>测试通过控制器方法形参获取请求参数</code> 提交，可成功跳转，且控制台打印 <code>username = admin, password = 123, hobby = [a, b, c]</code> ，表明请求参数通过 <code>@RequestParam</code> 映射到控制器形参，从而获取到参数。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/springmvc_in_action/request-param-RequestParam.png" alt="request-param-RequestParam"></p><br /><h5 id="required属性"><a href="#required属性" class="headerlink" title="required属性"></a>required属性</h5><p><code>@RequestParam</code> 的 required 属性表示是否必须存在所要映射的请求参数，默认值为 true，则当请求参数缺少 value 所指定的的参数时将出现 400 错误。如下，请求参数中缺少 <code>user_name=admin</code> ，返回 400 错误页面中可看到 <code>Required String parameter &#39;user_name&#39; is not present</code> 。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/springmvc_in_action/request-param-RequestParam-400.png" alt="request-param-RequestParam-400"></p><p>可通过设置 <code>required</code> 属性为 <code>false</code>，使得缺少对应请求参数时也能够执行相应的控制器方法。将 <code>testParam</code> 方法改为如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testParam&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testParam</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(value = &quot;user_name&quot;, required = false)</span> String username,</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(&quot;pw&quot;)</span>String password,</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(&quot;interest&quot;)</span> String[] hobby)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;username = &quot;</span> + username + <span class="string">&quot;, password = &quot;</span> + password + <span class="string">&quot;, hobby = &quot;</span> + Arrays.toString(hobby));</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>去掉 url 中的 <code>user_name=admin&amp;</code> ，可成功打开页面，此时控制台输出 <code>username = null, password = 123, hobby = [a, b, c]</code> ，可见在 <code>required = false</code> 时，若无对应请求参数，则控制器中对应的形参被赋值为 <code>null</code> 。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/springmvc_in_action/request-param-RequestParam-required-false.png" alt="request-param-RequestParam-required-false"></p><br /><h5 id="defaultValue属性"><a href="#defaultValue属性" class="headerlink" title="defaultValue属性"></a>defaultValue属性</h5><p>无论 <code>required</code> 属性值为 <code>true</code> 或 <code>false</code> ，当请求未携带 <code>value</code> 所指定的请求参数或该请求参数值为 <code>&quot;&quot;</code> (空字符串) 时，使用 <code>defaultValue</code> 属性值为形参赋值。</p><p>将 <code>testParam</code> 方法改为如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testParam&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testParam</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(</span></span></span><br><span class="line"><span class="meta"><span class="params">                value = &quot;user_name&quot;,</span></span></span><br><span class="line"><span class="meta"><span class="params">                required = false,</span></span></span><br><span class="line"><span class="meta"><span class="params">                defaultValue = &quot;defaultUser&quot;</span></span></span><br><span class="line"><span class="meta"><span class="params">        )</span> String username,</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(&quot;pw&quot;)</span>String password,</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(&quot;interest&quot;)</span> String[] hobby)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;username = &quot;</span> + username + <span class="string">&quot;, password = &quot;</span> + password + <span class="string">&quot;, hobby = &quot;</span> + Arrays.toString(hobby));</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>去掉 url 中的 <code>user_name=admin&amp;</code> 或改为 <code>user_name=&amp;</code> (参数为空字符串)，可成功打开页面，此时控制台输出 <code>username = defaultUser, password = 123, hobby = [a, b, c]</code> 。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/springmvc_in_action/request-param-RequestParam-defaultValue.png" alt="request-param-RequestParam-defaultValue"></p><br /><h4 id="RequestHeader"><a href="#RequestHeader" class="headerlink" title="@RequestHeader"></a>@RequestHeader</h4><p><code>@RequestHeader</code> 参数注解创建请求头信息和控制器方法形参的映射关系。<code>@RequestHeader</code> 注解的三个属性 <code>value</code>, <code>required</code>, <code>defaultValue</code> 用法同 <code>@RequestParam</code> 。</p><p>将 <code>testParam</code> 方法改为如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testParam&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testParam</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(</span></span></span><br><span class="line"><span class="meta"><span class="params">                value = &quot;user_name&quot;,</span></span></span><br><span class="line"><span class="meta"><span class="params">                required = false,</span></span></span><br><span class="line"><span class="meta"><span class="params">                defaultValue = &quot;defaultUser&quot;</span></span></span><br><span class="line"><span class="meta"><span class="params">        )</span> String username,</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(&quot;pw&quot;)</span>String password,</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(&quot;interest&quot;)</span> String[] hobby,</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestHeader(</span></span></span><br><span class="line"><span class="meta"><span class="params">                value = &quot;Host&quot;,</span></span></span><br><span class="line"><span class="meta"><span class="params">                required = false,</span></span></span><br><span class="line"><span class="meta"><span class="params">                defaultValue = &quot;localhost:8080&quot;</span></span></span><br><span class="line"><span class="meta"><span class="params">        )</span> String host)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;username = &quot;</span> + username + <span class="string">&quot;, password = &quot;</span> + password + <span class="string">&quot;, hobby = &quot;</span> + Arrays.toString(hobby));</span><br><span class="line">    System.out.println(<span class="string">&quot;host = &quot;</span> + host);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于请求中的 Headers 中有 <code>Host</code> ，且其值为 <code>localhost:8080</code> 。因此运行项目，访问 <code>http://localhost:8080/springMVC/param</code> ，填写表单并点击 <code>测试通过控制器方法形参获取请求参数</code> 提交，可成功跳转，且控制台打印如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">username = admin, password = 123, hobby = [a, b, c]</span><br><span class="line">host = localhost:8080</span><br></pre></td></tr></table></figure><br /><h4 id="CookieValue"><a href="#CookieValue" class="headerlink" title="@CookieValue"></a>@CookieValue</h4><p><code>@CookieValue</code> 参数注解创建请求头信息和控制器方法形参的映射关系。<code>@CookieValue</code> 注解的三个属性 <code>value</code>, <code>required</code>, <code>defaultValue</code> 用法同 <code>@RequestParam</code> 。</p><p>要测试 <code>@CookieValue</code> ，首先需要生成 cookie。可以在 <code>testServletAPI</code> 方法中加入 <code>request.getSession()</code> 方法来获取 session。如下是修改后的 <code>testServletAPI</code> 方法。如在「通过ServletAPI获取」一节中那样，访问 <code>http://localhost:8080/springmvc/testServletAPI?username=admin&amp;password=12345</code> 之后，该请求的返回报文 Headers 中就会记录 session 信息，并将其作为下次请求时携带的 cookie 。</p><p>※ session 与 cookie 的关系请参考 <a href="https://github.com/iyukiyama/javaweb_in_action">该仓库</a> 的 <a href="https://github.com/iyukiyama/javaweb_in_action/blob/master/JavaWeb%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98_yukiyama.md">JavaWeb学习实战_yukiyama.md</a> 教程的「session」一节中的「session与cookie」。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testServletAPI&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">testServletAPI</span><span class="params">(HttpServletRequest request)</span>&#123;</span><br><span class="line">    <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;username = &quot;</span> + username + <span class="string">&quot;, password = &quot;</span> + password);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一次请求时， cookie 信息在该次请求的响应 Headers 中，此时 cookie 已记录在本地浏览器中，并在下次请求时写入请求 Headers 中。如下是第一次请求时的响应 Headers 以及第二次请求的请求 Headers 。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/springmvc_in_action/request-param-CookieValue.png" alt="request-param-CookieValue"></p><p>有了 cookie 之后，将 <code>testParam</code> 方法改为如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testParam&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testParam</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(</span></span></span><br><span class="line"><span class="meta"><span class="params">                value = &quot;user_name&quot;,</span></span></span><br><span class="line"><span class="meta"><span class="params">                required = false,</span></span></span><br><span class="line"><span class="meta"><span class="params">                defaultValue = &quot;defaultUser&quot;</span></span></span><br><span class="line"><span class="meta"><span class="params">        )</span> String username,</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(&quot;pw&quot;)</span>String password,</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(&quot;interest&quot;)</span> String[] hobby,</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestHeader(</span></span></span><br><span class="line"><span class="meta"><span class="params">                value = &quot;Host&quot;,</span></span></span><br><span class="line"><span class="meta"><span class="params">                required = false,</span></span></span><br><span class="line"><span class="meta"><span class="params">                defaultValue = &quot;localhost:8080&quot;</span></span></span><br><span class="line"><span class="meta"><span class="params">        )</span> String host,</span></span><br><span class="line"><span class="params">        <span class="meta">@CookieValue(&quot;JSESSIONID&quot;)</span> String jsessionid</span></span><br><span class="line"><span class="params">        )</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;username = &quot;</span> + username + <span class="string">&quot;, password = &quot;</span> + password + <span class="string">&quot;, hobby = &quot;</span> + Arrays.toString(hobby));</span><br><span class="line">    System.out.println(<span class="string">&quot;host = &quot;</span> + host);</span><br><span class="line">    System.out.println(<span class="string">&quot;JSESSIONID = &quot;</span> + jsessionid);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行项目，访问 <code>http://localhost:8080/springMVC/param</code> ，填写表单并点击 <code>测试通过控制器方法形参获取请求参数</code> 提交，可成功跳转，且控制台打印如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">username = admin, password = 123, hobby = [a, b, c]</span><br><span class="line">host = localhost:8080</span><br><span class="line">JSESSIONID = D5A3EF7A9B13F0ABB5375E779D1E4691</span><br></pre></td></tr></table></figure><br /><h3 id="通过控制器方法Bean形参"><a href="#通过控制器方法Bean形参" class="headerlink" title="通过控制器方法Bean形参"></a>通过控制器方法Bean形参</h3><p>若需要获取的请求参数与 ORM 对象的字段一一对应，则控制器方法参数可设置为该 ORM 类型，则通过该形参得到的 ORM 对象实例的字段即为请求参数。</p><p>在 <code>test_param.html</code> 的 <code>&lt;body&gt;</code> 中新增如下表单。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/testBean&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    性别：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;男&quot;</span>&gt;</span>男<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;女&quot;</span>&gt;</span>女<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    年龄：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    邮箱：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;使用POJO接收请求参数&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 <code>ParamController</code> 控制器中新增如下方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testBean&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testBean</span><span class="params">(User user)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;user = &quot;</span> + user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行项目，填入参数后可点击提交按钮可正常跳转。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/springmvc_in_action/request-param-POJO.png" alt="request-param-POJO"></p><p>控制台输出如下信息，可看到通过在控制器方法中传入 Bean 对象，将请求参数赋值到了 Bean 对象的对应字段中。但其中 <code>sex</code> 参数值 <code>男</code> 未正确显示，需要处理此编码问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user = User&#123;id=null, username=&#x27;admin&#x27;, password=&#x27;123&#x27;, age=20, sex=&#x27;ç·&#x27;, email=&#x27;admin@gmail.com&#x27;&#125;</span><br></pre></td></tr></table></figure><br /><h3 id="请求参数乱码"><a href="#请求参数乱码" class="headerlink" title="请求参数乱码"></a>请求参数乱码</h3><p>若之前的表单的 method 为 get，则不会出现乱码问题。但 method 为 post 出现了汉字无法被正常显示的现象，可以使用 SpringMVC 提供的编码过滤器 <code>CharacterEncodingFilter</code> 解决请求参数中不能正确读取汉字的问题。</p><p>在 <code>web.xml</code> 中加入如下内容，即可完成在 <code>CharacterEncodingFilter</code> 中设置请求及响应的编码为 UTF-8 。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 设置编码过滤器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceResponseEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>重新运行项目，在表单中填入一些中文，可正确显示。</p><br /><h2 id="域对象共享数据"><a href="#域对象共享数据" class="headerlink" title="域对象共享数据"></a>域对象共享数据</h2><p>通过作用域对象可在应用中共享数据。后续按照 request、session、application 三个作用域依次讲解如何利用域对象共享数据。为完成演示，先做如下准备工作。</p><p>复制之前的 <code>springmvc-demo2</code> 为 <code>springmvcdemo3</code> 子项目。在父项目的 <code>&lt;modules&gt;</code> 标签中加入该子项目，并调整项目下的文件后如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">springmvcdemo3</span><br><span class="line">├── pom.xml</span><br><span class="line">└── src</span><br><span class="line">    └── main</span><br><span class="line">        ├── java</span><br><span class="line">        │   └── com</span><br><span class="line">        │       └── yukiyama</span><br><span class="line">        │           └── mvc</span><br><span class="line">        │               └── controller</span><br><span class="line">        │                   ├── ScopeController.java</span><br><span class="line">        │                   └── TestController.java</span><br><span class="line">        ├── resources</span><br><span class="line">        │   └── springMVC.xml</span><br><span class="line">        └── webapp</span><br><span class="line">            └── WEB-INF</span><br><span class="line">                ├── templates</span><br><span class="line">                │   ├── index.html</span><br><span class="line">                │   └── success.html</span><br><span class="line">                └── web.xml</span><br></pre></td></tr></table></figure><p>其中 <code>ScopeController</code> 控制器、<code>index.html</code> 、<code>success.html</code> 均为新建 (html 要引入 thymeleaf 命名空间)，用于完成后续演示。</p><p><code>ScopeController.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukiyama.mvc.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScopeController</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>index.html</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thyemleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>共享域对象<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>success.html</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thyemleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>success<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>后续在 <code>http://localhost:8080/springMVC/</code> 页面中通过点击不同链接完成本节测试。</p><br /><h3 id="request域共享"><a href="#request域共享" class="headerlink" title="request域共享"></a>request域共享</h3><p>有多种方式在 request 作用域中共享数据。</p><table><thead><tr><th>request域共享方式</th><th>共享方法</th></tr></thead><tbody><tr><td><code>HttpServletRequest</code></td><td><code>setAttribute(String name, Object o)</code></td></tr><tr><td><code>ModelAndView</code></td><td><code>addObject(String attributeName, @Nullable Object attributeValue)</code></td></tr><tr><td><code>Model</code></td><td><code>addAttribute(String var1, @Nullable Object var2)</code></td></tr><tr><td><code>Map</code></td><td><code>put(K key, V value)</code></td></tr><tr><td><code>ModelMap</code></td><td><code>addAttribute(String attributeName, @Nullable Object attributeValue)</code></td></tr></tbody></table><br /><h4 id="ServletAPI"><a href="#ServletAPI" class="headerlink" title="ServletAPI"></a>ServletAPI</h4><p>将 <code>HttpServletRequest request</code> 作为控制器方法的形参，此时 <code>request</code> 为当前请求对象，通过该对象的 <code>setAttribute</code> 方法共享 request 域数据。</p><p>在 <code>ScopeController</code> 控制器中增加如下方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testRequestServletAPI&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testRequestServletAPI</span><span class="params">(HttpServletRequest request)</span>&#123;</span><br><span class="line">    request.setAttribute(<span class="string">&quot;testRequestScope&quot;</span>, <span class="string">&quot;request sharing data set by Servlet API&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>index.html</code> 的 <code>&lt;body&gt;</code> 标签中加入如下超链接。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/testRequestServletAPI&#125;&quot;</span>&gt;</span>通过 Servlet API 在 request 域对象中共享数据<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 <code>success.html</code> 的 <code>&lt;body&gt;</code> 标签中加入如下。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;testRequestScope&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行项目，打开 <code>http://localhost:8080/springMVC/</code> ，点击相应链接后可看到如下，表明通过 <code>HttpServletRequest</code> 实例对象在 request 作用域下共享了数据。 </p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/springmvc_in_action/scope-servlet-api.png" alt="scope-servlet-api"></p><br /><h4 id="ModelAndView"><a href="#ModelAndView" class="headerlink" title="ModelAndView"></a>ModelAndView</h4><p>SpringMVC 提供了 <code>ModelAndView</code> 类来处理模型与视图，可利用其中的实例方法 <code>addObject</code> 向 request 作用域中设置共享数据。</p><p>在 <code>ScopeController</code> 控制器中增加如下方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testRequestModelAndView&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">testRequestModelAndView</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ModelAndView</span> <span class="variable">mav</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">    mav.addObject(<span class="string">&quot;testRequestScope&quot;</span>, <span class="string">&quot;request sharing data set by ModelAndView&quot;</span>);</span><br><span class="line">    mav.setViewName(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> mav;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>index.html</code> 的 <code>&lt;body&gt;</code> 标签中加入如下超链接。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/testRequestModelAndView&#125;&quot;</span>&gt;</span>通过 ModelAndView 在 request 域对象中共享数据<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行项目，打开 <code>http://localhost:8080/springMVC/</code> ，点击相应链接后可看到如下，表明通过 <code>ModelAndView</code> 实例对象在 request 作用域下共享了数据。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/springmvc_in_action/scope-modelandview.png" alt="scope-modelandview"></p><br /><h4 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h4><p>SpringMVC 提供了 <code>Model</code> 类来处理模型，可利用其中的实例方法 <code>addAttribute</code> 向 request 作用域中设置共享数据。</p><p>在 <code>ScopeController</code> 控制器中增加如下方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testRequestModel&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testRequestModel</span><span class="params">(Model model)</span>&#123;</span><br><span class="line">    model.addAttribute(<span class="string">&quot;testRequestScope&quot;</span>, <span class="string">&quot;request sharing data set by Model&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>index.html</code> 的 <code>&lt;body&gt;</code> 标签中加入如下超链接。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/testRequestModel&#125;&quot;</span>&gt;</span>通过 Model 在 request 域对象中共享数据<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行项目，打开 <code>http://localhost:8080/springMVC/</code> ，点击相应链接后可看到如下，表明通过 <code>Model</code> 实例对象在 request 作用域下共享了数据。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/springmvc_in_action/scope-model.png" alt="scope-model"></p><br /><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p>可以在控制器方法中传入 <code>Map</code> 实例，并 <code>put</code> 方法向 request 作用域中设置共享数据。</p><p>在 <code>ScopeController</code> 控制器中增加如下方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testRequestMap&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testRequestMap</span><span class="params">(Map&lt;String, Object&gt; map)</span>&#123;</span><br><span class="line">    map.put(<span class="string">&quot;testRequestScope&quot;</span>, <span class="string">&quot;request sharing data set by Map&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>index.html</code> 的 <code>&lt;body&gt;</code> 标签中加入如下超链接。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/testRequestMap&#125;&quot;</span>&gt;</span>通过 Map 在 request 域对象中共享数据<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行项目，打开 <code>http://localhost:8080/springMVC/</code> ，点击相应链接后可看到如下，表明通过 <code>Map</code> 实例对象在 request 作用域下共享了数据。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/springmvc_in_action/scope-map.png" alt="scope-map"></p><br /><h4 id="ModelMap"><a href="#ModelMap" class="headerlink" title="ModelMap"></a>ModelMap</h4><p>SpringMVC 提供了 <code>ModelMap</code> 类，可以在控制器方法中传入 <code>ModelMap</code> 实例，并利用 <code>addAttribute</code> 方法向 request 作用域中设置共享数据。</p><p>在 <code>ScopeController</code> 控制器中增加如下方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testRequestModelMap&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testRequestModelMap</span><span class="params">(ModelMap modelMap)</span>&#123;</span><br><span class="line">    modelMap.addAttribute(<span class="string">&quot;testRequestScope&quot;</span>, <span class="string">&quot;request sharing data set by ModelMap&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>index.html</code> 的 <code>&lt;body&gt;</code> 标签中加入如下超链接。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/testRequestModelMap&#125;&quot;</span>&gt;</span>通过 ModelMap 在 request 域对象中共享数据<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行项目，打开 <code>http://localhost:8080/springMVC/</code> ，点击相应链接后可看到如下，表明通过 <code>ModelMap</code> 实例对象在 request 作用域下共享了数据。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/springmvc_in_action/scope-modelmap.png" alt="scope-modelmap"></p><br /><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>前面的示例中，<code>Model</code>、<code>ModelMap</code>、<code>Map</code> 类型的参数实际上都是 <code>BindingAwareModelMap</code> 类型的实例对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface Model&#123;&#125;</span><br><span class="line">public class ModelMap extends LinkedHashMap&lt;String, Object&gt; &#123;&#125;</span><br><span class="line">public class ExtendedModelMap extends ModelMap implements Model &#123;&#125;</span><br><span class="line">public class BindingAwareModelMap extends ExtendedModelMap &#123;&#125;</span><br></pre></td></tr></table></figure><p>在实践中一般使用 <code>ModelAndView</code> 来共享 request 域数据，实际上无论使用哪一种方式，最终都会将共享数据封装到 <code>ModelAndView</code> 对象实例中 (更具体地，是 <code>ModelAndView</code> 实例中的 <code>ModelMap</code> 字段中)。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/springmvc_in_action/scope-diagram.png" alt="scope-diagram"></p><br /><h3 id="session域共享"><a href="#session域共享" class="headerlink" title="session域共享"></a>session域共享</h3><p>将 <code>HttpSession session</code> 作为控制器方法的形参，此时 <code>session</code> 为当前会话对象，通过该对象的 <code>setAttribute</code> 方法共享 session 域数据。</p><p>在 <code>ScopeController</code> 控制器中增加如下方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testSession&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testSession</span><span class="params">(HttpSession session)</span>&#123;</span><br><span class="line">    session.setAttribute(<span class="string">&quot;testSessionScope&quot;</span>, <span class="string">&quot;session sharing data set by HttpSession&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>index.html</code> 的 <code>&lt;body&gt;</code> 标签中加入如下超链接。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/testSession&#125;&quot;</span>&gt;</span>通过 HttpSession 在 session 域对象中共享数据<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 <code>success.html</code> 的 <code>&lt;body&gt;</code> 标签中加入如下获取 session 共享数据的 <code>&lt;p&gt;</code> 标签。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;session.testSessionScope&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行项目，打开 <code>http://localhost:8080/springMVC/</code> ，点击相应链接后可看到如下，表明通过 <code>HttpSession</code> 实例对象在 session 作用域下共享了数据。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/springmvc_in_action/scope-session.png" alt="scope-session"></p><br /><h3 id="application域共享"><a href="#application域共享" class="headerlink" title="application域共享"></a>application域共享</h3><p>将 <code>HttpSession session</code> 或 <code>HttpServletRequest request</code> 作为控制器方法的形参，通过 session 或 request 的 <code>getServletContext()</code> 方法获取 <code>ServletContext application</code> 。此时 <code>application</code> 为当前应用上下文对象，通过该对象的 <code>setAttribute</code> 方法共享 application 域数据。</p><p>在 <code>ScopeController</code> 控制器中增加如下方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testApplication&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testApplication</span><span class="params">(HttpSession session)</span>&#123;</span><br><span class="line">    <span class="type">ServletContext</span> <span class="variable">application</span> <span class="operator">=</span> session.getServletContext();</span><br><span class="line">    application.setAttribute(<span class="string">&quot;testApplicationScope&quot;</span>, <span class="string">&quot;application sharing data set by ServletContext&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述方法通过 <code>HttpSession</code> 对象来获取 <code>ServletContext</code> 对象，也可以通过 <code>HttpServletRequest</code> 对象来获取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testApplication&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testApplication</span><span class="params">(HttpServletRequest request)</span>&#123;</span><br><span class="line">    <span class="type">ServletContext</span> <span class="variable">application</span> <span class="operator">=</span> request.getServletContext();</span><br><span class="line">    application.setAttribute(<span class="string">&quot;testApplicationScope&quot;</span>, <span class="string">&quot;application sharing data set by ServletContext&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>index.html</code> 的 <code>&lt;body&gt;</code> 标签中加入如下超链接。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/testApplication&#125;&quot;</span>&gt;</span>通过 ServletContext 在 application 域对象中共享数据<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 <code>success.html</code> 的 <code>&lt;body&gt;</code> 标签中加入如下获取 application 共享数据的 <code>&lt;p&gt;</code> 标签。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;application.testApplicationScope&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行项目，打开 <code>http://localhost:8080/springMVC/</code> ，点击相应链接后可看到如下，表明通过 <code>ServletContext</code> 实例对象在 application 作用域下共享了数据。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/springmvc_in_action/scope-application.png" alt="scope-application"></p><br /><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>SpringMVC 中的视图是 <code>View</code> 接口，视图的作用是渲染数据，即将模型 Model 中的数据展示给用户。</p><p>SpringMVC 有很多种视图，默认有转发视图和重定向视图。若使用的视图技术为 Thymeleaf，则需要在 SpringMVC 的配置文件中配置 Thymeleaf 的视图解析器，由此视图解析器解析之后所得到的是 ThymeleafView。</p><p>复制之前的 <code>springmvc-demo3</code> 为 <code>springmvc-demo4</code> 子项目。在父项目的 <code>&lt;modules&gt;</code> 标签中加入该子项目，并调整项目下的文件后如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">springmvc-demo4</span><br><span class="line">├── pom.xml</span><br><span class="line">└── src</span><br><span class="line">    └── main</span><br><span class="line">        ├── java</span><br><span class="line">        │   └── com</span><br><span class="line">        │       └── yukiyama</span><br><span class="line">        │           └── mvc</span><br><span class="line">        │               └── controller</span><br><span class="line">        │                   ├── TestController.java</span><br><span class="line">        │                   └── ViewController.java</span><br><span class="line">        ├── resources</span><br><span class="line">        │   └── springMVC.xml</span><br><span class="line">        └── webapp</span><br><span class="line">            └── WEB-INF</span><br><span class="line">                ├── templates</span><br><span class="line">                │   ├── success.html</span><br><span class="line">                │   └── test_view.html</span><br><span class="line">                └── web.xml</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中 <code>ViewController</code> 控制器、<code>test_view.html</code> 、<code>success.html</code> 均为新建 (html 要引入 thymeleaf 命名空间)，用于完成后续演示。</p><p><code>TestController.java</code> 改为如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukiyama.mvc.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/view&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">testView</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;test_view&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ViewController.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukiyama.mvc.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ViewController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/testThymeleafView&quot;)</span> </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">testThymeleafView</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>test_view.html</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thyemleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>测试视图<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>success.html</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thyemleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>success<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>后续在 <code>http://localhost:8080/springMVC/view</code> 页面中通过点击不同链接，结合断点调试分析源码完观察不同视图的使用原理。</p><br /><h3 id="ThymeleafView"><a href="#ThymeleafView" class="headerlink" title="ThymeleafView"></a>ThymeleafView</h3><p>当控制器方法中所设置的 <strong>视图名称无前缀时</strong>  (前缀指的是转发前缀 <code>forward:</code> 和重定向前缀 <code>redirect:</code> ) ，视图名称会被 SpringMVC 配置文件中所配置的视图解析器解析得到相应的视图 (例如使用 <code>Thymeleaf</code> 时将得到 <code>ThymeleafView</code> 视图) 。视图名称拼接视图前缀和视图后缀所得到的最终路径，并通过 <strong>转发的方式</strong> 实现跳转。以下在源码层面观察使用该视图时的情形。</p><p>在 <code>ViewController</code> 控制器中增加如下方法。</p><p>在 <code>return &quot;success&quot;;</code> 处设置断点，后续我们将深入源码观察无前缀的视图名称是如何获得 <code>ThymeleafView</code> 的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testThymeleafView&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testThymeleafView</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>test_view.html</code> 的 <code>&lt;body&gt;</code> 标签中加入如下超链接。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/testThymeleafView&#125;&quot;</span>&gt;</span>测试testThymeleafView<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行项目，打开 <code>http://localhost:8080/springMVC/view</code> ，点击相应链接后程序运行至断点处。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/springmvc_in_action/view-th.png" alt="view-th"></p><p>在 Debug 页签的方法栈中找到 <code>doDispatch</code> 方法，点击进入该方法。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/springmvc_in_action/view-th-first-break-point.png" alt="view-th-first-break-point"></p><p>进入后位于如下 <code>mv = ha.handle</code> 行，<code>mv</code> 即 <code>ModelAndView</code> 实例，此实例将作为下方 <code>processDispatchResult</code> 方法的入参，而且可以看到作为参数时 <code>mv</code> 实例已经得到了正确的 <code>view</code> (即 <code>&quot;success&quot;</code> )。见名知义， <code>processDispatchResult</code> 方法用于处理转发结果。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/springmvc_in_action/view-th-break-point-mv.png" alt="view-th-break-point-mv"></p><p>打上断点进入该方法，为其中的渲染方法 <code>render</code> 打上断点。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/springmvc_in_action/view-th-processDispatchResult.png" alt="view-th-processDispatchResult"></p><p>可以看到，<code>render</code> 方法中执行 <code>resolveViewName</code> ，通过传入的 <code>viewName</code> (即 <code>&quot;success&quot;</code> ) 来取得 <code>view</code> 实例。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/springmvc_in_action/view-th-render.png" alt="view-th-render"></p><p>为 <code>resolveViewName</code> 方法打上断点，进入该方法后可以看到，<code>view</code> 是通过另一个同名方法 <code>resolveViewName</code> 的执行而取得的。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/springmvc_in_action/view-th-resolveViewName.png" alt="view-th-resolveViewName"></p><p>继续为此 <code>resolveViewName</code> 打上断点，进入该方法。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/springmvc_in_action/view-th-resolveViewName-internal.png" alt="view-th-resolveViewName-internal"></p><p>为 <code>createView</code> 方法打上断点，进入该方法。可以看到该方法会检查视图名称是否有 <code>redirect:</code> 或 <code>forward:</code> 前缀，当前视图名称无前缀，方法执行到 <code>loadView</code> 行。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/springmvc_in_action/view-th-createView.png" alt="view-th-createView"></p><p>为 <code>loadView</code> 方法打上断点，进入该方法。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/springmvc_in_action/view-th-loadView.png" alt="view-th-loadView"></p><p>该方法指定到 <code>(AbstractThymeleafView) beanFactory.initializeBean</code> 一行时，<code>view</code> 还未取得值，当该行执行结束时，<code>view</code> 最终取得值，为 <code>ThymeleafView</code> 。 </p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/springmvc_in_action/view-th-view.png" alt="view-th-view"></p><br /><h3 id="InternalResourceView"><a href="#InternalResourceView" class="headerlink" title="InternalResourceView"></a>InternalResourceView</h3><p>SpringMVC 中默认的 <strong>转发视图</strong> 是 <code>InternalResourceView</code> 。当控制器方法中所设置的视图名称以 <code>forward:</code> 为前缀时，视图名称不会被 SpringMVC 配置文件中所配置的视图解析器解析，而是会将前缀 <code>forward:</code> 去掉，剩余部分作为最终路径通过 <strong>转发的方式</strong> 实现跳转。相应的视图为 <code>InternalResourceView</code> 视图。</p><p>在 <code>ViewController</code> 控制器中增加如下方法。</p><p>在 <code>return</code> 处设置断点，后续我们将深入源码观察 <code>forward:</code> 视图名称是如何获得 <code>InternalResourceView</code> 的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testForward&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testForward</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;forward:/testThymeleafView&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>test_view.html</code> 的 <code>&lt;body&gt;</code> 标签中加入如下超链接。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/testForward&#125;&quot;</span>&gt;</span>测试转发视图<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行项目，打开 <code>http://localhost:8080/springMVC/view</code> ，点击相应链接后程序运行至断点处。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/springmvc_in_action/view-forward.png" alt="view-forward"></p><p>在 Debug 页签的方法栈中找到 <code>doDispatch</code> 方法，点击进入该方法。从此步骤开始一直进入到 <code>createView</code> 方法前，与「ThymeleafView」 一节的分析过程相同。</p><p>进入到 <code>createView</code> 方法后，可以看到由于视图名称有 <code>forward:</code> 前缀，因此进入 <code>viewName.startsWith(&quot;forward:&quot;)</code> 分支，并返回 <code>InternalResourceView</code> 视图实例。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/springmvc_in_action/view-internal-createView.png" alt="view-internal-createView"></p><p>当 <code>createView</code> 方法执行结束时，<code>view</code> 最终取得值，为 <code>InternalResourceView</code> 。 </p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/springmvc_in_action/view-internal-view.png" alt="view-internal-view"></p><br /><h3 id="RedirectView"><a href="#RedirectView" class="headerlink" title="RedirectView"></a>RedirectView</h3><p>SpringMVC 中默认的重定向视图是 <code>RedirectView</code> 。当控制器方法中所设置的视图名称以 <code>redirect:</code> 为前缀时，创建 <code>RedirectView</code> 视图，此时的视图名称不会被 SpringMVC 配置文件中所配置的视图解析器解析，而是会将前缀 <code>redirect:</code> 去掉，剩余部分作为最终路径通过 <strong>重定向的方式</strong> 实现跳转。</p><p>在实际业务中，当前请求处理完成后经常需要跳转到其他相比转发视图，重定向视图更常用。</p><p>※ 重定向视图在解析时，会先将 <code>redirect:</code> 前缀去掉，然后会判断剩余部分是否以 <code>/</code> 开头，若是则会自动拼接上下文路径。</p><p>在 <code>ViewController</code> 控制器中增加如下方法。</p><p>在 <code>return</code> 处设置断点，后续我们将深入源码观察 <code>redirect:</code> 视图名称是如何获得 <code>RedirectView</code> 的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testRedirect&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testRedirect</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/testThymeleafView&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>test_view.html</code> 的 <code>&lt;body&gt;</code> 标签中加入如下超链接。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/testRedirect&#125;&quot;</span>&gt;</span>测试重定向视图<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行项目，打开 <code>http://localhost:8080/springMVC/view</code> ，点击相应链接后程序运行至断点处。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/springmvc_in_action/view-redirect.png" alt="view-redirect"></p><p>在 Debug 页签的方法栈中找到 <code>doDispatch</code> 方法，点击进入该方法。从此步骤开始一直进入到 <code>createView</code> 方法前，与「ThymeleafView」 一节的分析过程相同。</p><p>进入到 <code>createView</code> 方法后，可以看到由于视图名称有 <code>redirect:</code> 前缀，因此进入 <code>viewName.startsWith(&quot;redirect:&quot;)</code> 分支，并返回 <code>InternalResourceView</code> 视图实例。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/springmvc_in_action/view-redirect-createView.png" alt="view-redirect-createView"></p><p>当 <code>createView</code> 方法执行结束时，<code>view</code> 最终取得值，为 <code>RedirectView</code> 。 </p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/springmvc_in_action/view-redirect-view.png" alt="view-redirect-view"></p><br /><h3 id="视图控制器"><a href="#视图控制器" class="headerlink" title="视图控制器"></a>视图控制器</h3><p>当控制器方法仅实现页面跳转而无需转发或重定向到其他页面，即只需要设置无前缀视图名称时，可在 SpringMVC 配置文件中用 <code>&lt;view-controller&gt;</code> 标签来代替以 <code>@RequestMapping</code> 注解的控制器方法。</p><p>注释掉如下方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    @RequestMapping(&quot;/view&quot;)</span></span><br><span class="line"><span class="comment">//    public String testView()&#123;</span></span><br><span class="line"><span class="comment">//        return &quot;test_view&quot;;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>SpringMVC.xml</code> 中增加 mvc 命名空间以及 <code>view-controller</code> 标签。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">       https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="string"><span class="tag">       https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 开启扫描 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.yukiyama.mvc.controller&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置Thymeleaf视图解析器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;viewResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.thymeleaf.spring5.view.ThymeleafViewResolver&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;order&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;characterEncoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;templateEngine&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.thymeleaf.spring5.SpringTemplateEngine&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;templateResolver&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                        <span class="comment">&lt;!-- 视图前缀 --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/templates/&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">                        <span class="comment">&lt;!-- 视图后缀 --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.html&quot;</span>/&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;templateMode&quot;</span> <span class="attr">value</span>=<span class="string">&quot;HTML5&quot;</span>/&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;characterEncoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:view-controller</span> <span class="attr">path</span>=<span class="string">&quot;/view&quot;</span> <span class="attr">view-name</span>=<span class="string">&quot;test_view&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mvc:view-controller</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行项目，可以打开 <code>http://localhost:8080/springmvc/view</code> 页面，但点击其中的链接返回 404 错误。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/springmvc_in_action/view-controller-404.png" alt="view-controller-404"></p><p>出现 404 错误的原因是当 SpringMVC 中设置 <code>&lt;view-controller&gt;</code> 时，其他控制器中的请求映射将失效，在 <code>springMVC.xml</code> 中的 <code>&lt;beans&gt;</code> 标签内设置 mvc 注解驱动即可 ( <code>&lt;mvc:annotation-driven /&gt;</code>  标签)。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 开启 mvc 注解驱动 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> /&gt;</span></span><br></pre></td></tr></table></figure><br /><h2 id="RESTful"><a href="#RESTful" class="headerlink" title="RESTful"></a>RESTful</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>REST：<strong>Re</strong>presentational <strong>S</strong>tate <strong>T</strong>ransfer，具体 (表述层) 状态转移。</p><blockquote><p>最原始的定义可参考 Roy Thomas Fielding 于2000年发表的博士论文中 <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm">Representational State Transfer (REST)</a> 一节的描述。</p><p>还可以参考此 <a href="https://www.bilibili.com/video/BV1BA411c7Sd/?spm_id_from=333.337.search-card.all.click&vd_source=c56ec421dded765a52ade50885eaab60">视频</a>。</p></blockquote><p><strong>资源</strong></p><p>资源是一种看待服务器的方式，即将服务器看作是由很多离散的资源组成。每个资源是服务器上一个可命名的抽象概念。因为资源是一个抽象的概念，所以它不仅仅能代表服务器文件系统中的一个文件、数据库中的一张表等等具体的东西，还可以将将资源理解为一些抽象事物。与面向对象设计类似，资源是以名词为核心来组织的，首先关注的是名词。一个资源可以由一个或多个 URI 来标识。URI 既是资源的名称，也是资源在 Web 上的地址。对某个资源感兴趣的客户端应用，可以通过资源的 URI 与其进行交互。</p><p><strong>Representational State</strong></p><p>理解了资源，再理解 Representational State 。 state 即状态，客户端与服务端的交互，本质是要改变资源的状态。例如在浏览器上点击「删除」按键删除一条记录，传递到服务器的是删除请求而非「资源」，服务器中相应的记录被删除后，可以说服务器中相应资源的状态被改变了，这就是 State 的意涵。</p><p><a href="https://dictionary.cambridge.org/us/dictionary/english/representational">Representational</a> 是一个形容词，意为 「showing things as they are normolly seen」 。例如 representational art &#x2F; 具象艺术，是一种描绘现实存在的事物的绘画艺术。Representational State 即具体状态，或通常所说的「表述层状态」，通常可以理解为增&#x2F;删&#x2F;改&#x2F;查。</p><p><strong>transfer</strong></p><p>即转移，转变。在客户端和服务器端之间转移代表资源状态的表述。通过转移和操作资源的表述，来间接实现操作资源的目的。</p><p><strong>-ful</strong></p><p>「xxx-ful」为形容词后缀，意为「充满了xxx的」、「富有xxx的」、「很有xxx的」，例如 beautiful, colorful, helpful 等。</p><br /><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>实现 RESTful ，简单来说就是以 REST 风格的 URL 完成增删改查操作，对应的 http 请求类型：GET 用来获取资源 (查)，POST 用来新建资源 (增)，PUT 用来更新资源 (改)，DELETE 用来删除资源 (删)。</p><p>而所谓 REST 风格指 URL 中不使用问号键值对方式携带请求参数，而是将要发送给服务器的数据作为 URL 地址的一部分，均以 <code>/</code> 隔开。</p><table><thead><tr><th>操作</th><th>传统方式</th><th>REST风格</th></tr></thead><tbody><tr><td>查询操作</td><td>getUserById?id&#x3D;1</td><td>user&#x2F;1 (GET 类型)</td></tr><tr><td>保存操作</td><td>saveUser</td><td>user (POST类型)</td></tr><tr><td>删除操作</td><td>deleteUser?id&#x3D;1</td><td>user&#x2F;1 (DELETE类型)</td></tr><tr><td>更新操作</td><td>updateUser</td><td>user (PUT类型)</td></tr></tbody></table><p>可以明显地看到 REST 风格的 URL 可以极大地压缩 URL 的数量。可以理解为，对同一资源的操作总是使用同一个 URL，而将具体操作体现在请求类型中。</p><p>在 <code>springmvc-demo04</code> 中增加如下 <code>UserController</code> 控制器，后续在此控制器中添加用于演示 RESTful 风格的增上改查方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukiyama.mvc.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMethod;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建 <code>test_rest.html</code> 配合演示。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 <code>springMVC.xml</code> 中添加如下视图控制器配合演示。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:view-controller</span> <span class="attr">path</span>=<span class="string">&quot;/rest&quot;</span> <span class="attr">view-name</span>=<span class="string">&quot;test_rest&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mvc:view-controller</span>&gt;</span></span><br></pre></td></tr></table></figure><br /><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><p>在 <code>UserController</code> 中添加如下方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/user&quot;, method = RequestMethod.GET)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getAllUsers</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;查询所有用户信息&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/user/&#123;id&#125;&quot;, method = RequestMethod.GET)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getUserById</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;根据 id 查询用户信息&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>test_rest.html</code> 的 <code>&lt;body&gt;</code> 标签中添加如下超链接。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/user&#125;&quot;</span>&gt;</span>查询所有用户信息<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/user/1&#125;&quot;</span>&gt;</span>根据 id 查询用户信息<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行项目，可以看到如下。同时，分别点击两条链接时，控制台输出相应的内容。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/springmvc_in_action/restful-get.png" alt="restful-get"></p><br /><h4 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h4><p>在 <code>UserController</code> 中添加如下方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/user&quot;, method = RequestMethod.POST)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">insertUser</span><span class="params">(String username, String password)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;添加用户： &quot;</span> + username + <span class="string">&quot;, &quot;</span> + password);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>test_rest.html</code> 的 <code>&lt;body&gt;</code> 标签中添加如下表单。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/user&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>, <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span>, <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>, <span class="attr">value</span>=<span class="string">&quot;添加&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行项目，在表单中填入 <code>yukiyama</code>, <code>123</code> 可以看到如下，且控制台输出相应内容。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/springmvc_in_action/restful-add.png" alt="restful-add"></p><br /><h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><h5 id="HiddenHttpMethodFilter"><a href="#HiddenHttpMethodFilter" class="headerlink" title="HiddenHttpMethodFilter"></a>HiddenHttpMethodFilter</h5><p>浏览器只支持发送 GET 和 POST 方式的请求，而修改操作对应的是 PUT 请求，我们需要 SpringMVC 提供的 <strong>HiddenHttpMethodFilter</strong> 过滤器 <strong>将 POST 请求转换为 DELETE 或 PUT 请求</strong> 。</p><p>在 <code>web.xml</code> 中配置  <code>HiddenHttpMethodFilter</code> 过滤器。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置 HiddenHttpMethodFilter --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>HiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.HiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>HiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如下是 <code>HiddenHttpMethodFilter</code> 类中执行过滤动作的 <code>doFilterInternal</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEFAULT_METHOD_PARAM</span> <span class="operator">=</span> <span class="string">&quot;_method&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="type">String</span> <span class="variable">methodParam</span> <span class="operator">=</span> DEFAULT_METHOD_PARAM;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doFilterInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span></span><br><span class="line">    <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">  <span class="comment">// 将 request 复制给 requestToUse，后者作为真正的「请求」</span></span><br><span class="line">  <span class="type">HttpServletRequest</span> <span class="variable">requestToUse</span> <span class="operator">=</span> request;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 两个条件，主要看第一个条件，当请求类型为 POST 时才满足。</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&quot;POST&quot;</span>.equals(request.getMethod()) &amp;&amp; request.getAttribute(WebUtils.ERROR_EXCEPTION_ATTRIBUTE) == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// this.methodParam 是固定的，为 &quot;_method&quot;。因此 paramValue 为参数为 &quot;_method&quot; 时的值。</span></span><br><span class="line">    <span class="comment">// 即在 post 表单中使用隐藏域参数 &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;PUT&quot;&gt;</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">paramValue</span> <span class="operator">=</span> request.getParameter(<span class="built_in">this</span>.methodParam);</span><br><span class="line">    <span class="comment">// 当获取到请求参数时</span></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasLength(paramValue)) &#123;</span><br><span class="line">      <span class="comment">// 将请求参数的字母转为大写字母</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> paramValue.toUpperCase(Locale.ENGLISH);</span><br><span class="line">      <span class="comment">// ALLOWED_METHODS 就是 &quot;PUT&quot;, &quot;DELETE&quot;, &quot;PATCH&quot; 这三种</span></span><br><span class="line">      <span class="keyword">if</span> (ALLOWED_METHODS.contains(method)) &#123;</span><br><span class="line">        <span class="comment">// 通过 HttpMethodRequestWrapper 构造器将 method 作为 requestToUse 的 method</span></span><br><span class="line">        requestToUse = <span class="keyword">new</span> <span class="title class_">HttpMethodRequestWrapper</span>(request, method);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 指定过滤方法</span></span><br><span class="line">  filterChain.doFilter(requestToUse, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>HttpMethodRequestWrapper</code> 内部类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">HttpMethodRequestWrapper</span> <span class="keyword">extends</span> <span class="title class_">HttpServletRequestWrapper</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String method;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">HttpMethodRequestWrapper</span><span class="params">(HttpServletRequest request, String method)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(request);</span><br><span class="line">    <span class="comment">// 将 method 赋值给当前类字段 this.method</span></span><br><span class="line">    <span class="built_in">this</span>.method = method;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.method;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>HiddenHttpMethodFilter</code> 处理 PUT &#x2F; DELETE 请求的条件如下。</p><ul><li><p>当前请求的请求方式必须为 POST 。</p></li><li><p>当前请求必须传输请求参数 <code>_method</code> 。</p></li></ul><p>满足以上条件，<code>HiddenHttpMethodFilter</code> 过滤器就会将当前请求的请求方式转换为请求参数 <code>_method</code> 的值，因此请求参数 <code>_method</code> 的值才是最终的请求方式。</p><p>※ 目前为止，SpringMVC 中提供了两个过滤器：<code>CharacterEncodingFilter</code> 和 <code>HiddenHttpMethodFilter</code> 。在 <code>web.xml</code> 中注册时，必须先注册 <code>CharacterEncodingFilter</code> ，再注册 <code>HiddenHttpMethodFilter</code> 。这是因为在 <code>CharacterEncodingFilter</code> 中通过 <code>request.setCharacterEncoding(encoding)</code> 方法设置字符集之前不能有获取请求参数的操作，而 <code>HiddenHttpMethodFilter</code> 恰有一个获取请求方式的操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">paramValue</span> <span class="operator">=</span> request.getParameter(<span class="built_in">this</span>.methodParam);</span><br></pre></td></tr></table></figure><br /><p>设置过滤器后，按如下完成 RESTful 风格的修改。</p><p>在 <code>UserController</code> 中添加如下方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/user&quot;, method = RequestMethod.PUT)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">updateUser</span><span class="params">(String username, String password)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;修改用户： &quot;</span> + username + <span class="string">&quot;, &quot;</span> + password);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>test_rest.html</code> 的 <code>&lt;body&gt;</code> 标签中添加如下表单。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/user&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;_method&quot;</span> <span class="attr">value</span>=<span class="string">&quot;PUT&quot;</span>&gt;</span></span><br><span class="line">    用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>, <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span>, <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>, <span class="attr">value</span>=<span class="string">&quot;修改&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行项目，可以看到如下。在表单中填入 <code>yukiyama</code>, <code>456</code> 可以看到如下，且控制台输出相应内容。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/springmvc_in_action/restful-update.png" alt="restful-update"></p><br /><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>在 <code>UserController</code> 中添加如下方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>在 <code>test_rest.html</code> 的 <code>&lt;body&gt;</code> 标签中添加如下超链接。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>运行项目，可以看到如下。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/springmvc_in_action/restful-del.png" alt="restful-del"></p><br /><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><p>新建 <code>springmvc-rest</code> 子工程用于演示 RESTful 风格的增删改查。</p><p>该子工程目录结构如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">springmvc-rest</span><br><span class="line">├── pom.xml</span><br><span class="line">└── src</span><br><span class="line">    └── main</span><br><span class="line">        ├── java</span><br><span class="line">        │   └── com</span><br><span class="line">        │       └── yukiyama</span><br><span class="line">        │           └── rest</span><br><span class="line">        │               ├── beans</span><br><span class="line">        │               │   └── Employee.java</span><br><span class="line">        │               ├── controller</span><br><span class="line">        │               │   └── EmployeeController.java</span><br><span class="line">        │               └── dao</span><br><span class="line">        │                   └── EmployeeDao.java</span><br><span class="line">        ├── resources</span><br><span class="line">        │   └── springMVC.xml</span><br><span class="line">        └── webapp</span><br><span class="line">            └── WEB-INF</span><br><span class="line">                ├── templates</span><br><span class="line">                │   ├── employee_list.html</span><br><span class="line">                │   └── index.html</span><br><span class="line">                └── web.xml</span><br></pre></td></tr></table></figure><p><code>springMVC.xml</code> 与 <code>web.xml</code> 与之前的设置类似，其他文件如下。</p><p><code>Employee.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukiyama.rest.beans;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="keyword">private</span> Integer gender; <span class="comment">// 1 male, 0 female</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(Integer id, String lastName, String email, Integer gender)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.lastName = lastName;</span><br><span class="line">        <span class="built_in">this</span>.email = email;</span><br><span class="line">        <span class="built_in">this</span>.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getLastName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> lastName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLastName</span><span class="params">(String lastName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.lastName = lastName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getEmail</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEmail</span><span class="params">(String email)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.email = email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getGender</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setGender</span><span class="params">(Integer gender)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>EmployeeController.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukiyama.rest.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.yukiyama.rest.beans.Employee;</span><br><span class="line"><span class="keyword">import</span> com.yukiyama.rest.dao.EmployeeDao;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.ui.Model;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMethod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmployeeController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> EmployeeDao employeeDao;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>EmployeeDao.java</code></p><p>并不实际连接数据库，而是以静态数据模拟。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukiyama.rest.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.yukiyama.rest.beans.Employee;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmployeeDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Integer, Employee&gt; employees = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        employees = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Employee&gt;();</span><br><span class="line"></span><br><span class="line">        employees.put(<span class="number">1001</span>, <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1001</span>, <span class="string">&quot;E-AA&quot;</span>, <span class="string">&quot;aa@163.com&quot;</span>, <span class="number">1</span>));</span><br><span class="line">        employees.put(<span class="number">1002</span>, <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1002</span>, <span class="string">&quot;E-BB&quot;</span>, <span class="string">&quot;bb@163.com&quot;</span>, <span class="number">1</span>));</span><br><span class="line">        employees.put(<span class="number">1003</span>, <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1003</span>, <span class="string">&quot;E-CC&quot;</span>, <span class="string">&quot;cc@163.com&quot;</span>, <span class="number">0</span>));</span><br><span class="line">        employees.put(<span class="number">1004</span>, <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1004</span>, <span class="string">&quot;E-DD&quot;</span>, <span class="string">&quot;dd@163.com&quot;</span>, <span class="number">0</span>));</span><br><span class="line">        employees.put(<span class="number">1005</span>, <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1005</span>, <span class="string">&quot;E-EE&quot;</span>, <span class="string">&quot;ee@163.com&quot;</span>, <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Integer</span> <span class="variable">initId</span> <span class="operator">=</span> <span class="number">1006</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(Employee employee)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(employee.getId() == <span class="literal">null</span>)&#123;</span><br><span class="line">            employee.setId(initId++);</span><br><span class="line">        &#125;</span><br><span class="line">        employees.put(employee.getId(), employee);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;Employee&gt; <span class="title function_">getAll</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> employees.values();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Employee <span class="title function_">get</span><span class="params">(Integer id)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> employees.get(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Integer id)</span>&#123;</span><br><span class="line">        employees.remove(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>index.html</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>本案例将实现如下功能。</p><table><thead><tr><th>功能</th><th>URL 地址</th><th>请求方式</th></tr></thead><tbody><tr><td>访问首页</td><td>&#x2F;</td><td>GET</td></tr><tr><td>查询全部数据</td><td>&#x2F;employee</td><td>GET</td></tr><tr><td>删除</td><td>&#x2F;employee&#x2F;2</td><td>DELETE</td></tr><tr><td>跳转到添加数据页面</td><td>&#x2F;toAdd</td><td>GET</td></tr><tr><td>执行保存</td><td>&#x2F;employee</td><td>POST</td></tr><tr><td>跳转到更新数据页面</td><td>&#x2F;employee&#x2F;2</td><td>GET</td></tr><tr><td>执行更新</td><td>&#x2F;employee</td><td>PUT</td></tr></tbody></table><br /><h4 id="查询所有"><a href="#查询所有" class="headerlink" title="查询所有"></a>查询所有</h4><p>在 <code>EmployeeController</code> 控制器中添加如下方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/employee&quot;, method = RequestMethod.GET)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getAllEmployee</span><span class="params">(Model model)</span>&#123;</span><br><span class="line">    Collection&lt;Employee&gt; employeeList = employeeDao.getAll();</span><br><span class="line">    model.addAttribute(<span class="string">&quot;employeeList&quot;</span>, employeeList);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;employee_list&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新增显示所有员工信息的页面 <code>employee_list.html</code> ，如下。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Employee List<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span> <span class="attr">cellspacing</span>=<span class="string">&quot;0&quot;</span> <span class="attr">cellpadding</span>=<span class="string">&quot;0&quot;</span> <span class="attr">style</span>=<span class="string">&quot;text-align: center&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">th</span> <span class="attr">colspan</span>=<span class="string">&quot;5&quot;</span>&gt;</span>Employee List<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">th</span>&gt;</span>id<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">th</span>&gt;</span>lastName<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">th</span>&gt;</span>email<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">th</span>&gt;</span>gender<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">th</span>&gt;</span>options<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">tr</span> <span class="attr">th:each</span>=<span class="string">&quot;employee : $&#123;employeeList&#125;&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;employee.id&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;employee.lastName&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;employee.email&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;employee.gender&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;delete&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;update&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 <code>index.html</code> 中添加跳转到 <code>employee_list.html</code> 页面的超链接。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/employee&#125;&quot;</span>&gt;</span>查看员工信息<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>将该子工程部署到 Tomcat 中，运行该子工程，打开「首页」后，点击链接可以看到员工信息表。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/springmvc_in_action/rest-all.png" alt="rest-all"></p><br /><h4 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h4><p>删除操作超链接绑定点击事件，通过点击删除操作超链接完成删除。如下是在 <code>employee_list.html</code> 中添加的内容。</p><p>引入 vue.js</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">th:src</span>=<span class="string">&quot;@&#123;/static/js/vue.js&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>删除操作超链接</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> @<span class="attr">click</span>=<span class="string">&quot;deleteEmployee&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;&#x27;/employee/&#x27;+$&#123;employee.id&#125;&#125;&quot;</span>&gt;</span>delete<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过 vue 处理点击事件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> vue = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>:<span class="string">&quot;#dataTable&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">methods</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">deleteEmployee</span>:<span class="keyword">function</span> (<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">//根据id获取表单元素</span></span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">var</span> deleteForm = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;deleteForm&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">//将触发点击事件的超链接的href属性赋值给表单的action</span></span></span><br><span class="line"><span class="language-javascript">                deleteForm.<span class="property">action</span> = event.<span class="property">target</span>.<span class="property">href</span>;</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">//提交表单</span></span></span><br><span class="line"><span class="language-javascript">                deleteForm.<span class="title function_">submit</span>();</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">//取消超链接的默认行为</span></span></span><br><span class="line"><span class="language-javascript">                event.<span class="title function_">preventDefault</span>();</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 <code>EmployeeController</code> 控制器中添加如下方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/employee/&#123;id&#125;&quot;, method = RequestMethod.DELETE)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">deleteEmployee</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span>&#123;</span><br><span class="line">    employeeDao.delete(id);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/employee&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行工程，可以通过点击 delete 超链接删除相应的员工信息。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/springmvc_in_action/rest-delete.png" alt="rest-delete"></p><br /><h4 id="添加-1"><a href="#添加-1" class="headerlink" title="添加"></a>添加</h4><p>新建添加用户信息页面 <code>employee_add.html</code> 。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>add employee<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/employee&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">  lastName: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;lastName&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  email: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  gender: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span>male</span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0&quot;</span>&gt;</span>female<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;add&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 <code>employee_list.html</code> 中添加 toAdd 超链接。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">th</span>&gt;</span>options（<span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/toAdd&#125;&quot;</span>&gt;</span>add<span class="tag">&lt;/<span class="name">a</span>&gt;</span>）<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 <code>springMVC.xml</code> 中添加如下视图控制器。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:view-controller</span> <span class="attr">path</span>=<span class="string">&quot;/toAdd&quot;</span> <span class="attr">view-name</span>=<span class="string">&quot;employee_add&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mvc:view-controller</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 <code>EmployeeController</code> 控制器中添加如下方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/employee&quot;, method = RequestMethod.POST)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">addEmployee</span><span class="params">(Employee employee)</span>&#123;</span><br><span class="line">    employeeDao.save(employee);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/employee&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行工程，如下，可以通过 options 后的 add 超链接跳转到添加用户的页面，可成功添加。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/springmvc_in_action/rest-add.png" alt="rest-add"></p><br /><h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4><p>新建更新用户信息页面 <code>employee_update.html</code> 。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>update employee<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/employee&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;_method&quot;</span> <span class="attr">value</span>=<span class="string">&quot;put&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;$&#123;employee.id&#125;&quot;</span>&gt;</span></span><br><span class="line">  lastName: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;lastName&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;$&#123;employee.lastName&#125;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  email: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;$&#123;employee.email&#125;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  gender: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span> <span class="attr">th:field</span>=<span class="string">&quot;$&#123;employee.gender&#125;&quot;</span>&gt;</span>male</span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0&quot;</span> <span class="attr">th:field</span>=<span class="string">&quot;$&#123;employee.gender&#125;&quot;</span>&gt;</span>female<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;update&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 <code>employee_list.html</code> 中添加 update 超链接。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;&#x27;/employee/&#x27;+$&#123;employee.id&#125;&#125;&quot;</span>&gt;</span>update<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 <code>EmployeeController</code> 控制器中添加如下方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/employee/&#123;id&#125;&quot;, method = RequestMethod.GET)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getEmployeeById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id, Model model)</span>&#123;</span><br><span class="line">    <span class="type">Employee</span> <span class="variable">employee</span> <span class="operator">=</span> employeeDao.get(id);</span><br><span class="line">    model.addAttribute(<span class="string">&quot;employee&quot;</span>, employee);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;employee_update&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行工程，如下，可以通过 update 超链接跳转到更新用户信息的页面。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/springmvc_in_action/rest-update1.png" alt="rest-update1"></p><p>接着在 <code>EmployeeController</code> 控制器中添加如下方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/employee&quot;, method = RequestMethod.PUT)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">updateEmployee</span><span class="params">(Employee employee)</span>&#123;</span><br><span class="line">    employeeDao.save(employee);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/employee&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行工程，如下，可以通过 update 超链接跳转到更新用户信息的页面，更新信息后重定向回到员工信息页面。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/springmvc_in_action/rest-update2.png" alt="rest-update2"></p><br /><h2 id="HttpMessageConverter"><a href="#HttpMessageConverter" class="headerlink" title="HttpMessageConverter"></a>HttpMessageConverter</h2><p><code>HttpMessageConverter</code>，报文信息转换器，它提供了两个注解和两个类型，可将请求报文转换为 Java 对象，或将 Java 对象转换为响应报文。</p><table><thead><tr><th>注解或类型</th><th>描述</th></tr></thead><tbody><tr><td><code>@RequestBody</code></td><td>参数注解，用以获取请求体。</td></tr><tr><td><code>RequestEntity</code></td><td>类型，用以获取请求报文。</td></tr><tr><td><code>@ResponseBody</code></td><td>注解参数，用以获取响应体。</td></tr><tr><td><code>ResponseEntity</code></td><td>类型，用以获取相应报文。</td></tr></tbody></table><p>新建 <code>springmvc-demo5</code> 子工程用于演示本节内容。该工程目录结构和主要文件内容如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">springmvc-demo5</span><br><span class="line">├── pom.xml</span><br><span class="line">└── src</span><br><span class="line">    └── main</span><br><span class="line">        ├── java</span><br><span class="line">        │   └── com</span><br><span class="line">        │       └── yukiyama</span><br><span class="line">        │           └── mvc</span><br><span class="line">        │               └── controllers</span><br><span class="line">        │                   └── HttpController.java</span><br><span class="line">        ├── resources</span><br><span class="line">        │   └── springMVC.xml</span><br><span class="line">        └── webapp</span><br><span class="line">            └── WEB-INF</span><br><span class="line">                ├── templates</span><br><span class="line">                │   ├── index.html</span><br><span class="line">                │   └── success.html</span><br><span class="line">                └── web.xml</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>HttpController</code> 控制器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukiyama.mvc.controllers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpController</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>index.html</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>success.html</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>success<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>success<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><br /><h3 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h3><p>使用 <code>@RequestBody</code> 标识控制器方法形参，当前请求的请求体就会为当前注解所标识的形参赋值。</p><p>在 <code>index.html</code> 页面中添加如下表单，确保发起请求时请求体不为空。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/testRequestBody&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;测试@RequestBody&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 <code>HttpController</code> 控制器中添加如下方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testRequestBody&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testRequestBody</span><span class="params">(<span class="meta">@RequestBody</span> String requestBody)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;requestBody = &quot;</span> + requestBody);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行工程，如下，添入内容后，控制器方法中的打印语句在控制台中打印出了 <code>requestBody = username=yukiyama&amp;password=123</code> 请求体内容。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/springmvc_in_action/requestbody.png" alt="requestbody"></p><br /><h3 id="RequestEntity"><a href="#RequestEntity" class="headerlink" title="RequestEntity"></a>RequestEntity</h3><p><code>RequestEntity</code> 封装请求报文的一种类型，在控制器方法的形参中设置该类型的形参，当前请求的请求报文就会赋值给该形参，可以通过 <code>getHeaders()</code> 获取请求头信息，通过 <code>getBody()</code> 获取请求体信息。</p><p>在 <code>index.html</code> 页面中添加如下表单，确保发起请求时请求体不为空。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/testRequestEntity&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;测试@RequestEntity&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 <code>HttpController</code> 控制器中添加如下方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testRequestEntity&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testRequestEntity</span><span class="params">(RequestEntity&lt;String&gt; requestEntity)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;requestEntity headers = &quot;</span> + requestEntity.getHeaders());</span><br><span class="line">    System.out.println(<span class="string">&quot;requestEntity body = &quot;</span> + requestEntity.getBody());</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行工程，如下。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/springmvc_in_action/requestentity.png" alt="requestentity"></p><p>控制台输出结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">requestEntity headers = [host:&quot;localhost:8080&quot;, connection:&quot;keep-alive&quot;, content-length:&quot;30&quot;, cache-control:&quot;max-age=0&quot;, sec-ch-ua:&quot;&quot;Google Chrome&quot;;v=&quot;107&quot;, &quot;Chromium&quot;;v=&quot;107&quot;, &quot;Not=A?Brand&quot;;v=&quot;24&quot;&quot;, sec-ch-ua-mobile:&quot;?0&quot;, sec-ch-ua-platform:&quot;&quot;macOS&quot;&quot;, upgrade-insecure-requests:&quot;1&quot;, origin:&quot;http://localhost:8080&quot;, user-agent:&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/107.0.0.0 Safari/537.36&quot;, accept:&quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&quot;, sec-fetch-site:&quot;same-origin&quot;, sec-fetch-mode:&quot;navigate&quot;, sec-fetch-user:&quot;?1&quot;, sec-fetch-dest:&quot;document&quot;, referer:&quot;http://localhost:8080/springmvc/&quot;, accept-encoding:&quot;gzip, deflate, br&quot;, accept-language:&quot;en,zh-CN;q=0.9,zh;q=0.8,ko-KR;q=0.7,ko;q=0.6,ja;q=0.5&quot;, cookie:&quot;Idea-a8cf3385=05276e99-fa7c-4015-b476-2565fefd4c05&quot;, Content-Type:&quot;application/x-www-form-urlencoded;charset=UTF-8&quot;]</span><br><span class="line">requestEntity body = username=yukiyama&amp;password=123</span><br></pre></td></tr></table></figure><br /><h3 id="ResponseBody"><a href="#ResponseBody" class="headerlink" title="@ResponseBody"></a>@ResponseBody</h3><p><code>@ResponseBody</code> 为方法注解，标识控制器方法，可以将该方法的返回值作为响应报文的响应体。</p><p>先给出利用 <code>HttpServletResponse</code> 的方式。</p><p>在 <code>HttpController</code> 控制器中增加如下方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;testHttpServletResponse&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testHttpServletResponse</span><span class="params">(HttpServletResponse httpServletResponse)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    httpServletResponse.getWriter().print(<span class="string">&quot;hello, HttpServletResponse&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>index.html</code> 中添加如下超链接。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/testHttpServletResponse&#125;&quot;</span>&gt;</span>测试利用 HttpServletResponse 获取响应体<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行工程，如下。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/springmvc_in_action/HttpServletResponse.png" alt="HttpServletResponse"></p><p>接着是利用  <code>@ResponseBody</code> 的方式。</p><p>在 <code>HttpController</code> 控制器中增加如下方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testResponseBody&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testResponseBody</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello, ResponseBody&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>index.html</code> 中添加如下超链接。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/testResponseBody&#125;&quot;</span>&gt;</span>测试利用 ResponseBody 获取响应体<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行工程，如下。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/springmvc_in_action/responsebody.png" alt="responsebody"></p><p>除了将 <code>String</code> 类型作为响应体，还可以直接返回 Java 对象，借助 jackson 的处理，将 Java 对象封装为 Json 对象作为响应体。</p><br /><h4 id="SpringMVC处理Json"><a href="#SpringMVC处理Json" class="headerlink" title="SpringMVC处理Json"></a>SpringMVC处理Json</h4><p>首先要引入 jackson 依赖用以处理 Json。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.12.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 <code>springMVC.xml</code> 中开启 mvc 的注解驱动，此时在 HandlerAdaptor 中会自动装配一个消息转换器：MappingJackson2HttpMessageConverter，可以将响应到浏览器的 Java 对象转换为 Json 格式的字符串。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>增加 <code>User</code> 类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukiyama.mvc.beans;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(Integer id, String username, String password, Integer age, String gender)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.username = username;</span><br><span class="line">        <span class="built_in">this</span>.password = password;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUsername</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPassword</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPassword</span><span class="params">(String password)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(Integer age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getGender</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setGender</span><span class="params">(String gender)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>HttpController</code> 控制器中增加如下方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testResponseBodyUser&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">testResponseBodyUser</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>, <span class="string">&quot;yukiyama&quot;</span>, <span class="string">&quot;123&quot;</span>, <span class="number">20</span>, <span class="string">&quot;male&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>index.html</code> 中添加如下超链接。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/testResponseBodyUser&#125;&quot;</span>&gt;</span>测试利用 ResponseBody 获取响应体 (以 Java 对象为响应体)<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行工程，如下。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/springmvc_in_action/responsebodyBean.png" alt="responsebodyBean"></p><br /><h4 id="SpringMVC处理ajax"><a href="#SpringMVC处理ajax" class="headerlink" title="SpringMVC处理ajax"></a>SpringMVC处理ajax</h4><p>引入 <code>vue.js</code> 以及 <code>axios.min.js</code> 文件，在 <code>index.html</code> 中添加如下内容。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/testAjax&#125;&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;testAjax&quot;</span>&gt;</span>testAjax<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">th:src</span>=<span class="string">&quot;@&#123;/static/js/vue.js&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">th:src</span>=<span class="string">&quot;@&#123;/static/js/axios.min.js&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> vue = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>:<span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">methods</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">testAjax</span>:<span class="keyword">function</span> (<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">axios</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">method</span>:<span class="string">&quot;post&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">url</span>:event.<span class="property">target</span>.<span class="property">href</span>,</span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">params</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">                        <span class="attr">username</span>:<span class="string">&quot;admin&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">                        <span class="attr">password</span>:<span class="string">&quot;123456&quot;</span></span></span><br><span class="line"><span class="language-javascript">                    &#125;</span></span><br><span class="line"><span class="language-javascript">                &#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="title function_">alert</span>(response.<span class="property">data</span>);</span></span><br><span class="line"><span class="language-javascript">                &#125;);</span></span><br><span class="line"><span class="language-javascript">                event.<span class="title function_">preventDefault</span>();</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 <code>HttpController</code> 控制器中添加如下方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testAxios&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testAxios</span><span class="params">(String usename, String password)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;usename = &quot;</span> + usename + <span class="string">&quot;, password&quot;</span> + password);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello, axios&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h4 id="RestController注解"><a href="#RestController注解" class="headerlink" title="@RestController注解"></a>@RestController注解</h4><p><code>@RestController</code> 注解是 springMVC 提供的复合注解，标识在控制器的类上，就相当于为类添加了<code>@Controller</code> 注解，并且为其中的每个方法添加@<code>ResponseBody</code> 注解。</p><br /><h3 id="ResponseEntity"><a href="#ResponseEntity" class="headerlink" title="ResponseEntity"></a>ResponseEntity</h3><p><code>ResponseEntity</code> 用于控制器方法的返回值类型，该控制器方法的返回值就是响应到浏览器的响应报文。</p><p>本节仍在 <code>springmvc-demo5</code> 工程中演示利用 <code>ResponseEntity</code> 实现文件上传下载功能。</p><p>新建 <code>FileUpDownController</code> 控制器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukiyama.mvc.controllers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileUpDownController</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建 <code>file.html</code> 页面用于测试上传下载功能。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>测试文件上传和下载<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>file<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><br /><h4 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h4><p>使用 <code>ResponseEntity</code> 实现下载文件的功能。</p><p>在 <code>springMVC.xml</code> 文件中添加如下视图控制器。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:view-controller</span> <span class="attr">path</span>=<span class="string">&quot;/file&quot;</span> <span class="attr">view-name</span>=<span class="string">&quot;file&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mvc:view-controller</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 <code>FileUpDownController</code> 控制器中添加如下方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testDown&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;<span class="type">byte</span>[]&gt; testResponseEntity(HttpSession session) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//获取ServletContext对象</span></span><br><span class="line">    <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> session.getServletContext();</span><br><span class="line">    <span class="comment">//获取服务器中文件的真实路径</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">realPath</span> <span class="operator">=</span> servletContext.getRealPath(<span class="string">&quot;/static/img/1.jpg&quot;</span>);</span><br><span class="line">    <span class="comment">//创建输入流</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(realPath);</span><br><span class="line">    <span class="comment">//创建字节数组</span></span><br><span class="line">    <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[is.available()];</span><br><span class="line">    <span class="comment">//将流读到字节数组中</span></span><br><span class="line">    is.read(bytes);</span><br><span class="line">    <span class="comment">//创建HttpHeaders对象设置响应头信息</span></span><br><span class="line">    MultiValueMap&lt;String, String&gt; headers = <span class="keyword">new</span> <span class="title class_">HttpHeaders</span>();</span><br><span class="line">    <span class="comment">//设置要下载方式以及下载文件的名字</span></span><br><span class="line">    headers.add(<span class="string">&quot;Content-Disposition&quot;</span>, <span class="string">&quot;attachment;filename=1.jpg&quot;</span>);</span><br><span class="line">    <span class="comment">//设置响应状态码</span></span><br><span class="line">    <span class="type">HttpStatus</span> <span class="variable">statusCode</span> <span class="operator">=</span> HttpStatus.OK;</span><br><span class="line">    <span class="comment">//创建ResponseEntity对象</span></span><br><span class="line">    ResponseEntity&lt;<span class="type">byte</span>[]&gt; responseEntity = <span class="keyword">new</span> <span class="title class_">ResponseEntity</span>&lt;&gt;(bytes, headers, statusCode);</span><br><span class="line">    <span class="comment">//关闭输入流</span></span><br><span class="line">    is.close();</span><br><span class="line">    <span class="keyword">return</span> responseEntity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>file.html</code> 中添加如下超链接。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/testDown&#125;&quot;</span>&gt;</span>下载 doraemon.png<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 工程的 <code>webapp/static/img</code> 路径下存有 doraemon.png 文件。</p><p>运行工程，点击链接后可下载图片。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/springmvc_in_action/download.png" alt="download"></p><br /><h4 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h4><p>文件上传要通过 form 表单，请求方式必须为 POST，并且需要添加属性 <code>enctype=&quot;multipart/form-data&quot;</code> 。</p><p>SpringMVC 中将上传的文件封装到 <code>MultipartFile</code> 对象中，通过此对象可以获取文件相关信息。</p><p>上传需要用到 <code>commons-fileupload</code> 依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 <code>SpringMVC.xml</code> 中添加 <code>multipartResolver</code> bean。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--必须通过文件解析器的解析才能将文件转换为MultipartFile对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;multipartResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 <code>FileUpDownController</code> 控制器中添加如下方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testUp&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testUp</span><span class="params">(MultipartFile photo, HttpSession session)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//获取上传的文件的文件名</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> photo.getOriginalFilename();</span><br><span class="line">    <span class="comment">//获取服务器中photo目录的路径</span></span><br><span class="line">    <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> session.getServletContext();</span><br><span class="line">    <span class="type">String</span> <span class="variable">photoPath</span> <span class="operator">=</span> servletContext.getRealPath(<span class="string">&quot;photo&quot;</span>);</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(photoPath);</span><br><span class="line">    <span class="keyword">if</span>(!file.exists())&#123;</span><br><span class="line">        file.mkdir();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">finalPath</span> <span class="operator">=</span> photoPath + File.separator + fileName;</span><br><span class="line">    <span class="comment">//实现上传功能</span></span><br><span class="line">    photo.transferTo(<span class="keyword">new</span> <span class="title class_">File</span>(finalPath));</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>file.html</code> 页面中添加如下表单。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/testUp&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span></span><br><span class="line">    文件上传：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;photo&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;上传&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行工程，可成功上传文件。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/springmvc_in_action/upload.png" alt="upload"></p><p>此外，对于同名文件，还可以在控制器方法中加入 UUID 生成语句来支持上传同名文件 (上传到服务器后文件名为 UUID) 。</p><p>支持同名文件上传的 <code>testUp</code>  方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testUp&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testUp</span><span class="params">(MultipartFile photo, HttpSession session)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//获取上传的文件的文件名</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> photo.getOriginalFilename();</span><br><span class="line">    <span class="comment">//处理文件重名问题</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">hzName</span> <span class="operator">=</span> fileName.substring(fileName.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">    fileName = UUID.randomUUID().toString() + hzName;</span><br><span class="line">    <span class="comment">//获取服务器中photo目录的路径</span></span><br><span class="line">    <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> session.getServletContext();</span><br><span class="line">    <span class="type">String</span> <span class="variable">photoPath</span> <span class="operator">=</span> servletContext.getRealPath(<span class="string">&quot;photo&quot;</span>);</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(photoPath);</span><br><span class="line">    <span class="keyword">if</span>(!file.exists())&#123;</span><br><span class="line">        file.mkdir();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">finalPath</span> <span class="operator">=</span> photoPath + File.separator + fileName;</span><br><span class="line">    <span class="comment">//实现上传功能</span></span><br><span class="line">    photo.transferTo(<span class="keyword">new</span> <span class="title class_">File</span>(finalPath));</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行工程，上传效果如下。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/springmvc_in_action/upload-uuid.png" alt="upload-uuid"></p><br /><h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><p>SpringMVC 中的拦截器用于拦截控制器方法的执行。拦截器需要实现 <code>HandlerInterceptor</code> 接口，此接口有三个 <code>default</code> 方法可供重写。</p><table><thead><tr><th>default 方法</th><th>描述</th></tr></thead><tbody><tr><td><code>default boolean preHandle</code></td><td>在控制器方法执行之前执行，返回 true 调用控制器方法，返回 false 表示不调用控制器方法。</td></tr><tr><td><code>default void postHandle</code></td><td>在控制器方法执行之后执行。</td></tr><tr><td><code>default void afterCompletion</code></td><td>在视图渲染之后执行。</td></tr></tbody></table><br /><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>创建 <code>springmvc-demo6</code> 子工程用于演示如何使用拦截器，该工程目录及文件结构如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">springmvc-demo6</span><br><span class="line">├── pom.xml</span><br><span class="line">└── src</span><br><span class="line">    └── main</span><br><span class="line">        ├── java</span><br><span class="line">        │   └── com</span><br><span class="line">        │       └── yukiyama</span><br><span class="line">        │           └── mvc</span><br><span class="line">        │               ├── controllers</span><br><span class="line">        │               │   └── TestController.java</span><br><span class="line">        │               └── interceptors</span><br><span class="line">        │                   └── FirstInterceptor.java</span><br><span class="line">        ├── resources</span><br><span class="line">        │   └── springMVC.xml</span><br><span class="line">        └── webapp</span><br><span class="line">            └── WEB-INF</span><br><span class="line">                ├── templates</span><br><span class="line">                │   ├── index.html</span><br><span class="line">                │   └── success.html</span><br><span class="line">                └── web.xml</span><br></pre></td></tr></table></figure><p>拦截器 <code>FirstInterceptor</code> 要实现 <code>HandlerInterceptor</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukiyama.mvc.interceptors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FirstInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在控制器方法执行之前执行</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;FirstInterceptor --&gt; preHandle&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 若为 false 则不会执行 postHandle 和 afterCompletion</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在控制器方法执行之后执行</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;FirstInterceptor --&gt; postHandle&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在视图渲染之后执行</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;FirstInterceptor --&gt; afterCompletion&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>TestController</code> 控制器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukiyama.mvc.controllers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/testInterceptor&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">testInterceptor</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>SpringMVC.xml</code> 配置拦截器，有三种方式，如下。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置拦截器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 方式一：以声明 bean 的方式引入拦截器，拦截所有请求 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;bean class=&quot;com.yukiyama.mvc.interceptors.FirstInterceptor&quot;&gt;&lt;/bean&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 方式二：以 ref 引用 bean 的方式引入拦截器，要求以类注解标识拦截器类为 bean (通常使用 @Component)，拦截所有请求 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;ref bean=&quot;firstInterceptor&quot;&gt;&lt;/ref&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 方式三：利用 &lt;mvc:interceptor&gt; 标签，可针对具体请求应用拦截器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 要拦截的请求 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/**&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 不拦截的请求 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:exclude-mapping</span> <span class="attr">path</span>=<span class="string">&quot;/&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;firstInterceptor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure><p>※ 采用方式三时， <code>&lt;mvc:mapping&gt;</code> 标签中的 <code>path=/**</code> 标签属性表示对于所有路径的请求所对应的控制器方法，都应用指定的拦截器。若 <code>path=/*</code> ，则对应所有单层的路径的请求。</p><p><code>index.html</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thyemleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>success<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/testInterceptor&#125;&quot;</span>&gt;</span>测试拦截器<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行工程，如下。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/springmvc_in_action/interceptor.png" alt="interceptor"></p><br /><h3 id="多个拦截器"><a href="#多个拦截器" class="headerlink" title="多个拦截器"></a>多个拦截器</h3><p>若每个拦截器的 <code>preHandle()</code> 都返回 true，此时多个拦截器的执行顺序和拦截器在 SpringMVC 的配置文件的配置顺序有关。<code>preHandle()</code> 会按照配置的顺序执行，而 <code>postHandle()</code> 和 <code>afterComplation()</code> 会按照配置的反序执行。</p><p>若某个拦截器的 <code>preHandle()</code> 返回了 false，它及之前的拦截器的 <code>preHandle()</code> 都会执行，<code>postHandle()</code> 都不执行，返回 false 的拦截器之前的拦截器的<code>afterComplation()</code> 会执行。</p><br /><h2 id="异常处理器"><a href="#异常处理器" class="headerlink" title="异常处理器"></a>异常处理器</h2><p><code>HandlerExceptionResolver</code> 是 SpringMVC 提供的处理控制器方法执行过程中所出现的异常的接口，其实现类有 <code>DefaultHandlerExceptionResolver</code> 和 <code>SimpleMappingExceptionResolver</code> ，后者可自定义。</p><p>可基于配置或基于注解使用异常解析器。</p><br /><h3 id="基于配置"><a href="#基于配置" class="headerlink" title="基于配置"></a>基于配置</h3><p>按如下方式在 <code>springMVC.xml</code> 中自定义，如下。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;exceptionMappings&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        properties的键表示处理器方法执行过程中出现的异常</span></span><br><span class="line"><span class="comment">        properties的值表示若出现指定异常时，设置一个新的视图名称，跳转到指定页面</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;java.lang.ArithmeticException&quot;</span>&gt;</span>error<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    exceptionAttribute属性设置一个属性名，将出现的异常信息在请求域中进行共享</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;exceptionAttribute&quot;</span> <span class="attr">value</span>=<span class="string">&quot;ex&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>仍在 <code>springmvc-demo6</code> 中演示异常解析器的使用。</p><p>新建 <code>error.html</code> ，发生指定异常时跳转到该页面。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thyemleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>异常页面<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">出现异常</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;ex&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 <code>index.html</code> 中添加如下超链接。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/testExceptionHandler&#125;&quot;</span>&gt;</span>测试异常处理<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 <code>TestController</code> 控制器中添加如下方法，其中 <code>10/0</code> 用于模拟算术异常 <code>java.lang.ArithmeticException</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testExceptionHandler&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testExceptionHandler</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="number">1</span>/<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行工程，点击「测试异常处理」链接，如下。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/springmvc_in_action/exception.png" alt="exception"></p><br /><h3 id="基于注解"><a href="#基于注解" class="headerlink" title="基于注解"></a>基于注解</h3><p>新建如下 <code>MyExceptionHandler</code> 异常处理器，以 <code>@ControllerActive</code> 类注解标识，异常处理器中以 <code>@ExceptionHandler</code> 标识处理器方法。<code>Excetion ex</code> 为捕获的异常，将其写入 <code>model</code> 中的请求域中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukiyama.mvc.exceptionHandlers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.ui.Model;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ControllerAdvice;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ExceptionHandler;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyExceptionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">testException</span><span class="params">(Exception ex, Model model)</span>&#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;ex&quot;</span>, ex);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;error&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行工程，效果与「基于配置」的方式相同。</p><br /><h2 id="注解方式的SpringMVC"><a href="#注解方式的SpringMVC" class="headerlink" title="注解方式的SpringMVC"></a>注解方式的SpringMVC</h2><p>目前为止 SpirngMVC 各功能的均基于 xml 配置文件实现，实际开发场景中常使用配置类和注解代替配置文件 (包括 <code>SpringMVC.xml</code> 及 <code>web.xml</code>) 。</p><br /><h3 id="web-xml配置类"><a href="#web-xml配置类" class="headerlink" title="web.xml配置类"></a>web.xml配置类</h3><p>在 Servlet 3.0 环境中，容器会在类路径中查找实现 javax.servlet.ServletContainerInitializer 接口的类，如果找到的话就用它来配置 servlet 容器。Spring 提供了这个接口的实现，名为 <code>SpringServletContainerInitializer</code> ，这个类反过来又会查找实现 <code>WebApplicationInitializer</code> 的类并将配置的任务交给它们来完成。</p><p>Spring3.2 引入了一个便利的 <code>WebApplicationInitializer</code> 基础实现，名为 <code>AbstractAnnotationConfigDispatcherServletInitializer</code> ，当我们的类继承了 <code>AbstractAnnotationConfigDispatcherServletInitializer</code> 并将其部署到 Servlet 3.0 容器的时候，容器会自动发现它，并用它来配置 Servlet 上下文。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukiyama.mvc.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.filter.CharacterEncodingFilter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.filter.HiddenHttpMethodFilter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.Filter;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代替 web.xml</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebInit</span> <span class="keyword">extends</span> <span class="title class_">AbstractAnnotationConfigDispatcherServletInitializer</span> &#123;</span><br><span class="line">    <span class="comment">// 指定spring的配置类</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;SpringConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 指定SpringMVC的配置类</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;WebConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 指定 DispatcherServlet 的映射规则，即 url-pattern</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;/&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 配置过滤器</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Filter[] getServletFilters() &#123;</span><br><span class="line">        <span class="type">CharacterEncodingFilter</span> <span class="variable">encodingFilter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CharacterEncodingFilter</span>();</span><br><span class="line">        encodingFilter.setEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        encodingFilter.setForceRequestEncoding(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">HiddenHttpMethodFilter</span> <span class="variable">hiddenHttpMethodFilter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HiddenHttpMethodFilter</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Filter</span>[]&#123;encodingFilter, hiddenHttpMethodFilter&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h3 id="Spring配置类"><a href="#Spring配置类" class="headerlink" title="Spring配置类"></a>Spring配置类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ssm 整合之后，spring 的配置信息写在此类中</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h3 id="SpringMVC配置类"><a href="#SpringMVC配置类" class="headerlink" title="SpringMVC配置类"></a>SpringMVC配置类</h3><p>代替 <code>SpringMVC.xml</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukiyama.mvc.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.yukiyama.mvc.interceptors.FirstInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.context.ContextLoader;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.context.WebApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.multipart.commons.CommonsMultipartResolver;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerExceptionResolver;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ViewResolver;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.handler.SimpleMappingExceptionResolver;</span><br><span class="line"><span class="keyword">import</span> org.thymeleaf.spring5.SpringTemplateEngine;</span><br><span class="line"><span class="keyword">import</span> org.thymeleaf.spring5.view.ThymeleafViewResolver;</span><br><span class="line"><span class="keyword">import</span> org.thymeleaf.templatemode.TemplateMode;</span><br><span class="line"><span class="keyword">import</span> org.thymeleaf.templateresolver.ITemplateResolver;</span><br><span class="line"><span class="keyword">import</span> org.thymeleaf.templateresolver.ServletContextTemplateResolver;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代替 SpringMVC.xml</span></span><br><span class="line"><span class="comment"> * 1. 扫描组建</span></span><br><span class="line"><span class="comment"> * 2. 视图解析器</span></span><br><span class="line"><span class="comment"> * 3. view-controller</span></span><br><span class="line"><span class="comment"> * 4. default-servlet-handler</span></span><br><span class="line"><span class="comment"> * 5. mvc 注解驱动</span></span><br><span class="line"><span class="comment"> * 6. 文件上传解析器</span></span><br><span class="line"><span class="comment"> * 7. 异常处理</span></span><br><span class="line"><span class="comment"> * 8. 拦截器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//扫描组件</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.yukiyama.mvc.controllers&quot;)</span></span><br><span class="line"><span class="comment">//开启MVC注解驱动</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用默认的servlet处理静态资源</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureDefaultServletHandling</span><span class="params">(DefaultServletHandlerConfigurer configurer)</span> &#123;</span><br><span class="line">        configurer.enable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置文件上传解析器</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CommonsMultipartResolver <span class="title function_">multipartResolver</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CommonsMultipartResolver</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置拦截器</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        <span class="type">FirstInterceptor</span> <span class="variable">firstInterceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FirstInterceptor</span>();</span><br><span class="line">        registry.addInterceptor(firstInterceptor).addPathPatterns(<span class="string">&quot;/**&quot;</span>);</span><br><span class="line"><span class="comment">//        registry.addInterceptor(firstInterceptor).addPathPatterns(&quot;/**&quot;).excludePathPatterns(&quot;/&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置视图控制</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span> &#123;</span><br><span class="line">        registry.addViewController(<span class="string">&quot;/&quot;</span>).setViewName(<span class="string">&quot;index&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置异常映射</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureHandlerExceptionResolvers</span><span class="params">(List&lt;HandlerExceptionResolver&gt; resolvers)</span> &#123;</span><br><span class="line">        <span class="type">SimpleMappingExceptionResolver</span> <span class="variable">exceptionResolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleMappingExceptionResolver</span>();</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">prop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        prop.setProperty(<span class="string">&quot;java.lang.ArithmeticException&quot;</span>, <span class="string">&quot;error&quot;</span>);</span><br><span class="line">        <span class="comment">//设置异常映射</span></span><br><span class="line">        exceptionResolver.setExceptionMappings(prop);</span><br><span class="line">        <span class="comment">//设置共享异常信息的键</span></span><br><span class="line">        exceptionResolver.setExceptionAttribute(<span class="string">&quot;ex&quot;</span>);</span><br><span class="line">        resolvers.add(exceptionResolver);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置生成模板解析器</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ITemplateResolver <span class="title function_">templateResolver</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">WebApplicationContext</span> <span class="variable">webApplicationContext</span> <span class="operator">=</span> ContextLoader.getCurrentWebApplicationContext();</span><br><span class="line">        <span class="comment">// ServletContextTemplateResolver需要一个ServletContext作为构造参数，可通过WebApplicationContext 的方法获得</span></span><br><span class="line">        <span class="type">ServletContextTemplateResolver</span> <span class="variable">templateResolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletContextTemplateResolver</span>(</span><br><span class="line">                webApplicationContext.getServletContext());</span><br><span class="line">        templateResolver.setPrefix(<span class="string">&quot;/WEB-INF/templates/&quot;</span>);</span><br><span class="line">        templateResolver.setSuffix(<span class="string">&quot;.html&quot;</span>);</span><br><span class="line">        templateResolver.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        templateResolver.setTemplateMode(TemplateMode.HTML);</span><br><span class="line">        <span class="keyword">return</span> templateResolver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成模板引擎并为模板引擎注入模板解析器</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SpringTemplateEngine <span class="title function_">templateEngine</span><span class="params">(ITemplateResolver templateResolver)</span> &#123;</span><br><span class="line">        <span class="type">SpringTemplateEngine</span> <span class="variable">templateEngine</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpringTemplateEngine</span>();</span><br><span class="line">        templateEngine.setTemplateResolver(templateResolver);</span><br><span class="line">        <span class="keyword">return</span> templateEngine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成视图解析器并未解析器注入模板引擎</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ViewResolver <span class="title function_">viewResolver</span><span class="params">(SpringTemplateEngine templateEngine)</span> &#123;</span><br><span class="line">        <span class="type">ThymeleafViewResolver</span> <span class="variable">viewResolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThymeleafViewResolver</span>();</span><br><span class="line">        viewResolver.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        viewResolver.setTemplateEngine(templateEngine);</span><br><span class="line">        <span class="keyword">return</span> viewResolver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h2 id="SpringMVC总结"><a href="#SpringMVC总结" class="headerlink" title="SpringMVC总结"></a>SpringMVC总结</h2><h3 id="SpringMVC常用组件"><a href="#SpringMVC常用组件" class="headerlink" title="SpringMVC常用组件"></a>SpringMVC常用组件</h3><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>DispatcherServlet</td><td><strong>前端控制器</strong>，框架提供。统一处理请求和响应，整个流程控制的中心，由它调用其它组件处理用户的请求。</td></tr><tr><td>HandlerMapping</td><td><strong>处理器映射器</strong>，框架提供。根据请求的 url、method 等信息查找相应的控制器方法。</td></tr><tr><td>Handler (Controller)</td><td><strong>处理器</strong>，工程师开发。在 DispatcherServlet 的控制下 Handler 处理具体请求。</td></tr><tr><td>HandlerAdapter</td><td><strong>处理器适配器</strong>，框架提供。通过 HandlerAdapter 执行控制器方法。</td></tr><tr><td>ViewResolver</td><td><strong>视图解析器</strong>，框架提供。进行视图解析，得到相应的视图，例如：ThymeleafView、InternalResourceView、RedirectView。</td></tr><tr><td>View</td><td><strong>视图</strong>，框架提供，具体页面由工程师编写。将模型数据通过页面展示给用户。</td></tr></tbody></table><br /><h3 id="DispatcherServlet初始化过程"><a href="#DispatcherServlet初始化过程" class="headerlink" title="DispatcherServlet初始化过程"></a>DispatcherServlet初始化过程</h3><p><code>DispatcherServlet</code> 通过若干层继承和实现，实现了 <code>Servlet</code> 接口，因此遵循 Servlet 的生命周期。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/springmvc_in_action/DispatcherServlet-diagram.png" alt="DispatcherServlet-diagram"></p><br /><h4 id="初始化WebApplicationContext"><a href="#初始化WebApplicationContext" class="headerlink" title="初始化WebApplicationContext"></a>初始化WebApplicationContext</h4><p>所在类：org.springframework.web.servlet.FrameworkServlet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> WebApplicationContext <span class="title function_">initWebApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">WebApplicationContext</span> <span class="variable">rootContext</span> <span class="operator">=</span></span><br><span class="line">        WebApplicationContextUtils.getWebApplicationContext(getServletContext());</span><br><span class="line">    <span class="type">WebApplicationContext</span> <span class="variable">wac</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.webApplicationContext != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// A context instance was injected at construction time -&gt; use it</span></span><br><span class="line">        wac = <span class="built_in">this</span>.webApplicationContext;</span><br><span class="line">        <span class="keyword">if</span> (wac <span class="keyword">instanceof</span> ConfigurableWebApplicationContext) &#123;</span><br><span class="line">            <span class="type">ConfigurableWebApplicationContext</span> <span class="variable">cwac</span> <span class="operator">=</span> (ConfigurableWebApplicationContext) wac;</span><br><span class="line">            <span class="keyword">if</span> (!cwac.isActive()) &#123;</span><br><span class="line">                <span class="comment">// The context has not yet been refreshed -&gt; provide services such as</span></span><br><span class="line">                <span class="comment">// setting the parent context, setting the application context id, etc</span></span><br><span class="line">                <span class="keyword">if</span> (cwac.getParent() == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// The context instance was injected without an explicit parent -&gt; set</span></span><br><span class="line">                    <span class="comment">// the root application context (if any; may be null) as the parent</span></span><br><span class="line">                    cwac.setParent(rootContext);</span><br><span class="line">                &#125;</span><br><span class="line">                configureAndRefreshWebApplicationContext(cwac);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (wac == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// No context instance was injected at construction time -&gt; see if one</span></span><br><span class="line">        <span class="comment">// has been registered in the servlet context. If one exists, it is assumed</span></span><br><span class="line">        <span class="comment">// that the parent context (if any) has already been set and that the</span></span><br><span class="line">        <span class="comment">// user has performed any initialization such as setting the context id</span></span><br><span class="line">        wac = findWebApplicationContext();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (wac == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// No context instance is defined for this servlet -&gt; create a local one</span></span><br><span class="line">        <span class="comment">// 创建WebApplicationContext</span></span><br><span class="line">        wac = createWebApplicationContext(rootContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.refreshEventReceived) &#123;</span><br><span class="line">        <span class="comment">// Either the context is not a ConfigurableApplicationContext with refresh</span></span><br><span class="line">        <span class="comment">// support or the context injected at construction time had already been</span></span><br><span class="line">        <span class="comment">// refreshed -&gt; trigger initial onRefresh manually here.</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>.onRefreshMonitor) &#123;</span><br><span class="line">            <span class="comment">// 刷新WebApplicationContext</span></span><br><span class="line">            onRefresh(wac);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.publishContext) &#123;</span><br><span class="line">        <span class="comment">// Publish the context as a servlet context attribute.</span></span><br><span class="line">        <span class="comment">// 将IOC容器在应用域共享</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">attrName</span> <span class="operator">=</span> getServletContextAttributeName();</span><br><span class="line">        getServletContext().setAttribute(attrName, wac);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wac;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h4 id="创建WebApplicationContext"><a href="#创建WebApplicationContext" class="headerlink" title="创建WebApplicationContext"></a>创建WebApplicationContext</h4><p>所在类：org.springframework.web.servlet.FrameworkServlet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> WebApplicationContext <span class="title function_">createWebApplicationContext</span><span class="params">(<span class="meta">@Nullable</span> ApplicationContext parent)</span> &#123;</span><br><span class="line">    Class&lt;?&gt; contextClass = getContextClass();</span><br><span class="line">    <span class="keyword">if</span> (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ApplicationContextException</span>(</span><br><span class="line">            <span class="string">&quot;Fatal initialization error in servlet with name &#x27;&quot;</span> + getServletName() +</span><br><span class="line">            <span class="string">&quot;&#x27;: custom WebApplicationContext class [&quot;</span> + contextClass.getName() +</span><br><span class="line">            <span class="string">&quot;] is not of type ConfigurableWebApplicationContext&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过反射创建 IOC 容器对象</span></span><br><span class="line">    <span class="type">ConfigurableWebApplicationContext</span> <span class="variable">wac</span> <span class="operator">=</span></span><br><span class="line">        (ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);</span><br><span class="line"></span><br><span class="line">    wac.setEnvironment(getEnvironment());</span><br><span class="line">    <span class="comment">// 设置父容器</span></span><br><span class="line">    wac.setParent(parent);</span><br><span class="line">    <span class="type">String</span> <span class="variable">configLocation</span> <span class="operator">=</span> getContextConfigLocation();</span><br><span class="line">    <span class="keyword">if</span> (configLocation != <span class="literal">null</span>) &#123;</span><br><span class="line">        wac.setConfigLocation(configLocation);</span><br><span class="line">    &#125;</span><br><span class="line">    configureAndRefreshWebApplicationContext(wac);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wac;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h4 id="DispatcherServlet初始化策略"><a href="#DispatcherServlet初始化策略" class="headerlink" title="DispatcherServlet初始化策略"></a>DispatcherServlet初始化策略</h4><p><code>FrameworkServlet</code> 创建 <code>WebApplicationContext</code> 后，刷新容器，调用 <code>onRefresh(wac)</code> ，此方法在 <code>DispatcherServlet</code> 中重写，调用了<code>initStrategies(context)</code> 方法，初始化策略，即初始化 <code>DispatcherServlet</code> 的各个组件。</p><p>所在类：org.springframework.web.servlet.DispatcherServlet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initStrategies</span><span class="params">(ApplicationContext context)</span> &#123;</span><br><span class="line">   initMultipartResolver(context);</span><br><span class="line">   initLocaleResolver(context);</span><br><span class="line">   initThemeResolver(context);</span><br><span class="line">   initHandlerMappings(context);</span><br><span class="line">   initHandlerAdapters(context);</span><br><span class="line">   initHandlerExceptionResolvers(context);</span><br><span class="line">   initRequestToViewNameTranslator(context);</span><br><span class="line">   initViewResolvers(context);</span><br><span class="line">   initFlashMapManager(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h3 id="DispatcherServlet处理请求"><a href="#DispatcherServlet处理请求" class="headerlink" title="DispatcherServlet处理请求"></a>DispatcherServlet处理请求</h3><h4 id="processRequest"><a href="#processRequest" class="headerlink" title="processRequest()"></a>processRequest()</h4><p><code>FrameworkServlet</code> 重写 <code>HttpServlet</code> 中的 <code>service()</code> 和 <code>doXxx()</code> ，这些方法中调用了<code>processRequest(request, response)</code> 。</p><p>所在类：org.springframework.web.servlet.FrameworkServlet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">processRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line">    <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="type">Throwable</span> <span class="variable">failureCause</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">LocaleContext</span> <span class="variable">previousLocaleContext</span> <span class="operator">=</span> LocaleContextHolder.getLocaleContext();</span><br><span class="line">    <span class="type">LocaleContext</span> <span class="variable">localeContext</span> <span class="operator">=</span> buildLocaleContext(request);</span><br><span class="line"></span><br><span class="line">    <span class="type">RequestAttributes</span> <span class="variable">previousAttributes</span> <span class="operator">=</span> RequestContextHolder.getRequestAttributes();</span><br><span class="line">    <span class="type">ServletRequestAttributes</span> <span class="variable">requestAttributes</span> <span class="operator">=</span> buildRequestAttributes(request, response, previousAttributes);</span><br><span class="line"></span><br><span class="line">    <span class="type">WebAsyncManager</span> <span class="variable">asyncManager</span> <span class="operator">=</span> WebAsyncUtils.getAsyncManager(request);</span><br><span class="line">    asyncManager.registerCallableInterceptor(FrameworkServlet.class.getName(), <span class="keyword">new</span> <span class="title class_">RequestBindingInterceptor</span>());</span><br><span class="line"></span><br><span class="line">    initContextHolders(request, localeContext, requestAttributes);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 执行服务，doService()是一个抽象方法，在DispatcherServlet中进行了重写</span></span><br><span class="line">        doService(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (ServletException | IOException ex) &#123;</span><br><span class="line">        failureCause = ex;</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        failureCause = ex;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NestedServletException</span>(<span class="string">&quot;Request processing failed&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        resetContextHolders(request, previousLocaleContext, previousAttributes);</span><br><span class="line">        <span class="keyword">if</span> (requestAttributes != <span class="literal">null</span>) &#123;</span><br><span class="line">            requestAttributes.requestCompleted();</span><br><span class="line">        &#125;</span><br><span class="line">        logResult(request, response, failureCause, asyncManager);</span><br><span class="line">        publishRequestHandledEvent(request, response, startTime, failureCause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h4 id="doService"><a href="#doService" class="headerlink" title="doService()"></a>doService()</h4><p>所在类：org.springframework.web.servlet.DispatcherServlet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doService</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    logRequest(request);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Keep a snapshot of the request attributes in case of an include,</span></span><br><span class="line">    <span class="comment">// to be able to restore the original attributes after the include.</span></span><br><span class="line">    Map&lt;String, Object&gt; attributesSnapshot = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (WebUtils.isIncludeRequest(request)) &#123;</span><br><span class="line">        attributesSnapshot = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Enumeration&lt;?&gt; attrNames = request.getAttributeNames();</span><br><span class="line">        <span class="keyword">while</span> (attrNames.hasMoreElements()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">attrName</span> <span class="operator">=</span> (String) attrNames.nextElement();</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.cleanupAfterInclude || attrName.startsWith(DEFAULT_STRATEGIES_PREFIX)) &#123;</span><br><span class="line">                attributesSnapshot.put(attrName, request.getAttribute(attrName));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make framework objects available to handlers and view objects.</span></span><br><span class="line">    request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext());</span><br><span class="line">    request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, <span class="built_in">this</span>.localeResolver);</span><br><span class="line">    request.setAttribute(THEME_RESOLVER_ATTRIBUTE, <span class="built_in">this</span>.themeResolver);</span><br><span class="line">    request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.flashMapManager != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">FlashMap</span> <span class="variable">inputFlashMap</span> <span class="operator">=</span> <span class="built_in">this</span>.flashMapManager.retrieveAndUpdate(request, response);</span><br><span class="line">        <span class="keyword">if</span> (inputFlashMap != <span class="literal">null</span>) &#123;</span><br><span class="line">            request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap));</span><br><span class="line">        &#125;</span><br><span class="line">        request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, <span class="keyword">new</span> <span class="title class_">FlashMap</span>());</span><br><span class="line">        request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, <span class="built_in">this</span>.flashMapManager);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">RequestPath</span> <span class="variable">requestPath</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.parseRequestPath &amp;&amp; !ServletRequestPathUtils.hasParsedRequestPath(request)) &#123;</span><br><span class="line">        requestPath = ServletRequestPathUtils.parseAndCache(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 处理请求和响应</span></span><br><span class="line">        doDispatch(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123;</span><br><span class="line">            <span class="comment">// Restore the original attribute snapshot, in case of an include.</span></span><br><span class="line">            <span class="keyword">if</span> (attributesSnapshot != <span class="literal">null</span>) &#123;</span><br><span class="line">                restoreAttributesAfterInclude(request, attributesSnapshot);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (requestPath != <span class="literal">null</span>) &#123;</span><br><span class="line">            ServletRequestPathUtils.clearParsedRequestPath(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h4 id="doDispatch"><a href="#doDispatch" class="headerlink" title="doDispatch()"></a>doDispatch()</h4><p>所在类：org.springframework.web.servlet.DispatcherServlet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">HttpServletRequest</span> <span class="variable">processedRequest</span> <span class="operator">=</span> request;</span><br><span class="line">    <span class="type">HandlerExecutionChain</span> <span class="variable">mappedHandler</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">multipartRequestParsed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">WebAsyncManager</span> <span class="variable">asyncManager</span> <span class="operator">=</span> WebAsyncUtils.getAsyncManager(request);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">ModelAndView</span> <span class="variable">mv</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Exception</span> <span class="variable">dispatchException</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            processedRequest = checkMultipart(request);</span><br><span class="line">            multipartRequestParsed = (processedRequest != request);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Determine handler for the current request.</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            mappedHandler：调用链</span></span><br><span class="line"><span class="comment">                包含handler、interceptorList、interceptorIndex</span></span><br><span class="line"><span class="comment">            handler：浏览器发送的请求所匹配的控制器方法</span></span><br><span class="line"><span class="comment">            interceptorList：处理控制器方法的所有拦截器集合</span></span><br><span class="line"><span class="comment">            interceptorIndex：拦截器索引，控制拦截器afterCompletion()的执行</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            mappedHandler = getHandler(processedRequest);</span><br><span class="line">            <span class="keyword">if</span> (mappedHandler == <span class="literal">null</span>) &#123;</span><br><span class="line">                noHandlerFound(processedRequest, response);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Determine handler adapter for the current request.</span></span><br><span class="line">           <span class="comment">// 通过控制器方法创建相应的处理器适配器，调用所对应的控制器方法</span></span><br><span class="line">            <span class="type">HandlerAdapter</span> <span class="variable">ha</span> <span class="operator">=</span> getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Process last-modified header, if supported by the handler.</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> request.getMethod();</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isGet</span> <span class="operator">=</span> <span class="string">&quot;GET&quot;</span>.equals(method);</span><br><span class="line">            <span class="keyword">if</span> (isGet || <span class="string">&quot;HEAD&quot;</span>.equals(method)) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">lastModified</span> <span class="operator">=</span> ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">new</span> <span class="title class_">ServletWebRequest</span>(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调用拦截器的preHandle()</span></span><br><span class="line">            <span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Actually invoke the handler.</span></span><br><span class="line">            <span class="comment">// 由处理器适配器调用具体的控制器方法，最终获得ModelAndView对象</span></span><br><span class="line">            mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            applyDefaultViewName(processedRequest, mv);</span><br><span class="line">            <span class="comment">// 调用拦截器的postHandle()</span></span><br><span class="line">            mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            dispatchException = ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">            <span class="comment">// As of 4.3, we&#x27;re processing Errors thrown from handler methods as well,</span></span><br><span class="line">            <span class="comment">// making them available for @ExceptionHandler methods and other scenarios.</span></span><br><span class="line">            dispatchException = <span class="keyword">new</span> <span class="title class_">NestedServletException</span>(<span class="string">&quot;Handler dispatch failed&quot;</span>, err);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 后续处理：处理模型数据和渲染视图</span></span><br><span class="line">        processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        triggerAfterCompletion(processedRequest, response, mappedHandler, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">        triggerAfterCompletion(processedRequest, response, mappedHandler,</span><br><span class="line">                               <span class="keyword">new</span> <span class="title class_">NestedServletException</span>(<span class="string">&quot;Handler processing failed&quot;</span>, err));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">            <span class="comment">// Instead of postHandle and afterCompletion</span></span><br><span class="line">            <span class="keyword">if</span> (mappedHandler != <span class="literal">null</span>) &#123;</span><br><span class="line">                mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Clean up any resources used by a multipart request.</span></span><br><span class="line">            <span class="keyword">if</span> (multipartRequestParsed) &#123;</span><br><span class="line">                cleanupMultipart(processedRequest);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h4 id="processDispatchResult"><a href="#processDispatchResult" class="headerlink" title="processDispatchResult()"></a>processDispatchResult()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processDispatchResult</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span><br><span class="line"><span class="params">                                   <span class="meta">@Nullable</span> HandlerExecutionChain mappedHandler, <span class="meta">@Nullable</span> ModelAndView mv,</span></span><br><span class="line"><span class="params">                                   <span class="meta">@Nullable</span> Exception exception)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">errorView</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (exception != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> ModelAndViewDefiningException) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;ModelAndViewDefiningException encountered&quot;</span>, exception);</span><br><span class="line">            mv = ((ModelAndViewDefiningException) exception).getModelAndView();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">handler</span> <span class="operator">=</span> (mappedHandler != <span class="literal">null</span> ? mappedHandler.getHandler() : <span class="literal">null</span>);</span><br><span class="line">            mv = processHandlerException(request, response, handler, exception);</span><br><span class="line">            errorView = (mv != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Did the handler return a view to render?</span></span><br><span class="line">    <span class="keyword">if</span> (mv != <span class="literal">null</span> &amp;&amp; !mv.wasCleared()) &#123;</span><br><span class="line">        <span class="comment">// 处理模型数据和渲染视图</span></span><br><span class="line">        render(mv, request, response);</span><br><span class="line">        <span class="keyword">if</span> (errorView) &#123;</span><br><span class="line">            WebUtils.clearErrorRequestAttributes(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;No view rendering, null ModelAndView returned.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123;</span><br><span class="line">        <span class="comment">// Concurrent handling started during a forward</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mappedHandler != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Exception (if any) is already handled..</span></span><br><span class="line">        <span class="comment">// 调用拦截器的afterCompletion()</span></span><br><span class="line">        mappedHandler.triggerAfterCompletion(request, response, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h3 id="SpringMVC的执行流程"><a href="#SpringMVC的执行流程" class="headerlink" title="SpringMVC的执行流程"></a>SpringMVC的执行流程</h3><ol><li><p>客户端 (浏览器) 向服务器发送请求，请求被 SpringMVC 前端控制器 <code>DispatcherServlet</code> 捕获。</p></li><li><p><code>DispatcherServlet</code> 解析 URL ，得到请求资源标识符 (URI) 并判断 URI 对应的映射。</p><ol><li>不存在。<ol><li>判断是否配置了 <code>mvc:default-servlet-handler</code>，若无，则控制台报映射查找不到，客户端展示 404 错误。若有，则访问目标资源（一般为静态资源，如：JS,CSS,HTML），找不到客户端也会展示 404 错误。</li></ol></li></ol><ol start="2"><li>存在。<ol><li>根据该 URI，调用 <code>HandlerMapping</code> 获得该 <code>Handler</code> 配置的所有相关的对象 (包括 Handler 对象以及 Handler 对象对应的拦截器)，最后以 <code>HandlerExecutionChain</code> 执行链对象的形式返回。</li><li><code>DispatcherServlet</code> 根据获得的 <code>Handler</code> ，选择一个合适的 <code>HandlerAdapter</code> 。</li><li>如果成功获得 <code>HandlerAdapter</code> ，此时将开始执行拦截器的 <code>preHandler(…)</code> 方法 (正向) 。</li><li>提取 Request 中的模型数据，填充 <code>Handler</code> 入参，开始执行 <code>Handler</code> (Controller) 方法，处理请求。在填充 <code>Handler</code> 的入参过程中，根据配置，Spring 将执行如下。<ol><li><code>HttpMessageConveter</code>： 将请求消息 (如Json、xml等数据) 转换成对象，将对象转换为指定的响应信息。</li><li>数据转换：对请求消息进行数据转换。如 <code>String</code> 转换成 <code>Integer</code>、<code>Double</code> 等。</li><li>数据格式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等。</li><li>数据验证： 验证数据的有效性 (长度、格式等)，验证结果存储到 <code>BindingResult</code> 或 <code>Error</code> 中。</li></ol></li></ol></li></ol></li><li><p><code>Handler</code> 执行完成后，向 <code>DispatcherServlet</code> 返回 <code>ModelAndView</code> 对象。</p></li><li><p>此时将开始执行拦截器的 <code>postHandle(...) 方法</code> (逆向)。</p></li><li><p>根据返回的 <code>ModelAndView</code> (此时会判断是否存在异常：如果存在异常，则执行 <code>HandlerExceptionResolver</code> 进行异常处理) 选择一个适合的 <code>ViewResolver</code> 进行视图解析，根据 <code>Model</code> 和 <code>View</code> ，来渲染视图。</p></li><li><p>渲染视图完毕执行拦截器的 <code>afterCompletion(…) 方法</code> (逆向)。</p></li><li><p>将渲染结果返回给客户端。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Spring系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring全家桶 </tag>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring5框架学习实战</title>
      <link href="/2022/10/07/spring5%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98_yukiyama/"/>
      <url>/2022/10/07/spring5%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98_yukiyama/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring5框架学习实战"><a href="#Spring5框架学习实战" class="headerlink" title="Spring5框架学习实战"></a>Spring5框架学习实战</h2><blockquote><p><a href="https://www.bilibili.com/video/BV1Vf4y127N5?spm_id_from=333.999.0.0&vd_source=c56ec421dded765a52ade50885eaab60">本文总结自尚硅谷视频</a>, <a href="https://blog.csdn.net/qq_35843514/article/details/114287046?spm=1001.2014.3001.5501">参考1</a>, <a href="https://repo.spring.io/ui/native/release/org/springframework/spring/">Spring 下载地址</a>, <a href="https://docs.spring.io/spring-framework/docs/5.3.x/reference/html/">Spring框架官方文档 (5.3.22)</a></p></blockquote><br /><h3 id="框架概述"><a href="#框架概述" class="headerlink" title="框架概述"></a>框架概述</h3><p><strong>Spring框架是什么？</strong></p><ul><li><p>Spring 是一个 <strong>开源的 Java EE 开发框架</strong> 。</p></li><li><p>Spring 框架的核心功能可以应用在任何 Java 应用程序中，尤其对 Java EE 平台上的 Web 应用程序有更好的扩展性。</p></li><li><p>Spring 框架的目标是使得 Java EE 应用程序的开发更加简便快捷，通过使用 POJO (Plain Old Java Object) 为基础的编程模型促进良好的编程风格。</p></li></ul><p><strong>Spring有哪些优点？</strong></p><ol><li><p><strong>方便解耦，简化开发</strong>。</p><ol><li>IoC 容器实现松耦合。对象之间的依赖关系交由 Spring 控制，避免了在一个对象代码中操作另一个对象所造成的耦合。</li><li>AOP 编程的支持。通过 Spring 提供的 AOP 功能，方便进行 <strong>面向切面</strong> 的编程，把应用的业务逻辑与系统的服务分离开来。</li></ol></li><li><p><strong>声明事务的支持</strong>。在 Spring 中，我们可以从单调烦闷的事务管理代码中解脱出来，通过声明式方式灵活地进行事务的管理，提高开发效率和质量。</p></li><li><p><strong>方便程序的测试</strong>。可以用非容器依赖的编程方式进行几乎所有的测试工作。Spring支持 Junit，可以通过注解方便的测试 Spring 程序。</p></li><li><p><strong>方便集成各种优秀框架</strong>。Spring 提供了对各种优秀框架（如Struts, Hibernate）等的直接支持。</p></li><li><p><strong>Java 源码是经典学习范例</strong>。Spring 的源码设计精妙、结构清晰、应用了许多 Java 设计模式，是对 Java 技术的极佳实践范例。</p></li><li><p><strong>异常处理</strong>。Spring 提供一个方便的 API 将特定技术的异常 (由 JDBC, Hibernate 等抛出) 转化为一致的 Unchecked 异常。</p></li></ol><p><strong>Spring 由哪些模块组成？(架构图)</strong></p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/spring_framework_in_action/spring-overview.png" alt="spring-overview"></p><table><thead><tr><th>模块</th><th>细分</th><th>描述</th></tr></thead><tbody><tr><td>Data Access&#x2F;Integration <br />数据访问&#x2F;集成</td><td></td><td></td></tr><tr><td></td><td>JDBC</td><td>对JDBC的封装。</td></tr><tr><td></td><td>ORM</td><td>支持数据集成框架的封装（如 Mybatis，Hibernate）。</td></tr><tr><td></td><td>OXM</td><td>Object XML Mapper，支持在 Java 对象和 XML 文档间转换。</td></tr><tr><td></td><td>JMS</td><td>生产者和消费者的消息功能实现。</td></tr><tr><td></td><td>Transactions</td><td>事务管理。</td></tr><tr><td>Web</td><td></td><td></td></tr><tr><td></td><td>WebSocket</td><td>提供 Socket 通信，web 端的的推送功能。</td></tr><tr><td></td><td>Servlet</td><td>Spring MVC 框架实现。</td></tr><tr><td></td><td>Web</td><td>包含 web 应用开发用到 Spring 框架时所需的核心类，包括自动载入 WebApplicationContext 特性的类，Struts 集成类、文件上传的支持类、Filter 类和大量辅助工具类。</td></tr><tr><td></td><td>Portlet</td><td>实现 web 模块功能的聚合（如网站首页（Port）下面可能会有不同的子窗口（Portlet））。</td></tr><tr><td>AOP</td><td></td><td>面向切面功能模块。</td></tr><tr><td>Aspects</td><td></td><td>面向切面的一个重要的组成部分，提供对 AspectJ 框架的整合。</td></tr><tr><td>Instrumentation</td><td></td><td>检测器，检测JVM 及 Tomcat 。</td></tr><tr><td>Messaging</td><td></td><td>Spring 提供的消息处理功能。</td></tr><tr><td>Core Container<br />核心容器</td><td>Beans</td><td>负责Bean工厂中Bean的装配，所谓Bean工厂即是创建对象的工厂，Bean的装配也就是对象的创建工作。</td></tr><tr><td></td><td>Core</td><td>负责 IoC 基本实现。</td></tr><tr><td></td><td>Context</td><td>Spring 的 IoC 容器大量调用 Spring Core 中的函数。Bean 创建好对象后，由 Context 负责建立 Bean 与 Bean 之间的关系并维护，可以把 Context 看成是 Bean 关系的集合。</td></tr><tr><td></td><td>SpEl</td><td>Spring Expression Language（Spring 表达式语言）。</td></tr><tr><td>Test</td><td></td><td>在做单元测试时，Spring会帮我们初始化一些测试过程当中需要用到的资源对象</td></tr></tbody></table><blockquote><p>该表内容 <a href="https://www.cnblogs.com/zilongmao/p/10156310.html">来源</a> 。</p></blockquote><br /><h3 id="本文测试例"><a href="#本文测试例" class="headerlink" title="本文测试例"></a>本文测试例</h3><p>对于每一个知识点，本文均给出对应的测试例。</p><table><thead><tr><th>测试例</th><th>涉及的类</th><th>测试方法</th><th>xml</th></tr></thead><tbody><tr><td><strong>基于XML文件的Bean管理</strong></td><td>com.yukiyama.spring.xml</td><td>TestXML</td><td></td></tr><tr><td>注入bean (创建对象)</td><td>User</td><td>testInjectBean</td><td>injectBean.xml</td></tr><tr><td>bean的作用域</td><td>Book, Order</td><td>testScope</td><td>scope.xml</td></tr><tr><td>bean的生命周期</td><td>LifeCycle</td><td>testLifeCycle</td><td>lifeCycle.xml</td></tr><tr><td>通过setter注入字段</td><td>Book</td><td>testInjectFieldBySetter</td><td>injectFieldBySetter.xml</td></tr><tr><td>通过构造器注入字段</td><td>User</td><td>testInjectFieldByConstructor</td><td>injectFieldByConstructor.xml</td></tr><tr><td>p名称空间的使用</td><td>Book</td><td>testInjectFieldBySetterWithPNamespace</td><td>pNamespace.xml</td></tr><tr><td>注入空值和特殊符号</td><td>Book</td><td>testNullAndSpecialStringDI</td><td>nullAndSpecialString.xml</td></tr><tr><td>注入外部bean</td><td>UserService, UserDao, UserDaoImpl</td><td>testInjectOuterBean</td><td>injectOuterBean.xml</td></tr><tr><td>注入内部bean</td><td>UserService, UserDao, UserDaoImpl</td><td>testInjectInnerBean</td><td>injectInnerBean.xml</td></tr><tr><td>外部级联赋值</td><td>Order, Book</td><td>testCascadeOuter</td><td>cascadeOuter.xml</td></tr><tr><td>内部级联赋值</td><td>Order, Book</td><td>testCascadeInner</td><td>cascadeInner.xml</td></tr><tr><td>注入集合字段</td><td>Bucket</td><td>testInjectCollectionType</td><td>injectCollectionType.xml</td></tr><tr><td>提取集合元素</td><td>Bucket</td><td>testInjectCollectionTypeUsingUtilTag</td><td>injectCollectionTypeUsingUtilTag.xml</td></tr><tr><td>FactoryBean</td><td></td><td></td><td></td></tr><tr><td>自动装配</td><td>Book, Order</td><td>testAutowire</td><td>autowire.xml</td></tr><tr><td>外部配置文件</td><td></td><td></td><td></td></tr><tr><td><strong>基于注解的bean管理</strong></td><td>com.yukiyama.spring.anno</td><td>TestAnno</td><td></td></tr><tr><td>注入bean</td><td>UserService</td><td>testAnnoInjectBean</td><td>anno.xml</td></tr><tr><td>注入引用类型字段</td><td>UserService, UserDao, UserDaoImpl</td><td>testAnnoInjectRefFiled</td><td>anno.xml</td></tr><tr><td>注入基本类型字段</td><td>UserService, UserDao, UserDaoImpl</td><td>testAnnoInjectValueFiled</td><td>anno.xml</td></tr><tr><td>完全注解开发</td><td>UserService, UserDao, UserDaoImpl</td><td>testCompleteAnno</td><td>无</td></tr></tbody></table><br /><h3 id="IoC"><a href="#IoC" class="headerlink" title="IoC"></a>IoC</h3><h4 id="IoC基本概念"><a href="#IoC基本概念" class="headerlink" title="IoC基本概念"></a>IoC基本概念</h4><p><strong>什么是 IoC？</strong></p><p>IoC (Inversion of Control), <strong>控制反转 &#x2F; 反转控制</strong>，一种程序设计思想，目的是为了降低程序的耦合度。</p><ul><li>控制 指的是对象的创建、字段注入、对象间的引用等。</li><li><strong>反转</strong> 指原本在对象内部直接控制 (例如通过 new 来创建对象) 其他对象，转变为将所有对象都交给 IoC 容器来控制。对于一个对象，IoC 容器负责查找和注入它所依赖的对象。</li></ul><p>在框架中，<code>org.springframework.beans</code> 和 <code>org.springframework.context</code> 两个包是 IoC 的基础。</p><p><strong>什么是 IoC 容器？</strong></p><p>IoC 容器即 <strong>对象工厂</strong> 。负责创建对象、通过 DI 管理对象、装配对象、配置对象、管理对象的生命周期。</p><p>IoC 容器有两种实现方式 (两个接口)：</p><ul><li><strong>BeanFactory 接口</strong>。IoC 容器的基本实现，加载配置文件时不会创建对象，在获取对象时才会创建对象。</li><li><strong>ApplicationContex 接口</strong>。BeanFactory 接口的子接口，是 <strong>BeanFactory 的超集</strong>，提供更多更强大的面向企业开发的功能。与 BeanFactory 不同的是，<strong>加载配置文件时即创建对象</strong>。</li></ul><p>下图是 IoC 容器示意图。</p><p><img src="https://docs.spring.io/spring-framework/docs/5.3.x/reference/html/images/container-magic.png"></p><p><strong>ApplicationContext 及其具体实现类？</strong></p><p><code>org.springframework.context.ApplicationContext</code> 接口 <strong>代表 Spring IoC 容器</strong>，负责实例化、配置和组装bean。容器通过读取 <strong>配置元数据</strong> 来获得关于要实例化、配置和组装哪些对象的指示。配置元数据以 XML、Java 注解或 Java 代码表示。它可以让你表达构成你的应用程序的对象以及这些对象之间丰富的相互依赖关系。</p><ul><li>FileSystemXmlApplicationContext ：此容器从一个 XML 文件中加载 beans 的配置，其有参构造器的参数为 XML  <strong>配置文件的全路径名</strong> (带盘符文件路径)。</li><li>ClassPathXmlApplicationContext：此容器从一个 XML 文件中加载 beans 的配置，该实现 <strong>在 classpath 里搜索XML 配置文件</strong>  (src文件夹中)。</li></ul><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h5qfkb8vfej21w80r8dno.jpg" alt="image-20220901004924269"></p><p><strong>IoC 的实现原理？</strong></p><ul><li>XML 解析。</li><li>工厂模式。不是通过 new 来创建对象，而是通过工厂 (IoC 容器) 来获取对象。</li><li>反射。创建对象实例是通过反射实现的。</li></ul><p><strong>什么是 DI？</strong></p><p>DI (Dependency Injection)， <strong>依赖注入</strong> 。与 IoC 可看作对同一概念的两个不同角度的描述，IoC 是对「将对象交给 Spring 管理」这一概念的概括描述，DI 则指出管理的具体实现，即 IoC 容器根据配置信息来为一个对象注入它所依赖的内容。</p><blockquote><p><a href="https://docs.spring.io/spring-framework/docs/5.3.x/reference/html/core.html#spring-core">5.3.x官方文档</a>: “IoC is also known as dependency injection (DI).”</p></blockquote><br /><h4 id="SpringBean"><a href="#SpringBean" class="headerlink" title="SpringBean"></a>SpringBean</h4><p><strong>Bean 的定义</strong> : Spring 中的 Bean 是一个被 Spring IoC 容器 <strong>实例化、组装和管理</strong> 的对象。</p><blockquote><p><a href="https://docs.spring.io/spring-framework/docs/5.3.x/reference/html/core.html#spring-core">5.3.x官方文档定义</a></p><p>In Spring, the objects that form the backbone of your application and that are managed by the Spring IoC <em>container</em> are called <em>beans</em>. <strong>A bean is an object that is instantiated, assembled, and managed by a Spring IoC container</strong>. Otherwise, a bean is simply one of many objects in your application. Beans, and the dependencies among them, are reflected in the <em>configuration metadata</em> used by a container.</p><p>另外注意与 JavaBean 的区别。JavaBean 是可序列化，具有空参构造器和 getter 和 setter 方法的 Java 对象。</p></blockquote><p><strong>Bean 管理的定义</strong> : 可理解为 IoC 中的 「控制」，即负责 <strong>对象的创建</strong> 和 <strong>字段的注入</strong>。</p><p><strong>Bean 管理的方式</strong></p><ul><li>基于 XML 配置文件</li><li>基于注解</li></ul><p><strong>两种 Bean</strong></p><ul><li>普通 bean 。bean 标签中 class 属性指定的类。 <code>ApplicationContext</code> 的 <code>getBean</code> 方法获取的类型即为 bean 标签中指定的类型。</li><li>工厂 bean (FactoryBean) 。 <code>ApplicationContext</code> 的 <code>getBean</code> 方法获取的类型可以与 bean 标签中指定的类型不同。</li></ul><p><strong>Bean 的配置元数据</strong></p><br /><h4 id="基于XML文件的Bean管理"><a href="#基于XML文件的Bean管理" class="headerlink" title="基于XML文件的Bean管理"></a>基于XML文件的Bean管理</h4><h5 id="XML-配置文件的内容"><a href="#XML-配置文件的内容" class="headerlink" title="XML 配置文件的内容"></a>XML 配置文件的内容</h5><ul><li><p><a href="https://www.runoob.com/xml/xml-namespaces.html">命名空间</a>。</p></li><li><p><code>bean</code> 标签：描述 Java 对象。通过无参构造器创建对象。</p><ul><li>id 属性: 对象的标识。</li><li>class: 类全路径 (包类路径) 。</li><li>name 属性: 也是对象的标识，可以有特殊符号，不常用。</li></ul></li><li><p><code>property</code> 标签：描述对象的字段，为 Bean 标签的子标签。</p><ul><li>name 属性：字段名</li><li>value 属性：字段值</li><li>ref 属性: bean 标签的 id 值。</li></ul></li><li><p><code>constructor-arg</code> 标签：描述构造器，为 Bean 标签的子标签。</p><ul><li>name 属性：参数名</li><li>value 属性：参数值</li><li>index 属性: 参数的序号，可替代 name 的作用，但不清晰，故不常用。</li></ul></li></ul><p><strong>XML 文件的名称空间</strong></p><blockquote><p><a href="https://www.cnblogs.com/gonjan-blog/p/6637106.html">参考</a></p></blockquote><p>如下最基本的 Spring XML 配置文件中，xmlns &#x2F; xmlns:xsi &#x2F; xsi:schemaLocation 三项便是 <strong><a href="https://www.runoob.com/xml/xml-namespaces.html">命名空间</a><strong>。命名空间的作用是</strong>自动为 XML 标签补全前缀，避免标签命名冲突</strong> 。类似 Java 中的包，不同的包下面可以存放相同的类名，只要在引入类时前面加上类的包就可以避免同名类的冲突。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><br /><h5 id="注入bean"><a href="#注入bean" class="headerlink" title="注入bean"></a>注入bean</h5><ol><li>在 idea 中创建 maven 工程 (quitckstart)</li><li>pom.xml 中添加必要依赖</li><li>工程中创建测试用的普通类</li><li>创建相关测试类</li><li>创建 xml 配置文件</li><li>在 src&#x2F;main&#x2F; 下创建 resources 文件夹，将 xml 配置文件放入该文件夹下</li></ol><p>pom.xml 文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.yukiyama.spring<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring_demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>spring_demo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/commons-logging/commons-logging --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>依赖关系</p><p>通过命令行工具，在该项目的 pom.xml 文件目录下执行 <code>mvn dependency:tree</code> 可看到如下依赖关系。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[INFO] --- maven-dependency-plugin:2.8:tree (default-cli) @ spring_demo ---</span><br><span class="line">[INFO] com.yukiyama.spring:spring_demo:jar:1.0-SNAPSHOT</span><br><span class="line">[INFO] +- junit:junit:jar:4.12:test</span><br><span class="line">[INFO] |  \- org.hamcrest:hamcrest-core:jar:1.3:test</span><br><span class="line">[INFO] +- commons-logging:commons-logging:jar:1.1.1:compile</span><br><span class="line">[INFO] \- org.springframework:spring-context:jar:5.2.6.RELEASE:compile</span><br><span class="line">[INFO]    +- org.springframework:spring-aop:jar:5.2.6.RELEASE:compile</span><br><span class="line">[INFO]    +- org.springframework:spring-beans:jar:5.2.6.RELEASE:compile</span><br><span class="line">[INFO]    +- org.springframework:spring-core:jar:5.2.6.RELEASE:compile</span><br><span class="line">[INFO]    |  \- org.springframework:spring-jcl:jar:5.2.6.RELEASE:compile</span><br><span class="line">[INFO]    \- org.springframework:spring-expression:jar:5.2.6.RELEASE:compile</span><br></pre></td></tr></table></figure><p>通过 idea 还可以看到重复的依赖已被自动忽略。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1h6pyld0vygj30k00diabg.jpg" alt="image-20221001182238675"></p><p>普通类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukiyama.spring.xml.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 装配 bean (通过 xml 配置方式获取对象)</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testInjectBean</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;【测试】装配 bean (通过 xml 配置方式获取对象)&quot;</span>);</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;getBean.xml&quot;</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;user&quot;</span>, User.class);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件 <code>injectBean.xml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 测试：配置bean --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.yukiyama.spring.xml.bean.User&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><br /><h5 id="Bean的作用域"><a href="#Bean的作用域" class="headerlink" title="Bean的作用域"></a>Bean的作用域</h5><p>所谓作用域 (scope) 即值 Bean 是 <strong>单实例</strong> 的还是 <strong>多实例</strong> 的。</p><ul><li>单实例 Bean 在 bean 标签中由 <code>scope=&quot;singleton&quot;</code> 属性确定 (默认值，可不写)，在 IoC 容器对象创建的时候 (BeanFactory &#x2F; ApplicationContext) 就会创建 bean 实例。整个 IoC 容器中该 bean 只存在这一个实例。</li><li>多实例 Bean 在 bean 标签中由 <code>scope=&quot;prototype&quot;</code> 属性确定，在 IoC 容器对象创建的时候 (BeanFactory &#x2F; ApplicationContext) 不会创建 bean 实例，而是在 IoC 容器获取该 bean 时 (如 <code>getBean()</code> 方法) 才创建实例。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 测试：bean 的作用域 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;book&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.yukiyama.spring.xml.bean.Book&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;order&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.yukiyama.spring.xml.bean.Order&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>除了 singleton 和 prototype 外，还有三种应用于 <code>WebApplicationContext</code> 的作用域。</p><table><thead><tr><th align="left">作用域</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">singleton</td><td align="left"><strong>默认作用域</strong>。在 Spring IoC 容器仅存在一个 Bean 实例，单例方式存在。</td></tr><tr><td align="left">prototype</td><td align="left">每次从容器中调用 Bean 时，都返回一个新的实例，即每次调用 getBean() 时，相当于执行 newXxxBean() 。</td></tr><tr><td align="left">request</td><td align="left">每次 HTTP 请求都会创建一个新的 Bean，该作用域仅适用于 WebApplicationContext 环境。</td></tr><tr><td align="left">session</td><td align="left">同一个 HTTP Session 共享一个 Bean，不同 Session 使用不同的 Bean ，仅适用于 WebApplicationContext 环境。</td></tr><tr><td align="left">global-session</td><td align="left">一般用于 Portlet 应用环境，该作用域仅适用于 WebApplicationContex t环境。</td></tr></tbody></table><br /><h5 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h5><p>从对象创建到销毁的过程。可在「调用初始化方法」前后加上「后置处理器」过程。</p><ol><li>创建 bean 实例。</li><li>为 bean 的字段设置值及引入其他 bean 。</li><li>执行 bean 后置处理器的 <code>postProcessBeforeInitialization</code> 方法。</li><li>执行 bean 的初始化方法  (需要在 xml 中配置初始化方法) 。</li><li>执行 bean 后置处理器的 <code>postProcessAfterInitialization</code> 方法。</li><li>使用 bean 。</li><li>关闭容器时，调用 bean 的销毁方法  (需要在 xml 中配置销毁方法) 。</li></ol><p>后置处理器的使用步骤。</p><ol><li>创建后置处理器类，实现  <code>BeanPostProcessor</code> 接口，重写 <code>postProcessBeforeInitialization</code> 和 <code>postProcessAfterInitialization</code> 方法。。</li><li>在 XML 文件中以 bean 标签添加后置处理器。XML 文件中的所有 bean 都会应用该后置处理器。</li></ol><p>如下代码演示 bean 的生命周期。</p><p>普通类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukiyama.spring.xml.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LifeCycle</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LifeCycle</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;step: non-args&#x27; constructor.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;step: initial method.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;LifeCycle&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;step: destroy method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后置处理器类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukiyama.spring.xml.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.BeanPostProcessor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;step: postProcessBeforeInitialization&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;step: postProcessAfterInitialization&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>xml 文件 <code>lifeCycle.xml</code> </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 测试：bean 的生命周期 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;lifeCycle&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.yukiyama.spring.xml.bean.LifeCycle&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;destroy&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;lifeCycleBean&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 后置处理器 bean --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;postProcessor&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.yukiyama.spring.xml.bean.PostProcessor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bean 的生命周期</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testLifeCycle</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;【测试】bean 的生命周期&quot;</span>);</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;lifeCycle.xml&quot;</span>);</span><br><span class="line">    <span class="type">LifeCycle</span> <span class="variable">lifeCycle</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;lifeCycle&quot;</span>, LifeCycle.class);</span><br><span class="line">    System.out.println(<span class="string">&quot;step: use bean&quot;</span>);</span><br><span class="line">    System.out.println(lifeCycle.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">【测试】bean 的生命周期</span><br><span class="line">step: non-args&#x27; constructor.</span><br><span class="line">step: postProcessBeforeInitialization</span><br><span class="line">step: initial method.</span><br><span class="line">step: postProcessAfterInitialization</span><br><span class="line">step: use bean</span><br><span class="line">LifeCycle&#123;name=&#x27;lifeCycleBean&#x27;&#125;</span><br></pre></td></tr></table></figure><br /><h5 id="注入字段"><a href="#注入字段" class="headerlink" title="注入字段"></a>注入字段</h5><p><strong>XML 文件的字段注入方式？</strong></p><ul><li>基于 <code>setter</code> 方法。<ol><li>创建类，定义属性和对应的 <code>setter</code> 。</li><li>XML 文件中配置对象 (Bean 标签) 和要注入的字段 (Property 标签)。</li></ol></li><li>基于有参构造器。<br>1. 创建类，定义属性和对应的有参构造器。<br>1. XML 文件中配置对象 (Bean 标签) 和相应的有参构造器参数 (constructor-arg 标签) ，即需要注入的字段。</li></ul><p>使用基于有参构造器的方式时通常基于构造器的方式用于 <strong>强制依赖</strong> ，setter 方式用于 <strong>可选依赖</strong> 。</p><br /><h6 id="基于setter"><a href="#基于setter" class="headerlink" title="基于setter"></a>基于setter</h6><p>如下演示基于 setter 的 DI。</p><p>普通类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukiyama.spring.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String author;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAuthor</span><span class="params">(String author)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.author = author;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Book&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, author=&#x27;&quot;</span> + author + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testInjectFieldBySetter</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;【测试】通过 setter 注入字段&quot;</span>);</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;injectFieldBySetter.xml&quot;</span>);</span><br><span class="line">    <span class="type">Book</span> <span class="variable">book</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;book&quot;</span>, Book.class);</span><br><span class="line">    System.out.println(book.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>xml 配置文件 <code>injectFieldBySetter.xml</code>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 测试：通过setter注入字段 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;book&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.yukiyama.spring.xml.bean.Book&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Hamlet&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;author&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Shakespeare&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><br /><h6 id="基于构造器"><a href="#基于构造器" class="headerlink" title="基于构造器"></a>基于构造器</h6><p>如下演示基于有参构造器的 DI。当一个类具有有参构造器时，参数对应的字段都需要在 xml 的 bean 标签下写出，即有多少个字段，就对应写出多少个 <code>&lt;constructor-arg&gt;</code> 标签内容，否则报错。因此说基于构造器的方式用于 <strong>强制依赖</strong> 。</p><p>普通类</p><p>在前述 <code>User</code> 类中加入有参构造器和 <code>toString()</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukiyama.spring.xml.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String userName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userName = userName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;userName=&#x27;&quot;</span> + userName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过构造器注入字段</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testInjectFieldByConstructor</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;【测试】通过构造器注入字段&quot;</span>);</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;injectFieldByConstructor.xml&quot;</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;user&quot;</span>, User.class);</span><br><span class="line">    System.out.println(user.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>xml 配置文件 <code>injectFieldByConstructor.xml</code>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 测试：通过构造器注入字段 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.yukiyama.spring.xml.bean.User&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;userName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;USER#1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><br /><h6 id="p名称空间"><a href="#p名称空间" class="headerlink" title="p名称空间"></a>p名称空间</h6><p>使用p名称空间可简化 setter 方式的字段注入的写法。</p><ol><li><p>在 XML 文件中添加 p 名称空间配置。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</span><br></pre></td></tr></table></figure></li><li><p>注入字段时，在 bean 标签中无需再以 property 子标签注入字段，可直接作为 bean 标签的属性注入字段。</p></li></ol><p>测试方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过 p 命名空间简化 setter 注入字段</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testInjectFieldBySetterWithPNamespace</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;【测试】通过 p 命名空间简化 setter 注入字段&quot;</span>);</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;pNamespace.xml&quot;</span>);</span><br><span class="line">    <span class="type">Book</span> <span class="variable">book</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;book&quot;</span>, Book.class);</span><br><span class="line">    System.out.println(book.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>xml 配置文件 <code>pNamespace.xml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 测试：p 名称空间简化 setter 注入字段写法 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;book&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.yukiyama.spring.xml.bean.Book&quot;</span> <span class="attr">p:name</span>=<span class="string">&quot;Harry Potter&quot;</span> <span class="attr">p:author</span>=<span class="string">&quot;J. K. Rowling&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><br /><h5 id="注入空值和特殊符号"><a href="#注入空值和特殊符号" class="headerlink" title="注入空值和特殊符号"></a>注入空值和特殊符号</h5><ul><li><p>注入空值: <code>&lt;null/&gt;</code> 标签</p></li><li><p>注入特殊符号: <code>![CDATA[]]</code></p></li></ul><p>测试方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注入空值和特殊符号字段</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testNullAndSpecialStringDI</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;【测试】注入空值和特殊符号字段&quot;</span>);</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;nullAndSpecialString.xml&quot;</span>);</span><br><span class="line">    <span class="type">Book</span> <span class="variable">book</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;book&quot;</span>, Book.class);</span><br><span class="line">    System.out.println(book.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>xml 配置文件: <code> nullAndSpecialString.xml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 测试：注入空值和特殊符号 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;book&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.yukiyama.spring.xml.bean.Book&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">null</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;author&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>&lt;![CDATA[&lt;&lt;special string&gt;&gt;]]&gt;<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><br /><h5 id="注入外部bean"><a href="#注入外部bean" class="headerlink" title="注入外部bean"></a>注入外部bean</h5><p>指在 XML 配置文件中，对于一个 bean 对象，其字段是另一个 bean 对象的情况下，若两者并列写出，且前者 bean 标签内通过 <code>&lt;property name=&quot;&quot; ref=&quot;&quot;&gt;</code> 的方式注入，则为「注入外部bean」。</p><p>例子: </p><ol><li><p>创建类 UserService 、接口 UserDao 及其实现类 UserDaoImpl。</p></li><li><p>在 UserService 中调用 UserDao 实现类中的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukiyama.spring.xml.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.yukiyama.spring.xml.dao.UserDao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDao</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> UserDao <span class="title function_">getUserDao</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userDao;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukiyama.spring.xml.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukiyama.spring.xml.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;This method: UserDaoImpl.update()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在 XML 配置文件中配置 <code>injectOuterBean.xml</code> 。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 测试：注入外部bean --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.yukiyama.spring.xml.Service.UserService&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.yukiyama.spring.xml.dao.UserDaoImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p>测试方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注入外部bean</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testInjectOuterBean</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;【测试】注入外部bean&quot;</span>);</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;injectOuterBean.xml&quot;</span>);</span><br><span class="line">    <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;userService&quot;</span>, UserService.class);</span><br><span class="line">    userService.getUserDao().update();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h5 id="注入内部bean"><a href="#注入内部bean" class="headerlink" title="注入内部bean"></a>注入内部bean</h5><p>与「注入外部bean」相对，在 property 中将 bean 标签作为子标签注入的方式为「注入内部bean」。</p><p>如下为 <code>injectInnerBean.xml</code> 。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 测试：注入内部bean --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.yukiyama.spring.xml.Service.UserService&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.yukiyama.spring.xml.dao.UserDaoImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注入内部bean</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testInjectInnerBean</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;【测试】注入内部bean&quot;</span>);</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;injectInnerBean.xml&quot;</span>);</span><br><span class="line">    <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;userService&quot;</span>, UserService.class);</span><br><span class="line">    userService.getUserDao().update();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h5 id="级联赋值"><a href="#级联赋值" class="headerlink" title="级联赋值"></a>级联赋值</h5><p>在一个 bean 对象 A 中注入另一个 bean 对象 B 的属性并对该属性赋值。</p><blockquote><p><a href="https://www.nhooo.com/note/qa3npp.html">参考</a></p></blockquote><br /><h6 id="外部级联赋值"><a href="#外部级联赋值" class="headerlink" title="外部级联赋值"></a>外部级联赋值</h6><p>在外部 bean <code>Book</code> 中注入字段 <code>name</code> 和 <code>author</code>  后，<code>Order</code> 再引用。</p><p>普通类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukiyama.spring.xml.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Book book;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBook</span><span class="params">(Book book)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.book = book;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Book <span class="title function_">getBook</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> book;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 级联赋值</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCascade</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;【测试】级联赋值&quot;</span>);</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;cascadeOuter.xml&quot;</span>);</span><br><span class="line">    <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;order&quot;</span>, Order.class);</span><br><span class="line">    System.out.println(order.getBook().toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>xml 配置文件 <code>cascadeOuter.xml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 测试：外部级联赋值 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;order&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.yukiyama.spring.xml.bean.Order&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;book&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;book&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;book&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.yukiyama.spring.xml.bean.Book&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Story of the stone&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;author&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Cao Xueqin&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><br /><h6 id="内部级联赋值"><a href="#内部级联赋值" class="headerlink" title="内部级联赋值"></a>内部级联赋值</h6><p>bean <code>Order</code> 直接赋值 bean <code>Book</code> 的属性 <code>name</code> 和 <code>author</code>。</p><p>xml 配置文件 <code>cascadeInner.xml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 测试：内部级联赋值 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;order&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.yukiyama.spring.xml.bean.Order&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;book&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;book&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;book.name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Story of the stone&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;book.author&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Cao Xueqin&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;book&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.yukiyama.spring.xml.bean.Book&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><br /><h5 id="注入集合字段"><a href="#注入集合字段" class="headerlink" title="注入集合字段"></a>注入集合字段</h5><ol><li>创建类，定义数组、list、map、set 类型字段，生成对应的 setter 方法。</li><li>在 XML 配置文件中配置。</li></ol><p>普通类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukiyama.spring.xml.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bucket</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String[] arr;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; list;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Book&gt; bookList;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Integer&gt; bookMap;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; set;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setArr</span><span class="params">(String[] arr)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.arr = arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setList</span><span class="params">(List&lt;String&gt; list)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookList</span><span class="params">(List&lt;Book&gt; bookList)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookList = bookList;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookMap</span><span class="params">(Map&lt;String, Integer&gt; bookMap)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookMap = bookMap;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSet</span><span class="params">(Set&lt;String&gt; set)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.set = set;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Bucket&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;arr=&quot;</span> + Arrays.toString(arr) +</span><br><span class="line">                <span class="string">&quot;, list=&quot;</span> + list +</span><br><span class="line">                <span class="string">&quot;, bookList=&quot;</span> + bookList +</span><br><span class="line">                <span class="string">&quot;, bookMap=&quot;</span> + bookMap +</span><br><span class="line">                <span class="string">&quot;, set=&quot;</span> + set +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注入各种集合类型字段</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testInjectCollectionType</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;【测试】注入各种集合类型字段&quot;</span>);</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;injectCollectionType.xml&quot;</span>);</span><br><span class="line">    <span class="type">Bucket</span> <span class="variable">bucket</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;bucket&quot;</span>, Bucket.class);</span><br><span class="line">    System.out.println(bucket.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>xml 配置文件 <code>injectCollectionType.xml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 测试注入各种集合字段 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bucket&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.yukiyama.spring.xml.bean.Bucket&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- array 字段注入 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;arr&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>arr1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>arr2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- list 字段注入 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>listEle1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>listEle2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 泛型的引用类型的 list 字段注入 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookList&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;book1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;book2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- map 字段注入 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookMap&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;bookName#1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;bookName#2&quot;</span> <span class="attr">value</span>=<span class="string">&quot;456&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- set 字段注入 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;set&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>setEle1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>setEle2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;book1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.yukiyama.spring.xml.bean.Book&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Story of the stone&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;author&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Cao Xueqin&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;book2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.yukiyama.spring.xml.bean.Book&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Harry Potter&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;author&quot;</span> <span class="attr">value</span>=<span class="string">&quot;J. K. Rowling&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><br /><h6 id="提取集合元素"><a href="#提取集合元素" class="headerlink" title="提取集合元素"></a>提取集合元素</h6><ol><li><p>在 XML 配置文件中引入 util 名称空间。</p></li><li><p>在 XML 配置文件中配置。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:util</span>=<span class="string">&quot;http://www.springframework.org/schema/util&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/util</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/util/spring-util.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 测试提取集合元素 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">util:list</span> <span class="attr">id</span>=<span class="string">&quot;stringList&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>listEle1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>listEle2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">util:list</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 测试集合字段 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bucket&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.yukiyama.spring.xml.bean.Bucket&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- list 字段注入，引用 util:list --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;list&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;stringList&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><br /><h5 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h5><p><code>FactoryBean</code> 即工厂 bean， 实现 <code>FactoryBean</code> 接口的类，通过 <code>ApplicationContext</code> 的 <code>getBean</code> 方法获取的类型可以与 bean 标签中指定的类型不同。</p><ol><li>创建类，令其实现 <code>FactoryBean</code> 接口，那么它就是一个工厂 bean。</li><li>实现接口的方法，在该方法中定义返回的具体的 bean 类型。</li><li>XML 配置文件完成配置。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukiyama.factorybean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.yukiyama.collectiontype.Course;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.FactoryBean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;Course&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> FactoryBean.<span class="built_in">super</span>.isSingleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定义返回 bean 类型</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Course <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Course</span> <span class="variable">course</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Course</span>();</span><br><span class="line">        course.setName(<span class="string">&quot;Spring5&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> course;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 演示 FactoryBean --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.yukiyama.factorybean.MyBean&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@org</span>.junit.Test</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFactoryBean</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean1.xml&quot;</span>);</span><br><span class="line">    <span class="type">Course</span> <span class="variable">course</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;myBean&quot;</span>, Course.class); <span class="comment">// 传入具体的返回类型</span></span><br><span class="line">    System.out.println(course);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h5 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h5><blockquote><p><a href="https://www.cnblogs.com/bear7/p/12531016.html">参考</a></p></blockquote><p>自动装配指对于 bean 类型的字段的注入不再通过配置文件中的 <code>&lt;property&gt;</code> 标签实现 (参考前面「注入外部Bean」、「注入内部Bean」内容)，而是在 <code>&lt;bean&gt;</code> 标签中通过 <code>autowire</code> 属性为当前 bean 装配字段 (也是 bean) 。Spring 根据指定的装配规则 (字段名称 <code>autowire = byName</code> 或字段类型 <code>autowire = byType</code>) 自动注入匹配的字段值。<code>autowire</code> 默认值为 <code>no</code> ，表示不使用自动装配。</p><ul><li><code>byName</code> : 根据当前 bean 中的字段名，在 xml 文件中寻找 <code>id</code> 与之对应的 bean，然后作为字段注入当前 bean 中。</li><li><code>byType</code> : 根据当前 bean 中的字段类型，在 xml 文件中寻找 <code>class</code> 与之对应的 bean，然后作为字段注入当前 bean 中。</li></ul><p>需要自动装配多个同类型字段时，应使用 <code>byName</code> ，若使用 <code>byType</code> ，则存在多个同类型 bean 将导致错误。</p><p>普通类</p><p>在 <code>Order</code> 类中设置两个 <code>Book</code> 类型字段。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukiyama.spring.xml.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Book book;</span><br><span class="line">    <span class="keyword">private</span> Book book1;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBook</span><span class="params">(Book book)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.book = book;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBook1</span><span class="params">(Book book)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.book1 = book;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Book <span class="title function_">getBook</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> book;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Order&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;book=&quot;</span> + book +</span><br><span class="line">                <span class="string">&quot;, book1=&quot;</span> + book1 +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自动装配</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAutowire</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;【测试】自动装配&quot;</span>);</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;autowire.xml&quot;</span>);</span><br><span class="line">    <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;order&quot;</span>, Order.class);</span><br><span class="line">    System.out.println(order);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>xml 配置文件 <code>autowire.xml</code> 。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">&lt;!-- 测试：自动装配 --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;order&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.yukiyama.spring.xml.bean.Order&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;book&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.yukiyama.spring.xml.bean.Book&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;book1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.yukiyama.spring.xml.bean.Book&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>若 <code>autowire=&quot;byType&quot;</code> 则报错。</p><br /><h5 id="外部配置文件"><a href="#外部配置文件" class="headerlink" title="外部配置文件"></a>外部配置文件</h5><p>对于 JDBC 连接等场景，需要注入的字段 (例如 <code>username</code>, <code>password</code> 等) 适合用配置文件维护，可以将这些字段的在 <code>&lt;property&gt;</code> 中的 <code>name</code> 和 <code>value</code> 作为键值对写到外部配置文件中。在 XML 中通过 <code>context</code> 名称空间引入配置文件来注入相应的字段。</p><p>例如，使用 <code>Druid</code> 连接池，直接在 XML 中配置字段注入的写法如下。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/crash&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;xxxxxx&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过外部配置文件注入的方法步骤如下。</p><ol><li>在项目 pom.xml 文件中增加 <a href="https://mvnrepository.com/artifact/com.alibaba/druid">druid</a> 依赖。</li><li>创建外部字段配置 <code>.properties</code> 文件，写入字段键值对 (字段名&#x3D;字段值)。</li><li>在 XML 中添加 <code>context</code> 命名空间声明，并通过 <code>&lt;context:property-placeholder&gt;</code> 引入 <code>.properties</code> 文件。</li><li>在 XML 中通过引入的 <code>.properties</code> 文件注入字段。</li></ol><p>jdbc.properties 文件。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">prop.driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">prop.url</span>=<span class="string">jdbc:mysql://localhost:3306/crash</span></span><br><span class="line"><span class="attr">prop.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">prop.password</span>=<span class="string">xxxxxx</span></span><br></pre></td></tr></table></figure><p>xml 配置文件 <code>properties.xml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 测试：引入外部配置文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:jdbc.properties&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 外部字段配置文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;prop.driver&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;prop.url&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;prop.username&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;prop.password&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><br /><h4 id="基于注解的Bean管理"><a href="#基于注解的Bean管理" class="headerlink" title="基于注解的Bean管理"></a>基于注解的Bean管理</h4><p>使用注解能够简化 XML 配置。</p><br /><h5 id="注入bean-1"><a href="#注入bean-1" class="headerlink" title="注入bean"></a>注入bean</h5><p>Spring 针对 Bean 管理中的「对象创建」提供如下注解。Spring 实际上 <strong>并不区分不同注解名称</strong> ，也就是说在代码中用如下任意一个注解标注一个 Bean 都是可以的。但 Spring 提倡在不同层次中使用对应名称的注解，使逻辑更清晰。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Component: 一般 bean 注解</span><br><span class="line">@Service: 通常用于 Service 层</span><br><span class="line">@Controller: 通常用于 Web 层</span><br><span class="line">@Repository: 通常用于 DAO 层</span><br></pre></td></tr></table></figure><p>使用注解创建对象的过程。</p><ol><li>在 pom.xml 中引入 AOP 依赖 <code>spring-aop-5.2.6.RELEASE.jar</code> (已经通过 <code>org.springframework:spring-context:5.2.6.RELEASE</code> 完成了依赖传递)。</li><li>在 XML 文件中添加 <code>context</code> 命名空间，并开启组件扫描 (<code>context:component-scan</code> 标签)。</li><li>创建类 (bean) ，添加类注解 (前述四种之一)。</li></ol><p><code>anno.xml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 测试：注解方式注入 bean --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.yukiyama.spring.anno&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>普通类</p><p>在其上添加类注解 <code>@Service(value = &quot;userService&quot;)</code> 。括号及其内的参数为该 bean 名称，若不写出则默认为该类名 (首字母小写) 。<code>UserDao</code> 接口与 <code>UserDaoImpl</code> 的代码与「注入外部bean」一节中给出的相同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukiyama.spring.anno.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.yukiyama.spring.anno.dao.UserDao;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service(value = &quot;userService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">useDao</span><span class="params">()</span>&#123;</span><br><span class="line">        userDao.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注解方式注入 bean</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAnnoInjectBean</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;【测试】注解方式注入 bean&quot;</span>);</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;annoInjectBean.xml&quot;</span>);</span><br><span class="line">    <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;userService&quot;</span>, UserService.class);</span><br><span class="line">    System.out.println(userService);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h6 id="组件扫描过滤器"><a href="#组件扫描过滤器" class="headerlink" title="组件扫描过滤器"></a>组件扫描过滤器</h6><blockquote><p><a href="https://blog.csdn.net/W_Z_W_888/article/details/80946783">参考</a></p></blockquote><p>在 XML 中的组件扫描标签中 (<code>&lt;context:component-scan&gt;</code>) ，通过过滤标签可设置只扫描某些注解，或不扫描哪些注解。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.yukiyama.spring.anno&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Service&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure><br /><h5 id="注入字段-1"><a href="#注入字段-1" class="headerlink" title="注入字段"></a>注入字段</h5><p>注入字段主要使用如下注解。</p><ul><li>注入引用类型字段<ul><li>@Autowired: 根据字段类型注入 (自动装配)</li><li>@Qualifier: 根据字段名称注入</li><li>@Resource: 支持根据类型或名称注入</li></ul></li><li>注入基本类型字段<ul><li>@Value</li></ul></li></ul><ol><li>创建类，添加类注解 (以 <code>UserService</code> 和 <code>UserDaoImpl</code> 为例，为前者添加类注解 <code>@Service</code> ，为后者添加 <code>@Repository</code>)。</li><li>在 <code>UserService</code> 中添加 <code>UserDao</code> 类型字段，并使用上述 <strong>字段注解</strong> 。</li></ol><p>例一：使用 <code>@Autowired</code> 注解根据字段类型 <code>UserDao</code> (接口) ，寻找其实现类 <code>UserDaoImpl</code> 后注入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukiyama.spring.anno.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.yukiyama.spring.anno.dao.UserDao;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">useDao</span><span class="params">()</span>&#123;</span><br><span class="line">        userDao.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例二：同时使用  <code>@Autowired</code> 和 <code>@Qulifier</code> ，并为后者添加 <code>value</code> 属性，实现根据名称注入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukiyama.spring.anno.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.yukiyama.spring.anno.dao.UserDao;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(value = &quot;yukiyamaDao&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">useDao</span><span class="params">()</span>&#123;</span><br><span class="line">        userDao.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时的 <code>UserDaoImpl</code> 类注解 <code>@Repository</code> 后需要添加 <code>value</code> 属性 (只使用 <code>@Autowired</code> 注解时不需要该属性)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukiyama.spring.anno.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository(value = &quot;yukiyamaDao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;This method: UserDaoImpl.update()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例三：演示 <code>@Resource</code> 的使用。需要注意的是 <code>@Resource</code> 在 <code>javax.annotation.Resource;</code> 中，并不在 Spring 框架中，因此不被推荐使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只需要将 UserService 中的注解换成 @Resource 即可实现按类型注入。</span></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如下实现按名称注入。</span></span><br><span class="line"><span class="meta">@Resource(name = &quot;yukiyamaDao&quot;)</span></span><br><span class="line"><span class="keyword">private</span> UserDao userDao;</span><br></pre></td></tr></table></figure><p>以上三例使用如下测试方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注解方式注入引用类型字段</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAnnoInjectRefFiled</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;【测试】注解方式注入引用类型字段&quot;</span>);</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;annoInjectBean.xml&quot;</span>);</span><br><span class="line">    <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;userService&quot;</span>, UserService.class);</span><br><span class="line">    userService.useDao();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>演示 <code>@Value</code> 的使用。在 <code>UserService</code> 中加入 <code>String</code> 类型的 <code>name</code> 字段及 <code>getName</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(value = &quot;yukiyamaUserService&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注解方式注入基本类型字段</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAnnoInjectValueFiled</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;【测试】注解方式注入引用类型字段&quot;</span>);</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;annoInjectBean.xml&quot;</span>);</span><br><span class="line">    <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;userService&quot;</span>, UserService.class);</span><br><span class="line">    System.out.println(userService.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h5 id="完全注解方式"><a href="#完全注解方式" class="headerlink" title="完全注解方式"></a>完全注解方式</h5><p>前述基于注解的 Bean 管理中，XML 中只需要开启组件扫描即可，已经十分简化，但若将此功能用类文件而不是 XML 来实现，则可完全抛弃 XML 配置，此形式称为「完全注解开发」。</p><ol><li>创建替代 XML 文件的配置类，并添加 <code>@Configuration</code> 和 <code>@ComponentScan</code> 注解。</li><li>测试类需要相应修改 (使用 <code>AnnotationConfigApplicationContext</code>)。</li></ol><p>配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukiyama.spring.anno.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标记该类为配置类</span></span><br><span class="line"><span class="meta">@Configuration</span> </span><br><span class="line"><span class="comment">// 相当于 xml 文件中的 &lt;context:component-scan base-package=&quot;com.yukiyama.spring.anno&quot;/&gt;</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &#123;&quot;com.yukiyama.spring.anno&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 完全注解开发</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCompleteAnno</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;【测试】注解方式注入引用类型字段&quot;</span>);</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">    <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;userService&quot;</span>, UserService.class);</span><br><span class="line">    System.out.println(userService.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><h4 id="AOP基本概念"><a href="#AOP基本概念" class="headerlink" title="AOP基本概念"></a>AOP基本概念</h4><p>AOP (Aspect Oriented Programming)，面向切面编程 &#x2F; 面向方面编程。利用 AOP 可以 <strong>解耦业务逻辑，提高程序重用性和开发效率</strong> 。</p><p>更通俗地说，可以在不修改原有代码的基础上为主干功能添加新功能。例如对于一个页面登录功能，若希望加入用户鉴权功能，无需在原有代码中加入判断逻辑，而是通过 AOP 的方式在不修改源代码的情况下添加该新功能。</p><p><strong>AOP 的实现原理</strong></p><p>动态代理。</p><ul><li>有接口，使用 JDK 动态代理。</li><li>无接口，使用 CGLIB 动态代理。</li></ul><br /><h5 id="JDK-动态代理"><a href="#JDK-动态代理" class="headerlink" title="JDK 动态代理"></a>JDK 动态代理</h5><blockquote><p><a href="https://www.bilibili.com/video/BV1Dt41187wj?spm_id_from=333.337.search-card.all.click&vd_source=c56ec421dded765a52ade50885eaab60">参考1</a>, <a href="https://segmentfault.com/a/1190000011291179">参考2</a>, <a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1264804593397984#0">参考3</a></p></blockquote><p>动态代理与静态代理的区别主要为: 静态代理类要实现接口，编译完成后有一 <code>.class</code> 文件。动态代理类不实现接口，在运行时动态生成，编译后无 <code>.class</code> 文件，而是在 <strong>运行时动态生成类字节码并加载到 JVM 中</strong> 。</p><p>动态代理是 <strong>反射与代理模式</strong> 的应用，涉及到 <code>java.lang.reflect</code> 中若干类和方法， 其中最关键的方法为 <code>Proxy.newProxyInstance</code> 静态方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Object <span class="title function_">newProxyInstance</span><span class="params">(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</span> </span><br></pre></td></tr></table></figure><table><thead><tr><th>方法参数和返回值</th><th>描述</th></tr></thead><tbody><tr><td><code>ClassLoader loader</code></td><td>指定当前目标对象使用的类加载器</td></tr><tr><td><code>Class&lt;?&gt;[] interfaces</code></td><td>目标对象实现的接口的类型 (数组)</td></tr><tr><td><code>InvocationHandler h</code></td><td>事件处理器</td></tr><tr><td><code>Object</code></td><td>返回一个指定接口的代理类实例</td></tr></tbody></table><p>动态代理的实现步骤如下。</p><ol><li>创建主题类和代理类都要实现的 <strong>接口</strong> ，定义接口方法。</li><li>创建 <strong>接口实现类作为主题类</strong> ，重写方法。</li><li>创建实现 <code>InvocationHandler</code> 接口的实现类作为 <strong>代理类</strong>  (也可以用匿名类形式写出)。<ol><li>内部通过有参构造器持有主题类对象。</li><li>重写 <code>invoke</code> 方法，在方法中完成 <strong>「前置增强」</strong> 与 <strong>「后置增强」</strong> (按需要) 。</li><li>可自定义一个 <code>getProxyInstance</code> 方法，内部调用 <code>Proxy.newProxyInstance</code> 静态方法，返回代理对象实例。</li></ol></li><li>完成代理。</li></ol><p>如下代码演示动态代理实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代理类和主题类需要实现的接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line">    String <span class="title function_">update</span><span class="params">(String id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主题类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行主题类add方法，&quot;</span> + a + <span class="string">&quot;+&quot;</span> + b + <span class="string">&quot; = &quot;</span> + (a + b));</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">update</span><span class="params">(String id)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行主题类update方法，更新为&quot;</span> + id);</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoProxy</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object obj; <span class="comment">// 持有主题类对象</span></span><br><span class="line">    <span class="comment">// 通过有参构造器传入主题类对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserDaoProxy</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 增强的逻辑</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 前置增强</span></span><br><span class="line">        System.out.println(<span class="string">&quot;前置增强 &quot;</span> + method.getName() + <span class="string">&quot; ，传递的参数: &quot;</span> + Arrays.toString(args));</span><br><span class="line">        <span class="comment">// 被增强的方法，指定代理对象及其参数</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">res</span> <span class="operator">=</span> method.invoke(obj, args);</span><br><span class="line">        <span class="comment">// 后置增强</span></span><br><span class="line">        System.out.println(<span class="string">&quot;后置增强&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过 Proxy.newProxyInstance 静态方法返回代理对象</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getProxyInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(obj.getClass().getClassLoader(),</span><br><span class="line">                obj.getClass().getInterfaces(), <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下代码执行动态代理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态代理演示</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicProxyDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 主题对象</span></span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line">        <span class="comment">// 代理人对象</span></span><br><span class="line">        <span class="type">UserDaoProxy</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDaoProxy</span>(userDao);</span><br><span class="line">        <span class="comment">// 代理人对象代理后得到的代理对象</span></span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">proxyDao</span> <span class="operator">=</span> (UserDao) proxy.getProxyInstance();</span><br><span class="line">        proxyDao.add(<span class="number">7</span>, <span class="number">8</span>);</span><br><span class="line">        proxyDao.update(<span class="string">&quot;yukiyama&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">前置增强 add ，传递的参数: [7, 8]</span><br><span class="line">执行主题类add方法，7+8 = 15</span><br><span class="line">后置增强</span><br><span class="line">前置增强 update ，传递的参数: [yukiyama]</span><br><span class="line">执行主题类update方法，更新为yukiyama</span><br><span class="line">后置增强</span><br></pre></td></tr></table></figure><br /><h5 id="AOP术语"><a href="#AOP术语" class="headerlink" title="AOP术语"></a>AOP术语</h5><p>AOP 中有许多重要的概念，对应了一些并不是很直观的术语。这些术语是通用的而非 Spring 所特有的。这些术语的官方释义如下 (来自 <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop">Spring官方文档</a>) ，每一条概念的英文原文下是中文翻译和必要的注释。</p><blockquote><p>Aspect 切面, Join Point 连接点, Advice 通知&#x2F;增强, Pointcut 切点, Introduction 引入, Target object 目标类, AOP Proxy AOP代理, Weaving 织入</p></blockquote><p>在不了解 AOP 实现细节的情况下，即便阅读如下较为详细的定义，也很难形成具象的理解，尽管如此，我们仍先列出这些概念的释义，在后续 AOP 实现中再反复体会理解。</p><table><thead><tr><th>AOP Concepts</th></tr></thead><tbody><tr><td><strong>Aspect</strong>: A modularization of a concern that cuts across multiple classes. Transaction management is a good example of a crosscutting concern in enterprise Java applications. In Spring AOP, aspects are implemented by using regular classes (the <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-schema">schema-based approach</a>) or regular classes annotated with the <code>@Aspect</code> annotation (the <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-ataspectj">@AspectJ style</a>).</td></tr><tr><td><strong>切面</strong>: 横跨不同类的关注点的模块化。「事务管理」即是企业级 Java 应用中横跨 (类) 的关注点中的一个好例子。在 Spring AOP 中，切面由基于模式的方法或由 <code>@Aspect</code> 注解的普通类来实现。<br />※ 解释: concern 指的是代理类，代理类里的通知 (功能增强) 是业务所关注的 (concern) ，它可以作用到不同类 (的方法) 上，所以说「 …that cuts across multiple classes」。基于模式的方法指的是用 XML 配置文件实现 AOP 的方式。</td></tr><tr><td><strong>Join point</strong>: A point during the execution of a program, such as the execution of a method or the handling of an exception. In Spring AOP, a join point always represents a method execution.</td></tr><tr><td><strong>连接点</strong>: 程序执行过程中的点 (一个动作)，例如一个方法的执行或一个异常的处理。在 Spring AOP 中，一个连接点总是代表一个方法的执行。<br />※ 解释: 连接点即被代理的类的被增强的方法或执行该方法时产生的异常 (当使用 <code>@AfterThrowing</code> 通知时)，通知 (增强方法) 作用于该方法或执行该方法时产生的异常 (当使用 <code>@AfterThrowing</code> 通知时)。</td></tr><tr><td><strong>Advice</strong>: Action taken by an aspect at a particular join point. Different types of advice include “around”, “before” and “after” advice. (Advice types are discussed later.) Many AOP frameworks, including Spring, model an advice as an interceptor and maintain a chain of interceptors around the join point.</td></tr><tr><td><strong>通知&#x2F;增强&#x2F;建议</strong>: 切面在特定连接点上的动作。不同类型的通知包括「环绕通知」、「前置通知」、「后置通知」等 (后续讨论)。包括 Spring 在内的许多 AOP 框架，都将通知作为一个拦截器，并在连接点周围维护一个拦截器链。<br />※ 解释: 通知即切面类中的用于增强目标类方法的方法 (即 Action) 。「拦截」是说这个通知 (方法) 会在目标方法执行之前或之后或前后 (所谓「around」) 执行 (由通知类型决定) 。「拦截器链」指的是对要增强的方法，可以有多个通知 (多个增强方法)。</td></tr><tr><td><strong>Pointcut</strong>: A predicate that matches join points. Advice is associated with a pointcut expression and runs at any join point matched by the pointcut (for example, the execution of a method with a certain name). The concept of join points as matched by pointcut expressions is central to AOP, and Spring uses the AspectJ pointcut expression language by default.</td></tr><tr><td><strong>切点&#x2F;切入点</strong>: 连接点的声明。通知会作用于切点表达式匹配的所有连接点 (例如，执行一个具有特定名称的方法)。由切点表达式匹配连接点这一概念是 AOP 的核心，Spring 默认使用 AspectJ 的切点表达式语言。<br />※ 解释: 所谓「predicate」即 XML 方式中的 <code>&lt;aop:pointcut id=&quot;&quot; expression=&quot;&quot;&gt;</code> 或注解方式中的 <code>@Before(value = &quot;execution()&quot;)</code> ，均通过 <code>expression</code> (切点表达式) 来指定具体的连接点 (被增强的方法) 。</td></tr><tr><td><strong>Introduction</strong>: Declaring additional methods or fields on behalf of a type. Spring AOP lets you introduce new interfaces (and a corresponding implementation) to any advised object. For example, you could use an introduction to make a bean implement an <code>IsModified</code> interface, to simplify caching. (An introduction is known as an inter-type declaration in the AspectJ community.)</td></tr><tr><td><strong>引入</strong>: 为一个类型声明额外的方法或字段。Spring AOP 允许你为任何通知的对象引入新的接口 (以及相应的实现) 。例如，你可以使用引入来使一个 bean 实现 <code>IsModified</code> 接口，以实现一个简化的缓存功能 (引入在 AspectJ 社区中被称为类型间声明)。<br />※ 解释: 对方法的增强的过程为「织入」，对接口的增强的过程为「引入」。所谓对接口的增强，即在不改动接口的前提下，使该接口的实现类实现一个该接口并不提供的方法，具体过程可以参考 <a href="https://blog.csdn.net/zyhlwzy/article/details/70314157">这里</a> 。</td></tr><tr><td><strong>Target object</strong>: An object being advised by one or more aspects. Also referred to as the “advised object”. Since Spring AOP is implemented by using runtime proxies, this object is always a proxied object.</td></tr><tr><td><strong>目标对象&#x2F;目标类</strong>: 被一个或多个切面所增强的对象。也被称为 「被增强对象」。由于 Spring AOP 是通过使用运行时代理来实现的，这个对象总是一个被代理的对象。<br />※ 解释: 即动态代理中主题类 (被代理的类)。</td></tr><tr><td><strong>AOP proxy</strong>: An object created by the AOP framework in order to implement the aspect contracts (advise method executions and so on). In the Spring Framework, an AOP proxy is a JDK dynamic proxy or a CGLIB proxy.</td></tr><tr><td><strong>AOP 代理</strong>: 一个由 AOP 框架创建的对象，以实现切面功能 (增强方法的执行等) 。在 Spring 框架中，AOP 代理是一个 JDK 动态代理或CGLIB 代理。<br />※ 解释: 即动态代理，有接口时，使用基于接口的 JDK 动态代理，否则使用基于类的 CGLIB 动态代理。</td></tr><tr><td><strong>Weaving</strong>: linking aspects with other application types or objects to create an advised object. This can be done at compile time (using the AspectJ compiler, for example), load time, or at runtime. Spring AOP, like other pure Java AOP frameworks, performs weaving at runtime.</td></tr><tr><td><strong>织入</strong>: 将切面与其他应用类型或对象联系起来，以创建一个增强对象。这可以在编译期 (如使用 AspectJ 编译器) 、加载期或运行时完成。Spring AOP 和其他纯 Java AOP 框架一样，在运行时织入。<br />※ 解释: 即创建增强对象 (代理类对象) 的过程，该过程如同将通知  (增强方法) 「织入」到被代理类中。</td></tr></tbody></table><table><thead><tr><th>通知类型</th><th>描述</th></tr></thead><tbody><tr><td>前置通知 <code>@Before</code></td><td>在连接点之前执行的增强方法。</td></tr><tr><td>环绕通知 <code>@Around</code></td><td>在连接点之前以及之后都可以执行的增强方法，可选择是否传入 <code>ProceedingJoinPoint</code> 对象来决定是否执行连接点 (被增强方法) 。</td></tr><tr><td>返回型后置通知 <code>@AfterReturning</code></td><td>在连接点正常返回后执行的增强方法。</td></tr><tr><td>异常型后置通知 <code>@AfterThrowing</code></td><td>在连接点发生异常后执行的增强方法。</td></tr><tr><td>后置通知 (最终通知) <code>@After</code></td><td>无论连接点是否正常完成运行，在其运行结束后都会执行的增强方法。</td></tr></tbody></table><br /><h4 id="基于AspectJ的AOP"><a href="#基于AspectJ的AOP" class="headerlink" title="基于AspectJ的AOP"></a>基于AspectJ的AOP</h4><p><a href="https://www.eclipse.org/aspectj/">AspectJ</a> 是 Eclipse 基金会的独立的开源 AOP 框架，Spring 框架整合了 AspectJ，并支持 <strong>利用 XML 配置文件</strong> 或 <strong>注解方式</strong> ，通过 AspectJ 来实现 AOP。使用前应向项目中引入相关依赖，此外还要了解 <strong>「切入点表达式」</strong> 的写法。</p><ul><li>在项目中引入 AOP 相关依赖。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-aspects --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aspects<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>切入点表达式。用于指示将通知施加到哪些方法中。</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">语法结构： execution([权限修饰符] [返回类型] [类全路径] [方法名称]([参数列表]))</span><br><span class="line"></span><br><span class="line">举例1：增强 com.yukiyama.dao.BookDao 类的 add 方法</span><br><span class="line">execution(* com.yukiyama.dao.BookDao.add(..))</span><br><span class="line">举例2：增强 com.yukiyama.dao.BookDao 类的所有方法</span><br><span class="line">execution(* com.yukiyama.dao.BookDao.*(..))</span><br><span class="line">举例3：增强 com.yukiyama.dao 下所有类的所有方法</span><br><span class="line">execution(* com.yukiyama.dao.*.*(..))</span><br></pre></td></tr></table></figure><br /><h5 id="基于XML"><a href="#基于XML" class="headerlink" title="基于XML"></a>基于XML</h5><p>按如下步骤演示使用 <strong>XML配置文件方式</strong> 实现 AOP 增强的过程。</p><p>第1步: 创建主题类 (要被增强的目标类) ，定义方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukiyama.spring.aop.xml.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukiyama.spring.aop.xml.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;This method: UserDaoImpl.update()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第2步: 创建代理类 (即增强主题类功能的增强类) 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukiyama.spring.aop.xml.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoProxy</span> &#123;</span><br><span class="line">    <span class="comment">// 前置增强: 在连接点之前执行</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;==== before advice ====&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;This method: UserDaoProxy.before()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 环绕增强: 在连接点前后均执行</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;This method: UserDaoProxy.around()&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;==== around advice: before ====&quot;</span>);</span><br><span class="line">        pjp.proceed();</span><br><span class="line">        System.out.println(<span class="string">&quot;==== around advice: after ====&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 后置增强 (正常退出): 在方法返回之后，正常返回后执行</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;==== afterReturning advice ====&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;This method: UserDaoProxy.afterReturning()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 后置增强 (异常退出): 抛出异常时执行</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;==== afterThrowing advice ====&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;This method: UserDaoProxy.afterThrowing()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 后置增强 (最终增强): 无论是否抛出异常均执行</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;==== after advice ====&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;This method: UserDaoProxy.after()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第3步: 完成通知的配置。在 XML 配置文件中添加 <code>aop</code> 命名空间，声明要创建的 bean 对象，完成 aop 配置。</p><p>xml 配置文件 <code>aop.xml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                          http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 测试：aop --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDaoImpl&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.yukiyama.spring.aop.xml.dao.UserDaoImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDaoProxy&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.yukiyama.spring.aop.xml.dao.UserDaoProxy&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- aop 配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置切点 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;update&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.yukiyama.spring.aop.xml.dao.UserDao.update(..))&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置切面 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;userDaoProxy&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 配置通知类型及作用的方法 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;before&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;update&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">&quot;around&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;update&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">&quot;afterReturning&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;update&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">&quot;afterThrowing&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;update&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">&quot;after&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;update&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>完成上述步骤后以如下测试代码测试效果。<code>TestAOPXML</code> 中的如下方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// xml-based aop</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAopXml</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;aop.xml&quot;</span>);</span><br><span class="line">    <span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;userDaoImpl&quot;</span>, UserDao.class);</span><br><span class="line">    userDao.update();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无异常时控制台输出如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">==== before advice ====</span><br><span class="line">This method: UserDaoProxy.before()</span><br><span class="line">This method: UserDaoProxy.around()</span><br><span class="line">==== around advice: before ====</span><br><span class="line">This method: UserDaoImpl.update()</span><br><span class="line">==== around advice: after ====</span><br><span class="line">==== afterReturning advice ====</span><br><span class="line">This method: UserDaoProxy.afterReturning()</span><br><span class="line">==== after advice ====</span><br><span class="line">This method: UserDaoProxy.after()</span><br></pre></td></tr></table></figure><p>有异常时控制台输出如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">==== before advice ====</span><br><span class="line">This method: UserDaoProxy.before()</span><br><span class="line">This method: UserDaoProxy.around()</span><br><span class="line">==== around advice: before ====</span><br><span class="line">This method: UserDaoImpl.update()</span><br><span class="line">==== afterThrowing advice ====</span><br><span class="line">This method: UserDaoProxy.afterThrowing()</span><br><span class="line">==== after advice ====</span><br><span class="line">This method: UserDaoProxy.after()</span><br></pre></td></tr></table></figure><br /><h5 id="基于注解"><a href="#基于注解" class="headerlink" title="基于注解"></a>基于注解</h5><p>按如下步骤演示使用 <strong>注解方式</strong> 实现 AOP 增强的过程，展示五种通知类型的效果。</p><p>第1步: 创建主题类 (要被增强的目标类) ，定义方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukiyama.spring.aop.anno.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component(&quot;userDaoImpl&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;This method: UserDaoImpl.update()&quot;</span>);</span><br><span class="line">        <span class="comment">// int a = 10 / 0;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第2步: 创建代理类 (即增强主题类功能的增强类) 。</p><p>如下添加了五种通知，并展示了增强注解参数的几种不同的写法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引用公共切入点</span></span><br><span class="line"><span class="meta">@Before(&quot;pointcut()&quot;)</span></span><br><span class="line"><span class="comment">// 普通写法</span></span><br><span class="line"><span class="meta">@AfterReturning(value = &quot;execution(* com.yukiyama.spring.aop.anno.dao.UserDao.update(..))&quot;)</span></span><br><span class="line"><span class="comment">// 省略 &quot;value = &quot;</span></span><br><span class="line"><span class="meta">@AfterThrowing(&quot;execution(* com.yukiyama.spring.aop.anno.dao.UserDao.update(..))&quot;)</span></span><br><span class="line"><span class="comment">// 使用通配符</span></span><br><span class="line"><span class="meta">@After(&quot;execution(void com.yukiyama.spring.aop.anno.*.*.*(..))&quot;)</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukiyama.spring.aop.anno.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoProxy</span> &#123;</span><br><span class="line">    <span class="comment">// 提取公共切入点</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.yukiyama.spring.aop.anno.dao.UserDao.update(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pointcut</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前置增强: 在连接点之前执行</span></span><br><span class="line">    <span class="meta">@Before(&quot;pointcut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;==== before advice ====&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;This method: UserDaoProxy.before()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 环绕增强: 在连接点前后均执行</span></span><br><span class="line">    <span class="meta">@Around(&quot;pointcut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;This method: UserDaoProxy.around()&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;==== around advice: before ====&quot;</span>);</span><br><span class="line">        pjp.proceed();</span><br><span class="line">        System.out.println(<span class="string">&quot;==== around advice: after ====&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 后置增强 (正常退出): 在方法返回之后，正常返回后执行</span></span><br><span class="line">    <span class="meta">@AfterReturning(value = &quot;execution(* com.yukiyama.spring.aop.anno.dao.UserDao.update(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;==== afterReturning advice ====&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;This method: UserDaoProxy.afterReturning()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 后置增强 (异常退出): 抛出异常时执行</span></span><br><span class="line">    <span class="meta">@AfterThrowing(&quot;execution(* com.yukiyama.spring.aop.anno.dao.UserDao.update(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;==== afterThrowing advice ====&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;This method: UserDaoProxy.afterThrowing()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 后置增强 (最终增强): 无论是否抛出异常均执行</span></span><br><span class="line">    <span class="meta">@After(&quot;execution(void com.yukiyama.spring.aop.anno.*.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;==== after advice ====&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;This method: UserDaoProxy.after()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第3步: 完成通知的配置。</p><ol><li>在 XML 配置文件中添加 <code>context</code> 和 <code>aop</code> 命名空间，开启注解扫描，添加生成代理对象的配置。 xml 配置文件 <code>aopAnno.xml</code>。</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 测试：注解方式aop --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 开启注解扫描 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.yukiyama.spring.aop.anno.dao&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 启用 AspectJ 生成代理对象 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>在被增强类和增强类上类上添加 <code>@Component</code> 注解，在增强类上添加 <code>@Aspect</code> 注解 (见给出的类代码) 。</li></ol><p>第4步: 在增强类的通知方法中添加使用切入点表达式的通知类型注解 (见前面的增强类代码) 。</p><p>完成上述步骤后以如下测试代码测试效果。在 <code>TestAOPAnno</code> 中的如下方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// anno-based aop</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAopAnno</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;aopAnno.xml&quot;</span>);</span><br><span class="line">    <span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;userDaoImpl&quot;</span>, UserDao.class);</span><br><span class="line">    userDao.update();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无异常时控制台输出如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">This method: UserDaoProxy.around()</span><br><span class="line">==== around advice: before ====</span><br><span class="line">==== before advice ====</span><br><span class="line">This method: UserDaoProxy.before()</span><br><span class="line">This method: UserDaoImpl.update()</span><br><span class="line">==== around advice: after ====</span><br><span class="line">==== after advice ====</span><br><span class="line">This method: UserDaoProxy.after()</span><br><span class="line">==== afterReturning advice ====</span><br><span class="line">This method: UserDaoProxy.afterReturning()</span><br></pre></td></tr></table></figure><p>有异常时控制台输出如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">This method: UserDaoProxy.around()</span><br><span class="line">==== around advice: before ====</span><br><span class="line">==== before advice ====</span><br><span class="line">This method: UserDaoProxy.before()</span><br><span class="line">This method: UserDaoImpl.update()</span><br><span class="line">==== after advice ====</span><br><span class="line">This method: UserDaoProxy.after()</span><br><span class="line">==== afterThrowing advice ====</span><br><span class="line">This method: UserDaoProxy.afterThrowing()</span><br></pre></td></tr></table></figure><br /><h6 id="切入点抽取"><a href="#切入点抽取" class="headerlink" title="切入点抽取"></a>切入点抽取</h6><p>前面的例子中，每一个通知的切入点表达式都是相同的，可以利用 <code>@Pointcut</code> 注解抽取相同的表达式。见前面给出的 <code>UserDaoProxy</code> 类的如下方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 提取公共切入点</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;execution(* com.yukiyama.spring.aop.anno.dao.UserDao.update(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pointcut</span><span class="params">()</span>&#123;&#125;</span><br></pre></td></tr></table></figure><br /><h6 id="Order注解"><a href="#Order注解" class="headerlink" title="Order注解"></a>Order注解</h6><p>当一个类有多个增强类时，可通过在不同增强类上添加类注解 <code>@Order(n)</code> 来设置增强的优先级，整数 $n$ 越小优先级越高。例如另建一个 <code>VIPUserDaoProxy</code> 类作为 <code>UserDao</code> 类的增强类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukiyama.spring.aop.anno.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.annotation.Order;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Order(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VIPUserDaoProxy</span> &#123;</span><br><span class="line">    <span class="meta">@Before(&quot;execution(void com.yukiyama.spring.aop.anno.*.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;==== VIPUserDaoProxy: before advice ====&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;This method: VIPUserDaoProxy.before()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时在 <code>UserProxy</code> 上添加类注解 <code>@Order(5)</code> ，则 <code>VIPUserDaoProxy</code> 的通知先执行。得到如下结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">==== VIPUserDaoProxy: before advice ====</span><br><span class="line">This method: VIPUserDaoProxy.before()</span><br><span class="line">This method: UserDaoProxy.around()</span><br><span class="line">==== around advice: before ====</span><br><span class="line">==== before advice ====</span><br><span class="line">This method: UserDaoProxy.before()</span><br><span class="line">This method: UserDaoImpl.update()</span><br><span class="line">==== around advice: after ====</span><br><span class="line">==== after advice ====</span><br><span class="line">This method: UserDaoProxy.after()</span><br><span class="line">==== afterReturning advice ====</span><br><span class="line">This method: UserDaoProxy.afterReturning()</span><br></pre></td></tr></table></figure><br /><h6 id="完全注解方式-1"><a href="#完全注解方式-1" class="headerlink" title="完全注解方式"></a>完全注解方式</h6><p>可以创建配置类实现无需 XML 文件的完全注解方式的 AOP 。配置类如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukiyama.spring.aop.anno.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.EnableAspectJAutoProxy;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;com.yukiyama.spring.aop.anno&quot;)</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy(proxyTargetClass = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>配置类的三个用于支持纯注解方式的类注解的作用如下。</p><table><thead><tr><th>类注解</th><th>描述</th></tr></thead><tbody><tr><td><code>@Configuration</code></td><td>表明当前类是配置类，代替 xml 的作用。</td></tr><tr><td><code>@ComponentScan</code></td><td>属性 <code>basePackages</code> 指定扫描哪个包下的类，装配哪些具有 Bean 注解的类 (如 <code>@Component</code>)。若不指定包，则默认扫描配置类所在包。<br />代替 xml 方式中 <code>&lt;context:component-scan base-package=&quot;&quot;&gt;</code> 的作用。</td></tr><tr><td><code>@EnableAspectJAutoProxy</code></td><td>启用 AspectJ 自动生成代理对象，需要设置属性 <code>proxyTargetClass = true</code> (默认为 false) 。<br />代替 xml 方式中 <code>&lt;aop:aspectj-autoproxy&gt;</code> 的作用。</td></tr></tbody></table><p>无需 XML ，而是由 <code>AnnotationConfigApplicationContext</code> 获取 <code>ApplicationContext</code> 实例。 在 <code>TestAOPAnno</code> 中添加如下方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// anno-based aop (complete annotation)</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAopCompleteAnno</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">    <span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;userDaoImpl&quot;</span>, UserDao.class);</span><br><span class="line">    userDao.update();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h4 id="AOP概念具象化"><a href="#AOP概念具象化" class="headerlink" title="AOP概念具象化"></a>AOP概念具象化</h4><p>有了前述 AOP 实现的具体例子，对应具体代码，给出如下具像化描述。</p><table><thead><tr><th>概念</th><th>具象描述</th></tr></thead><tbody><tr><td>切面</td><td>切面类，由切点和通知组合而成，即 <code>UserDaoProxy</code> 类和 <code>VIPUserDaoProxy</code> 类。</td></tr><tr><td>连接点</td><td>可以被增强的主题类 (被代理类) 中的方法，即 <code>UserDaoImpl.update()</code> 。</td></tr><tr><td>通知 (增强&#x2F;建议)</td><td>切面类中的增强方法，即 <code>UserDaoProxy.before()</code>, <code>UserDaoProxy.after()</code> 等。</td></tr><tr><td>切点</td><td>连接点的声明，即切面类中的通知注解，例如 <code>@Before(value = &quot;execution()&quot;)</code> (若是 XML 方式，则为 <code>&lt;aop:pointcut id=&quot;p&quot; expression=&quot;execution()&quot; /&gt;</code>)。<br />又因为切点表达式对应到实际被增强的连接点，所以切点有时也指该连接点，即  <code>UserDaoImpl.update()</code>  。</td></tr><tr><td>引入</td><td>对接口的增强的过程，前述例子不涉及。</td></tr><tr><td>目标类</td><td>主题类 (被代理类)，即 <code>UserDaoImpl</code> 。</td></tr><tr><td>AOP代理</td><td>指经过动态代理后创建出来的代理类的对象，即测试方法中 <code>UserDao userDao = context.getBean(&quot;userDaoImpl&quot;, UserDao.class);</code> 得到的 <code>userDao</code> 。</td></tr><tr><td>织入</td><td>创建增强对象 (代理类对象) 的过程。</td></tr></tbody></table><br /><h3 id="JdbcTemplate"><a href="#JdbcTemplate" class="headerlink" title="JdbcTemplate"></a>JdbcTemplate</h3><br /><h3 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h3><br /><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文主要内容总结如下。</p><table><thead><tr><th>问题</th><th></th></tr></thead><tbody><tr><td>描述 Spring 框架</td><td></td></tr><tr><td>Spring 的优点</td><td></td></tr><tr><td>Spring 的模块组成</td><td></td></tr><tr><td>描述 IoC</td><td></td></tr><tr><td>描述 IoC 容器</td><td></td></tr><tr><td>ApplicationContext 的具体实现类</td><td></td></tr><tr><td>IoC 的实现原理</td><td></td></tr><tr><td>描述 DI</td><td></td></tr><tr><td>Bean 的定义</td><td></td></tr><tr><td>Bean 的管理的含义</td><td></td></tr><tr><td>Bean 管理的方式</td><td></td></tr><tr><td>两种 Bean</td><td></td></tr><tr><td>Bean 的配置元数据</td><td></td></tr><tr><td>Bean 的作用域</td><td></td></tr><tr><td>Bean 的生命周期</td><td></td></tr><tr><td>XML配置文件的内容，主要标签和字段</td><td></td></tr><tr><td>XML配置文件的命名空间</td><td></td></tr><tr><td>注入字段 (DI) 的三种方式</td><td></td></tr><tr><td>注入空值和特殊符号</td><td></td></tr><tr><td>注入外部 Bean 写法</td><td></td></tr><tr><td>注入内部 Bean 写法</td><td></td></tr><tr><td>级联赋值的两种方式</td><td></td></tr></tbody></table><br />]]></content>
      
      
      <categories>
          
          <category> Spring系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring全家桶 </tag>
            
            <tag> Spring5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>红黑树从入门到看开</title>
      <link href="/2022/09/14/%E7%BA%A2%E9%BB%91%E6%A0%91%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%9C%8B%E5%BC%80/"/>
      <url>/2022/09/14/%E7%BA%A2%E9%BB%91%E6%A0%91%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%9C%8B%E5%BC%80/</url>
      
        <content type="html"><![CDATA[<h1 id="红黑树从入门到看开"><a href="#红黑树从入门到看开" class="headerlink" title="红黑树从入门到看开"></a>红黑树从入门到看开</h1><blockquote><ul><li><p>可在作者的 <a href="https://github.com/iyukiyama/leetcode-posts">github仓库</a> 中获取本文和其他文章的 markdown 源文件及相关代码。</p></li><li><p>欢迎评论或仓库 PR 指出文章错漏或与我讨论相关问题，我将长期维护所有文章。</p></li><li><p>所有文章均用 Typora 完成写作，可使用 Typora 打开文章 md 文件，以获得最佳阅读体验。</p></li></ul></blockquote><p>⚠️ ⚠️ ⚠️ <strong>谨以此三万字文章献给有志于彻底掌握红黑树一切细节的朋友。</strong></p><p>❗️ <strong>【NEW】</strong> ❗️</p><ul><li>9-15:  <a href="https://leetcode.cn/circle/discuss/SwgIJV/">红黑树从入门到看开</a></li></ul><p>这是小白 yuki 推出的「树ADT」系列文章的第 6 篇 (6&#x2F;13) 。</p><hr><blockquote><p>$keywords$ :</p><p>2-3树 &#x2F; 2-3-4树 &#x2F; 完美平衡 &#x2F; 完美黑平衡 &#x2F; 结点变换 &#x2F; 旋转 &#x2F; 反色 &#x2F; 红黑树 &#x2F; 红与黑的本质 &#x2F; 红黑树五大性质 &#x2F; 2-3-4树与红黑树同构 &#x2F; 插入结点 &#x2F; 删除结点 &#x2F; 情形归约 &#x2F; JDK TreeMap 源码解析 &#x2F; 左倾红黑树 &#x2F; 2-3树与左倾红黑树同构 &#x2F; 左倾红黑树三大性质</p></blockquote><p>红黑树，向来被认为是最难理解和掌握的常见高级数据结构之一，yuki 在学习过程中也的确深感其难度之大。在耗费巨量时间与无数次长考后，终于总结出一点小小的心得，为了不负已然磨损殆尽的智商和时光，惶恐写就本文。对于 <strong>有志于全面掌握红黑树的读者朋友</strong> ，希望本文能够帮助你更快更平滑以至更彻底地理解红黑树。</p><p>阅读本文前，读者需要掌握 BST (<a href="https://leetcode.cn/circle/discuss/wPzlSb/">二叉查找树</a>) 以及至少一种基于旋转操作的平衡 BST (<a href="https://leetcode.cn/circle/discuss/zbwD3p/">AVL树</a>, <a href="https://leetcode.cn/circle/discuss/BCK17f/">splay树</a>) 。文章主要内容如下。</p><ul><li>本文将依次讲解 <strong>「2-3树与2-3-4树」</strong> 、 <strong>「红黑树」</strong> 以及 <strong>「左倾红黑树」</strong> 。</li><li>在「2-3树与2-3-4树」章节中指出该平衡 BST 相比之前介绍过过其他平衡 BST (<a href="https://leetcode.cn/circle/discuss/zbwD3p/">AVL树</a>, <a href="https://leetcode.cn/circle/discuss/BCK17f/">splay树</a>) 的优点。</li><li>指出「2-3树与2-3-4树」情形多样，编程复杂的缺点，并以保持其优点规避其缺点为目标，引入「红黑树」。</li><li>在「红黑树」章节中指出红黑树是保持 BST 形态的2-3-4树的「同构」，而 <strong>保证「同构」的根本是 BST 结点的红黑颜色信息</strong> 。</li><li>深入讨论了 <strong>红黑颜色的本质</strong> ，以及从该颜色信息出发如何得到 <strong>红黑树的五大性质</strong> 。</li><li>详细讲解了 <strong>红黑树的结点插入与结点删除操作</strong> ，尤其是后者。在「删除结点」操作中列出了 42 种2-3-4树上的结点删除情形，并通过一系列细心的对比分析，归约出 4 种独立情形。该方法于他处未曾见， <strong>应当是 yuki 的一小创新</strong> 。逐情形对比2-3-4树与红黑树以及归约大量情形的做法，相比单纯基于红黑树性质的分析 (算法导论的做法) 要更具象，使我们能够清晰地了解删除结点每一步动作的目的，并确信 4 种独立情形即可覆盖所有可能的情况。</li><li>指出 JDK 源码的一处疑似有瑕疵的写法，并给出逻辑更恰当的改进写法。</li><li>给出了「红黑树」的较为完整的类实现代码。</li><li>在「左倾红黑树 (LLRBT)」章节中指出 Sedgewick 是如何通过一条简单的规则 ( <strong>3-结点左倾约束</strong> ) 完成对经典红黑树天才般的改造。</li><li>详细讲解了 <strong>LLRBT 的结点插入与结点删除操作</strong> ，尤其是后者。在3-结点左倾约束的指导下，反色及旋转的奇妙配合使 LLRBT 插入结点和删除结点的操作相比经典红黑树要轻盈许多。</li><li>给出了「LLRBT」的较为完整的类实现代码。</li></ul><p>说实话红黑树的难度本来并不是小白 yuki 能够驾驭的，但奈何人菜瘾大，为此着实苦苦求索了一段时间，因此文章中有所错漏几乎是不可避免的，欢迎读者朋友们批评指正！</p><p>另外，本文原题 「红黑树 (树ADT连载 6&#x2F;13)」，十分干瘪，不太符合作者沉稳中又略带一点玩世不恭的气质，遂改为现标题。<strong>「看开」表示作者的一种态度</strong>，即看完本文，若仍不能掌握红黑树，那就算了，就像钱钟书说的，大不了一棵红黑树，实在不值得如此殚精竭虑。</p><hr><p>yuki的其他文章如下，欢迎阅读指正！</p><blockquote><p>如下所有文章同时也在我的 github <a href="https://github.com/iyukiyama/leetcode-posts">仓库</a> 中维护。</p></blockquote><table><thead><tr><th>文章</th><th>[发布时间] 字数&#x2F;览&#x2F;藏&#x2F;赞 (~2022-10-20)</th></tr></thead><tbody><tr><td><a href="https://leetcode.cn/circle/discuss/eBo9UB/">十大排序从入门到入赘</a>  🔥🔥🔥</td><td>[20220516]  2.5万字&#x2F;64.8k览&#x2F;3.7k藏&#x2F;937赞</td></tr><tr><td><a href="https://leetcode.cn/circle/discuss/ooxfo8/">二分查找从入门到入睡</a> 🔥🔥🔥</td><td>[20220509]  2.3万字&#x2F;38.4k览&#x2F;2.1k藏&#x2F;503赞</td></tr><tr><td><a href="https://leetcode.cn/circle/discuss/qmjuMW/">并查集从入门到出门</a> 🔥🔥</td><td>[20220514]  1.2万字&#x2F;17.9k览&#x2F;1.0k藏&#x2F;321赞</td></tr><tr><td><a href="https://leetcode.cn/circle/discuss/FyPTTM/">图论算法从入门到放下</a> 🔥🔥</td><td>[20220617]  5.6万字&#x2F;19.9k览&#x2F;1.3k藏&#x2F;365赞</td></tr><tr><td>树ADT系列 (预计13篇)</td><td>系列文章，连载中</td></tr><tr><td>3. <a href="https://leetcode.cn/circle/discuss/wPzlSb/">二叉查找树</a></td><td>[20220801]  5千字</td></tr><tr><td>4. <a href="https://leetcode.cn/circle/discuss/zbwD3p/">AVL树</a></td><td>[20220817]  5千字</td></tr><tr><td>5. <a href="https://leetcode.cn/circle/discuss/BCK17f/">splay树</a></td><td>[20220817]  5千字</td></tr><tr><td>6. <a href="https://leetcode.cn/circle/discuss/SwgIJV/">红黑树从入门到看开</a> 🔥🤯🤯🤯</td><td>[20220915]  3万字&#x2F;5.3k览&#x2F;269藏&#x2F;72赞</td></tr><tr><td>10. <a href="https://leetcode.cn/circle/discuss/qGREiN/">树状数组从入门到下车</a> 🔥🤯</td><td>[20220722]  1.4万字&#x2F;5.8k览&#x2F;196藏&#x2F;72赞</td></tr><tr><td>11. <a href="https://leetcode.cn/circle/discuss/H4aMOn/">线段树从入门到急停</a> 🔥🤯</td><td>[20220726]  2.5万字&#x2F;8.7k览&#x2F;481藏&#x2F;138赞</td></tr><tr><td><a href="https://leetcode.cn/circle/discuss/GV0JrV/">图论相关证明系列</a></td><td>系列文章</td></tr><tr><td>1. <a href="https://leetcode.cn/circle/discuss/jJQn7V/">Dijkstra正确性证明</a> 🤯</td><td>[20220531]</td></tr><tr><td>2. <a href="https://leetcode.cn/circle/discuss/VVEc8f/">Prim正确性证明</a> 🤯</td><td>[20220919]</td></tr><tr><td>3. <a href="https://leetcode.cn/circle/discuss/xeEwYl/">Bellman-Ford及SPFA正确性证明</a></td><td>[20220602]</td></tr><tr><td>4. <a href="https://leetcode.cn/circle/discuss/Nbzix4/">Floyd正确性证明</a></td><td>[20220602]</td></tr><tr><td>5. <a href="https://leetcode.cn/circle/discuss/tMIy36/">最大流最小割定理证明</a> 🤯🤯</td><td>[20220719]</td></tr><tr><td>6. <a href="https://leetcode.cn/circle/discuss/tN3sZc/">Edmonds-Karp复杂度证明</a> 🤯🤯</td><td>[20220515]</td></tr><tr><td>7. <a href="https://leetcode.cn/circle/discuss/T9Xa1R/">Dinic复杂度证明</a> 🤯🤯</td><td>[20220531]</td></tr></tbody></table><hr><p>[TOC]</p><hr><h2 id="2-3树与2-3-4树"><a href="#2-3树与2-3-4树" class="headerlink" title="2-3树与2-3-4树"></a>2-3树与2-3-4树</h2><blockquote><p>一切妄图脱离2-3-4树来理解「红黑树」的努力都是徒劳的。–– <em>yukiyama</em></p></blockquote><p>在 <a href="https://leetcode.cn/circle/discuss/zbwD3p/">AVL树</a> 和 <a href="https://leetcode.cn/circle/discuss/BCK17f/">splay树</a> 两篇文章中，我们介绍了两种平衡二叉树的实现，其中AVL树通过跟踪并动态维护树的高度信息在每次操作后 <strong>严格保持树平衡</strong> ，而伸展树无需维护树的高度信息，而是通过 <strong>「展开」</strong> 降低多次操作的摊还时间复杂度。这两种平衡树的基础均为 <strong>「旋转」</strong> 操作，通过旋转来调整局部树高使树保持平衡或趋向平衡。本节我们介绍的2-3树和2-3-4树也是平衡树，但它不基于「旋转」操作，而是通过 <strong>动态地调整结点容量</strong> 来实现平衡。</p><p>在二叉树中，每一个结点最多只有两个子结点，当某结点拥有两个子结点时，称其为 <strong>2-结点</strong> ，其持有一个数据项以及两个子结点。2-3树和2-3-4树不是二叉树，因为前者除了2-结点外，还可以有 <strong>3-结点</strong>  (3-结点持有两个数据项以及三个子结点) ， 后者除了2-结点和3-结点外，还有 <strong>4-结点</strong>  (4-结点持有三个数据项以及四个子结点) 。后续我们将看到2-3树和2-3-4树如何通过结点之间的动态变换来保持平衡。</p><p><img src="https://pic.leetcode-cn.com/1657339600-LLHCyV-image.png" alt="image.png"></p><blockquote><p>「算法导论」称 <a href="https://en.wikipedia.org/wiki/John_Hopcroft"> John Hopcroft</a> 于1970 发明2-3树 (未发表)。</p><p>本节部分内容为 Robert Sedgewick &amp; Kevin Wayne 所著「算法: 第4版」相关章节的整理和总结。</p></blockquote><br /><h3 id="2-3树"><a href="#2-3树" class="headerlink" title="2-3树"></a>2-3树</h3><p>一棵2-3树的结点分为 <strong>内部结点</strong> (<em>internal nodes</em>) 和 <strong>叶子结点</strong>  (<em>leaf nodes</em>) ，定义如下。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">内部结点:</span><br><span class="line">  2-结点: 拥有1个数据项x，2个子结点。</span><br><span class="line">    -左子树中任意结点数据项均小于x。</span><br><span class="line">    -右子树中任意结点数据项均大于x。</span><br><span class="line">  3-结点: 拥有2个数据项x,y，3个子结点。</span><br><span class="line">    -左子树中任意结点数据项均小于x。</span><br><span class="line">    -中间子树中任意结点数据项均介于x与y之间。</span><br><span class="line">    -右子树中任意结点数据项均大于y。</span><br><span class="line">叶子结点: 无子结点，数据项为 1 项或 2 项。</span><br></pre></td></tr></table></figure><p>后续我们会看到，在2-3树的操作过程中，可能会「临时」产生一些4-结点。如下是一棵典型的2-3树。</p><p><img src="https://pic.leetcode-cn.com/1656589324-UbHgKh-image.png" alt="image.png"></p><br /><h4 id="结点变换"><a href="#结点变换" class="headerlink" title="结点变换"></a>结点变换</h4><p>2-3树实现平衡的基础在于 <strong>「结点变换」</strong> ，不同情形的「插入」很好地体现了不同的变换，下面我们通过插入操作来了解2-3树结点变换的过程。</p><p>执行插入方法之前首先要执行 $find$ 方法，当待插入结点不存在时执行插入操作。查找操作与基本 BST 的不同在于3-结点存在 2 个数据项，因此需要比较两次来确定下一步要去往该结点的左、中、还是右子树。与 BST 类似， <strong>插入总是在树的底部执行</strong> ，略有不同的是， BST 中待插入对象总是作为叶子结点插入，而在2-3树中，若作为叶子结点插入会破坏2-3树的 <strong>完美平衡</strong> ，所谓完美平衡指 <strong>2-3树的所有叶子结点到根结点的路径长度相同</strong> 。实际上该数据结构3-结点的设计就是为了容纳待插入对象，使树能够保持完美平衡，因此待插入对象总是被插入到一个叶子结点中，但这又带来下面2中的问题。</p><ol><li><p>若该叶子结点为2-结点，可直接插入，此结点变为3-结点。</p></li><li><p>若该叶子结点为3-结点，插入后变为4-结点，不符合2-3树的定义。</p></li></ol><p>因此对于2，需要进行「结点变换」以使得插入后的树仍是一棵完美平衡的2-3树，我们通过下表和示意图分析不同插入情形所对应的结点变换过程。</p><table><thead><tr><th>情形</th><th>具体过程</th></tr></thead><tbody><tr><td>1. 插入至2-结点中</td><td>插入后变为3-结点</td></tr><tr><td>2. 插入至3-结点中<br />(该结点为根结点)</td><td>插入后变为4-结点，然后分解为3个2-结点。(树高+1)</td></tr><tr><td>3. 插入至3-结点中<br />(父结点为2-结点)</td><td>插入后变为4-结点，然后分解为3个2-结点，但其中一个与父结点合并，使得父结点变为3-结点</td></tr><tr><td>4. 插入至3-结点中<br />(父结点为3-结点)</td><td>与上一条类似，但父结点变为4-结点，继续向上 (送入一个结点后) 分解直到：<br />1. 遇到2-结点，转变为情形1。<br />2. 到根处仍为3-结点，最终为情形2。</td></tr></tbody></table><p>下图展示了从左至右依次为情形1,2,3,4。</p><p><img src="https://pic.leetcode-cn.com/1656589879-xmBWVS-image.png" alt="image.png"></p><p>我们看到，2-3树的插入过程十分简单，并且从中容易看出2-3树保持平衡的关键所在。在插入的过程中，若插入3-结点，则通过向上变换有机会找到一个2-结点，2-结点膨胀为3-结点将插入对象「消化」在其中，树高不变，只有向上变换到根结点处仍不能消化时，通过分解变换，树高才会增长 1，而这个增长使得 <strong>所有叶子结点</strong> 到根结点的路径长度 <strong>同时增加 1</strong> ，因此2-3树能够保持平衡，并且是 <strong>完美平衡</strong> 的。我们还能感到树高的增长是缓慢的，因为在插入过程中的4-结点裂变为3个2-结点时，提高了之后的「消化能力」，使得向上变换不容易到达当前根结点使树长高。在稍后的「小结」中，我们会具体计算树高 $h$ 与结点数 $n$ 的关系。</p><br /><h3 id="2-3-4树"><a href="#2-3-4树" class="headerlink" title="2-3-4树"></a>2-3-4树</h3><h4 id="结点变换-1"><a href="#结点变换-1" class="headerlink" title="结点变换"></a>结点变换</h4><p>在理解了2-3树的基础上，2-3-4树的学习是简单的，因为后者只不过比前者多了一种4-结点。2-3-4树保持平衡的关键也是「结点变换」，过程类似，如下表。</p><table><thead><tr><th>情形</th><th>具体过程</th></tr></thead><tbody><tr><td>1. 插入至2-结点或3-结点中</td><td>插入后变为3-结点或4结点</td></tr><tr><td>2. 插入至4-结点中<br />(该结点为根结点)</td><td>4-结点先分解为3个2-结点后 (树高+1) 再插入。</td></tr><tr><td>3. 插入至4-结点中<br />(父结点为2-结点)</td><td>4-结点先分解为3个2-结点，其中一个与父结点合并，使得父结点变为3-结点，然后再插入。</td></tr><tr><td>4. 插入至4-结点中<br />(父结点为3-结点)</td><td>4-结点先分解为3个2-结点，其中一个与父结点合并，使得父结点变为4-结点，然后再插入。</td></tr><tr><td>5. 插入至4-结点中<br />(父结点为4-结点)</td><td>与上一条类似，但父结点变为5-结点，继续向上 (送入一个结点后) 分解直到：<br />1. 遇到2-结点或3-结点，转变为情形1。<br />2. 遇到4-结点，继续上送。<br />3. 到根处仍为4-结点，转变为情形2。</td></tr></tbody></table><p>插入4-结点可以统一描述为：该4-结点分解为3个2-结点，将其中一个上送后 (与该4-结点的父结点结合为3-结点或4-结点或5-结点)，待插入结点插入到分解后的左子结点或右子结点中。</p><p>如下示意图中，$x$ 表示插入的键，为了方便表示，其他键都用「口」表示，但它们是不同的，且符合大小顺序的要求。从这个示意图中可直观地看到插入至2-结点&#x2F;3-结点&#x2F;4-结点后的变化。插入4-结点时，分解后的父结点用虚线框表示上送的结点可能插入2-结点&#x2F;3-结点&#x2F;4-结点。通过这个示意图我们发现2-3-4树的插入是非常简单的，读者需要准确地理解各个情形的过程，因为后续的「红黑树」的插入过程，将完全以这张图为基础对照说明。</p><p>※ 在「插入4-结点」情形中，我们无需仔细讨论虚线框中的 「..口..」具体是3-结点&#x2F;4-结点&#x2F;5-结点的哪种情形，当对应到红黑树后我们将看到无论是哪种情形，都只需要简单反色后继续上溯考察重复同样的过程即可。若读者不放心，可以列出分解后由于上送一个结点使得「..口..」分别为3-结点&#x2F;4-结点&#x2F;5-结点的情形加以分析。其中若为3-结点&#x2F;4-结点，则上送一次即结束，若为5-结点，则继续上送结点并重复同样的考察。</p><p><img src="https://pic.leetcode-cn.com/1656929234-TWNvow-image.png" alt="image.png"></p><br /><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>现在我们来考虑2-3树中结点数 $n$ 与树高 $h$ 的关系。当一棵具有 $n$ 个结点的2-3树的所有结点均为2-结点时，树高最高，所有结点均为3-结点时，树高最低。因此有：<br>$$<br>2^{h+1}-1 \leq n \leq \frac{3^{h+1}-1}{2}<br>$$</p><p>$$<br>log _{3}(2n+1)-1\leq h \leq \log _{2}(n+1)-1<br>$$</p><p>即树高 $h$ 为 $O(logn)$ ，从这个角度也可以看出2-3树是平衡的，且之前我们分析过，它是完美平衡的，主要操作的最坏时间复杂度均为 $O(logn)$ 。2-3-4树的分析类似，略。</p><p>相比 AVL 树，2-3树&#x2F;2-3-4树在无需通过树高信息跟踪树的平衡状态的情况下就保持了完美平衡，相比伸展树，2-3树&#x2F;2-3-4树总是能 <strong>稳定地保持平衡</strong> ，因此它们应当是十分理想的平衡树方案，但在本节中我们未给出具体实现，这是因为需要处理的情况较多，代码编写复杂，对不同情况的判断和处理会产生许多额外的开销，因此虽然理论上很理想，在实践中却几乎不被使用。但理解这两者是异常重要的，因为一种被广泛应用的称作「红黑树」的平衡 BST 正是以其思想为基础，更确切地，我们指出 –– <strong>经典红黑树与2-3-4树同构 (isomorphic)，左倾红黑树与2-3树同构</strong> 。在后续的「红黑树」与「左倾红黑树」章节中，我们将分析如何根据一些简单的规则将2-3-4树构造成经典红黑树，将2-3树构造成左倾红黑树，并给出它们的具体实现，同时我们将会看到红黑树&#x2F;左倾红黑树如何兼顾2-3-4树&#x2F;2-3树和 BST 两者的优点。</p><br /><h2 id="经典红黑树"><a href="#经典红黑树" class="headerlink" title="经典红黑树"></a>经典红黑树</h2><p>有了2-3树&#x2F;2-3-4树的知识铺垫后，本节我们学习在实践中被广为应用的 **「红黑树 (<em>red-black tree)<em>」</em></em> 。区别于主要基于2-3树的「左倾红黑树」，本节讲解的是基于2-3-4树的 <strong>「经典红黑树」</strong> 。</p><p>在前文中我们提到过红黑树是2-3-4树的同构，本节我们将看到如何通过两条简单的规则将2-3-4树转变为红黑树。首先，红黑树是一棵 BST ，相比基本 BST，它通过附加的 <strong>1bit 信息 (颜色) 和旋转操作</strong>，实现在保持 BST 结构的基础上始终与2-3-4树同构，因此它既能沿用基本 BST 的许多操作，同时也能够保持 2-3-4树「完美平衡」(在红黑树中为 <strong>「完美黑平衡」</strong> ) 的优点。</p><blockquote><p>注意：虽然2-3树和2-3-4树无旋转操作，但基于它们的经典红黑树和左倾红黑树涉及旋转操作，因此读者要确保完全理解旋转操作后再继续阅读后文。</p><p>红黑树由 <a href="https://en.wikipedia.org/wiki/Rudolf_Bayer">Rudolf Bayer</a> 发明于 1972 年的<a href="https://link.springer.com/article/10.1007/BF00289509">此篇论文</a> 中，并称此数据结构为「对称二叉B树 (<em>symmetric binary B-tree</em>)」。「红黑树」这一称呼则由 <a href="https://en.wikipedia.org/wiki/Leonidas_J._Guibas">Leonidas J. Guibas</a> 和 <a href="https://en.wikipedia.org/wiki/Robert_Sedgewick_(computer_scientist)">Robert Sedgewick</a> 在<a href="https://ieeexplore.ieee.org/document/4567957/">此论文</a>中提出。</p></blockquote><br /><h3 id="从2-3-4树到红黑树"><a href="#从2-3-4树到红黑树" class="headerlink" title="从2-3-4树到红黑树"></a>从2-3-4树到红黑树</h3><h4 id="两条规则-定义"><a href="#两条规则-定义" class="headerlink" title="两条规则 (定义)"></a>两条规则 (定义)</h4><p>只需按照如下规则 (也可视作红黑树的定义) 即可将2-3-4树转换为红黑树。显然红黑树与2-3-4树严格对应，因此说它们是 <strong>同构</strong> 的。</p><ol><li>所有3-结点转换为由红链链接的两个结点 (左斜或右斜均可)，该链的父结点为黑色，子结点为红色。</li><li>所有4-结点转换为两条构成「^」形状的红链，两个子结点为红色，父结点为黑色。</li></ol><p>下图展示了2-3-4树及其对应的红黑树 (红黑树结点未标数字，对照原2-3-4树即可知道每一个结点的数字)，中间的红黑树将红链横放，虚线框住的单条红链即为一个3-结点，两条相邻红链即为一个4-结点后， <strong>红黑树与2-3-4树严格对应</strong> 的关系清晰可见。</p><p>※ 关于「链的颜色」: 除根结点外，树上的每个结点都有一条来自父结点的链指向它，因此我们可以把链也涂上颜色，链的颜色与它唯一指向的结点的颜色相同。</p><p><img src="https://pic.leetcode-cn.com/1656829242-uMxXGa-image.png" alt="image.png"></p><br /><h4 id="红与黑"><a href="#红与黑" class="headerlink" title="红与黑"></a>红与黑</h4><p>通过上述定义和对应关系，我们指出红黑树颜色的本质：</p><blockquote><p>红与黑的本质是在原 BST 结点的基础上附加的 1bit 信息，该比特位使得2-3-4树在展成 BST 的情况下仍能保持与原2-3-4树同构，也就是通过查询结点的红与黑标记即能还原这些结点在原2-3-4树中所对应的结点 (2-结点&#x2F;3-结点&#x2F;4-结点)。</p></blockquote><p>可见红与黑只不过是这 1bit 信息的具体化，实际上在程序中通常用布尔值来表达，并且规定 $BLACK &#x3D; true, RED &#x3D; false$，或相反，还可以用数字 1 和 0 来表达，只要体现出这 1bit 信息即可。红与黑也只不过是命名人的一种选择，在 wiki 词条中介绍了当年 Guibas 和 Sedgewick 将该2-3-4树的同构命名为红黑树的原因。不得不说「红黑」的表达确实令人印象深刻。</p><blockquote><p>In a 1978 paper, “A Dichromatic Framework for Balanced Trees”, <a href="https://en.wikipedia.org/wiki/Leonidas_J._Guibas">Leonidas J. Guibas</a> and <a href="https://en.wikipedia.org/wiki/Robert_Sedgewick_(computer_scientist)">Robert Sedgewick</a> derived the red–black tree from the symmetric binary B-tree. The color “red” was chosen because it was the best-looking color produced by the color laser printer available to the authors while working at <a href="https://en.wikipedia.org/wiki/Xerox_PARC">Xerox PARC</a>. Another response from Guibas states that it was because of the red and black pens available to them to draw the trees.</p></blockquote><p>现在我们再回到前述两条规则。</p><ul><li>对于规则1，其本质是用两个颜色相异的结点表达2-3-4树中的3-结点，若颜色相同，则等同于失去该信息 (「信息」的本质，单纯相同无信息，单纯相异也无信息，可相同可相异，有了变化和对比才有信息)，也就无法表达3-结点 (只能表达2-结点)。子结点为红，父结点为黑只是一种规定，完全可以规定子为黑父为红 (只要相异即可)，只不过如上面引用的 wiki 中的文字所说，红色醒目，用以提示多键结点 (3-结点&#x2F;4结点) 是更自然的选择。</li><li>对于规则2，我们指出，4-结点转换为 BST 中的「 <code>^</code> 」形结构是一种 <strong>更恰当的人为选择</strong> ，因为我们完全可以把4-结点转换成3个在一条直线上的结点，而不破坏 BST 的结点有序性质。如下图，我们把前面2-3-4树例子中两处 4-结点分别展成「<code>/</code>」形和「<code>\</code>」形，如下，不难看出该 (与规则2不符的) 「红黑树」仍然满足 BST 的性质 (可填入数字验证)，并且也是完美黑平衡的，只不过相比「 <code>^</code> 」形更不平衡 (针对 BST 形态而言)，且用「 <code>^</code> 」表达4-结点只需这一种形态，而「<code>/</code>」和「<code>\</code>」却是两种形态。你可能看到过 <strong>「红黑树中不允许出现两个连续红结点」</strong> 、<strong>「红黑树红结点的子结点必为黑结点」</strong> 、<strong>「红黑树红结点的父结点必为黑结点」</strong> 之类的描述，原因就在于我们选择了更恰当的「<code>^</code>」形来表达4-结点，从而使得红黑树中不存在两个连续红结点的情况。</li></ul><p><img src="https://pic.leetcode-cn.com/1656832645-LUrWPn-image.png" alt="image.png"></p><p>总之，在红黑树中，一对 <strong>父黑子红</strong> 的结点就对应着2-3-4树中的3-结点，除非这个父结点的另一个孩子结点也是红，那么这三个父子子结点就对应着2-3-4树中的4-结点。更一般的描述是，红黑树通过 <strong>子结点和父结点的颜色关系</strong> 来将具体的红黑结点与2-3-4树中的2-结点&#x2F;3-结点&#x2F;4-结点相对应，具体如下。</p><ul><li><p>2-结点：当一个黑结点不存在红子结点时，它就是2-3-4树中的一个2-结点。</p></li><li><p>3-结点：当一个黑结点只有一个红子结点时 (可以有两个子结点，但有且只有一个红子结点)，这对父黑子红结点构成2-3-4树中的一个3-结点。</p></li><li><p>4-结点：当一个黑结点存在两个红子结点时，这三个结点构成2-3-4树中的一个4-结点。</p></li></ul><p> <strong>除上述情形外，不存在其他情形。</strong> 下图三行示意图分别是红黑树对应2-3-4树中的2-结点&#x2F;3-结点&#x2F;4-结点的不同情形。</p><p><img src="https://pic.leetcode-cn.com/1656833806-CRJKvV-image.png" alt="image.png"></p><br /><h4 id="五大性质"><a href="#五大性质" class="headerlink" title="五大性质"></a>五大性质</h4><p>在理解红黑树定义及红黑颜色的本质后，我们指出红黑树具有以下性质。</p><table><thead><tr><th>五大性质</th><th>描述</th></tr></thead><tbody><tr><td>1. 颜色</td><td>红黑树的结点或者为黑色或者为红色。</td></tr><tr><td>2. 根结点</td><td>根结点为黑色。</td></tr><tr><td>3. null结点</td><td>叶子结点的null子结点(上图未画出，通常都不会画出)为黑色。</td></tr><tr><td>4. 不可连续红</td><td>红色结点的子结点为黑色。</td></tr><tr><td>5. 完美黑平衡</td><td>红黑树是「完美黑平衡」的，即任意叶子结点到根结点所经过的黑链数相同。</td></tr></tbody></table><p>※ 注意，「算法导论」中「红黑树」一章的「叶子结点」指的是我们通常所理解的叶子结点 (有实际意义值的末端结点) 的 null 子结点。从该书的图13-1(a)可看出。</p><p>对于这五大性质，我们进一步有如下解释。</p><ul><li>对于1，红黑颜色即前述 1bit 信息，使得2-3-4树转换为 BST 后仍能严格表达原2-3-4树，即这是红黑树与2-3-4树同构所要求的。</li><li>对于2，假设在原2-3-4树中根结点是一个3-结点或4-结点，按照定义 (规则1和2)，根结点必须为黑色，否则形成两个相邻的红色结点。又或红黑树只有根结点，若为红，则单个红色结点无意义，而单个黑结点有意义。</li><li>对于3，当叶子结点为红色时，若其 null 子结点为红色，则形成两个相邻的红色结点，违反定义，所以 null 子结点必须为黑色。</li><li>对于4，两个相邻红结点违反定义。</li><li>对于5，因为2-3-4树是完美平衡的，转换成红黑树后，不考虑红链 (本质为3-结点或4-结点) 的情况下 (即只考虑黑链，回想一下红链横放的图示) 是完美平衡的，于是对整棵红黑树，我们称其 <strong>完美黑平衡</strong> 。</li></ul><p>如果把红黑树的性质看作某种理论系统，那么这个系统完全是从一条公理出发得到的，我们姑且称之为 1bit 公理，前面已叙述过，此处再次概括如下。</p><blockquote><p>1bit 红黑信息使 BST 形态的红黑树与2-3-4树同构。</p></blockquote><p>本节开头的规则1和规则2都是这一公理的具体体现 (规则2中人为选择了更恰当的「^」形) 。而前述所谓红黑树的五大性质都是遵从两条规则得到的，因此也可以说这五大性质是从这个 1bit 公理出发得到的 (第5条是对2-3-4树固有性质的继承，但也是因为 1bit 公理使得红黑树与2-3-4树同构所具有的)。换言之，1bit 公理对红黑树系统来说是完备的。</p><p>我们不厌其烦地强调2-3-4树与红黑树的对应关系，并且深入理解红黑的本质，目的都是为了在之后的红黑树实现中，能够更清晰地看出红黑树的各种操作，本质上都是为了保持与2-3-4树同构。若能在脑海中自如地切换红黑树与2-3-4树，理解红黑树将不再困难。</p><br /><h3 id="结点变换-2"><a href="#结点变换-2" class="headerlink" title="结点变换"></a>结点变换</h3><p>现在，我们深刻地理解了红黑树与2-3-4树的严格对应关系，因此我们也可以确定其保持平衡的操作必然 <strong>与2-3-4树严格对应</strong> ，我们已经知道，2-3-4树是通过「结点变换」来保持平衡的，之前我们通过考察2-3-4树结点插入过程分析过其结点变换过程，在本节中我们采用对照的方式，首先考察红黑树插入结点过程中的结点变换 (保持与2-3-4树同构的操作，即变色及旋转)，然后考察在2-3-4树中未涉及的删除结点过程的结点变换，后者相比前者要复杂得多。</p><br /><h4 id="插入结点"><a href="#插入结点" class="headerlink" title="插入结点"></a>插入结点</h4><h5 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h5><p>在「红黑树保持平衡的操作与2-3-4树严格对应」这一结论的指导下，我们很容易按照2-3-4树插入情形，一边对照着画出两种树的插入过程 (后续三张图)，一边写下如下红黑树与之对应的变换过程。</p><table><thead><tr><th>情形</th><th>2-3-4树</th><th>红黑树</th></tr></thead><tbody><tr><td>1. 插入至2-结点</td><td>变为 <strong>3-结点</strong></td><td>变为 <strong>红链</strong> (左斜或右斜)</td></tr><tr><td>2. 插入至3-结点</td><td>变为 <strong>4-结点</strong></td><td>变为两条相邻的 <strong>红链</strong>，<br />若原3-结点左斜，则可能构成 <code>^, /, &lt;</code> 三种形态之一<br />若原3-结点右斜，则可能构成 <code>^, \, &gt;</code> 三种形态之一<br />非「^」形要调整为「 ^ 」形</td></tr><tr><td>3. 插入至4-结点中<br />(该结点为根结点)</td><td>4-结点先 <strong>分解</strong> 为3个2-结点后 (树高+1) 再插入。</td><td>4-结点 (2-3-4树) 中的3个结点 (红黑树) 各自反色即完成分解，然后插入</td></tr><tr><td>4. 插入至4-结点中<br />(父结点为2-结点)</td><td>4-结点先分解为3个2-结点，其中一个与父结点合并，使得父结点变为3-结点，然后再插入。</td><td>同上</td></tr><tr><td>5. 插入至4-结点中<br />(父结点为3-结点)</td><td>4-结点先分解为3个2-结点，其中一个与父结点合并，使得父结点变为4-结点，然后再插入。</td><td>同上</td></tr><tr><td>6. 插入至4-结点中<br />(父结点为4-结点)</td><td>与上一条类似，但父结点变为5-结点，继续向上 (送入一个结点后) 分解直到：<br />1. 遇到2-结点或3-结点，转变为情形1或情形2。<br />2. 遇到4-结点，继续上送。<br />3. 到根处仍为4-结点，转变为情形3。</td><td>同上</td></tr></tbody></table><p>这里有必要强调待插入结点的颜色，对应到2-3-4树中，结点一定会被插入到2-结点&#x2F;3-结点&#x2F;4-结点其中之一，从后续「插入调整」中的三张图中容易看出，无论哪种情形，插入后 $x$ 必须为红结点才符合定义，因此总是 <strong>将待插入结点其作为红结点插入</strong> 。</p><p>※ 除非当前树为空，此时插入结点将作为新的根结点，其为黑色，为统一操作，在程序实现上仍然将其作为红色结点插入，最后 $root$ 会执行置黑的操作。</p><br /><h5 id="插入调整"><a href="#插入调整" class="headerlink" title="插入调整"></a>插入调整</h5><p>现在我们具体分析插入结点后的调整操作。</p><p><strong>■ 插入2-结点 (2变3)</strong></p><p>如下，<strong>若在一黑结点下插入，且该黑结点没有红子结点时</strong>，那么这个黑结点就代表了2-结点，也就是此时我们会将 $x$ 插入一个2-结点，因此 $x$ 可直接插入。根据 $x$ 与该2-结点数据项大小关系，有左斜或右斜两种可能。</p><p><img src="https://pic.leetcode-cn.com/1656929918-vMjeLz-image.png" alt="image.png"></p><p><strong>■ 插入3-结点 (3变4)</strong></p><p>如下图。</p><ul><li><strong>若在一红色结点下插入，且该红结点不存在红色兄弟结点时</strong>，那么这个红结点就代表了3-结点 (与它的黑父结点构成3-结点)，因此 $x$ 可直接插入此3-结点。</li><li><strong>若在一黑色结点下插入</strong>，则为左下和右上两种「^」情形，也属于插入3-结点情形。</li></ul><p>如我们在上一张表格中所述，插入3-结点将产生两条相邻的红链，若原红链左斜，则可能构成 「<code>^,&lt;,/</code> 」形态之一，若原红链右斜，则可能构成「<code>^,&gt;,\</code>」 形态之一，共有 6 种情形 (下图表现红黑树的 6 个格子)，5种形态。其中，「^」形态的两种情形无需调整，其他情形需要经过如图的旋转和反色操作调整为符合 <strong>规则2</strong> 要求的「 ^ 」形态。可以看到，在左斜3-结点下插入与在右斜3-结点下插入是完全对称的，在代码分析中我们会看到镜像情形的代码只需简单修改即可。</p><p>对于两种无需处理的「^」情形，结合「插入2-结点」的情形，有此结论：<strong>当待插入结点在一黑色结点下插入时，直接插入而无需其他处理</strong>。</p><p><img src="https://pic.leetcode-cn.com/1657018538-WyYnys-image.png" alt="image.png"></p><p><strong>■ 插入4-结点 (4分解为三个2-结点后其中一个2变3)</strong></p><p>如下，<strong>若在一红色结点下插入，且该红结点有一红色兄弟结点时</strong>，那么这个红结点就代表了4-结点 (与它的黑父结点以及红色兄弟结点构成4-结点)，也就是此时我们会将 $x$ 插入一个4-结点，通过下图，<strong>与2-3-4树对照</strong> ，我们发现，插入4-结点只需将原4-结点的3个结点各自反色即可，简单得令人惊讶。由于上送结点可能需要上溯调整，因此反色后要置 $x &#x3D; x.parent.parent$  并继续考察 $x$ ，后续请读者结合伪代码和相应的代码理解。</p><p><img src="https://pic.leetcode-cn.com/1656931544-tbgsJV-image.png" alt="image.png"></p><p>从上述对照分析中我们发现红黑树的插入确实完美地与2-3-4树一一对应，观察这样的对应甚至可以说是赏心悦目的。除了插入3-结点需要对其中的 4 种情况稍作处理外  (其余两种「^」直接插入) ，插入2-结点和插入4-结点都十分简单。前面三张图片是按插入2-3-4树中哪一种结点分类分析的，实际编写代码时，我们要 <strong>按照插入 BST 形式的红黑树</strong> 来编写，因此还需稍作整理如下。</p><blockquote><p>下表中的case1&#x2F;2&#x2F;3即为「算法导论」第13章 RB-INSERT-FIXUP(T, z) 伪代码中的 case1&#x2F;2&#x2F;3。</p></blockquote><p>【插入结点的父结点为一左子结点】</p><table><thead><tr><th>情形</th><th>2-3-4树情形</th><th>红黑树情形</th></tr></thead><tbody><tr><td>case0</td><td>插入2-结点 &amp; 插入3-结点的黑父结点之下的情形</td><td>在黑结点下插入: 直接插入</td></tr><tr><td>case1</td><td>插入4-结点</td><td>在红结点下插入，且该结点有红色兄弟结点 (插入结点的叔结点) <br />原4-结点的3个结点反色</td></tr><tr><td>case2</td><td>插入3结点，「&lt;」形</td><td>在红结点下插入，且该结点无红色兄弟结点  (插入结点的叔结点)<br />插入结点为右子结点: <br />下段左旋&gt;反色&gt;上段右旋</td></tr><tr><td>case3</td><td>插入3结点，「&#x2F;」形</td><td>在红结点下插入，且该结点无红色兄弟结点  (插入结点的叔结点)<br />插入结点为左子结点: <br />反色&gt;上段右旋</td></tr></tbody></table><p>【插入结点的父结点为一右子结点】</p><table><thead><tr><th>情形</th><th>2-3-4树情形</th><th>红黑树情形</th></tr></thead><tbody><tr><td>case0</td><td>插入2-结点 &amp; 插入3-结点的黑父结点之下的情形</td><td>在黑结点下插入: 直接插入</td></tr><tr><td>case1</td><td>插入4-结点</td><td>在红结点下插入，且该结点有红色兄弟结点 (插入结点的叔结点):<br />原4-结点的3个结点反色</td></tr><tr><td>case2</td><td>插入3结点，「<code>&gt;</code>」形</td><td>在红结点下插入，且该结点无红色兄弟结点 (插入结点的叔结点):<br />插入结点插入后为左子结点: <br />下段右旋&gt;反色&gt;上段左旋</td></tr><tr><td>case3</td><td>插入3结点，「<code>\</code>」形</td><td>在红结点下插入，且该结点无红色兄弟结点 (插入结点的叔结点):<br />插入结点插入后为右子结点: <br />反色&gt;上段左旋</td></tr></tbody></table><p>这两个表格是两种对称的情形，表格中「红黑树情形」对应的伪代码如下 (「算法导论」第13章 RB-INSERT-FIXUP(T, z) )。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">RB-INSERT-FIXUP (T, z)</span><br><span class="line"><span class="number">1</span> <span class="keyword">while</span> z.p.color == RED         <span class="comment">// 不满足则为 case0</span></span><br><span class="line"><span class="number">2</span>   <span class="keyword">if</span> z.p == z.p.p.left         <span class="comment">// 插入结点的父结点为一左子结点</span></span><br><span class="line"><span class="number">3</span>        y = z.p.p.right         <span class="comment">// 插入结点的叔结点 </span></span><br><span class="line"><span class="number">4</span>     <span class="keyword">if</span> y.color == RED          <span class="comment">// case1 叔结点为红色 (插入4-结点)</span></span><br><span class="line"><span class="number">5</span>        z.p.color = BLACK       <span class="comment">// case1 反色</span></span><br><span class="line"><span class="number">6</span>        y.color = BLACK         <span class="comment">// case1 反色</span></span><br><span class="line"><span class="number">7</span>        z.p.p.color = RED       <span class="comment">// case1 反色</span></span><br><span class="line"><span class="number">8</span>        z = z.p.p               <span class="comment">// case1 继续上溯调整</span></span><br><span class="line"><span class="number">9</span>     <span class="keyword">else</span> <span class="keyword">if</span> z == z.p.right     <span class="comment">// case2 叔结点为黑色且插入结点作为右儿子 (插入3-结点，「&lt;」形)</span></span><br><span class="line"><span class="number">10</span>             z = z.p           <span class="comment">// case2 准备下段左旋</span></span><br><span class="line"><span class="number">11</span>             LEFT-ROTATE(T, z);<span class="comment">// case2 下段左旋</span></span><br><span class="line"><span class="number">12</span>       z.p.color = BLACK       <span class="comment">// case3 反色</span></span><br><span class="line"><span class="number">13</span>       z.p.p.color = RED       <span class="comment">// case3 反色</span></span><br><span class="line"><span class="number">14</span>       RIGHT-ROTATE(T, z.p.p)  <span class="comment">// case3 「/」形，上段右旋 </span></span><br><span class="line"><span class="number">15</span>   <span class="keyword">else</span> (same as then clause   <span class="comment">// 插入结点的父结点为一右子结点</span></span><br><span class="line">         with “right” and “left” exchanged)</span><br><span class="line"><span class="number">16</span> T.root.color = BLACK</span><br></pre></td></tr></table></figure><br /><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><p>将上述伪代码翻译成代码。插入方法  <code>put(Node h, K key, V val)</code>  最后一行调用的 <code>fixAfterInsertion(newNode)</code> 方法即上述伪代码的直白翻译。方法中调用的 <code>flipColors</code>, <code>flipColor</code>, <code>setColor</code>, <code>rotateLeft</code>, <code>rotateRight</code> 实现十分简单，其中旋转操作与我们在AVL树中看过的旋转操作一样，这些方法的具体实现请参考「类的实现代码」。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(K key, V val)</span> &#123; <span class="comment">// 插入key-val结点</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;first argument to put() is null&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (val == <span class="literal">null</span>) &#123; <span class="comment">// 表示删除该key</span></span><br><span class="line">        delete(key);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    put(root, key, val); <span class="comment">// 调用实际插入方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(Node h, K key, V val)</span> &#123;</span><br><span class="line">    <span class="type">int</span> compareRes;</span><br><span class="line">    Node&lt;K, V&gt; cur = h, p = <span class="literal">null</span>; <span class="comment">// cur: 当前结点，p: cur的父结点</span></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        p = cur;</span><br><span class="line">        compareRes = key.compareTo(cur.key);</span><br><span class="line">        <span class="keyword">if</span> (compareRes &lt; <span class="number">0</span>) cur = cur.left; <span class="comment">// 往左</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(compareRes &gt; <span class="number">0</span>) cur = cur.right; <span class="comment">// 往右</span></span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// 存在key，修改其值后返回</span></span><br><span class="line">            cur.val = val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// while正常结束，后续执行插入</span></span><br><span class="line">    Node&lt;K, V&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K, V&gt;(RED, key, val, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>); <span class="comment">// 插入的结点总是红色的</span></span><br><span class="line">    newNode.parent = p;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">null</span>) &#123; <span class="comment">// 非空树，插入到 p 下</span></span><br><span class="line">        compareRes = newNode.key.compareTo(p.key);</span><br><span class="line">        <span class="keyword">if</span> (compareRes &lt; <span class="number">0</span>) p.left = newNode; <span class="comment">// 作为左子结点插入</span></span><br><span class="line">        <span class="keyword">else</span> p.right = newNode; <span class="comment">// 作为右子结点插入</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">this</span>.root = newNode; <span class="comment">// p == null 说明未进入while，树空，newNode作为根结点插入</span></span><br><span class="line">    fixAfterInsertion(newNode); <span class="comment">// 向上调整，恢复红黑树平衡</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fixAfterInsertion</span><span class="params">(Node&lt;K, V&gt; k)</span> &#123;</span><br><span class="line">    Node&lt;K, V&gt; p, g; <span class="comment">// parent, grandParent</span></span><br><span class="line">    <span class="keyword">while</span> (((p = parentOf(k)) != <span class="literal">null</span>) &amp;&amp; isRed(p)) &#123;</span><br><span class="line">        g = parentOf(p);</span><br><span class="line">        <span class="keyword">if</span> (p == g.left) &#123; <span class="comment">// k的父结点是一个左儿子</span></span><br><span class="line">            Node&lt;K, V&gt; u = g.right; <span class="comment">// uncle: p的兄弟结点，k的叔结点</span></span><br><span class="line">            <span class="keyword">if</span> (isRed(u)) &#123; <span class="comment">// case1: k的叔结点为红，则k插入到一个4-结点中</span></span><br><span class="line">                flipColors(g);</span><br><span class="line">                k = g; <span class="comment">// 插入4-结点只需反色，此时要上溯到变红的g</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// k的叔结点为黑，则k插入到一个3-结点中</span></span><br><span class="line">                <span class="keyword">if</span> (k == p.right) &#123; <span class="comment">// case2: k 是一个右儿子</span></span><br><span class="line">                    k = p;</span><br><span class="line">                    rotateLeft(p); <span class="comment">// 左旋，之后k在底部</span></span><br><span class="line">                &#125;</span><br><span class="line">                flipColor(p); <span class="comment">// case3: 反色 setColor(p, BLACK);</span></span><br><span class="line">                flipColor(g); <span class="comment">// case3: 反色 setColor(g, RED);</span></span><br><span class="line">                rotateRight(g); <span class="comment">// case3: 右旋</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// k的父结点是一个右儿子</span></span><br><span class="line">            Node&lt;K, V&gt; u = g.left;</span><br><span class="line">            <span class="keyword">if</span> (isRed(u)) &#123;</span><br><span class="line">                flipColors(g);</span><br><span class="line">                k = g;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (k == p.left) &#123;</span><br><span class="line">                    k = p;</span><br><span class="line">                    rotateRight(p);</span><br><span class="line">                &#125;</span><br><span class="line">                flipColor(p);</span><br><span class="line">                flipColor(g);</span><br><span class="line">                rotateLeft(g);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (k == root) setColor(k, BLACK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h4 id="删除结点"><a href="#删除结点" class="headerlink" title="删除结点"></a>删除结点</h4><p>与「插入结点」操作一样，我们仍旧遵循「红黑树保持平衡的操作与2-3-4树严格对应」这一结论，来分析「删除结点」的过程。红黑树结点删除的操作向来被看作  <strong>高级数据结构中最为复杂和难以理解的操作之一</strong>，以至于一些久负盛名的算法书，例如 Sedgewick 的「算法第4版」(该树的红黑树为左倾红黑树)、Weiss的「数算」对删除结点的操作都只有只言片语，后者的红黑树代码实现中甚至略去了删除结点的部分。「算法导论」给出的过程较为详细，但缺少实现代码，且只基于恢复红黑性质而未能联系2-3-4树来解释，不但难以理解，且未对照2-3-4树的删除过程，让人对其正确性信心不足。</p><p>我们指出红黑树删除操作难以理解的一个关键在于，操作是针对 BST 形态的红黑树，但本质却要求删除后保持仍为一棵符合定义的完美平衡的2-3-4树 (同构)，在多种情形下建立二者之间的联系极大地增加了我们的思考负担。但读者朋友不必担心，本小节我将配以大量图示详细叙述，通过严格对比2-3-4树和红黑树，确保读者能够比较轻松地理解红黑树删除操作的每一处细节，并确信归约出的4种情形确实能够覆盖所有删除情形。本小节内容较多，预先列出后续行文顺序如下。</p><ol><li>删除操作: 说明红黑树对应的2-3-4树中删除结点的操作。指出删除3-结点或4-结点中的键是容易的， <strong>只有删除2-结点才需要向上调整</strong> 。</li><li>情形归约: 列出 42 种删除2-结点的情形，从中归约出 4 种情形， <strong>并指出其中需要向上调整的情形</strong> 。</li><li>删除调整: 通过对比2-3-4树删除2-结点的过程，分析出红黑树删除2-结点的过程 (如何旋转及变色)，并给出伪代码。</li><li>代码实现: 给出红黑树删除结点的 Java 实现代码。</li></ol><br /><h5 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h5><p>如同 BST 的删除操作那样，删除结点的方法中，首先要找到该结点，若存在，则根据目标结点的位置及其左右子树是否存在，执行具体的删除动作，无论删除的结点在何处，最终都会 <strong>删除一个对应于2-3-4树上的叶子结点</strong> (这一点是关键，后面详细说明) 。与「插入结点」中的考虑一样，删除结点后要保证红黑树仍与2-3-4树同构。当要删除的结点 (红黑树) 对应为2-3-4树中3-结点或4-结点中的键时，可以直接删除该键而不破坏平衡 (叶子结点仍在，只是少了一个键)，若待删除结点对应2-3-4树中的2-结点时，删除该结点将导致其父结点的子结点数少一个，不满足2-3-4树结点的结构 (2-3-4树语境)。类似「插入结点」后的操作， <strong>关键在于删除2-结点后恢复同构</strong> ，这是本节重点，在进入该内容讲解之前，我们先分析2-3-4树的结点删除操作。有了 BST 删除操作的经验，我们很容易将在2-3-4树中要删除的键 ($key$) 分为如下两种情形 (见下表情形1和情形2)。</p><ol><li>情形1: $key$ 的后继键一定在叶子结点中，且如果该叶子结点为3-结点或4-结点，一定是结点中最左侧 (最小) 的那个键。例如删除图中的30，其后继为32，若删除34，其后继为35，若删除45，其后继为48。</li><li>情形2: 可直接删除目标 $key$ (键值) ，若该键在3-结点或4-结点中，例如删除32或53，可直接删除。若该键在2-结点中，如删除40，则其父结点失去2-3-4树结构性质。</li></ol><p><img src="https://pic.leetcode-cn.com/1657353243-VnVwnq-image.png" alt="image.png"></p><p>2-3-4树删除 $key$ 情形 (以 $key$ 是否在叶子结点中划分)。</p><table><thead><tr><th>2-3-4树删除 $key$ 情形</th><th>删除操作</th></tr></thead><tbody><tr><td>情形1: $key$ 不在叶子结点中</td><td>用 $key$ 的后继键值替换 $key$，然后删除后继键值<br />※ 后继键必为某叶子结点中的最小键</td></tr><tr><td>情形2: $key$ 在叶子结点中</td><td>直接删除目标键值<br />※ 若目标键在2-结点中，删除后失去2-3-4树结构性质，要调整</td></tr></tbody></table><p>红黑树删除结点情形 (以删除结点的子结点情形划分)。</p><table><thead><tr><th>红黑树删除结点 $x$ 情形</th><th>删除操作</th></tr></thead><tbody><tr><td>情形a: $x$ 有左右子结点</td><td>用后继结点 (的键值) 替换 $x$ (的键值)，然后删除后继结点<br />※ 删除后继结点必为情形b或情形c</td></tr><tr><td>情形b: $x$ 有一个子结点</td><td>建立子结点与 $x.parent$ 的链接，然后删除 $x$<br />※ $x$ 及其子结点构成3-结点，删除后不影响同构</td></tr><tr><td>情形c: $x$ 无子结点</td><td>删除 $x$ <br />※ $x$ 对应2-3-4树中的多种情形，可能为红或黑，若为2-3-4树中的2-结点，则删除后失同构，需调整</td></tr></tbody></table><p>对于上述两表，对比说明如下。</p><ol><li><p>情形a包括了情形1以及情形2中删除4-结点的中间 $key$ 的情况，这一情形需要找到 $x$ 的后继结点，然后转为情形b或情形c。</p></li><li><p>情形b除了从情形a中转移过来的情况外，还包括情形2中删除右斜3-结点左键和删除左斜3-结点右键这两种情况。它们都表现为删除3-结点中黑色的那个结点。</p></li><li><p>情形c除了从情形a中转移过来的情况外，还包括情形2中删除2-结点 (1)、删除右斜3-结点右键 (2)、删除左斜3-结点的左键 (3)、删除4-结点的左键 (4)、删除4-结点的右键 (5) 这5种情况。如果是(1)，那么删除了一个2-结点，失同构，需要调整，如果是 (2), (3), (4), (5)，可直接删除。而且我们发现这5种情况中只有 (1) 满足 $x$ 为黑色。</p></li></ol><ul><li>对于情形a，当我们判断 $x$ 存在左右孩子后，令 <code>x = x.successor</code> ，即可转为b, c情形。</li><li>对于情形b，当判断 $x$ 只有一个孩子时，我们建立 $x.parent$ 与 $x.child$ 的链接关系，然后删除 $x$ 。需要注意的是，情形b保证了 $x$ 一定是黑色的，$x.child$ 一定是红色的，删除 $x$ 后原3-结点变为2-结点，因此 $x.child$ 要置为黑色，仍与2-3-4树同构，无需调整，删除结束。</li><li>对于情形c，直接删除 $x$ ，但若 $x$ 为黑，失同构，需要调整。</li></ul><p>通过上述分析，我们发现仅有 $x$  <strong>无孩子结点且为黑</strong> 时才需要恢复同构。在理解了红黑树的删除操作后，我们给出下面的代码。删除结点的操作由公有的 $delete$ 驱动方法和私有的具体方法构成。在驱动方法中先执行 $get$ 查找是否存在键为 $key$ 的结点，存在则执行具体删除方法。代码中的注释与前述分析是完全一致的，请读者对照阅读，应当不难理解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(K key)</span> &#123; <span class="comment">// 删除key对应的结点</span></span><br><span class="line">    Node&lt;K, V&gt; x = get(<span class="built_in">this</span>.root, key); <span class="comment">// 找到key对应的结点x</span></span><br><span class="line">    <span class="keyword">if</span> (x != <span class="literal">null</span>) delete(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Node&lt;K, V&gt; x)</span> &#123; <span class="comment">// 删除结点x</span></span><br><span class="line">    <span class="keyword">if</span> (x.left != <span class="literal">null</span> &amp;&amp; x.right != <span class="literal">null</span>) &#123; <span class="comment">// x有左右孩子</span></span><br><span class="line">        Node&lt;K,V&gt; s = successor(x); <span class="comment">// 找到x的后继s</span></span><br><span class="line">        x.key = s.key; <span class="comment">// s取代x</span></span><br><span class="line">        x.val = s.val; <span class="comment">// s取代x</span></span><br><span class="line">        x = s; <span class="comment">// x此时是实际要删除的s</span></span><br><span class="line">    &#125; <span class="comment">// 经过此if后，x为实际要删除的结点，x要么是无孩子的叶子结点，要么只有一个孩子结点</span></span><br><span class="line">    Node&lt;K,V&gt; r = x.left != <span class="literal">null</span> ? x.left : x.right; <span class="comment">// r: replacement，即x.child，用来取代x</span></span><br><span class="line">    <span class="keyword">if</span> (r != <span class="literal">null</span>) &#123; <span class="comment">// 情形b: x只有左孩子或右孩子 </span></span><br><span class="line">        <span class="comment">// 以下四句链接x.p与r</span></span><br><span class="line">        r.parent = x.parent;</span><br><span class="line">        <span class="keyword">if</span> (x.parent == <span class="literal">null</span>) root = r; <span class="comment">// 原x为root</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x == x.parent.left) x.parent.left  = r; <span class="comment">// 原x不为root且为一个左孩子</span></span><br><span class="line">        <span class="keyword">else</span> x.parent.right = r; <span class="comment">// 原x不为root且为一个右孩子</span></span><br><span class="line">        x.left = x.right = x.parent = <span class="literal">null</span>; <span class="comment">// 删除x (x脱离树，置其左右子结点和父结点为 null)</span></span><br><span class="line">        setColor(r, BLACK); <span class="comment">// #1 r一定为红，置黑</span></span><br><span class="line">        <span class="comment">// if (x.color == BLACK) fixAfterDeletion(r); // #2 调整</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x.parent == <span class="literal">null</span>)  &#123; <span class="comment">// case2 x无孩子且无父结点，x为根结点，且该树只有此结点</span></span><br><span class="line">        root = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 情形c: x无孩子 (r为null)</span></span><br><span class="line">        <span class="keyword">if</span> (x.color == BLACK) fixAfterDeletion(x); <span class="comment">// x为2结点，调整</span></span><br><span class="line">        <span class="keyword">if</span> (x.parent != <span class="literal">null</span>) &#123; <span class="comment">// 删除x</span></span><br><span class="line">            <span class="keyword">if</span> (x == x.parent.left) x.parent.left = <span class="literal">null</span>; <span class="comment">// x为一左子结点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (x == x.parent.right) x.parent.right = <span class="literal">null</span>; <span class="comment">// x为一右子结点</span></span><br><span class="line">            x.parent = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上上面给出的代码基本上就是 JDK 的 TreeMap 中的 $deleteEntry$ <a href="https://github.com/openjdk/jdk/blob/master/src/java.base/share/classes/java/util/TreeMap.java">方法</a>。说「基本上」是因为，在源码中有 #2 行而无 #1 行，而我们给出的方法中有 #1 行而无 #2 行。若读者理解了前述分析，相信很容易接受我们给出的写法。反而 JDK 源码的写法似乎不佳，关于这一点，需要读者先理解接下来要讲解的 $fixAfterDeletion$ 方法后才能讨论，如果确如作者分析的那样，我们应该向 Oracle 提交该方法的改进请求。详细探讨请见「补充」。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setColor(r, BLACK); <span class="comment">// #1 r一定为红，置黑</span></span><br><span class="line"><span class="comment">// if (x.color == BLACK) fixAfterDeletion(r); // #2 调平</span></span><br></pre></td></tr></table></figure><br /><h5 id="情形归约"><a href="#情形归约" class="headerlink" title="情形归约"></a>情形归约</h5><p>删除2-结点 ($x$) 后要恢复与2-3-4树同构，可令 $x$ 的父结点向下补充缺失的2-结点。可以这么考虑，删除 $x$ 之前，我们先利用父结点的键将该处填充为一个3-结点或4-结点，于是 $x$ 可直接删除，父结点出借了一个键，根据其键数变化，还需要一些调整。以下列出删除2-结点的不同情形，只有情形3-2需要向上调整，其他情形在常数次操作后恢复同构。</p><ul><li>情形1: 若 $x$ 的兄弟结点为3-结点。$x$ 从其父结点中取一个键到 $x$ 中组成3-结点，但父结点的键数要保持不变，否者链的数量也会减1，因此父结点从 $x$ 的兄弟结点中取一个键。删除 $x$ ，平衡恢复。</li><li>情形2: 若 $x$ 的兄弟结点为4-结点。$x$ 、$x$ 的父结点中的一个键、$x$ 兄弟结点中的一个键组成一个4-结点。但父结点的键数要保持不变，否者链的数量也会减1，因此父结点从 $x$ 的兄弟结点中取一个键。删除 $x$ ，平衡恢复。</li><li>情形3: 若 $x$ 的兄弟结点为2-结点。由于 $x$ 的兄弟结点只有一个键，不能向上述两种情形那样通过 $x$ 兄弟结点来「间接取键」，但我们可以把 $x$ 、$x$ 父结点中的一个键、$x$ 兄弟结点合并为一个4-结点。$x$ 的父结点少了一个键，但链也少了一条，结构仍是正确的。删除 $x$。<ul><li>情形3-1: 若父结点为3-结点或4-结点，父结点借出一个结点，缩小为2-结点或3-结点。平衡恢复。</li><li>情形3-2: 若父结点为2-结点，则在合并后父结点「缺失」。如同「插入结点」最后的向上调整，此情形的结点删除也需要继续 <strong>向上调整</strong> 。</li></ul></li></ul><p>情形3-2向上调整的过程中，若遇到一个3-结点或4-结点，它被亏空处「借键」后变为2-结点或3-结点)，调整结束。否则一直调整到根处，若根为2-结点，补充亏空后整棵2-3-4树高度减1，所有叶子结点到根的路径长度同时减1，调整结束。</p><p><img src="https://pic.leetcode-cn.com/1663647407-DuaTIc-image.png" alt="image.png"></p><p>※ 此图并未画出所有情形的所有子情形 (例如 $x$ 的父结点可以为2-结点&#x2F;3-结点&#x2F;4-结点，又如 $x$ 的位置不一定在最左边等)，但对解释删除2-结点的操作来说已经完备，读者若不放心，可依据此图过程画出其他情形。</p><p>经过上述分析，我们发现 <strong>删除后的调整过程是关键</strong> 。当我们试图对照2-3-4树中删除2-结点的各种情形画出红黑树删除过程中结点变换的过程时，我们很快发现 <strong>该情形实在太多</strong> ，逐个讨论耗时甚巨，很容易迷失在旋转与变色中，因此需要减少讨论情形。如同算法导论，我们也会指出删除结点的 <strong>4 种情形</strong> ，但与算法导论直接从抽象的红黑性质入手不同，本小节避免谈及红黑树的5条性质，而是将2-3-4树与红黑树对照分析，从众多具体的2-3-4树情形归约到 4 种情形。</p><p>虽然该方法前期工作较繁琐， <strong>需要极大的耐心和细心</strong> ，但我们能够清楚地看到每一种情形的2-3-4树和红黑树的对应关系，归约得到的4种情形是很容易理解和接受的。之后对4种情形的删除操作的分析，将会坚定而轻松。</p><p>下图全面分析删除2-结点 (结点 $x$) 的不同情形，建议读者预先验证下每个情形的2-3-4树是否与红黑树对应。$x$ 为一个 <strong>左子结点</strong> 的情形已用绿色框框住，可以看到，当它是一个右子结点时，有同样多的 <strong>镜像情形</strong> ，根据「插入结点」的经验，实际编程时，只需将 $x$ 为左子结点的代码中的 $left$ 和 $right$ 交换即得到镜像情形的代码。于是对于整张图的42种情形 (红黑树)，只需看绿色框中的21种。</p><p><img src="https://pic.leetcode-cn.com/1657191505-LgyJPv-image.png" alt="image.png"></p><p>如下，我们列出这21种情形的标号，实际上仍未列完，图中红黑树未接结点的黑色链条，可以接2-结点、3-结点或4-结点，其中3-结点又分为左斜或右斜。不过我们 <strong>保证已经覆盖了所有删除情形</strong> ，因为只有与 $x$ 相邻的黑色链条才可能影响变换的结果，而在2-3-4树示意图中与 $x$ 相邻的「..□..」（即红黑树中的黑色链条所链接的2-结点&#x2F;3-结点&#x2F;4-结点），总能够在已经给出的某种情形中找到对应 (例如 1-4 对应2-3-4树中 $x$ 右侧的 「..□..」，可以为2-结点，3-结点或4-结点，分别由1-5，2-5，3-5对应的2-3-4树所对应)。</p><table><thead><tr><th>$x$ 的兄弟结点</th><th>$x$ 的父结点</th><th>情形</th></tr></thead><tbody><tr><td>2-结点</td><td>2-结点</td><td>1-1</td></tr><tr><td></td><td>3-结点</td><td>1-2, 1-3, 1-4, 1-5</td></tr><tr><td></td><td>4-结点</td><td>1-6, 1-7</td></tr><tr><td>3-结点</td><td>2-结点</td><td>2-1</td></tr><tr><td></td><td>3-结点</td><td>2-2, 2-3, 2-4, 2-5</td></tr><tr><td></td><td>4-结点</td><td>2-6, 2-7</td></tr><tr><td>4-结点</td><td>2-结点</td><td>3-1</td></tr><tr><td></td><td>3-结点</td><td>3-2, 3-3, 3-4, 3-5</td></tr><tr><td></td><td>4-结点</td><td>3-6, 3-7</td></tr></tbody></table><p>现在，我们观察所列情形的2-3-4树和对应的红黑树的形态，归约其中的等价情形。再次强调，以下讨论中 $x$ 是一个左子结点 (绿色框)，其对称情形是 $x$ 为一个右子结点。</p><ol><li><p>我们首先看到 $x.p$ 为4-结点的情形，例如 1-6 ，一个红色结点连着两个黑色子结点的部分，在 1-2 中也有相同的部分。通过与它们对应的2-3-4树容易观察到，<strong>相同部分才会参与变换</strong>，不同的部分不参与变换，所以它们可以看作一种情形。同理，1-7, 2-6, 2-7, 3-6, 3-7 都不必重复讨论，这样就去掉了 6 种情形。</p></li><li><p>利用同样的方法 (对照2-3-4树)，我们观察到 1-1, 1-2, 1-5 参与变换的部分也是一样的，同理 2-1, 2-2, 2-5 情况等价， 3-1, 3-2, 3-5 情况等价，于是再去掉 6 种情形。</p></li><li><p>对于1-4，其 $x$ (在红黑树中) 的兄弟结点只能是黑色结点 (即黑链下挂的未画出的结点)，若为2-结点，则 1-1 与该部分对应，若为3-结点，则 2-1 与该部分对应，若为4-结点，则3-1与该部分对应，因此1-4可以不用重复讨论。同理，2-4，3-4也可以去掉。注意，虽然「^」形结构父结点在 1-1 中为黑，在 1-4 中为红，但通过对2-3-4树的观察可知，变换所涉及的结点只有「^」结构的三个结点，因此它们是等价的 (颜色变化后续说明)。</p></li><li><p>现在只剩下1-1, 2-1, 3-1, 1-3, 2-3, 3-3 六种情形。更进一步，我们分析1-3, 2-3, 3-3 这三种情形。它们的共同特点是 $x$ (在红黑树中的) 的兄弟结点为红色，实际上意味着在2-3-4树中 $x$ 的父结点为 (右斜的) 3-结点。因为1-3, 2-3, 3-3 分别与1-2, 2-2, 3-2 对应同一种2-3-4树，只是前三个的 $x.p$ (3-结点) 为左斜，后三个为右斜，所以我们尝试左旋 $x.p$ 使后者与前者相同， <strong>左旋后发现确实转换成了 1-2, 2-2, 3-2 情形</strong> 。于是，我们遇到 $x$ 的兄弟结点为红色结点时，左旋 $x.p$ (及相应变色) 即可得到之前讨论过的情形，而 1-2, 2-2, 3-2 在上述第2条的讨论中，已经被我们去掉了，1-1, 2-1, 3-1 是它们的等价。</p></li></ol><p><img src="https://pic.leetcode-cn.com/1657202985-hxfSCu-image.png" alt="image.png"></p><p>最终我们从众多情形中归约出4种情形，包括三种基本情形 1-1, 2-1, 3-1，以及情形 x-3 (表示 1-3 &amp; 2-3 &amp; 3-3，共同点是 $x$ 的兄弟结点为红色，左旋 $x.p$ 后转换为基本情形)。</p><p>※ 情形2-1有两种，但只需要将左侧结构的 $w$ ($x$ 的兄弟结点) 右旋即可得到右侧结构，我们从2-3-4树的角度将此二者看作一种情形，后续实际编程时的4种情形与此处略有不同。</p><p>接下来分析这四种情形的结点删除过程，以及删除后的调整。</p><br /><h5 id="删除调整"><a href="#删除调整" class="headerlink" title="删除调整"></a>删除调整</h5><p>为方便叙述，我们将前述归约出的4种情形与「算法导论」给出的 case1~4 对照如下。</p><table><thead><tr><th>算法导论4情形</th><th>对应前述4情形</th></tr></thead><tbody><tr><td>case1: $w$ 为红色</td><td>情形x-3<br />只需对 $x.p$ 置红及 $w$ 反色并左旋 $x.p$ 后转为后续情形</td></tr><tr><td>case2: $w$ 为黑色，且其孩子左黑右黑</td><td>情形1-1</td></tr><tr><td>case3: $w$ 为黑色，且其孩子左红右黑</td><td>情形2-1左侧<br />只需对 $w$ 及 $w.left$ 反色并右旋 $w$ 即为 case4</td></tr><tr><td>case4: $w$ 为黑色，且其孩子左黑右红或左红右红</td><td>情形2-1右侧 &amp; 情形3-1</td></tr></tbody></table><p>※ $w$ 是待删除结点 $x$ 的兄弟结点。</p><p>现在我们画出 case1~4 删除结点 $x$ 前后的2-3-4树和红黑树。左侧的「删除前后 (2-3-4树)」是简单的，我们根据左侧2-3-4树删除 $x$ 后的结果，考虑并尝试对删除前的红黑树做旋转和颜色调整操作，不难得到右侧「删除前后 (红黑树)」中的过程。</p><p><img src="https://pic.leetcode-cn.com/1657258262-RCDMKq-image.png" alt="image.png"></p><p>为了便于读者观察，黑色虚线椭圆框住的 $x.p$ 结点只考察了2-结点的情形，只有此情形才可能在 case2 时，需要继续向上尝试调整。如果 $x.p$ 为3-结点或4-结点，如我们在前面「删除操作」小节中讨论的那样，在本次调平后必然能够恢复平衡。而且 $x.p$ 必然为红色 (3-结点或4-结点的子结点必为红色，请看情形1-2和情形1-6的2-3-4树) ，调整后这个结点是原3-结点或4-结点出借的结点，如果还保持红色，将无法脱离原3-结点或4-结点 (2-3-4树)，因此必须置黑。这是 RB-DELETE-FIXUP(T, x) 伪代码最后一行的作用。</p><p>至此，我们已经完成了红黑树删除结点操作中最为困难的「删除后调整」的分析，并写下了在红黑树中四种删除2-结点情形的调整动作。现在只需将上图「删除前后 (红黑树)」中具体动作写成代码即可。下面是「算法导论」给出的 RB-DELETE-FIXUP(T, x) 伪代码，与我们在图中写下的过程是一样的，以下逐行给出注释。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">RB-DELETE-FIXUP(T, x)                     <span class="comment">// 从被删除的结点x开始调整</span></span><br><span class="line"><span class="number">1</span>  <span class="keyword">while</span> x ≠ T.root and x.color == BLACK  <span class="comment">// x未上溯到根，且x为黑 (删除2-结点)</span></span><br><span class="line"><span class="number">2</span>    <span class="keyword">if</span> x == x.p.left                     <span class="comment">// x是一个左孩子</span></span><br><span class="line"><span class="number">3</span>      w = x.p.right                      <span class="comment">// w是x的叔结点</span></span><br><span class="line"><span class="number">4</span>      <span class="keyword">if</span> w.color == RED                  <span class="comment">// case1 w为红 (则x.p为3-结点，其子结点必为黑)</span></span><br><span class="line"><span class="number">5</span>        w.color = BLACK                  <span class="comment">// case1 w置黑(反色)</span></span><br><span class="line"><span class="number">6</span>        x.p.color = RED                  <span class="comment">// case1 x.p置红(反色)</span></span><br><span class="line"><span class="number">7</span>        LEFT-ROTATE(T, x.p)              <span class="comment">// case1 左旋x.p (前两行反色是为了左旋后变为case2)</span></span><br><span class="line"><span class="number">8</span>        w = x.p.right                    <span class="comment">// case1 有了第3行，此行可省略(因为旋转时x.p.right引用会相应调整)</span></span><br><span class="line"><span class="number">9</span>      <span class="keyword">if</span> w.left.color == BLACK           </span><br><span class="line">            and w.right.color == BLACK    <span class="comment">// case2 w的孩子结点左黑右黑</span></span><br><span class="line"><span class="number">10</span>        w.color = RED                   <span class="comment">// case2 w置红(反色，进入该分支时w一定是黑色，反色目的是让它作为一个3-结点中的红色结点)</span></span><br><span class="line"><span class="number">11</span>        x = x.p                         <span class="comment">// case2 继续向上调整，此情况的x.p可能为黑，表示上一行注释中</span></span><br><span class="line">                                          <span class="comment">// 所说的3-结点是通过3个2-结点合并而来的(合并为4-结点后删去x)，因此x.p(2-结点)亏空</span></span><br><span class="line"><span class="number">12</span>     <span class="keyword">else</span> <span class="keyword">if</span> w.right.color == BLACK     <span class="comment">// case3 w的孩子结点左红右黑，此情形结束后必平衡</span></span><br><span class="line"><span class="number">13</span>             w.left.color = BLACK       <span class="comment">// case3 w左孩子置黑(反色)</span></span><br><span class="line"><span class="number">14</span>             w.color = RED              <span class="comment">// case3 w置红(反色, 进入该分支时w一定是黑色)</span></span><br><span class="line"><span class="number">15</span>             RIGHT-ROTATE(T, w)         <span class="comment">// case3 右旋w (前两行反色是为了右旋后变为case4)</span></span><br><span class="line"><span class="number">16</span>             w = x.p.right              <span class="comment">// case3 有了第3行，此行可省略(因为旋转时x.p.right引用会相应调整)</span></span><br><span class="line">                                          <span class="comment">// 从下一行开始是w孩子结点为左黑右红或左红右红的情形，此情形结束后必平衡</span></span><br><span class="line"><span class="number">17</span>          w.color = x.p.color           <span class="comment">// case4 继承x.p的颜色，后续左旋x.p后w会取代x.p的位置</span></span><br><span class="line"><span class="number">18</span>          x.p.color = BLACK             <span class="comment">// case4 x.p置黑，目的是为了让它作为调整后原x位置新形成的3-结点中的黑色结点</span></span><br><span class="line"><span class="number">19</span>          w.right.color = BLACK         <span class="comment">// case4 w右孩子置黑(反色，目的是为了让它成为一个2-结点)</span></span><br><span class="line"><span class="number">20</span>          LEFT-ROTATE(T, x.p)           <span class="comment">// case4 左旋x.p，令左侧挂上一个3-结点(原x被删除的位置)</span></span><br><span class="line"><span class="number">21</span>          x = T.root                    <span class="comment">// case4 此句用于退出while，因为case3和case4调整后必平衡</span></span><br><span class="line"><span class="number">22</span>   <span class="keyword">else</span> (same as then clause with </span><br><span class="line">           <span class="string">&quot;right&quot;</span> and <span class="string">&quot;left&quot;</span> exchanged)  <span class="comment">// x是右孩子，为镜像情形，将前面代码中的left与right交换即可得到本处代码</span></span><br><span class="line"><span class="number">23</span> x.color = BLACK                        <span class="comment">// while结束要么是case3/case4调整后已平衡 x被被置为root后主动退出，</span></span><br><span class="line">                                          <span class="comment">// 要么是case1/case2 x为红。若为前者无需此句(此时的root一定是黑的)</span></span><br><span class="line">                                          <span class="comment">// 若为后者，说明此时的x结点是原3-结点或4-结点出借的结点，如果还保持红色，</span></span><br><span class="line">                                          <span class="comment">// 将无法脱离原3-结点或4-结点 (2-3-4树)，因此必须置黑。</span></span><br><span class="line">                                          <span class="comment">// 此句也可以写成这样: if(x != root) x.color = BLACK</span></span><br></pre></td></tr></table></figure><br /><h5 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h5><p>下面给出删除结点的完整代码。<code>delete</code> 驱动方法和具体方法前面已给出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(K key)</span> &#123;&#125; <span class="comment">// 前面已给出，此处省略</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Node&lt;K, V&gt; x)</span> &#123;&#125; <span class="comment">// 前面已给出，此处省略</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fixAfterDeletion</span><span class="params">(Node&lt;K, V&gt; x)</span> &#123;</span><br><span class="line">    Node&lt;K, V&gt; parent = parentOf(x);</span><br><span class="line">    <span class="keyword">while</span> (isBlack(x) &amp;&amp; x != root) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == leftOf(parent)) &#123; <span class="comment">// x是一个左子结点</span></span><br><span class="line">            Node&lt;K, V&gt; sib = rightOf(parent);</span><br><span class="line">            <span class="comment">// case1：sib为红，转换为后续case</span></span><br><span class="line">            <span class="keyword">if</span> (isRed(sib)) &#123;</span><br><span class="line">                setColor(parent, RED);</span><br><span class="line">                setColor(sib,BLACK);</span><br><span class="line">                rotateLeft(parent);</span><br><span class="line">                <span class="comment">// sib = parent.right; //「算法导论」伪代码有此句，可以省略</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// case2:左黑右黑，这种情形可能需要继续向上调平</span></span><br><span class="line">            <span class="keyword">if</span> (isBlack(leftOf(sib)) &amp;&amp; isBlack(rightOf(sib))) &#123;</span><br><span class="line">                setColor(sib, RED);</span><br><span class="line">                x = parent; <span class="comment">// 向上调平</span></span><br><span class="line">                parent = parentOf(x); <span class="comment">// 更新parent</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// case3 &amp; case4 一定能够调平</span></span><br><span class="line">                <span class="comment">// case3: 右黑，其实就是左红右黑，转换为case4</span></span><br><span class="line">                <span class="keyword">if</span> (isBlack(rightOf(sib))) &#123;</span><br><span class="line">                    setColor(sib.left, BLACK);</span><br><span class="line">                    setColor(sib, RED);</span><br><span class="line">                    rotateRight(sib);</span><br><span class="line">                    <span class="comment">// sib = parent.right; //「算法导论」伪代码有此句，可以省略</span></span><br><span class="line">                &#125; <span class="comment">// 以下是case4: 右红，其实就是左红右红或左黑右红，这种情形一定会调平</span></span><br><span class="line">                setColor(sib, colorOf(parent));</span><br><span class="line">                setColor(parent, BLACK);</span><br><span class="line">                setColor(rightOf(sib), BLACK);</span><br><span class="line">                rotateLeft(parent);</span><br><span class="line">                x = root; <span class="comment">//此句用于退出while，因为case3和case4调整后必平衡</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;K, V&gt; sib = leftOf(parent);</span><br><span class="line">            <span class="keyword">if</span> (isRed(sib)) &#123;</span><br><span class="line">                setColor(parent, RED);</span><br><span class="line">                setColor(sib, BLACK);</span><br><span class="line">                rotateRight(parent);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isBlack(leftOf(sib)) &amp;&amp; isBlack(rightOf(sib))) &#123;</span><br><span class="line">                setColor(sib, RED);</span><br><span class="line">                x = parent;</span><br><span class="line">                parent = parentOf(x);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (isBlack(leftOf(sib))) &#123;</span><br><span class="line">                    setColor(sib.right, BLACK);</span><br><span class="line">                    setColor(sib, RED);</span><br><span class="line">                    rotateLeft(sib);</span><br><span class="line">                &#125;</span><br><span class="line">                setColor(sib, colorOf(parent));</span><br><span class="line">                setColor(parent, BLACK);</span><br><span class="line">                setColor(leftOf(sib), BLACK);</span><br><span class="line">                rotateRight(parent);</span><br><span class="line">                x = root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// while结束要么是case3/case4调整后已平衡 x被被置为root后主动退出，</span></span><br><span class="line">    <span class="comment">// 要么是case1/case2 x为红。若为前者无需此句(此时的root一定是黑的)</span></span><br><span class="line">    <span class="comment">// 若为后者，说明此时的x结点是原3-结点或4-结点出借的结点，如果还保持红色，</span></span><br><span class="line">    <span class="comment">// 将无法脱离原3-结点或4-结点 (2-3-4树)，因此必须置黑。</span></span><br><span class="line">    setColor(x, BLACK); <span class="comment">// 也可以写成这样 if(x != root) setColor(x, BLACK);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h5 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h5><p>【补充1: JDK TreeMap类源码中的deleteEntry方法】</p><p>在「删除操作」小节中，我们指出 JDK 的 TreeMap 类的 $deleteEntry$ <a href="https://github.com/openjdk/jdk/blob/master/src/java.base/share/classes/java/util/TreeMap.java">方法</a>，源码的实现略有不妥，即该方法中有如下 #2 行而无 #1 行，由于 $x.color$ 一定是黑，因此总是会执行调整方法，进入 $fixAfterDeletion$ 方法后，又因为 $r$ 的兄弟结点是黑色的 $null$ ，因此会进入 case2 分支，执行 $x &#x3D; x.p$ (即原 $r.p$ ) 语句后，满足 $x.color &#x3D;&#x3D; BLACK$，继续调整。到这里我们可以这么理解，源码的写法使得原 $r.p$ 被看作亏空的2-结点 (确实被删除了，$r$ 取代之)，通过 $fixAfterDeletion$ 方法一定能够补上此亏空 (即向上调平)，而 $r$ 仍是红色，将与补上的2-结点 (见case2的2-3-4树) 或3-结点 (见case3或case4的2-3-4树) 组成3-结点或4-结点，因此原来补亏后亏空处变为2-结点或3-结点，现在变成了3-结点或4-结点，一方面红黑性质不变，一方面平衡也能得到保证，因此源码是正确的。但原本该处并不需要调整 (该分支删除3-结点的键，删除后并不导致失衡)，执行这样的调整显然是多余的。目前作者正尝试向 Oracle 报告该见解，若读者有不同看法也欢迎与作者交流 (hainanlxs AT yahoo.co.jp)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setColor(r, BLACK); <span class="comment">// #1 r一定为红，置黑</span></span><br><span class="line"><span class="comment">// if (x.color == BLACK) fixAfterDeletion(r); // #2 调整</span></span><br></pre></td></tr></table></figure><p>【补充2: 算法导论两处伪代码及注释】</p><p>我们给出的删除结点的方法基本上应用的是 JDK TreeMap的 <code>remove/deleteEntry</code> 方法，不过下面也给出如下「算法导论」中的相关伪代码，供读者对照学习。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RB-TRANSPLANT (T, u, v)  <span class="comment">// v取代u (链接u.p和v)</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">if</span> u.p == T.nil        <span class="comment">// 若u为根</span></span><br><span class="line"><span class="number">2</span>   T.root = v           <span class="comment">// 则新根为v</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">else</span> <span class="keyword">if</span> u == u.p.left  <span class="comment">// 否则若u为一左儿子</span></span><br><span class="line"><span class="number">4</span>   u.p.left = v         <span class="comment">// 其父的左儿子更新为v</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">else</span> u.p.right == v    <span class="comment">// 否则若u为一右儿子，其父的右儿子更新为v</span></span><br><span class="line"><span class="number">6</span> v.p = u.p              <span class="comment">// v父置为u父</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">RB-DELETE(T, z)                        <span class="comment">// 待删除结点z</span></span><br><span class="line"><span class="number">1</span>  y = z</span><br><span class="line"><span class="number">2</span>  y-original-color = y.color          <span class="comment">// 记录待删除结点的颜色</span></span><br><span class="line"><span class="number">3</span>  <span class="keyword">if</span> z.left == T.nil                  <span class="comment">// z无左孩子</span></span><br><span class="line"><span class="number">4</span>    x = z.right                       <span class="comment">//   x为z的右孩子</span></span><br><span class="line"><span class="number">5</span>    RB-TRANSPLANT(T, z, z.right)      <span class="comment">//   链接z.p和x</span></span><br><span class="line"><span class="number">6</span>  <span class="keyword">else</span> <span class="keyword">if</span> z.right == T.nil            <span class="comment">// z无右孩子</span></span><br><span class="line"><span class="number">7</span>    x = z.left                        <span class="comment">//   x为z的左孩子</span></span><br><span class="line"><span class="number">8</span>    RB-TRANSPLANT(T, z, z.left)       <span class="comment">//   链接z.p和x</span></span><br><span class="line"><span class="number">9</span>  <span class="keyword">else</span> y = TREE-MINIMUM(z.right)      <span class="comment">// z具有两个孩子，令y为z的后继，y将用于替换z，随后删除y</span></span><br><span class="line"><span class="number">10</span>   y-original-color = y.color        <span class="comment">// 记录y的颜色</span></span><br><span class="line"><span class="number">11</span>   x = y.right                       <span class="comment">// x是y的右儿子（y必无左儿子）</span></span><br><span class="line"><span class="number">12</span>   <span class="keyword">if</span> y.p == z                       <span class="comment">// 若y的父亲为z</span></span><br><span class="line"><span class="number">13</span>     x.p = z                         <span class="comment">//   令x的父亲为z (删除y) // 这一行CLRS写错了</span></span><br><span class="line"><span class="number">14</span>   <span class="keyword">else</span> RB-TRANSPLANT(T, y, y.right) <span class="comment">// 否则链接y.p和x (删除y)</span></span><br><span class="line"><span class="number">15</span>     y.right = z.right               <span class="comment">// 将z右子树挂到y右侧 (此时y已经是x了)</span></span><br><span class="line"><span class="number">16</span>     y.right.p = y                   <span class="comment">// 令z的右子树指向y (与上一行一起链接y和z.right)</span></span><br><span class="line"><span class="number">17</span>   RB-TRANSPLANT(T, z, y)            <span class="comment">// 链接z.p和y</span></span><br><span class="line"><span class="number">18</span>   y.left = z.left                   <span class="comment">// 将z左子树挂到y左侧 </span></span><br><span class="line"><span class="number">19</span>   y.left.p = y                      <span class="comment">// 令z的左子树指向y (与上一行一起链接y和z.left)</span></span><br><span class="line"><span class="number">20</span>   y.color = z.color                 <span class="comment">// y继承z的颜色</span></span><br><span class="line"><span class="number">21</span> <span class="keyword">if</span> y-original-color == BLACK        <span class="comment">// 说明删除了一个2-结点，要调平</span></span><br><span class="line"><span class="number">22</span>   RB-DELETE-FIXUP(T, x)             <span class="comment">// 上溯调平</span></span><br></pre></td></tr></table></figure><br /><h3 id="红黑树类架构"><a href="#红黑树类架构" class="headerlink" title="红黑树类架构"></a>红黑树类架构</h3><p>以下是红黑树类 (MyRBTree) 架构。</p><table><thead><tr><th>类成员&#x2F;方法</th><th>描述</th></tr></thead><tbody><tr><td><code>private Node&lt;K, V&gt; root;</code></td><td>字段，红黑树的根结点</td></tr><tr><td><code>private static final Boolean RED = false, BLACK = true;</code></td><td>常量字段，红与黑</td></tr><tr><td><code>public MyRBTree()</code></td><td>无参构造器，$root$ 初始为 $null$</td></tr><tr><td><code>public void makeEmpty()</code></td><td>树置空</td></tr><tr><td><code>public boolean isEmpty()</code></td><td>判断树是否为空</td></tr><tr><td><code>public boolean contains(K key)</code></td><td>判断是否有键为 $key$ 的结点</td></tr><tr><td><code>public V get(K key)</code></td><td>获取对应 $key$ 的 $val$</td></tr><tr><td><code>public K min()</code></td><td>返回最小 $key$</td></tr><tr><td><code>public K max()</code></td><td>返回最大 $key$</td></tr><tr><td><code>public Node&lt;K, V&gt; successor(Node&lt;K, V&gt; node)</code></td><td>返回 $node$ 的后继结点</td></tr><tr><td><code>public void put(K key, V val)</code></td><td>插入结点驱动方法</td></tr><tr><td><code>public void rotateLeft(Node&lt;K, V&gt; h)</code></td><td>左旋</td></tr><tr><td><code>public void rotateRight(Node&lt;K, V&gt; h)</code></td><td>右旋</td></tr><tr><td><code>public void delete(K key)</code></td><td>删除 $key$</td></tr><tr><td><code>public void printTree()</code></td><td>中序遍历打印红黑树</td></tr><tr><td><code>private Node&lt;K, V&gt; get(Node&lt;K, V&gt; x, K key)</code></td><td>在以 $x$ 为根结点的树中寻找目标键 $key$</td></tr><tr><td><code>private void fixAfterInsertion(Node&lt;K, V&gt; x)</code></td><td>插入 $x$ 结点后的调整</td></tr><tr><td><code>private void fixAfterDeletion(Node&lt;K, V&gt; x)</code></td><td>删除 $x$ 结点后的调整</td></tr><tr><td><code>private Node&lt;K,V&gt; leftOf(Node&lt;K,V&gt; p)</code></td><td>返回 $p$ 结点的左子结点</td></tr><tr><td><code>private Node&lt;K,V&gt; rightOf(Node&lt;K,V&gt; p)</code></td><td>返回 $p$ 结点的右子结点</td></tr><tr><td><code>private Node&lt;K, V&gt; parentOf(Node&lt;K, V&gt; node)</code></td><td>返回 $node$ 结点的父结点</td></tr><tr><td><code>private boolean colorOf(Node&lt;K, V&gt; node)</code></td><td>返回 $node$ 结点的颜色</td></tr><tr><td><code>private boolean isRed(Node&lt;K, V&gt; node)</code></td><td>判断 $node$ 结点是否为红</td></tr><tr><td><code>private boolean isBlack(Node&lt;K, V&gt; node)</code></td><td>判断 $node$ 结点是否为黑</td></tr><tr><td><code>private void setColor(Node&lt;K,V&gt; node, boolean color)</code></td><td>设置结点 $node$ 颜色为 $color$</td></tr><tr><td><code>private void put(Node&lt;K, V&gt; h, K key, V val)</code></td><td>插入结点</td></tr><tr><td><code>private void delete(Node&lt;K, V&gt; x)</code></td><td>删除结点</td></tr><tr><td><code>private void flipColor(Node&lt;K, V&gt; h)</code></td><td>结点 $h$ 反色</td></tr><tr><td><code>private void flipColors(Node&lt;K, V&gt; h)</code></td><td>结点 $h$ 及其左右子结点反色</td></tr><tr><td><code>private void printTree(Node t)</code></td><td>红序遍历打印红黑树 (以 $t$ 为根结点)</td></tr></tbody></table><p>以下为红黑树结点嵌套类 $Node$ 的架构。</p><table><thead><tr><th>类成员&#x2F;方法</th><th>描述</th></tr></thead><tbody><tr><td><code>public boolean color</code></td><td>字段，本结点颜色</td></tr><tr><td><code>public K key</code></td><td>字段，本结点 $key$</td></tr><tr><td><code>public V val</code></td><td>字段，本结点 $value$</td></tr><tr><td><code>public Node&lt;K, V&gt; parent, left, right</code></td><td>三个字段，本结点的父结点&#x2F;左子结点&#x2F;右子结点</td></tr><tr><td><code>public Node(Boolean color, K key, V val, Node parent, Node left, Node right)</code></td><td>构造器</td></tr></tbody></table><br /><h3 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h3><p>重难点方法已在前面章节中详细介绍，完整的类代码请参考「类的实现代码」。</p><br /><h3 id="类的实现代码"><a href="#类的实现代码" class="headerlink" title="类的实现代码"></a>类的实现代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyRBTree</span>&lt;K <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;K&gt;, V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;K, V&gt; root;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Boolean</span> <span class="variable">RED</span> <span class="operator">=</span> <span class="literal">false</span>, BLACK = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyRBTree</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeEmpty</span><span class="params">()</span> &#123; <span class="comment">// 树置空</span></span><br><span class="line">        root = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123; <span class="comment">// 树判空</span></span><br><span class="line">        <span class="keyword">return</span> root == <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(K key)</span> &#123; <span class="comment">// 判断是否存在key</span></span><br><span class="line">        <span class="keyword">if</span> (key == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;argument to contains() is null&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> get(root, key) != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(K key)</span> &#123; <span class="comment">// 获取对应key的val</span></span><br><span class="line">        <span class="keyword">if</span> (key == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;argument to get() is null&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> get(root, key).val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;K, V&gt; <span class="title function_">get</span><span class="params">(Node&lt;K, V&gt; x, K key)</span> &#123; <span class="comment">// 在以 x 为根结点的树中寻找目标键 key</span></span><br><span class="line">        <span class="keyword">while</span> (x != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">compareRes</span> <span class="operator">=</span> key.compareTo(x.key);</span><br><span class="line">            <span class="keyword">if</span> (compareRes &lt; <span class="number">0</span>) x = x.left; <span class="comment">// 在左子树中寻找</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (compareRes &gt; <span class="number">0</span>) x = x.right; <span class="comment">// 在右子树中寻找</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> x; <span class="comment">// 找到返回该目标 key 的 val</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    private Node&lt;K, V&gt; get(Node&lt;K, V&gt; x, K key) &#123; // 递归版本get</span></span><br><span class="line"><span class="comment">//        if (x == null) return null;</span></span><br><span class="line"><span class="comment">//        int cmp = key.compareTo(x.key);</span></span><br><span class="line"><span class="comment">//        if (cmp &lt; 0) return get(x.left, key); // 在左子树中寻找</span></span><br><span class="line"><span class="comment">//        else if (cmp &gt; 0) return get(x.right, key); // 在右子树中寻找</span></span><br><span class="line"><span class="comment">//        else return x; // 找到</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="keyword">public</span> K <span class="title function_">min</span><span class="params">()</span> &#123; <span class="comment">// 返回最小键值</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>(<span class="string">&quot;calls min() with empty symbol table&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> min(root).key;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;K, V&gt; <span class="title function_">min</span><span class="params">(Node&lt;K, V&gt; x)</span> &#123; <span class="comment">// 返回最小结点</span></span><br><span class="line">        <span class="keyword">if</span> (x.left == <span class="literal">null</span>) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> min(x.left);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    public Node&lt;K, V&gt; min(Node&lt;K, V&gt; node) &#123; // 迭代版</span></span><br><span class="line"><span class="comment">//        if (node.left == null) return node;</span></span><br><span class="line"><span class="comment">//        while (node.left != null) node = node.left;</span></span><br><span class="line"><span class="comment">//        return node;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="keyword">public</span> K <span class="title function_">max</span><span class="params">()</span> &#123; <span class="comment">// 返回最大键值</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>(<span class="string">&quot;calls max() with empty symbol table&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> max(root).key;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;K, V&gt; <span class="title function_">max</span><span class="params">(Node&lt;K, V&gt; x)</span> &#123; <span class="comment">// 返回最大键</span></span><br><span class="line">        <span class="keyword">if</span> (x.right == <span class="literal">null</span>) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> max(x.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Node&lt;K, V&gt; <span class="title function_">successor</span><span class="params">(Node&lt;K, V&gt; node)</span> &#123; <span class="comment">// 返回结点 node 的后继结点</span></span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="literal">null</span>) <span class="keyword">return</span> min(node.right);</span><br><span class="line">        <span class="comment">//下面这里是不会进入的，因为只有node的两个孩子都不为null时才会进入这个方法</span></span><br><span class="line">        Node&lt;K, V&gt; y = node.parent;</span><br><span class="line">        <span class="keyword">while</span> ((y != <span class="literal">null</span>) &amp;&amp; (y.right == node)) &#123;</span><br><span class="line">            node = y;</span><br><span class="line">            y = y.parent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(K key, V val)</span> &#123; <span class="comment">// 插入key-val结点</span></span><br><span class="line">        <span class="keyword">if</span> (key == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;first argument to put() is null&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (val == <span class="literal">null</span>) &#123; <span class="comment">// 表示删除该key</span></span><br><span class="line">            delete(key);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        put(root, key, val); <span class="comment">// 调用实际插入方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(Node&lt;K, V&gt; h, K key, V val)</span> &#123; <span class="comment">// 从结点 h 开始插入 key-val 结点</span></span><br><span class="line">        <span class="type">int</span> compareRes;</span><br><span class="line">        Node&lt;K, V&gt; cur = h, p = <span class="literal">null</span>; <span class="comment">// cur: 当前结点，p: cur的父结点</span></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            p = cur;</span><br><span class="line">            compareRes = key.compareTo(cur.key);</span><br><span class="line">            <span class="keyword">if</span> (compareRes &lt; <span class="number">0</span>) cur = cur.left; <span class="comment">// 往左</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(compareRes &gt; <span class="number">0</span>) cur = cur.right; <span class="comment">// 往右</span></span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// 存在key，修改其值后返回</span></span><br><span class="line">                cur.val = val;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="comment">// while正常结束，后续执行插入</span></span><br><span class="line">        Node&lt;K, V&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(RED, key, val, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>); <span class="comment">// 插入的结点总是红色的</span></span><br><span class="line">        newNode.parent = p;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">null</span>) &#123; <span class="comment">// 非空树，插入到 p 下</span></span><br><span class="line">            compareRes = newNode.key.compareTo(p.key);</span><br><span class="line">            <span class="keyword">if</span> (compareRes &lt; <span class="number">0</span>) p.left = newNode; <span class="comment">// 作为左子结点插入</span></span><br><span class="line">            <span class="keyword">else</span> p.right = newNode; <span class="comment">// 作为右子结点插入</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">this</span>.root = newNode; <span class="comment">// p == null 说明未进入while，树空，newNode作为根结点插入</span></span><br><span class="line">        fixAfterInsertion(newNode); <span class="comment">// 向上调整，保持与2-3树同构</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotateLeft</span><span class="params">(Node&lt;K, V&gt; h)</span> &#123; <span class="comment">// 左旋</span></span><br><span class="line">        Node&lt;K, V&gt; x = h.right; <span class="comment">// h左上x右下</span></span><br><span class="line">        h.right = x.left; <span class="comment">// x左子树挂到h右侧</span></span><br><span class="line">        <span class="keyword">if</span> (x.left != <span class="literal">null</span>) x.left.parent = h; <span class="comment">// x左子树不空，x左子树的父节点更新为h</span></span><br><span class="line">        x.parent = h.parent; <span class="comment">// x转到h位置上，x的父节点为h的父节点</span></span><br><span class="line">        <span class="keyword">if</span> (h.parent == <span class="literal">null</span>) <span class="built_in">this</span>.root = x; <span class="comment">// 若h为根结点 则x取代h后x为根结点</span></span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// 若h不为根结点</span></span><br><span class="line">            <span class="keyword">if</span> (h == h.parent.left) h.parent.left = x; <span class="comment">// h是左儿子，h的父节点更新其左儿子为x</span></span><br><span class="line">            <span class="keyword">else</span> h.parent.right = x; <span class="comment">// h是右儿子，h的父节点更新其右儿子为x</span></span><br><span class="line">        &#125;</span><br><span class="line">        x.left = h; <span class="comment">// x左儿子更新为h</span></span><br><span class="line">        h.parent = x; <span class="comment">// h父节点更新为x</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotateRight</span><span class="params">(Node&lt;K, V&gt; h)</span> &#123; <span class="comment">// 右旋</span></span><br><span class="line">        Node&lt;K, V&gt; x = h.left;</span><br><span class="line">        h.left = x.right;</span><br><span class="line">        <span class="keyword">if</span> (x.right != <span class="literal">null</span>) x.right.parent = h;</span><br><span class="line">        x.parent = h.parent;</span><br><span class="line">        <span class="keyword">if</span> (h.parent == <span class="literal">null</span>) <span class="built_in">this</span>.root = x;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (h == h.parent.right) h.parent.right = x;</span><br><span class="line">            <span class="keyword">else</span> h.parent.left = x;</span><br><span class="line">        &#125;</span><br><span class="line">        x.right = h;</span><br><span class="line">        h.parent = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fixAfterInsertion</span><span class="params">(Node&lt;K, V&gt; x)</span> &#123; <span class="comment">// 插入结点 x 后向上调整</span></span><br><span class="line">        Node&lt;K, V&gt; p, g; <span class="comment">// parent, grandParent</span></span><br><span class="line">        <span class="keyword">while</span> (((p = parentOf(x)) != <span class="literal">null</span>) &amp;&amp; isRed(p)) &#123;</span><br><span class="line">            g = parentOf(p);</span><br><span class="line">            <span class="keyword">if</span> (p == g.left) &#123; <span class="comment">// x的父节点是一个左儿子</span></span><br><span class="line">                Node&lt;K, V&gt; u = g.right; <span class="comment">// uncle: p的兄弟结点，k的叔结点</span></span><br><span class="line">                <span class="keyword">if</span> (isRed(u)) &#123; <span class="comment">// case1: x的叔结点为红，则x插入到一个4-结点中</span></span><br><span class="line">                    flipColors(g);</span><br><span class="line">                    x = g; <span class="comment">// 插入4-结点只需反色，此时要上溯到变红的g</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// x的叔结点为黑，则x插入到一个3-结点中</span></span><br><span class="line">                    <span class="keyword">if</span> (x == p.right) &#123; <span class="comment">// case2: x是一个右儿子</span></span><br><span class="line">                        x = p;</span><br><span class="line">                        rotateLeft(p); <span class="comment">// 左旋，之后x在底部</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    flipColor(p); <span class="comment">// case3: 反色 setColor(p, BLACK);</span></span><br><span class="line">                    flipColor(g); <span class="comment">// case3: 反色 setColor(g, RED);</span></span><br><span class="line">                    rotateRight(g); <span class="comment">// case3: 右旋</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// x的父节点是一个右儿子</span></span><br><span class="line">                Node&lt;K, V&gt; u = g.left;</span><br><span class="line">                <span class="keyword">if</span> (isRed(u)) &#123;</span><br><span class="line">                    flipColors(g);</span><br><span class="line">                    x = g;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (x == p.left) &#123;</span><br><span class="line">                        x = p;</span><br><span class="line">                        rotateRight(p);</span><br><span class="line">                    &#125;</span><br><span class="line">                    flipColor(p);</span><br><span class="line">                    flipColor(g);</span><br><span class="line">                    rotateLeft(g);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x == root) setColor(x, BLACK);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(K key)</span> &#123; <span class="comment">// 删除key对应的结点</span></span><br><span class="line">        Node&lt;K, V&gt; x = get(<span class="built_in">this</span>.root, key); <span class="comment">// 找到key对应的结点x</span></span><br><span class="line">        <span class="keyword">if</span> (x != <span class="literal">null</span>) delete(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Node&lt;K, V&gt; x)</span> &#123; <span class="comment">// 删除结点 x</span></span><br><span class="line">        <span class="keyword">if</span> (x.left != <span class="literal">null</span> &amp;&amp; x.right != <span class="literal">null</span>) &#123; <span class="comment">// x 有左右孩子</span></span><br><span class="line">            Node&lt;K,V&gt; s = successor(x); <span class="comment">// 找到x的后继</span></span><br><span class="line">            x.key = s.key; <span class="comment">// s 取代 x</span></span><br><span class="line">            x.val = s.val; <span class="comment">// s 取代 x</span></span><br><span class="line">            x = s; <span class="comment">// x 此时是实际要删除的 s</span></span><br><span class="line">        &#125; <span class="comment">// 经过此 if 后，x 为实际要删除的结点，x 要么为无孩子的叶子结点，要么只有一个孩子结点</span></span><br><span class="line">        <span class="comment">// case1:x只有左孩子或右孩子</span></span><br><span class="line">        <span class="comment">// case2:若x无孩子，r为null</span></span><br><span class="line">        Node&lt;K,V&gt; r = x.left != <span class="literal">null</span> ? x.left : x.right; <span class="comment">// r: replacement用来取代x</span></span><br><span class="line">        <span class="keyword">if</span> (r != <span class="literal">null</span>) &#123; <span class="comment">// case1</span></span><br><span class="line">            <span class="comment">// if(colorOf(r) != RED) System.out.println(&quot;xx&quot;); // 测试，r一定为红</span></span><br><span class="line">            <span class="comment">// if(colorOf(x) != BLACK) System.out.println(&quot;xx&quot;); // 测试，x一定为黑</span></span><br><span class="line">            <span class="comment">// Node&lt;K, V&gt; uncle = r == x.left ? x.right : x.left; //</span></span><br><span class="line">            <span class="comment">// if(uncle != null) System.out.println(&quot;xx&quot;); // 测试，uncle一定为null</span></span><br><span class="line">            <span class="comment">// if(colorOf(uncle) != BLACK) System.out.println(&quot;xx&quot;); // 测试，uncle一定为黑（null）</span></span><br><span class="line">            <span class="comment">// 以下四句链接x.p与r</span></span><br><span class="line">            r.parent = x.parent;</span><br><span class="line">            <span class="keyword">if</span> (x.parent == <span class="literal">null</span>) root = r; <span class="comment">// 原x为root</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (x == x.parent.left) x.parent.left  = r; <span class="comment">// 原x不为root且为一个左孩子</span></span><br><span class="line">            <span class="keyword">else</span> x.parent.right = r; <span class="comment">// 原x不为root且为一个右孩子</span></span><br><span class="line">            x.left = x.right = x.parent = <span class="literal">null</span>; <span class="comment">// 删除x (x脱离树，置其左右子结点和父结点为 null)</span></span><br><span class="line">            setColor(r, BLACK); <span class="comment">// r一定为红，置黑</span></span><br><span class="line">            <span class="comment">// if (x.color == BLACK) fixAfterDeletion(r); // 调整</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x.parent == <span class="literal">null</span>)  &#123; <span class="comment">// case2 x无孩子且无父结点，x为根结点，且该树只有此结点</span></span><br><span class="line">            root = <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// case2 x无孩子但有父节点，则x为一叶子结点</span></span><br><span class="line">            <span class="keyword">if</span> (x.color == BLACK) fixAfterDeletion(x); <span class="comment">// x为2结点，调整</span></span><br><span class="line">            <span class="keyword">if</span> (x.parent != <span class="literal">null</span>) &#123; <span class="comment">// 删除x</span></span><br><span class="line">                <span class="keyword">if</span> (x == x.parent.left) x.parent.left = <span class="literal">null</span>; <span class="comment">// x为一左子结点</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (x == x.parent.right) x.parent.right = <span class="literal">null</span>; <span class="comment">// x为一右子结点</span></span><br><span class="line">                x.parent = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fixAfterDeletion</span><span class="params">(Node&lt;K, V&gt; x)</span> &#123; <span class="comment">// 删除结点 x 后向上调整</span></span><br><span class="line">        Node&lt;K, V&gt; parent = parentOf(x);</span><br><span class="line">        <span class="keyword">while</span> (isBlack(x) &amp;&amp; x != root) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x == leftOf(parent)) &#123; <span class="comment">// x是一个左子结点</span></span><br><span class="line">                Node&lt;K, V&gt; sib = rightOf(parent);</span><br><span class="line">                <span class="comment">// case1：sib为红，转换为后续case</span></span><br><span class="line">                <span class="keyword">if</span> (isRed(sib)) &#123;</span><br><span class="line">                    setColor(parent, RED);</span><br><span class="line">                    setColor(sib,BLACK);</span><br><span class="line">                    rotateLeft(parent);</span><br><span class="line">                    <span class="comment">// sib = parent.right; //「算法导论」伪代码有此句，可以省略</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// case2:左黑右黑，这种情形可能需要继续向上调平</span></span><br><span class="line">                <span class="keyword">if</span> (isBlack(leftOf(sib)) &amp;&amp; isBlack(rightOf(sib))) &#123;</span><br><span class="line">                    setColor(sib, RED);</span><br><span class="line">                    x = parent; <span class="comment">// 向上调平</span></span><br><span class="line">                    parent = parentOf(x); <span class="comment">// 更新parent</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// case3 &amp; case4 一定能够恢复同构</span></span><br><span class="line">                    <span class="comment">// case3: 右黑，其实就是左红右黑，转换为case4</span></span><br><span class="line">                    <span class="keyword">if</span> (isBlack(rightOf(sib))) &#123;</span><br><span class="line">                        setColor(sib.left, BLACK);</span><br><span class="line">                        setColor(sib, RED);</span><br><span class="line">                        rotateRight(sib);</span><br><span class="line">                        <span class="comment">// sib = parent.right; //「算法导论」伪代码有此句，可以省略</span></span><br><span class="line">                    &#125; <span class="comment">// 以下是case4: 右红，其实就是左红右红或左黑右红，这种情形一定恢复同构</span></span><br><span class="line">                    setColor(sib, colorOf(parent));</span><br><span class="line">                    setColor(parent, BLACK);</span><br><span class="line">                    setColor(rightOf(sib), BLACK);</span><br><span class="line">                    rotateLeft(parent);</span><br><span class="line">                    x = root; <span class="comment">//此句用于退出while，因为case3和case4调整后必恢复同构</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Node&lt;K, V&gt; sib = leftOf(parent);</span><br><span class="line">                <span class="keyword">if</span> (isRed(sib)) &#123;</span><br><span class="line">                    setColor(parent, RED);</span><br><span class="line">                    setColor(sib, BLACK);</span><br><span class="line">                    rotateRight(parent);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (isBlack(leftOf(sib)) &amp;&amp; isBlack(rightOf(sib))) &#123;</span><br><span class="line">                    setColor(sib, RED);</span><br><span class="line">                    x = parent;</span><br><span class="line">                    parent = parentOf(x);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (isBlack(leftOf(sib))) &#123;</span><br><span class="line">                        setColor(sib.right, BLACK);</span><br><span class="line">                        setColor(sib, RED);</span><br><span class="line">                        rotateLeft(sib);</span><br><span class="line">                    &#125;</span><br><span class="line">                    setColor(sib, colorOf(parent));</span><br><span class="line">                    setColor(parent, BLACK);</span><br><span class="line">                    setColor(leftOf(sib), BLACK);</span><br><span class="line">                    rotateRight(parent);</span><br><span class="line">                    x = root;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// while结束要么是case3/case4调整后已平衡 x被被置为root后主动退出，</span></span><br><span class="line">        <span class="comment">// 要么是case1/case2 x为红。若为前者无需此句(此时的root一定是黑的)</span></span><br><span class="line">        <span class="comment">// 若为后者，说明此时的x结点是原3-结点或4-结点出借的结点，如果还保持红色，</span></span><br><span class="line">        <span class="comment">// 将无法脱离原3-结点或4-结点 (2-3-4树)，因此必须置黑。</span></span><br><span class="line">        setColor(x, BLACK); <span class="comment">// 也可以写成这样 if(x != root) setColor(x, BLACK);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;K,V&gt; <span class="title function_">leftOf</span><span class="params">(Node&lt;K,V&gt; p)</span> &#123; <span class="comment">// 返回 p 的左子结点</span></span><br><span class="line">        <span class="keyword">return</span> (p == <span class="literal">null</span>) ? <span class="literal">null</span>: p.left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node&lt;K,V&gt; <span class="title function_">rightOf</span><span class="params">(Node&lt;K,V&gt; p)</span> &#123; <span class="comment">// 返回 p 的右子结点</span></span><br><span class="line">        <span class="keyword">return</span> (p == <span class="literal">null</span>) ? <span class="literal">null</span>: p.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;K, V&gt; <span class="title function_">parentOf</span><span class="params">(Node&lt;K, V&gt; node)</span> &#123; <span class="comment">// 返回 p 的父结点</span></span><br><span class="line">        <span class="keyword">return</span> node != <span class="literal">null</span> ? node.parent : <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">colorOf</span><span class="params">(Node&lt;K, V&gt; node)</span> &#123; <span class="comment">// 返回 node 的颜色</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span>) <span class="keyword">return</span> node.color;</span><br><span class="line">        <span class="keyword">return</span> BLACK;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    public void setParent(Node&lt;K, V&gt; node, Node&lt;K, V&gt; parent) &#123;</span></span><br><span class="line"><span class="comment">//        if (node != null) node.parent = parent;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isRed</span><span class="params">(Node&lt;K, V&gt; node)</span> &#123; <span class="comment">// 判断 node 是否为红</span></span><br><span class="line">        <span class="keyword">return</span> (node != <span class="literal">null</span> &amp;&amp; node.color == RED) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isBlack</span><span class="params">(Node&lt;K, V&gt; node)</span> &#123; <span class="comment">// 判断 node 是否为黑</span></span><br><span class="line">        <span class="keyword">return</span> !isRed(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setColor</span><span class="params">(Node&lt;K,V&gt; node, <span class="type">boolean</span> color)</span> &#123; <span class="comment">// 设置 node 的颜色为 color</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span>) node.color = color;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">flipColor</span><span class="params">(Node&lt;K, V&gt; h)</span> &#123; <span class="comment">// 结点 h 反色</span></span><br><span class="line">        h.color = !h.color;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">flipColors</span><span class="params">(Node&lt;K, V&gt; h)</span> &#123; <span class="comment">// 「^」形反色 (h为「^」形的父结点)</span></span><br><span class="line">        h.color = !h.color;</span><br><span class="line">        h.left.color = !h.left.color;</span><br><span class="line">        h.right.color = !h.right.color;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printTree</span><span class="params">()</span>&#123; <span class="comment">// 中序遍历打印红黑树</span></span><br><span class="line">        printTree(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printTree</span><span class="params">(Node t)</span> &#123; <span class="comment">// 中序遍历打印红黑树</span></span><br><span class="line">        <span class="keyword">if</span>(t != <span class="literal">null</span>) &#123;</span><br><span class="line">            printTree(t.left);</span><br><span class="line">            System.out.print(t.key + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            printTree(t.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 红黑树结点嵌套类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;K&gt;, V&gt; &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> color;</span><br><span class="line">        <span class="keyword">public</span> K key;</span><br><span class="line">        <span class="keyword">public</span> V val;</span><br><span class="line">        <span class="keyword">public</span> Node&lt;K, V&gt; parent, left, right;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Boolean color, K key, V val, Node parent, Node left, Node right)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.color = color;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.val = val;</span><br><span class="line">            <span class="built_in">this</span>.parent = parent;</span><br><span class="line">            <span class="built_in">this</span>.left = left;</span><br><span class="line">            <span class="built_in">this</span>.right = right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( String [ ] args )</span> &#123;</span><br><span class="line">    MyRBTree&lt;Integer, Integer&gt; t = <span class="keyword">new</span> <span class="title class_">MyRBTree</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">NUMS</span> <span class="operator">=</span> <span class="number">1_000_000</span>, GAP = <span class="number">307</span>;</span><br><span class="line"></span><br><span class="line">    System.out.println( <span class="string">&quot;Checking... (no bad output means success)&quot;</span> );</span><br><span class="line">    <span class="comment">// 插入测试</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> GAP; key != <span class="number">0</span>; key = (key + GAP) % NUMS) t.put( key , key + <span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;Inserts complete&quot;</span>);</span><br><span class="line">    <span class="comment">// 删除测试</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> <span class="number">1</span>; key &lt; NUMS; key += <span class="number">2</span>) t.delete(key);</span><br><span class="line">    System.out.println( <span class="string">&quot;Removes complete&quot;</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> <span class="number">2</span>; key &lt; NUMS; key += <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!t.contains(key)) System.out.println( <span class="string">&quot;Error: find fails for &quot;</span> + key );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> <span class="number">1</span>; key &lt; NUMS; key += <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(t.contains(key)) System.out.println( <span class="string">&quot;Error: Found deleted item &quot;</span> + key );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    NUMS = <span class="number">5_000_000</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> GAP; key != <span class="number">0</span>; key = (key + GAP) % NUMS) t.put( key , key + <span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;Inserts complete&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> <span class="number">1</span>; key &lt; NUMS; key += <span class="number">2</span>) t.delete(key);</span><br><span class="line">    System.out.println( <span class="string">&quot;Removes complete&quot;</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> <span class="number">2</span>; key &lt; NUMS; key += <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!t.contains(key)) System.out.println( <span class="string">&quot;Error: find fails for &quot;</span> + key );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> <span class="number">1</span>; key &lt; NUMS; key += <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(t.contains(key)) System.out.println( <span class="string">&quot;Error: Found deleted item &quot;</span> + key );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下说明测试通过。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Checking... (no bad output means success)</span><br><span class="line">Inserts complete</span><br><span class="line">Removes complete</span><br><span class="line">Inserts complete</span><br><span class="line">Removes complete</span><br></pre></td></tr></table></figure><br /><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><ul><li>指出了红黑颜色本质上是 BST 附带的1bit信息，该信息的存在使得红黑树在保持 BST 形态的同时始终与2-3-4树同构。</li><li>详细解释了红黑树五大性质的根本。</li><li>深入分析并展示了红黑树的插入结点和删除结点操作。</li><li>在「删除结点」小节中，仔细对比了各情形下的2-3-4树与红黑树形态，从数十种形态中成功归约出 4 种独立情形。</li><li>提出 JDK 中代码中的疑似存在的逻辑瑕疵 (充分验证后将向 Oracle 报告该问题)。</li><li>给出了较为完整的红黑树类的代码。</li></ul><br /><h2 id="左倾红黑树"><a href="#左倾红黑树" class="headerlink" title="左倾红黑树"></a>左倾红黑树</h2><p>这一节我们学习前述经典红黑树的一种变体，即著名的 <em>Algorithms 4th</em> 一书中介绍的 <strong>左倾红黑树 ( <em>Left-Leaning Red-black Tree, LLRBT</em> )</strong> ，LLRBT 的提出者以及「红黑树」的命名者正是该书作者 Sedgewick。</p><p>我们已经知道，经典红黑树与2-3-4树同构，本节中我们将看到  <strong>LLRBT 与2-3树同构</strong> ，它也是 BST ，因此在保持2-3树的「完美平衡」优点的基础上 (在 <em>LLRBT</em> 中体现为完美黑平衡)，也能够直接继承基本 BST 操作的写法，这一点与经典红黑树是一样的。在 LLRBT 中，尤其是在其删除操作中，我们将领略技巧十分高超的代码实现。</p><blockquote><p>「左倾红黑树」由 Sedgewick 在 <a href="https://sedgewick.io/wp-content/themes/sedgewick/papers/2008LLRB.pdf">这篇论文</a> 中提出。</p><p><a href="http://read.seas.harvard.edu/~kohler/">Eddie Kohler</a> 的文章 <a href="https://read.seas.harvard.edu/~kohler/notes/llrb.html">Left-Leaning Red-Black Trees Considered Harmful</a> 指出了 LLRBT 的一些缺点，文章中对经典红黑树和 LLRBT 做了许多比较，推荐阅读。</p></blockquote><br /><h3 id="从2-3树到LLRBT"><a href="#从2-3树到LLRBT" class="headerlink" title="从2-3树到LLRBT"></a>从2-3树到LLRBT</h3><p>从2-3树转换为 LLRBT 比2-3-4树到红黑树的转换更为简单，只需将2-3树的所有3-结点转变为一条 <strong>左斜的红链</strong> (这就是 LLRBT 名称的由来) 即可。子结点 (左下结点) 为红色，父结点 (右上结点) 为黑色。显然 LLRBT 可与一棵2-3树严格对应。下图将红黑树中的红链横放，将红链看作一个3-结点后，能够很清楚地看出 LLRBT 与2-3树严格对应。</p><p>※ LLRBT 规定红链左斜是为了使红黑树更易于实现。本节图片多为 <em>Algorithms 4th</em> 的原图。</p><p><img src="https://pic.leetcode-cn.com/1656579122-NSljEB-image.png" alt="image.png"></p><p>有了这样的定义和对应关系后，我们指出 LLRBT 具有以下性质。</p><table><thead><tr><th>LLRBT 性质</th><th>描述</th></tr></thead><tbody><tr><td>1. 红链左斜</td><td>所有红链都是左斜的</td></tr><tr><td>2. 红链不相邻</td><td>不存在与同一个结点相连的两条红链</td></tr><tr><td>3. 完美黑平衡</td><td>LLRBT 是「完美黑平衡」的，即任意叶子结点到根结点所经过的黑链数相同。</td></tr></tbody></table><ul><li>1由定义决定。</li><li>对于2，在「红黑树」一节中我们已经知道，两条相邻的红链是4-结点。</li><li>对于3，因为2-3树是完美平衡的，转换成 LLRBT 后，不考虑红链 (本质为一个3-结点) 的情况下 (即只考虑黑链) 是完美平衡的，于是对整棵 LLRBT ，我们就说它完美黑平衡。</li></ul><br /><h4 id="结点变换-3"><a href="#结点变换-3" class="headerlink" title="结点变换"></a>结点变换</h4><p>LLRBT 与2-3树严格对应，因此其保持平衡的操作也应当 <strong>与2-3树相对应</strong> ，我们已经知道，2-3树是通过「结点变换」来保持平衡的，之前我们通过考察2-3树结点插入过程分析过其结点变换过程，同样地，在本节中我们采用对照的方式，首先考察 LLRBT 插入结点过程中的结点变换，然后考察在2-3树中未涉及的删除结点过程中的结点变换，后者相比前者要更为复杂。</p><br /><h4 id="插入结点-1"><a href="#插入结点-1" class="headerlink" title="插入结点"></a>插入结点</h4><p>我们直接对比2-3树的插入情形，写出 LLRBT 与之对应的变换过程。</p><ol><li>情形1。在2-3树中插入目标键 ($x$) 后2-结点变为3-结点，对应到 LLRBT 即按照基本 BST 方式插入后，插入结点与其父结点的链为 <strong>红链</strong> (红链才能对应到2-3树中的3-结点)，实际表现为该插入结点为红色。如果红链为右链，那么根据性质1，需左旋该链，实际操作为左旋其父结点 (左旋方法参数传入父结点)。</li><li>情形2。对于2-3树插入目标键 ($x$) 后3-结点 (两个键分别为 $y,z$ ) 变为4-结点，然后分解为3个2-结点。这个分解实际上包含了三种细分情形，$x &lt; y &lt; z$， $y &lt; x &lt; z$，$y &lt; z &lt; x$ ，使得分解后 $x,y,z$ 的相对位置有所不同，但形态上是一样的。但对应到 LLRBT 中，这三种情形的形态各不相同，分别为 <strong>「&#x2F;」形、「&lt;」形及「^」形</strong> ，如后图。这三种形态都表现为 <strong>「两条相邻的红链」</strong> ，我们知道这代表了4-结点，所以也要像2-3树那样分解为3个2-结点，具体操作如下。<ol><li>首先考虑「^」形，此形态 <strong>本身已经是三个2-结点</strong> ，因此直接将「^」上的三个结点反色即可，即将左右子结点的颜色置黑，父结点置红。</li><li>对于「&#x2F;」形，只需将上段红链右旋后 (对右上顶点执行右旋) 即可转变为「^」形，随后反色。</li><li>对于「&lt;」形，只需将下段红链左旋后 (对中间顶点执行左旋) 即可转变为「&#x2F;」形，然后将上段红链右旋变为「^」形，最后反色。</li></ol></li><li>情形3。在2-3树中也是4-结点分解为3个2结点，但父结点会变为3-结点，对应到 LLRBT 中，根据情形2的分析，变换为3个2结点最终都对应着「^」形结构，父结点变为3-结点对应着 「^」 形结构的 <strong>中结点要被置为红色</strong> ，相当于向父结点中放入一个结点。这一对应使得该情形的 「^」 形反色时，左右两个结点被置为黑色的同时，中结点要被置为红色。</li><li>情形4。如下图，三种情形最终都会变成右侧形态，即对应2-3树中父结点变为4-结点 (两条相邻红链)，此后继续向上按规则变换即可 (在实现中在递归的回溯过程中执行)。</li></ol><p><img src="https://pic.leetcode-cn.com/1656579594-VeVCZn-image.png" alt="image.png"></p><p>※ 在情形2中，由于 LLBRT 在操作后只有左红链，所以插入结点后一定不会出现「<code>\</code>」形或「<code>&gt;</code>」形。</p><table><thead><tr><th>情形</th><th>2-3树</th><th>LLRBT</th></tr></thead><tbody><tr><td>1. 插入至2-结点中</td><td>变为 <strong>3-结点</strong></td><td>变为 <strong>红链</strong> ，若为右红链，则左旋</td></tr><tr><td>2. 插入至3-结点中<br />(该结点为根结点)</td><td>变为4-结点，分解为3个2-结点</td><td>根据新键与原3-结点(红链连接的两个结点)中两键的大小关系，有三种情形。<br />1. 「^」形，反色<br />2. 「&#x2F;」形，上段右旋为「^」后反色<br />3. 「&lt;」形，下段左旋为「&#x2F;」后上段右旋为「^」后反色</td></tr><tr><td>3. 插入至3-结点中<br />(父结点为2-结点)</td><td>变为4-结点，分解为3个2-结点，其中一个与父结点合并，使得父结点变为3-结点</td><td>同上</td></tr><tr><td>4. 插入至3-结点中<br />(父结点为3-结点)</td><td>与上一条类似，其中一个与父结点合并，使得父结点变为4-结点，继续向上(插入一个结点后)分解直到：<br />1. 遇到2-结点，转变为情形1。<br />2. 到根处仍为3-结点，转变为情形2。</td><td>「^」「&#x2F;」「&lt;」最终都使得其上侧变为两条相邻的红链，此后再继续向上变换。</td></tr></tbody></table><p>下图展示了在 LLRBT 的2-结点和3-结点中插入结点的过程。</p><p><img src="https://pic.leetcode-cn.com/1656593349-jhEnAc-image.png" alt="image.png"></p><p>通过上述对照分析，我们看到通过颜色调整和旋转 LLRBT 的实现确实与2-3树一一对应，这也解释了一些一开始不太好理解的操作细节，例如令插入结点为「红色」、三种「相邻红链」情形的变换过程，以及「^」形时的反色动作 (两个子结点变黑，父结点变红)， 这些都是 LLRBT 与2-3树同构所要求的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(K key, V val)</span> &#123; <span class="comment">// 插入key-val结点</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;first argument to put() is null&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (val == <span class="literal">null</span>) &#123; <span class="comment">// 表示删除该key</span></span><br><span class="line">        delete(key);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    root = put(root, key, val); <span class="comment">// 调用实际插入方法</span></span><br><span class="line">    root.color = BLACK; <span class="comment">// 每次插入结点后根结点都要描黑</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">put</span><span class="params">(Node h, K key, V val)</span> &#123; <span class="comment">// 在以h为根的树中插入结点key-val</span></span><br><span class="line">    <span class="keyword">if</span> (h == <span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Node</span>(key, val, RED, <span class="number">1</span>); <span class="comment">// 插入 (与父结点用红链连接)</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">compareRes</span> <span class="operator">=</span> key.compareTo(h.key);</span><br><span class="line">    <span class="keyword">if</span> (compareRes &lt; <span class="number">0</span>) h.left = put(h.left, key, val); <span class="comment">// 在左子树中寻找插入位置</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (compareRes &gt; <span class="number">0</span>) h.right = put(h.right, key, val); <span class="comment">// 在右子树中寻找插入位置</span></span><br><span class="line">    <span class="keyword">else</span> h.val = val; <span class="comment">// key相等，更新键</span></span><br><span class="line">    <span class="keyword">return</span> balance(h); <span class="comment">// 回溯过程中向上调整</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">balance</span><span class="params">(Node h)</span> &#123; <span class="comment">// 恢复结点h处的LLRBT性质</span></span><br><span class="line">    <span class="keyword">if</span> (!isRed(h.left) &amp;&amp; isRed(h.right)) h = rotateLeft(h); <span class="comment">// 左黑右红（包含「&lt;」形），左旋</span></span><br><span class="line">    <span class="keyword">if</span> (isRed(h.left) &amp;&amp; isRed(h.left.left)) h = rotateRight(h); <span class="comment">// 「/」形，上段右旋</span></span><br><span class="line">    <span class="keyword">if</span> (isRed(h.left) &amp;&amp; isRed(h.right)) flipColors(h); <span class="comment">// 「^」型，反色</span></span><br><span class="line">    h.size = size(h.left) + size(h.right) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h5 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h5><p>现在我们来看 LLRBT 中的旋转操作。下图分别展示了左旋和右旋过程以及相应的代码，我们之前说过，2-3树&#x2F;2-3-4树不是通过旋转，而是通过结点变换来保持平衡，但是，当我们用红黑树&#x2F;LLRBT 来表示2-3-4树&#x2F;2-3树时，为了能够在保持与2-3-4树&#x2F;2-3树的对应，是需要旋转操作的，这一点我们已经在前面分析过了。从下图可以看到，LLRBT 的旋转操作与以前我们学习过的旋转操作基本一样，只是因为要保持链的颜色不变，因此多了 <strong>结点颜色调整</strong> 的步骤 (以及子树结点数的更新)。</p><p><img src="https://pic.leetcode-cn.com/1656662489-Tkudlb-Snipaste_2022-07-01_16-01-08.png" alt="image.png"></p><br /><h4 id="删除结点-1"><a href="#删除结点-1" class="headerlink" title="删除结点"></a>删除结点</h4><p>如同 BST 的删除操作那样，删除结点的方法中，首先要找到该结点，然后用该结点右子结点为根结点的子树中的最小结点 (键值) 来替换删除目标结点，再执行删除最小结点方法删掉被替换的最小结点，因此需要 <strong>先实现删除最小结点方法</strong> 。</p><p>我们先考虑2-3树的删除过程，首先把「删除结点」的表述替换成「删除键」(在2-3树中，只有最小键在2-结点中才会「删除结点」，否则只是删除键)。最小键一定在叶子结点中，当该叶子结点为3-结点时 (最小键为该3-结点的两个键中较小的那个)，直接删除该最小键即可。若最小键对应的叶子结点是2-结点，直接删除会导致不满足2-3树的结构要求。为了保持仍为一棵2-3树，一个简单的想法是，通过某种 <strong>「膨胀调整」</strong> ，使得删除最小键时，它所在的叶子结点的容量比2-结点大，这时候就可以直接删除它 (此时它是结点中最左边的键)，结点仍在 (只是缩小了)，也就能够保持完美平衡。</p><p>因为我们不知道什么时候会到达最小键所在的叶子结点，为了能够让最小键所在结点最终调整成比2-结点大的结点，我们需要从根开始这一调整，在从根到目标结点的路径上，考察途径的当前结点，当此结点为2-结点时，将其膨胀。在「插入结点」过程中，对临时出现的4-结点，我们采取了分解操作，相对应地，膨胀可以看作 <strong>分解的逆过程</strong> 。</p><p>「结点膨胀」的实现稍后讲解，先假设已经实现，那么经过上述操作，我们 <strong>一定能够保证</strong> 到达最小键所在结点时，该结点比2-结点大，从而能够删除最小键而不破坏2-3树的完美平衡性质。此外，如下事实也是易知的。</p><ol><li>过程中可能会出现4-结点 (但不会出现更大的结点) ，也可以说删除操作使得这棵树的 <strong>中间态为一棵2-3-4树</strong> 。</li><li>如果是根结点及其左右儿子结点均为2-结点的情况，这三个2-结点将膨胀为一个4-结点，树高将减 1 (对2-3-4树而言减1，对 LLRBT 而言则不变) 。</li><li>最小键对应到 BST 中，一定是一个 <strong>左斜红链下的红色叶子结点</strong> 。</li></ol><p>对于第 3 点，我们也可以说删除最小键所做的膨胀操作，就是为了保证我们最终删除的最小键，是一个左斜链下的红色叶子结点。</p><p><img src="https://pic.leetcode-cn.com/1656597810-EriWBE-image.png" alt="image.png"></p><p>完成删除后，程序开始回溯，在回溯的过程中分解删除路径上临时产生的4-结点，这一过程与「插入结点」的回溯过程完全相同。回溯到根结点时，若删除开始之前根结点及其左右儿子结点均为2-结点的情况，它们会合成为一个4-结点，那么此时会被分解为三个2-结点，树高加 1  (对2-3-4树而言加1，对 LLRBT 而言则不变) 。</p><br /><h5 id="膨胀"><a href="#膨胀" class="headerlink" title="膨胀"></a>膨胀</h5><p>现在我们来分析「结点膨胀」，这一部分是整个 LLRBT 最难的内容，请读者将如下文字描述与示意图和代码结合起来理解。示意图中 LLRBT 以常规的 BST 形式呈现，为了集中精力理解膨胀过程，不再表现键值，一些不重要的分支也不画出。注意，描述时我们必须同时将 LLBRT 看作2-3-4树 (虽然 LLBRT 对应的是2-3树，但删除的过程的中间态是2-3-4树) ，必要时我会在「结点」一词后用括号 (BST) 或 (2-3-4树) 来强调此时说的结点是哪种形态语境下的结点。这样做的原因是为了保持 LLRBT 始终与2-3树同构，因此当行文强调2-3树&#x2F;2-3-4树时，读者不妨在脑海中将 LLRBT 中的红链放平，将水平的结点看作一个结点 (2-3树&#x2F;2-3-4树的结点)。以下，我们将当前结点为根结点的情况记作case1，不为根结点的情况记作case2。</p><p><strong>首先处理case1</strong> 。当前结点 (BST) 是根结点 (BST) ，为黑色，我们要考察它是2-结点还是3-结点。先列出我们的目标：</p><ol><li>如果根结点是3-结点，无需处理，继续前往左子树。</li><li>如果根结点是2-结点。<ol><li>且两个子结点都是2-结点，将这三个2-结点膨胀为一个4-结点。</li><li>若左子结点为2-结点，右子结点不是2-结点，就通过右子结点借一个键到左子结点中 (通过旋转，实际借的是根结点的键)。</li></ol></li></ol><p>现在来实现上述目标。在删除最小键驱动方法中，若不满足 <code>if (!isRed(root.left) &amp;&amp; !isRed(root.right))</code> ，则说明根结点为3-结点，记作case1-1，否则根结点为2-结点，记作case1-2 (注意，根据 LLRBT 的性质，根结点及其左右子结点的形态只能是case1-1或case1-2)。对于case1-2，先将根结点 (BST) 翻红，这么操作的原因稍后解释。接着调用删除最小键具体方法，执行 <code>root = deleteMin(root)</code> 。</p><ul><li>case1-1: 根结点为3-结点，无需膨胀，但不直接去往左子树，而是与case1-2一样，先执行 <code>root = deleteMin(root)</code> 。</li><li>case1-2: 根结点为2-结点，继续考察，执行  <code>root = deleteMin(root)</code> 。<ul><li>case1-2-1: 通过 <code>if (!isRed(h.left) &amp;&amp; !isRed(h.left.left))</code> 考察根结点的左子结点 (2-3-4树)，若不满足 $if$ 条件，则根结点的左子结点为3-结点或case1-1，无需膨胀，执行下一句 <code>h.left = deleteMin(h.left)</code> ，去往左子树递归删除。</li><li>case1-2-2: 若满足上述 $if$ 条件，则根结点的左子结点为2-结点，需膨胀，但还不知道是「三个2-结点膨胀为一个4-结点」，还是从根结点的右子结点 (间接地) 「借键膨胀」，这取决于根结点的右子结点是否为2-结点，于是执行 <code>h = moveRedLeft(h)</code> 进一步处理。进入该方法后首先执行反色语句 <code>flipColors(h)</code> ，这么做的原因我们马上会知道。<ul><li>case1-2-2-1: 反色后通过 <code>if (isRed(h.right.left))</code> 考察根结点的右子结点是否为2-结点，若不满足，则为2-结点，需要将根结点及其左右子结点膨胀为一个4-结点， <strong>而刚才的反色操作已经完成了这一膨胀</strong> ，这就是进入 <code>moveRedLeft(h)</code> 方法后先执行反色操作的原因。</li><li>case1-2-2-2: 若满足，则根结点的右子结点为一个3-结点，于是通过 <strong>两次旋转</strong> 将左子结点膨胀为一个3-结点 (借用了原根结点的键，根结点则借来了其右子结点的键，因此可以说左子结点借了原根的键，也可以说左子结点「间接地」借了右子结点的键)。两次旋转完成后还需 <strong>一次反色</strong> 恢复 LLRBT 性质。另外，这一次的反色操作让我们看清了 case1-2 先将根结点翻红的原因，详细解释请看【补充QA】。</li></ul></li></ul></li></ul><p>通过上述操作，当前结点为根结点的情况 (case1) 处理完成，我们保证了接下来要去往的 <strong>根结点的左子结点</strong> 为3-结点 (case1-1, case1-2-1, case1-2-2-2) 或4-结点 (case 1-2-2-1) 。</p><p><img src="https://pic.leetcode-cn.com/1656757397-byYtDn-image.png" alt="image.png"></p><p><strong>接着处理case2。</strong> 不妨假设当前结点是根结点的左子结点，根据前述分析，当前结点是一个3-结点或4-结点的最小键所在的结点 (BST) ，且为红色。我们要考察它的左子结点 (2-3-4树) 是否需要膨胀。由于当前结点不是根结点，因此在程序中此时位于删除最小键的具体方法 <code>deleteMin(Node h)</code> 中，如果当前结点的左子结点为 $null$ ，那么当前结点就是最小键，返回 $null$ 即意味着将其删除，即此句 <code>if (h.left == null) return null</code>。如果不是 $null$ ，那么有如下情况。</p><ul><li>case2-1: 通过 <code>if (!isRed(h.left) &amp;&amp; !isRed(h.left.left))</code> 考察当前结点的左子结点 (2-3-4树)，若不满足 $if$ 条件，则根结点的左子结点为3-结点，无需膨胀，执行下一句 <code>h.left = deleteMin(h.left)</code> ，去往左子树递归删除。</li><li>case2-2: 若满足上述 $if$ 条件，则当前结点的左子结点为2-结点，需膨胀，但还不知道是「三个2-结点膨胀为一个4-结点」，还是从根结点的右子结点 (间接地) 「借键膨胀」，这取决于根结点的右子结点是否为2-结点，于是执行 <code>h = moveRedLeft(h)</code> 进一步处理。进入该方法后首先执行反色语句 <code>flipColors(h)</code> ，这么做的原因我们在case1中已经见过了。<ul><li>case2-2-1: 反色后通过 <code>if (isRed(h.right.left))</code> 考察当前结点的右子结点是否为2-结点，若不满足，则为2-结点，需要将当前结点 (BST) 及其左右子结点膨胀为一个4-结点， <strong>而刚才的反色操作已经完成了这一膨胀</strong> 。</li><li>case2-2-2: 若满足，则当前结点的右子结点为一个3-结点，于是通过 <strong>两次旋转</strong> 将左子结点膨胀为一个3-结点 (借用了当前结点 (2-3-4树) 中的最小键，当前结点则借来了其右子结点的键，因此可以说左子结点借了原根的键，也可以说左子结点「间接地」借了右子结点的键)。两次旋转完成后还需 <strong>一次反色</strong> 恢复 LLRBT 性质。</li></ul></li></ul><p><img src="https://pic.leetcode-cn.com/1656757415-iUfkUF-image.png" alt="image.png"></p><p>通过上面的分析，可以感受到这部分代码极具技巧性，case2 在代码上就是 case1-2 的复用 (实际意义上只有极细微的差别)，返回前的 <code>balance(h)</code> 也与插入结点时的回溯一样，反色后旋转在一定规则的指导下竟然能配合得如此奇妙，实在是令人拍案叫绝。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteMin</span><span class="params">()</span> &#123; <span class="comment">// 删除最小键驱动方法</span></span><br><span class="line">    <span class="keyword">if</span> (isEmpty()) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>(<span class="string">&quot;BST underflow&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!isRed(root.left) &amp;&amp; !isRed(root.right)) root.color = RED; <span class="comment">// 根结点为2-结点</span></span><br><span class="line">    root = deleteMin(root); <span class="comment">// 调用删除最小键具体方法</span></span><br><span class="line">    <span class="keyword">if</span> (!isEmpty()) root.color = BLACK; <span class="comment">// 恢复根结点颜色为黑色</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">deleteMin</span><span class="params">(Node h)</span> &#123; <span class="comment">// 删除以h为根结点的最小键</span></span><br><span class="line">    <span class="keyword">if</span> (h.left == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 找到最小键，删除(即返回null，使得这个最小键的父结点.left=null)</span></span><br><span class="line">    <span class="keyword">if</span> (!isRed(h.left) &amp;&amp; !isRed(h.left.left)) h = moveRedLeft(h); <span class="comment">// 借键</span></span><br><span class="line">    h.left = deleteMin(h.left); <span class="comment">// 向左子树递归删除</span></span><br><span class="line">    <span class="keyword">return</span> balance(h); <span class="comment">// 回溯过程中恢复路径上结点的LLRBT性质(分解4-结点)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">moveRedLeft</span><span class="params">(Node h)</span> &#123;</span><br><span class="line">    flipColors(h);</span><br><span class="line">    <span class="keyword">if</span> (isRed(h.right.left)) &#123; <span class="comment">// h.left 的兄弟结点是3-结点</span></span><br><span class="line">        h.right = rotateRight(h.right);</span><br><span class="line">        h = rotateLeft(h);</span><br><span class="line">        flipColors(h);</span><br><span class="line">    &#125; <span class="comment">// 若不满足，说明</span></span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【补充QA】</p><ul><li><p>在删除最小键驱动方法 $deleteMin$ 中，case1-2 时的 <code>root.color = RED</code> 的意义？</p><ul><li>我们已经知道，一个「^」形所代表的4-结点 (父黑左右子结点红，以下简称黑红红) 分解为三个2-结点时，形态不变，只需将三个结点的颜色翻转 (翻转为父红左右子结点黑，以下简称红黑黑)。膨胀是其逆过程，因此也只需将三个结点的颜色翻转，但是不要忘了，初始时，根结点的颜色总是黑色的，因此需要先将根结点颜色翻红。通过后续动作很容易验证这一操作的必要性及正确性，根结点翻红后三个结点为红黑黑，而后的三种情况如下，均符合 LLRBT (含中间态) 的性质。<ul><li>不反色为case1-2-1，红黑黑。</li><li>经过一次反色变为case1-2-2-1，黑红红。</li><li>经过两次反色变为case1-2-2-2，红黑黑。</li></ul></li></ul></li><li><p>$moveRedLeft$ 方法实现「借键」，这个方法名应该怎么理解？</p><ul><li>(仅为作者的个人看法) 这个方法的命名大概是想表达 move red to left。整个过程看起来像是从兄弟结点借键，但实际上借的是父结点的键，只不过父结点能够借出给左子结点，是因为右子结点把其较小键借给了父结点，这是通过两次旋转实现的传递。总之代码作者可能是想表达该方法最终让 $left$ 变 $red$ 了，但不关心是从谁那 $move$ 来的。</li></ul></li><li><p>$deleteMax &#x2F; moveRedRight$ 的分析分别与 $deleteMin&#x2F;moveRedLeft$ 类似，但各自都有一条语句的区别。</p><ul><li><p>在删除最大键的具体方法 $deleteMax$ 中，第一行的 <code>if (isRed(h.left)) h = rotateRight(h)</code> 是删除最小键具体方法所没有的。这是因为对于删除最小键，膨胀变换保证了这个最小键对应左斜链下的红色叶子结点，因此可直接删除。而最大键如果在左斜红链父结点中，就不能直接删除，需要右旋将最大键置于右链子结点后才可以直接删除。如果最大键在4-结点中，可直接删除，不过前述语句对这两种情况都统一做了右旋，使得最终可以直接删除最大键所在的右下末端结点。示意图如下。</p><p><img src="https://pic.leetcode-cn.com/1656754338-xsZTbe-image.png" alt="image.png"></p></li></ul></li></ul><p>最后来分析删除指定键的方法 $delete$ (包括驱动方法和具体方法) 。与 $deleteMin$ 一样，首先考虑目标键在叶子结点中 (2-3树)，且该叶子结点为2-结点中，直接删除会导致失去2-3树结构。因此也要像 $deleteMin$ 那样自顶向下「膨胀」，在删除指定键的路径上，总是使当前结点不为2-结点。找到目标后在以其右子结点为根结点的子树中寻找最小键，用其键值替换掉删除目标的键值，而后执行 $deleteMin$ 删除这个最小键。具体请看如下代码注释。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(K key)</span> &#123; <span class="comment">// 删除指定键驱动方法</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;argument to delete() is null&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!contains(key)) <span class="keyword">return</span>; <span class="comment">// 检测删除目标是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (!isRed(root.left) &amp;&amp; !isRed(root.right)) root.color = RED; <span class="comment">// 根结点为2-结点</span></span><br><span class="line">    root = delete(root, key); <span class="comment">// 调用具体删除指定键的方法</span></span><br><span class="line">    <span class="keyword">if</span> (!isEmpty()) root.color = BLACK; <span class="comment">// 恢复根结点颜色为黑色</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">delete</span><span class="params">(Node h, K key)</span> &#123; <span class="comment">// 在以h为根结点的树中删除指定键</span></span><br><span class="line">    <span class="keyword">if</span> (key.compareTo(h.key) &lt; <span class="number">0</span>)  &#123; <span class="comment">// 目标在当前h的左子树中</span></span><br><span class="line">        <span class="keyword">if</span> (!isRed(h.left) &amp;&amp; !isRed(h.left.left)) h = moveRedLeft(h); <span class="comment">// h.left是一个2-结点，借键膨胀</span></span><br><span class="line">        h.left = delete(h.left, key); <span class="comment">// 递归删除</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">// 目标可能等于h.key也可能在h的右子树中</span></span><br><span class="line">        <span class="keyword">if</span> (isRed(h.left)) h = rotateRight(h); <span class="comment">// 避免目标结点无右子树 (若无右子树则无法用min(h.right)来完成替换)</span></span><br><span class="line">        <span class="keyword">if</span> (key.compareTo(h.key) == <span class="number">0</span> &amp;&amp; (h.right == <span class="literal">null</span>)) <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// h为目标结点且无右子树，说明目标结点为叶子结点，可直接删除</span></span><br><span class="line">        <span class="keyword">if</span> (!isRed(h.right) &amp;&amp; !isRed(h.right.left)) h = moveRedRight(h); <span class="comment">// h.right是一个2-结点，借键膨胀</span></span><br><span class="line">        <span class="keyword">if</span> (key.compareTo(h.key) == <span class="number">0</span>) &#123; <span class="comment">// h为目标结点且有右子树</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">x</span> <span class="operator">=</span> min(h.right); <span class="comment">// 找到h的后继x</span></span><br><span class="line">            h.key = x.key; <span class="comment">// x取代h</span></span><br><span class="line">            h.val = x.val; <span class="comment">// x取代h</span></span><br><span class="line">            h.right = deleteMin(h.right); <span class="comment">// 删除x</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> h.right = delete(h.right, key); <span class="comment">// 递归删除</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> balance(h); <span class="comment">// 回溯过程中恢复路径上结点的LLRBT性质(分解4-结点)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h3 id="LLRBT类架构"><a href="#LLRBT类架构" class="headerlink" title="LLRBT类架构"></a>LLRBT类架构</h3><p>以下是LLRBT类 (LeftLeaningRedBlackTree) 架构。</p><table><thead><tr><th>类成员&#x2F;方法</th><th>描述</th></tr></thead><tbody><tr><td><code>private Node&lt;K, V&gt; root;</code></td><td>字段，LLRBT 的根结点</td></tr><tr><td><code>private static final Boolean RED = false, BLACK = true;</code></td><td>常量字段，红与黑</td></tr><tr><td><code>public LeftLeaningRedBlackTree()</code></td><td>无参构造器，$root$ 初始为 $null$</td></tr><tr><td><code>public int size()</code></td><td>返回当前树的大小驱动方法</td></tr><tr><td><code>public void makeEmpty()</code></td><td>树置空</td></tr><tr><td><code>public boolean isEmpty()</code></td><td>判断树是否为空</td></tr><tr><td><code>public boolean contains(K key)</code></td><td>判断是否有键为 $key$ 的结点</td></tr><tr><td><code>public V get(K key)</code></td><td>获取对应 $key$ 的 $val$</td></tr><tr><td><code>public K min()</code></td><td>返回最小 $key$</td></tr><tr><td><code>public K max()</code></td><td>返回最大 $key$</td></tr><tr><td><code>public void put(K key, V val)</code></td><td>插入结点驱动方法</td></tr><tr><td><code>public void deleteMin()</code></td><td>删除最小键驱动方法</td></tr><tr><td><code>public void deleteMax()</code></td><td>删除最大键驱动方法</td></tr><tr><td><code>public int height()</code></td><td>返回当前树高</td></tr><tr><td><code>public void rotateLeft(Node&lt;K, V&gt; h)</code></td><td>左旋</td></tr><tr><td><code>public void rotateRight(Node&lt;K, V&gt; h)</code></td><td>右旋</td></tr><tr><td><code>public void delete(K key)</code></td><td>删除 $key$</td></tr><tr><td><code>public void printTree()</code></td><td>中序遍历打印红黑树</td></tr><tr><td><code>public K floor(K key)</code></td><td>返回小于等于 key 的键</td></tr><tr><td><code>public K ceiling(K key)</code></td><td>返回大于等于 key 的键</td></tr><tr><td><code>private int size(Node&lt;K, V&gt; x)</code></td><td>返回以结点 x 为根结点的树的大小</td></tr><tr><td><code>private Node&lt;K, V&gt; get(Node&lt;K, V&gt; x, K key)</code></td><td>在以 $x$ 为根结点的树中寻找目标键 $key$</td></tr><tr><td><code>private Node&lt;K, V&gt; min(Node&lt;K, V&gt; x)</code></td><td>返回最小结点</td></tr><tr><td><code>private Node&lt;K, V&gt; max(Node&lt;K, V&gt; x)</code></td><td>返回最大结点</td></tr><tr><td><code>private boolean isRed(Node&lt;K, V&gt; node)</code></td><td>判断 $node$ 结点是否为红</td></tr><tr><td><code>private Node put(Node&lt;K, V&gt; h, K key, V val)</code></td><td>插入结点</td></tr><tr><td><code>private Node deleteMin(Node h)</code></td><td>删除以h为根结点的最小键</td></tr><tr><td><code>private Node&lt;K, V&gt; delete(Node&lt;K, V&gt; h, K key)</code></td><td>在以 h 为根结点的树中删除指定键</td></tr><tr><td><code>private void flipColors(Node&lt;K, V&gt; h)</code></td><td>结点 $h$ 及其左右子结点反色</td></tr><tr><td><code>private Node moveRedLeft(Node h)</code></td><td>借键到左侧</td></tr><tr><td><code>private Node moveRedRight(Node h)</code></td><td>借键到右侧</td></tr><tr><td><code>private Node balance(Node h)</code></td><td>恢复结点 h 处的 LLRBT 性质</td></tr><tr><td><code>private int height(Node x)</code></td><td>返回以结点 x 为根结点的树的树高</td></tr><tr><td><code>private Node&lt;K, V&gt; floor(Node&lt;K, V&gt; x, K key)</code></td><td>在以 x 为根结点的树中返回小于等于 key 的结点</td></tr><tr><td><code>private Node&lt;K, V&gt; ceiling(Node&lt;K, V&gt; x, K key)</code></td><td>在以 x 为根结点的树中返回大于等于 key 的结点</td></tr><tr><td><code>private void printTree(Node t)</code></td><td>红序遍历打印红黑树 (以 $t$ 为根结点)</td></tr></tbody></table><p>以下为 LLRBT 结点嵌套类 $Node$ 的架构。</p><table><thead><tr><th>类成员&#x2F;方法</th><th>描述</th></tr></thead><tbody><tr><td><code>public boolean color</code></td><td>字段，本结点颜色</td></tr><tr><td><code>public K key</code></td><td>字段，本结点 $key$</td></tr><tr><td><code>public V val</code></td><td>字段，本结点 $value$</td></tr><tr><td><code>public Node&lt;K, V&gt; left, right</code></td><td>两个字段，本结点的左子结点&#x2F;右子结点</td></tr><tr><td><code>private int size</code></td><td>以本结点为根结点的树的大小</td></tr><tr><td><code>public Node(K key, V val, boolean color, int size)</code></td><td>构造器</td></tr></tbody></table><br /><h3 id="主要方法-1"><a href="#主要方法-1" class="headerlink" title="主要方法"></a>主要方法</h3><p>重难点方法已在前面章节中详细介绍，完整的类代码请参考「类的实现代码」。</p><br /><h3 id="类的实现代码-1"><a href="#类的实现代码-1" class="headerlink" title="类的实现代码"></a>类的实现代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LeftLeaningRedBlackTree</span>&lt;K <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;K&gt;, V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">RED</span> <span class="operator">=</span> <span class="literal">false</span>, BLACK = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;K, V&gt; root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LeftLeaningRedBlackTree</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123; <span class="comment">// 当前树的大小</span></span><br><span class="line">        <span class="keyword">return</span> size(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">(Node&lt;K, V&gt; x)</span> &#123; <span class="comment">// 返回以结点 x 为根结点的树的大小</span></span><br><span class="line">        <span class="keyword">if</span> (x == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> x.size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeEmpty</span><span class="params">()</span> &#123; <span class="comment">// 树置空</span></span><br><span class="line">        root = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123; <span class="comment">// 树判空</span></span><br><span class="line">        <span class="keyword">return</span> root == <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(K key)</span> &#123; <span class="comment">// 判断树中是否存在键为 key 的结点</span></span><br><span class="line">        <span class="keyword">return</span> get(key) != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(K key)</span> &#123; <span class="comment">// 获取对应key的val</span></span><br><span class="line">        <span class="keyword">if</span> (key == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;argument to get() is null&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> get(root, key).val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;K, V&gt; <span class="title function_">get</span><span class="params">(Node&lt;K, V&gt; x, K key)</span> &#123; <span class="comment">// 在以 x 为根结点的树中寻找目标键 key</span></span><br><span class="line">        <span class="keyword">while</span> (x != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">compareRes</span> <span class="operator">=</span> key.compareTo(x.key);</span><br><span class="line">            <span class="keyword">if</span> (compareRes &lt; <span class="number">0</span>) x = x.left; <span class="comment">// 在左子树中寻找</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (compareRes &gt; <span class="number">0</span>) x = x.right; <span class="comment">// 在右子树中寻找</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> x; <span class="comment">// 找到返回目标结点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    private V get(Node x, K key) &#123; // 递归版本get</span></span><br><span class="line"><span class="comment">//        if (x == null) return null;</span></span><br><span class="line"><span class="comment">//        int cmp = key.compareTo(x.key);</span></span><br><span class="line"><span class="comment">//        if (cmp &lt; 0) return get(x.left, key);</span></span><br><span class="line"><span class="comment">//        else if (cmp &gt; 0) return get(x.right, key);</span></span><br><span class="line"><span class="comment">//        else return x.val;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isRed</span><span class="params">(Node x)</span> &#123; <span class="comment">// 判断结点是否为红色</span></span><br><span class="line">        <span class="keyword">if</span> (x == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 空结点为黑色</span></span><br><span class="line">        <span class="keyword">return</span> x.color == RED;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(K key, V val)</span> &#123; <span class="comment">// 插入 key-val 结点</span></span><br><span class="line">        <span class="keyword">if</span> (key == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;first argument to put() is null&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (val == <span class="literal">null</span>) &#123; <span class="comment">// 表示删除该key</span></span><br><span class="line">            delete(key);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        root = put(root, key, val); <span class="comment">// 调用实际插入方法</span></span><br><span class="line">        root.color = BLACK; <span class="comment">// 每次插入结点后根结点都要描黑</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">put</span><span class="params">(Node&lt;K, V&gt; h, K key, V val)</span> &#123; <span class="comment">// 在以 h 为根的树中插入结点 key-val</span></span><br><span class="line">        <span class="keyword">if</span> (h == <span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Node</span>(key, val, RED, <span class="number">1</span>); <span class="comment">// 插入 (与父节点用红链连接)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">compareRes</span> <span class="operator">=</span> key.compareTo(h.key);</span><br><span class="line">        <span class="keyword">if</span> (compareRes &lt; <span class="number">0</span>) h.left = put(h.left, key, val); <span class="comment">// 在左子树中寻找插入位置</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (compareRes &gt; <span class="number">0</span>) h.right = put(h.right, key, val); <span class="comment">// 在右子树中寻找插入位置</span></span><br><span class="line">        <span class="keyword">else</span> h.val = val; <span class="comment">// key相等，更新键</span></span><br><span class="line">        <span class="comment">// 回溯过程中向上调整</span></span><br><span class="line">        <span class="keyword">return</span> balance(h);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteMin</span><span class="params">()</span> &#123; <span class="comment">// 删除最小键驱动方法</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>(<span class="string">&quot;BST underflow&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!isRed(root.left) &amp;&amp; !isRed(root.right)) root.color = RED; <span class="comment">// 根结点为2-结点</span></span><br><span class="line">        root = deleteMin(root); <span class="comment">// 调用删除最小键具体方法</span></span><br><span class="line">        <span class="keyword">if</span> (!isEmpty()) root.color = BLACK; <span class="comment">// 恢复根结点颜色为黑色</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">deleteMin</span><span class="params">(Node h)</span> &#123; <span class="comment">// 删除以h为根结点的最小键</span></span><br><span class="line">        <span class="keyword">if</span> (h.left == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 找到最小键，删除(即返回null，使得这个最小键的父节点.left=null)</span></span><br><span class="line">        <span class="keyword">if</span> (!isRed(h.left) &amp;&amp; !isRed(h.left.left)) h = moveRedLeft(h); <span class="comment">// 借键</span></span><br><span class="line">        h.left = deleteMin(h.left); <span class="comment">// 向左子树递归删除</span></span><br><span class="line">        <span class="keyword">return</span> balance(h); <span class="comment">// 回溯过程中恢复路径上结点的LLRBT性质(分解4-结点)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteMax</span><span class="params">()</span> &#123; <span class="comment">// 删除最大键驱动方法</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>(<span class="string">&quot;BST underflow&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!isRed(root.left) &amp;&amp; !isRed(root.right)) root.color = RED;</span><br><span class="line">        root = deleteMax(root);</span><br><span class="line">        <span class="keyword">if</span> (!isEmpty()) root.color = BLACK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">deleteMax</span><span class="params">(Node h)</span> &#123; <span class="comment">// 删除最大键具体方法</span></span><br><span class="line">        <span class="keyword">if</span> (isRed(h.left)) h = rotateRight(h); <span class="comment">// 避免最大键为左红链父结点的情况，将其右旋至右下末端</span></span><br><span class="line">        <span class="keyword">if</span> (h.right == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (!isRed(h.right) &amp;&amp; !isRed(h.right.left)) h = moveRedRight(h);</span><br><span class="line">        h.right = deleteMax(h.right);</span><br><span class="line">        <span class="keyword">return</span> balance(h);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(K key)</span> &#123; <span class="comment">// 删除指定键驱动方法</span></span><br><span class="line">        <span class="keyword">if</span> (key == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;argument to delete() is null&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!contains(key)) <span class="keyword">return</span>; <span class="comment">// 检测删除目标是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (!isRed(root.left) &amp;&amp; !isRed(root.right)) root.color = RED; <span class="comment">// 根结点为2-结点</span></span><br><span class="line">        root = delete(root, key); <span class="comment">// 调用具体删除指定键的方法</span></span><br><span class="line">        <span class="keyword">if</span> (!isEmpty()) root.color = BLACK; <span class="comment">// 恢复根结点颜色为黑色</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;K, V&gt; <span class="title function_">delete</span><span class="params">(Node&lt;K, V&gt; h, K key)</span> &#123; <span class="comment">// 在以 h 为根结点的树中删除指定键</span></span><br><span class="line">        <span class="keyword">if</span> (key.compareTo(h.key) &lt; <span class="number">0</span>) &#123; <span class="comment">// 目标在当前h的左子树中</span></span><br><span class="line">            <span class="keyword">if</span> (!isRed(h.left) &amp;&amp; !isRed(h.left.left)) h = moveRedLeft(h); <span class="comment">// h.left是一个2-结点，借键膨胀</span></span><br><span class="line">            h.left = delete(h.left, key); <span class="comment">// 递归删除</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 目标可能等于h.key也可能在h的右子树中</span></span><br><span class="line">            <span class="keyword">if</span> (isRed(h.left)) h = rotateRight(h); <span class="comment">// 避免目标结点无右子树 (若无右子树则无法用min(h.right)来完成替换)</span></span><br><span class="line">            <span class="keyword">if</span> (key.compareTo(h.key) == <span class="number">0</span> &amp;&amp; (h.right == <span class="literal">null</span>)) <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// h为目标结点且无右子树，说明目标结点为叶子结点，可直接删除</span></span><br><span class="line">            <span class="keyword">if</span> (!isRed(h.right) &amp;&amp; !isRed(h.right.left)) h = moveRedRight(h); <span class="comment">// h.right是一个2-结点，借键膨胀</span></span><br><span class="line">            <span class="keyword">if</span> (key.compareTo(h.key) == <span class="number">0</span>) &#123; <span class="comment">// h为目标结点且有右子树</span></span><br><span class="line">                Node&lt;K, V&gt; x = min(h.right); <span class="comment">// 找到h的后继x</span></span><br><span class="line">                h.key = x.key; <span class="comment">// x取代h</span></span><br><span class="line">                h.val = x.val; <span class="comment">// x取代h</span></span><br><span class="line">                h.right = deleteMin(h.right); <span class="comment">// 删除x</span></span><br><span class="line">            &#125; <span class="keyword">else</span> h.right = delete(h.right, key); <span class="comment">// 递归删除</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> balance(h); <span class="comment">// 回溯过程中恢复路径上结点的LLRBT性质(分解4-结点)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;K, V&gt; <span class="title function_">rotateRight</span><span class="params">(Node&lt;K, V&gt; h)</span> &#123; <span class="comment">// 右旋</span></span><br><span class="line">        Node&lt;K, V&gt; x = h.left;</span><br><span class="line">        h.left = x.right;</span><br><span class="line">        x.right = h;</span><br><span class="line">        x.color = h.color;</span><br><span class="line">        h.color = RED;</span><br><span class="line">        x.size = h.size;</span><br><span class="line">        h.size = size(h.left) + size(h.right) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;K, V&gt; <span class="title function_">rotateLeft</span><span class="params">(Node&lt;K, V&gt; h)</span> &#123; <span class="comment">// 左旋</span></span><br><span class="line">        Node&lt;K, V&gt; x = h.right;</span><br><span class="line">        h.right = x.left;</span><br><span class="line">        x.left = h;</span><br><span class="line">        x.color = h.color;</span><br><span class="line">        h.color = RED;</span><br><span class="line">        x.size = h.size;</span><br><span class="line">        h.size = size(h.left) + size(h.right) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">flipColors</span><span class="params">(Node h)</span> &#123; <span class="comment">// 反色</span></span><br><span class="line">        h.color = !h.color;</span><br><span class="line">        h.left.color = !h.left.color;</span><br><span class="line">        h.right.color = !h.right.color;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">moveRedLeft</span><span class="params">(Node h)</span> &#123; <span class="comment">// 借键</span></span><br><span class="line">        flipColors(h);</span><br><span class="line">        <span class="keyword">if</span> (isRed(h.right.left)) &#123; <span class="comment">// h.left 的兄弟结点是3-结点</span></span><br><span class="line">            h.right = rotateRight(h.right);</span><br><span class="line">            h = rotateLeft(h);</span><br><span class="line">            flipColors(h);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">moveRedRight</span><span class="params">(Node h)</span> &#123;</span><br><span class="line">        flipColors(h);</span><br><span class="line">        <span class="keyword">if</span> (isRed(h.left.left)) &#123;</span><br><span class="line">            h = rotateRight(h); <span class="comment">// 从「/」形右旋即可完成借键，无需像moveRedLeft那样先从「&gt;」形右旋为「\」形再左旋完成借键</span></span><br><span class="line">            flipColors(h);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">balance</span><span class="params">(Node h)</span> &#123; <span class="comment">// 恢复结点 h 处的 LLRBT 性质</span></span><br><span class="line">        <span class="keyword">if</span> (!isRed(h.left) &amp;&amp; isRed(h.right)) h = rotateLeft(h); <span class="comment">// 左黑右红（包含「&lt;」形），左旋</span></span><br><span class="line">        <span class="keyword">if</span> (isRed(h.left) &amp;&amp; isRed(h.left.left)) h = rotateRight(h); <span class="comment">// 「/」形，上段右旋</span></span><br><span class="line">        <span class="keyword">if</span> (isRed(h.left) &amp;&amp; isRed(h.right)) flipColors(h); <span class="comment">// 「^」型，反色</span></span><br><span class="line">        h.size = size(h.left) + size(h.right) + <span class="number">1</span>; <span class="comment">// 更新 h.size</span></span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">height</span><span class="params">()</span> &#123; <span class="comment">// 返回当前树高</span></span><br><span class="line">        <span class="keyword">return</span> height(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">height</span><span class="params">(Node x)</span> &#123; <span class="comment">// 返回以结点 x 为根结点的树的树高</span></span><br><span class="line">        <span class="keyword">if</span> (x == <span class="literal">null</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + Math.max(height(x.left), height(x.right));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> K <span class="title function_">min</span><span class="params">()</span> &#123; <span class="comment">// 返回最小键</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>(<span class="string">&quot;calls min() with empty symbol table&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> min(root).key;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;K, V&gt; <span class="title function_">min</span><span class="params">(Node&lt;K, V&gt; x)</span> &#123; <span class="comment">// 返回最小结点</span></span><br><span class="line">        <span class="keyword">if</span> (x.left == <span class="literal">null</span>) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> min(x.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> K <span class="title function_">max</span><span class="params">()</span> &#123; <span class="comment">// 返回最大键</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>(<span class="string">&quot;calls max() with empty symbol table&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> max(root).key;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;K, V&gt; <span class="title function_">max</span><span class="params">(Node&lt;K, V&gt; x)</span> &#123; <span class="comment">// 返回最大结点</span></span><br><span class="line">        <span class="keyword">if</span> (x.right == <span class="literal">null</span>) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> max(x.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printTree</span><span class="params">()</span> &#123; <span class="comment">// 按中序遍历打印树的驱动方法</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) System.out.println(<span class="string">&quot;Empty tree&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> printTree(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printTree</span><span class="params">(Node t)</span> &#123; <span class="comment">// 中序遍历打印树 (以 t 结点为根结点的树)</span></span><br><span class="line">        <span class="keyword">if</span> (t != <span class="literal">null</span>) &#123;</span><br><span class="line">            printTree(t.left);</span><br><span class="line">            System.out.println(t.key);</span><br><span class="line">            printTree(t.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> K <span class="title function_">floor</span><span class="params">(K key)</span> &#123; <span class="comment">// 返回小于等于 key 的键</span></span><br><span class="line">        <span class="keyword">if</span> (key == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;argument to floor() is null&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>(<span class="string">&quot;calls floor() with empty symbol table&quot;</span>);</span><br><span class="line">        Node&lt;K, V&gt; x = floor(root, key);</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>(<span class="string">&quot;argument to floor() is too small&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> x.key;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;K, V&gt; <span class="title function_">floor</span><span class="params">(Node&lt;K, V&gt; x, K key)</span> &#123; <span class="comment">// 在以 x 为根结点的树中返回小于等于 key 的结点</span></span><br><span class="line">        <span class="keyword">if</span> (x == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> key.compareTo(x.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp == <span class="number">0</span>) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) <span class="keyword">return</span> floor(x.left, key);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> floor(x.right, key);</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="literal">null</span>) <span class="keyword">return</span> t;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> K <span class="title function_">ceiling</span><span class="params">(K key)</span> &#123; <span class="comment">// 返回大于等于 key 的键</span></span><br><span class="line">        <span class="keyword">if</span> (key == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;argument to ceiling() is null&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>(<span class="string">&quot;calls ceiling() with empty symbol table&quot;</span>);</span><br><span class="line">        Node&lt;K, V&gt; x = ceiling(root, key);</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>(<span class="string">&quot;argument to ceiling() is too large&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> x.key;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;K, V&gt; <span class="title function_">ceiling</span><span class="params">(Node&lt;K, V&gt; x, K key)</span> &#123; <span class="comment">// 在以 x 为根结点的树中返回大于等于 key 的结点</span></span><br><span class="line">        <span class="keyword">if</span> (x == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> key.compareTo(x.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp == <span class="number">0</span>) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) <span class="keyword">return</span> ceiling(x.right, key);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> ceiling(x.left, key);</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="literal">null</span>) <span class="keyword">return</span> t;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * LLRBT结点类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;K&gt;, V&gt; &#123;</span><br><span class="line">        <span class="keyword">private</span> K key;</span><br><span class="line">        <span class="keyword">private</span> V val;</span><br><span class="line">        <span class="keyword">private</span> Node&lt;K, V&gt; left, right;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">boolean</span> color;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(K key, V val, <span class="type">boolean</span> color, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.val = val;</span><br><span class="line">            <span class="built_in">this</span>.color = color;</span><br><span class="line">            <span class="built_in">this</span>.size = size;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h3 id="测试代码-1"><a href="#测试代码-1" class="headerlink" title="测试代码"></a>测试代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( String [ ] args )</span> &#123;</span><br><span class="line">    LeftLeaningRedBlackTree&lt;Integer, Integer&gt; t = <span class="keyword">new</span> <span class="title class_">LeftLeaningRedBlackTree</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">NUMS</span> <span class="operator">=</span> <span class="number">1_000_000</span>, GAP = <span class="number">307</span>;</span><br><span class="line"></span><br><span class="line">    System.out.println( <span class="string">&quot;Checking... (no bad output means success)&quot;</span> );</span><br><span class="line">    <span class="comment">// 插入测试</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> GAP; key != <span class="number">0</span>; key = (key + GAP) % NUMS) t.put( key , key + <span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;Inserts complete&quot;</span>);</span><br><span class="line">    <span class="comment">// 删除测试</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> <span class="number">1</span>; key &lt; NUMS; key += <span class="number">2</span>) t.delete(key);</span><br><span class="line">    System.out.println( <span class="string">&quot;Removes complete&quot;</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> <span class="number">2</span>; key &lt; NUMS; key += <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!t.contains(key)) System.out.println( <span class="string">&quot;Error: find fails for &quot;</span> + key );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> <span class="number">1</span>; key &lt; NUMS; key += <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(t.contains(key)) System.out.println( <span class="string">&quot;Error: Found deleted item &quot;</span> + key );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    NUMS = <span class="number">5_000_000</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> GAP; key != <span class="number">0</span>; key = (key + GAP) % NUMS) t.put( key , key + <span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;Inserts complete&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> <span class="number">1</span>; key &lt; NUMS; key += <span class="number">2</span>) t.delete(key);</span><br><span class="line">    System.out.println( <span class="string">&quot;Removes complete&quot;</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> <span class="number">2</span>; key &lt; NUMS; key += <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!t.contains(key)) System.out.println( <span class="string">&quot;Error: find fails for &quot;</span> + key );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> <span class="number">1</span>; key &lt; NUMS; key += <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(t.contains(key)) System.out.println( <span class="string">&quot;Error: Found deleted item &quot;</span> + key );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下说明测试通过。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Checking... (no bad output means success)</span><br><span class="line">Inserts complete</span><br><span class="line">Removes complete</span><br><span class="line">Inserts complete</span><br><span class="line">Removes complete</span><br></pre></td></tr></table></figure><br /><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><ul><li>介绍了 LLRBT 相比传统红黑树的改进之处，即总是使3-结点左斜，从而保证 LLRBT 与2-3树而非2-3-4树同构。</li><li>详细解释了 LLRBT 的三个性质。</li><li>深入分析并展示了 LLRBT 的插入结点和删除结点操作。</li><li>给出了较为完整的 LLRBT 类的代码。</li></ul><br />]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 平衡二叉树 </tag>
            
            <tag> 树 </tag>
            
            <tag> 算法与数据结构 </tag>
            
            <tag> 红黑树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git学习实战</title>
      <link href="/2022/09/01/git%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98_yukiyama/"/>
      <url>/2022/09/01/git%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98_yukiyama/</url>
      
        <content type="html"><![CDATA[<h1 id="Git学习实战-yukiyama"><a href="#Git学习实战-yukiyama" class="headerlink" title="Git学习实战_yukiyama"></a>Git学习实战_yukiyama</h1><blockquote><p>本文总结自 <a href="https://git-scm.com/book/en/v2">progit</a> 。</p><p>操作环境为 macOS Monterey 12.6 &#x2F; git 2.37.3 &#x2F; IntelliJ IDEA 2022.2.1 (Ultimate Edition) 。</p></blockquote><br /><h2 id="Git概述"><a href="#Git概述" class="headerlink" title="Git概述"></a>Git概述</h2><p>Git 是一个开源的 <strong>分布式版本控制系统</strong> 。</p><p>git 文件四种状态: 未跟踪 (untracked)、 未修改 (unmodified)、已修改 (modified) 、已暂存 (staged) 。</p><table><thead><tr><th>状态</th><th>描述</th></tr></thead><tbody><tr><td>untracked</td><td>未追踪。文件未被 git 管理，执行 <code>git add</code> 可将其转换为「已追踪」的「未修改状态」。</td></tr><tr><td>unmodified</td><td>未修改。已追踪，从「已暂存」状态执行 <code>git commit</code> 提交后的状态。因此也被称作「已提交」状态 (commited) 。</td></tr><tr><td>modified</td><td>已修改。已追踪，并且发生了修改，但还未暂存。</td></tr><tr><td>staged</td><td>已暂存。已追踪，对一个修改过的文件执行 <code>git add</code> 后的状态。</td></tr></tbody></table><p><img src="https://git-scm.com/book/en/v2/images/lifecycle.png" alt="image-20220927002133083"></p><p>git 中的三个区域: 仓库、工作目录、暂存区域。</p><table><thead><tr><th>区域</th><th>描述</th></tr></thead><tbody><tr><td>工作目录</td><td>对项目的某个版本独立提取出来的内容。从 Git 仓库的压缩数据库中提取出来，放在磁盘上供用户使用和修改。</td></tr><tr><td>暂存区 &#x2F; 索引</td><td>实际上是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中，有时也被称作「索引」。</td></tr><tr><td>Git仓库 &#x2F; 版本库</td><td>Git 用来保存项目的元数据和对象数据库的地方。</td></tr></tbody></table><p><img src="https://git-scm.com/book/en/v2/images/areas.png" alt="image-20220927004419468"></p><br /><h2 id="Git安装"><a href="#Git安装" class="headerlink" title="Git安装"></a>Git安装</h2><p>在装有 homebrew 的 mac 下安装 git ，只需执行如下命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install git</span><br></pre></td></tr></table></figure><p>安装后执行 <code>git --version</code> 可查看 git 版本。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama ~ % git --version</span><br><span class="line">git version 2.37.3</span><br><span class="line">yukiyama@yukiyama ~ %</span><br></pre></td></tr></table></figure><br /><h2 id="命令一览"><a href="#命令一览" class="headerlink" title="命令一览"></a>命令一览</h2><p>git 常用命令。使用 <code>git help &lt;verb&gt;</code>, <code>git &lt;verb&gt; --help</code>, <code>man git-&lt;verb&gt;</code> 可查看相关命令的详细用法。</p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td><strong>■ 基本操作</strong></td><td></td></tr><tr><td>git config –[system&#x2F;global&#x2F;local] user.name &lt;用户名&gt;</td><td>设置不同层级git配置文件中的git用户名</td></tr><tr><td>git config –[system&#x2F;global&#x2F;local] user.email &lt;邮箱&gt;</td><td>设置不同层级git配置文件中的git邮箱</td></tr><tr><td>git config –[system&#x2F;global&#x2F;local] –list</td><td>查看不同层级git配置内容</td></tr><tr><td>git config –[system&#x2F;global&#x2F;local] –edit</td><td>编辑不同层级git配置内容</td></tr><tr><td>git config –[system&#x2F;global&#x2F;local] &lt;变量组名.变量&gt;</td><td>查看不同层级下的git配置中的变量值</td></tr><tr><td>git init</td><td>将当前文件夹初始化为本地库</td></tr><tr><td>git add &lt;文件名&gt;</td><td>添加到暂存区</td></tr><tr><td>git add &lt;目录&gt;</td><td>添加指定目录及其子目录到暂存区</td></tr><tr><td>git add .</td><td>添加当前目录下的所有文件和所有子目录到暂存区<br />※ 过滤 <code>.gitignore</code></td></tr><tr><td>git add *</td><td>添加当前目录下的所有文件和所有子目录到暂存区<br />※ 不过滤 <code>.gitignore</code> ，一般不使用该命令。</td></tr><tr><td>git ls-files</td><td>查看当前目录下已跟踪的文件</td></tr><tr><td>git commit -m “&lt;本次提交的附带信息&gt;”</td><td>提交到本地库</td></tr><tr><td>git status</td><td>本地库状态</td></tr><tr><td>git status -s</td><td>本地库状态缩略信息</td></tr><tr><td>git diff &lt;文件名&gt;</td><td>列出指定文件在工作目录中修改前后的差异。</td></tr><tr><td>git diff –staged &lt;文件名&gt;</td><td>列出指定文件在暂存区与当前仓库版本间的差异。</td></tr><tr><td>git diff &lt;版本号&gt; &lt;文件名&gt;</td><td>列出指定文件在工作目录及指定仓库版本间的差异。</td></tr><tr><td>git reflog</td><td>查看历史记录缩略信息</td></tr><tr><td>git rm &lt;文件名&gt;</td><td>从已经跟踪的文件清单中 (暂存区域) 移除指定文件，同时删除该文件</td></tr><tr><td>git mv &lt;文件名1&gt; &lt;文件名2&gt;</td><td>将文件名1改成文件名2</td></tr><tr><td>git log</td><td>查看历史记录完整信息</td></tr><tr><td>git log -p</td><td>查看历史记录完整信息并展示每次提交的差异</td></tr><tr><td>git log -2</td><td>查看2条历史记录完整信息</td></tr><tr><td>git log –oneline –graph –all</td><td>以图形形式 (分支流) 查看提交历史</td></tr><tr><td>git reflog</td><td>查看历史记录缩略信息</td></tr><tr><td>git reflog -p</td><td>查看历史记录缩略信息并展示每次提交的差异</td></tr><tr><td>git reflog -2</td><td>查看2条历史记录缩略信息</td></tr><tr><td><strong>■ 撤销操作</strong></td><td></td></tr><tr><td>git commit –amend</td><td>修改 message 后提交暂存区，替换掉最后一次提交，即提交数不变 (commit id不同)。</td></tr><tr><td>git commit –amend -m “&lt;提交信息&gt;”</td><td>同上，但不会打开编辑器编辑提交信息，而是直接写上提交信息。</td></tr><tr><td>git restore –staged &lt;文件名&gt;</td><td>将暂存区的指定文件移出暂存区</td></tr><tr><td>git restore &lt;文件名&gt;</td><td>都在工作目录下，将已修改状态的指定文件回退到未修改的状态。</td></tr><tr><td>git rest HEAD &lt;文件名&gt;</td><td>同 <code>git restore --staged &lt;文件名&gt;</code></td></tr><tr><td>git checkout –</td><td>同 <code>git restore &lt;文件名&gt;</code></td></tr><tr><td><strong>■ 切换操作</strong></td><td></td></tr><tr><td>git reset –soft &lt;版本号&gt;</td><td>将 HEAD 指向指定的版本 (commit) ，不改动 index 和 working tree。<br />※ 不可指定文件名 (指定则报错)。</td></tr><tr><td>git reset –mixed  &lt;版本号&gt;</td><td>不指定文件。将 HEAD 指向指定的版本 (commit) ，并使得暂存区与指定版本一致，即在指定版本之后加入暂存区的所有文件都移出暂存区。<br />※ <code>--mixed</code> 参数是默认的，也可不写。</td></tr><tr><td>git reset –mixed  &lt;版本号&gt; &lt;文件名&gt;</td><td>指定文件。<code>HEAD</code> 指针不变，但指定的文件对应的暂存区内容将切换到指定版本的状态，其他文件在暂存区的内容不变。</td></tr><tr><td>git reset –hard &lt;版本号&gt;</td><td>将 HEAD, index 和 working tree 都切换到指定版本号的状态。<br />※ 不可指定文件名 (指定则报错)。</td></tr><tr><td><strong>■ 分支操作</strong></td><td></td></tr><tr><td>git branch</td><td>列出本地所有分支名</td></tr><tr><td>git branch -r</td><td>列出远程所有分支名</td></tr><tr><td>git branch -a</td><td>列出本地及远程的所有分支名</td></tr><tr><td>git branch &lt;分支名&gt;</td><td>以指定分支名创建新分支</td></tr><tr><td>git branch -d &lt;分支名&gt;</td><td>删除指定分支</td></tr><tr><td>git switch &lt;分支名&gt;</td><td>切换到指定分支</td></tr><tr><td>git switch -c &lt;分支名&gt;</td><td>创建并切换分支</td></tr><tr><td>git checkout &lt;分支名&gt;</td><td>切换到指定分支</td></tr><tr><td>git checkout -b &lt;分支名&gt;</td><td>创建并切换分支</td></tr><tr><td>git merge &lt;分支名&gt;</td><td>将指定分支合并入当前分支</td></tr><tr><td>git rebase &lt;分支名&gt;</td><td>以当前分支为基底，将指定分支在分歧后的修改合入当前分支</td></tr><tr><td><strong>■ 远程操作</strong></td><td></td></tr><tr><td>git remote add &lt;远程仓库地址别名&gt; &lt;远程仓库地址&gt;</td><td>关联本地仓库与远程仓库</td></tr><tr><td>git remote</td><td>列出远程仓库 (别名)</td></tr><tr><td>git remove -v</td><td>列出远程仓库详细信息 (别&amp;原地址 fetch&amp;push)</td></tr><tr><td>git remote show &lt;远程仓库地址别名&gt;</td><td>查看远程仓库详细信息</td></tr><tr><td>git remote rename &lt;当前别名&gt; &lt;新别名&gt;</td><td>修改远程仓库地址别名</td></tr><tr><td>git clone &lt;远程仓库地址&gt;</td><td>将远程仓库克隆到当前目录下</td></tr><tr><td>git push &lt;远程仓库地址&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</td><td>推送本地当前分支版本到远程仓库指定分支</td></tr><tr><td>git push -u &lt;远程仓库地址别名&gt; &lt;远程仓库分支名&gt;</td><td>将本地仓库当前分支内容推送到指定远程仓库的指定分支<br />※ <code>-u</code> 是 <code>--set-upstream</code> 的缩略，关联当前分支与指定的远程仓库分支，方便之后仅使用 <code>git push</code> 完成推送。</td></tr><tr><td>git push &lt;远程仓库地址&gt; &lt;分支名&gt;</td><td>当本地分支名与远程分支名相同时的略写</td></tr><tr><td>git push</td><td>若当前本地分支已与远程仓库某分支通过 <code>--set-upstream</code> 参数绑定过，则可直接将本地分支当前版本推送到该远程分支</td></tr><tr><td>git fetch &lt;远程仓库别名&gt; &lt;远程仓库分支名&gt;</td><td>从指定远程仓库获取指定分支的最新版本到当前仓库中，但不 merge</td></tr><tr><td>git fetch &lt;远程仓库别名&gt;</td><td>从指定远程仓库的获取所有分支中的最新版本到当前仓库中，但不 merge</td></tr><tr><td>git fetch</td><td>类似 push ，若已经设置了 <code>--set-upstream</code> ，则可省略后续参数</td></tr><tr><td>git pull &lt;远程仓库别名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</td><td>从指定远程仓库获取指定分支的最新版本到指定本地分支中，并 merge</td></tr><tr><td>git pull &lt;远程仓库别名&gt; &lt;分支名&gt;</td><td>远程分支名与本地分支名相同时的简写</td></tr><tr><td>git pull</td><td>类似 push ，若已经设置了 <code>--set-upstream</code> ，则可省略后续参数</td></tr></tbody></table><br /><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="git-config"><a href="#git-config" class="headerlink" title="git config"></a>git config</h3><p>git 有三个层级的配置文件。</p><table><thead><tr><th>配置文件</th><th>描述</th></tr></thead><tbody><tr><td>系统级 (system)</td><td>配置对OS系统下所有用户有效。<br />使用 brew 安装时，为该文件: <code>/usr/local/etc/config</code></td></tr><tr><td>系统用户级 (global)</td><td>配置对OS系统下当前用户有效。<br />为该文件 <code>/Users/yukiyama/.gitconfig</code></td></tr><tr><td>当前仓库级别 (local)</td><td>配置对当前仓库有效。<br />为 <code>.git</code> 文件夹下的 <code>.gitconfig</code></td></tr></tbody></table><p>如下，可通过 <code>cat</code> 命令查看三个层级下的 git 配置内容。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama ~ % cat /usr/local/etc/gitconfig</span><br><span class="line">[credential]</span><br><span class="line">helper = osxkeychain</span><br><span class="line">yukiyama@yukiyama ~ % cat ~/.gitconfig</span><br><span class="line">[filter &quot;lfs&quot;]</span><br><span class="line">clean = git-lfs clean -- %f</span><br><span class="line">smudge = git-lfs smudge -- %f</span><br><span class="line">process = git-lfs filter-process</span><br><span class="line">required = true</span><br><span class="line">[user]</span><br><span class="line">name = yukiyama</span><br><span class="line">email = yukiyama@yuki.com</span><br><span class="line">[init]</span><br><span class="line">defaultBranch = master</span><br><span class="line">yukiyama@yukiyama ~ % cat iCloud/study/tech/git/git-demo/.git/config</span><br><span class="line">[core]</span><br><span class="line">repositoryformatversion = 0</span><br><span class="line">filemode = true</span><br><span class="line">bare = false</span><br><span class="line">logallrefupdates = true</span><br><span class="line">ignorecase = true</span><br><span class="line">precomposeunicode = true</span><br><span class="line">[user]</span><br><span class="line">name = iyukiyama</span><br><span class="line">email = yukiyama@yama.com</span><br><span class="line">yukiyama@yukiyama ~ %</span><br></pre></td></tr></table></figure><p>也可以通过 <code>git config --[system/global/local] --list</code> 查看。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama ~ % git config --system --list</span><br><span class="line">credential.helper=osxkeychain</span><br><span class="line">yukiyama@yukiyama ~ % git config --global --list</span><br><span class="line">filter.lfs.clean=git-lfs clean -- %f</span><br><span class="line">filter.lfs.smudge=git-lfs smudge -- %f</span><br><span class="line">filter.lfs.process=git-lfs filter-process</span><br><span class="line">filter.lfs.required=true</span><br><span class="line">user.name=yukiyama</span><br><span class="line">user.email=yukiyama@yuki.com</span><br><span class="line">init.defaultbranch=master</span><br><span class="line">yukiyama@yukiyama ~ % cd iCloud/study/tech/git/git-demo/</span><br><span class="line">yukiyama@yukiyama git-demo % git config --local --list</span><br><span class="line">core.repositoryformatversion=0</span><br><span class="line">core.filemode=true</span><br><span class="line">core.bare=false</span><br><span class="line">core.logallrefupdates=true</span><br><span class="line">core.ignorecase=true</span><br><span class="line">core.precomposeunicode=true</span><br><span class="line">user.name=iyukiyama</span><br><span class="line">user.email=yukiyama@yama.com</span><br><span class="line">yukiyama@yukiyama git-demo %</span><br></pre></td></tr></table></figure><p>需要注意带有 <code>--local</code> 参数的 <code>git config</code> 命令要在仓库内执行，否则返回如下错误提示。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama ~ % git config --local user.name</span><br><span class="line">fatal: --local can only be used inside a git repository</span><br><span class="line">yukiyama@yukiyama ~ %</span><br></pre></td></tr></table></figure><br /><h4 id="配置用户签名"><a href="#配置用户签名" class="headerlink" title="配置用户签名"></a>配置用户签名</h4><p>可以通过 <code>vim</code> 命令或者带 <code>--edit</code> 参数的 <code>git config</code> 命令打开配置文件完成编辑，更好的方式是直接使用 <code>git config</code> 命令指定具体的变量。通常在使用 git 进行版本控制管理前，需要设置用户名及邮箱，即「用户签名」，用于标识操作者信息，无该信息则无法提交。</p><p>如下设置 global 层级的 user.name 及 user.email。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama git-demo % git config --global user.name yukiyama</span><br><span class="line">yukiyama@yukiyama git-demo % git config --global user.name</span><br><span class="line">yukiyama</span><br><span class="line">yukiyama@yukiyama git-demo % git config --global user.email yukiyama@gmail.com</span><br><span class="line">yukiyama@yukiyama git-demo % git config --global user.email</span><br><span class="line">yukiyama@gmail.com</span><br></pre></td></tr></table></figure><p>当我们希望对某个具体的 git 项目 (即 <code>.git</code> 所在目录) 使用不同于 global 的用户签名时，使用 <code>--local</code> 参数单独设置，如下。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama git-demo % git config --local user.name yukiyama123</span><br><span class="line">yukiyama@yukiyama git-demo % git config --local user.name</span><br><span class="line">yukiyama123</span><br><span class="line">yukiyama@yukiyama git-demo % git config --local user.email yukiyama@outlook.com</span><br><span class="line">yukiyama@yukiyama git-demo % git config --local user.email</span><br><span class="line">yukiyama@outlook.com</span><br></pre></td></tr></table></figure><p>需要注意的是，「用户签名」与在「远程操作」中使用远程库平台 (如 github) 的账户信息无关，只不过我们也可以将用户签名设置为远程库平台的账号名及邮箱。</p><br /><h4 id="配置全局忽略"><a href="#配置全局忽略" class="headerlink" title="配置全局忽略"></a>配置全局忽略</h4><p>使用 MacOS 时，本地 git 仓库中可能会出现 MacOS 中特有的 <code>.DS_Store</code> 文件。类似这样的文件或文件夹，我们可以针对每一个本地 git 仓库，在 <code>.git</code> 所在目录下设置相应地 <code>.gitignore</code> 文件来忽略指定的文件和文件夹，也可以设置一个全局忽略配置文件 <code>.gitignore_global</code> (通常与全局配置文件 <code>.gitconfig</code> 放置在同一目录下，即 <code>~/</code> 下) 。例如新建一个 <code>~/.gitignore_global</code> 文件如下。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama ~ % cat ~/.gitignore_global</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">MacOS .DS_Store</span></span><br><span class="line">**/.DS_Store</span><br><span class="line">yukiyama@yukiyama ~ %</span><br></pre></td></tr></table></figure><blockquote><p><code>**</code> 表示子目录子子目录等多层匹配</p></blockquote><p>然后使用 <code>git config --global core.excludesfile ~/.gitignore_global</code> 命令配置到全局配置文件中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama git-demo % git config --global core.excludesfile ~/.gitignore_global</span><br><span class="line">yukiyama@yukiyama git-demo % git config --global --list</span><br><span class="line">filter.lfs.clean=git-lfs clean -- %f</span><br><span class="line">filter.lfs.smudge=git-lfs smudge -- %f</span><br><span class="line">filter.lfs.process=git-lfs filter-process</span><br><span class="line">target/</span><br><span class="line">filter.lfs.required=true</span><br><span class="line">user.name=yukiyama</span><br><span class="line">user.email=yukiyama@163.com</span><br><span class="line">init.defaultbranch=master</span><br><span class="line">core.excludesfile=/Users/yukiyama/.gitignore_global</span><br><span class="line">yukiyama@yukiyama git-demo %</span><br></pre></td></tr></table></figure><p>对于已经在 <code>.gitignore_global</code> 中的忽略规则，之后就不需要再针对每一个 git 仓库设置单独设置了。</p><br /><h4 id="配置忽略转义"><a href="#配置忽略转义" class="headerlink" title="配置忽略转义"></a>配置忽略转义</h4><p>使用 git 命令时，命令行回显信息的中文字符会被转义。如下，<code>中文.md</code> 被显示为 <code>\344\270\255\346\226\207.md</code> 。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama pics % vim 中文.md</span><br><span class="line">yukiyama@yukiyama pics % git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up to date with &#x27;origin/master&#x27;.</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line">&quot;\344\270\255\346\226\207.md&quot;</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</span><br><span class="line">yukiyama@yukiyama pics %</span><br></pre></td></tr></table></figure><p>可以将 <code>core.quotepath</code> 设置为 <code>false</code> 禁止转义，以便显示中文。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama pics % git config --global core.quotepath false</span><br><span class="line">yukiyama@yukiyama pics % git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up to date with &#x27;origin/master&#x27;.</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line">中文.md</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</span><br><span class="line">yukiyama@yukiyama pics %</span><br></pre></td></tr></table></figure><p><code>core.quotePath</code> 参数的作用如下 (来自 <a href="https://git-scm.com/docs/git-config">官方文档</a> )。</p><blockquote><p>Commands that output paths (e.g. <em>ls-files</em>, <em>diff</em>), will quote “unusual” characters in the pathname by enclosing the pathname in double-quotes and escaping those characters with backslashes in the same way C escapes control characters (e.g. <code>\t</code> for TAB, <code>\n</code> for LF, <code>\\</code> for backslash) or bytes with values larger than 0x80 (e.g. octal <code>\302\265</code> for “micro” in UTF-8). If this variable is set to false, bytes higher than 0x80 are not considered “unusual” any more. Double-quotes, backslash and control characters are always escaped regardless of the setting of this variable. A simple space character is not considered “unusual”. Many commands can output pathnames completely verbatim using the <code>-z</code> option. The default value is true.</p></blockquote><br /><h3 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h3><p>使用在文件夹下目录下执行 <code>git init</code> ，将此文件夹作为 git 本地仓库管理。执行后将出现 <code>.git</code> 隐藏文件夹，其内保存了 git 用于版本管理的各种信息文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama git-demo % git init</span><br><span class="line">Initialized empty Git repository in /Users/yukiyama/Library/Mobile Documents/com~apple~CloudDocs/study/tech/git/git-demo/.git/</span><br><span class="line">yukiyama@yukiyama git-demo %</span><br></pre></td></tr></table></figure><p>可以随时使用 <code>git status</code> 查看仓库文件状态。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama git-demo1 % git status</span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">No commits yet</span><br><span class="line"></span><br><span class="line">nothing to commit (create/copy files and use &quot;git add&quot; to track)</span><br><span class="line">yukiyama@yukiyama git-demo1 %</span><br></pre></td></tr></table></figure><br /><h3 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h3><p>文件夹初始化为 git 仓库后，尚未有文件被 git 追踪管理，此时使用 <code>git add &lt;文件名&gt;</code> 命令将指定文件放入「暂存区」。暂存区本质上是一个文件，它保存了下次将提交的文件列表信息。如下，新增一个 <code>hello.txt</code> 文件后，使用 <code>git status</code> 查看仓库内文件所属状态，可以看到 <code>Untracked files</code> 信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama git-demo % git status</span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">No commits yet</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line">.DS_Store</span><br><span class="line">hello.txt</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</span><br><span class="line">yukiyama@yukiyama git-demo %</span><br></pre></td></tr></table></figure><p>此时使用 <code>git add helle.txt</code> 即可将文件放入「暂存区」(标记为追踪文件)。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama git-demo % git add hello.txt</span><br><span class="line">yukiyama@yukiyama git-demo % git status</span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">No commits yet</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage)</span><br><span class="line">new file:   hello.txt</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line">.DS_Store</span><br><span class="line"></span><br><span class="line">yukiyama@yukiyama git-demo %</span><br></pre></td></tr></table></figure><ul><li><code>git add .</code> 会把本地所 有 untrack 的 (包括追踪过但又修改了的) 文件都加入暂存区，并且会根据 <code>.gitignore</code> 过滤忽略文件。</li><li><code>git add *</code> 会忽略 <code>.gitignore</code> 把任何文件都加入。执行时会出现如下提示，加上 <code>-f</code> 参数后可强制加入，但显然通常我们不会这么做。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama hello-git % git add *</span><br><span class="line">The following paths are ignored by one of your .gitignore files:</span><br><span class="line">test</span><br><span class="line">test.txt</span><br><span class="line">hint: Use -f if you really want to add them.</span><br><span class="line">hint: Turn this message off by running</span><br><span class="line">hint: &quot;git config advice.addIgnoredFile false&quot;</span><br><span class="line">yukiyama@yukiyama hello-git %</span><br></pre></td></tr></table></figure><br /><h3 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h3><p>使用 <code>git commit -m &quot;&lt;message&gt;&quot; &lt;filename&gt;</code>提交指定文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama git-demo % git commit -m &quot;first commit&quot; hello.txt</span><br><span class="line">[master (root-commit) 3d542ed] first commit</span><br><span class="line"> 1 file changed, 3 insertions(+)</span><br><span class="line"> create mode 100644 hello.txt</span><br><span class="line">yukiyama@yukiyama git-demo % git status</span><br><span class="line">On branch master</span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line">.DS_Store</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</span><br><span class="line">yukiyama@yukiyama git-demo %</span><br></pre></td></tr></table></figure><p><strong>修改文件</strong></p><p>修改文件后 git 会检测到被修改的文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama git-demo % git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">modified:   hello.txt</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line">.DS_Store</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br><span class="line">yukiyama@yukiyama git-demo %</span><br></pre></td></tr></table></figure><p><strong>再次添加并提交</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama git-demo % git add hello.txt</span><br><span class="line">yukiyama@yukiyama git-demo % git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage)</span><br><span class="line">modified:   hello.txt</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line">.DS_Store</span><br><span class="line"></span><br><span class="line">yukiyama@yukiyama git-demo % git commit -m &quot;first changed&quot;</span><br><span class="line">[master c246db6] first changed</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br><span class="line">yukiyama@yukiyama git-demo %</span><br></pre></td></tr></table></figure><p>也可以使用 <code>git commit -am &quot;&lt;message&gt;&quot;</code> 将所有已跟踪的文件 <strong>暂存并提交</strong> (即 add 与 commit 一起完成)。</p><br /><h3 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h3><p><code>git status</code> 命令可以添加 <code>-s</code> (<code>--short</code>) 参数以紧凑形式返回状态信息。如下，添加 <code>untracked.txt</code>, <code>added.txt</code> 和 <code>modified.txt</code> 文件演示处于 <code>untracked(??)</code>, <code>added(A)</code> , <code>modified(_M)</code> (M在右侧) 以及 <code>modifiedAdded(M_)</code> (M在左侧) 状态的情况。</p><ul><li><code>untracked.txt</code> 新建后尚未通过 <code>git add</code> 添加到暂存区。</li><li><code>added.txt</code> 新建后通过 <code>git add</code> 添加到了暂存区，但未 <code>git commit</code> 提交。</li><li><code>modified.txt</code> 新建后添加到了暂存区，且已提交，并在提交后做了修改。</li><li><code>modifiedAdded.txt</code> 新建后添加到了暂存区，且已提交，并在提交后做了修改，之后又提交到了暂存区。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama git-demo % git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage)</span><br><span class="line">new file:   added.txt</span><br><span class="line">modified:   modifiedAdded.txt</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">modified:   .DS_Store</span><br><span class="line">modified:   modified.txt</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line">untracked.txt</span><br><span class="line"></span><br><span class="line">yukiyama@yukiyama git-demo % git status -s</span><br><span class="line"> M .DS_Store</span><br><span class="line">A  added.txt</span><br><span class="line"> M modified.txt</span><br><span class="line">M  modifiedAdded.txt</span><br><span class="line">?? untracked.txt</span><br><span class="line">yukiyama@yukiyama git-demo %</span><br></pre></td></tr></table></figure><br /><h3 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h3><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>git diff &lt;文件名&gt;</td><td>列出指定文件在工作目录中修改前后的差异。</td></tr><tr><td>git diff –staged &lt;文件名&gt;</td><td>列出指定文件在暂存区与当前仓库版本间的差异。</td></tr><tr><td>git diff &lt;版本号&gt; &lt;文件名&gt;</td><td>列出指定文件在工作目录及指定仓库版本间的差异。</td></tr></tbody></table><p>※ <code>--staged</code> 也可以使用 <code>--cached</code> 代替。</p><p>※ 上述命令均针对被 git 管理的文件，即被 <code>git add</code> 过的文件。当不指定具体文件时，列出所有文件的差异。</p><p>※ 「版本号」可以用 HEAD, HEAD^, HEAD^^, HEAD<del>1, HEAD</del>2 等形式表示。HEAD 表示当前版本，HEAD^ 表示当前版本的前一个版本，有多少个 <code>^</code> 就往前多少个版本，<code>~1</code> 表示当前版本的前一个版本，数字是多少，就表示往前多少个版本。</p><p>新建 diff.txt 且该文件只有一行「only first line when created」。可以看到由于尚未对 compare.txt 执行 <code>git add</code> ，即此文件还未被 git 管理，因此 三条 <code>git diff</code> 命令均无回显。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama hello-git % vim compare.txt</span><br><span class="line">yukiyama@yukiyama hello-git % git diff</span><br><span class="line">yukiyama@yukiyama hello-git % git diff --staged compare.txt</span><br><span class="line">yukiyama@yukiyama hello-git % git diff HEAD compare.txt</span><br></pre></td></tr></table></figure><p>执行 <code>git add compare.txt</code> 之后。可以看到如下。</p><ul><li><code>git diff</code> 命令无回显，因为是初次被 git 管理，即第一次出现在 git 的工作目录，此文件在工作目录中无历史可比较版本。</li><li><code>git diff --staged</code> 列出首行差异，因为此时暂存区比当前仓库版本多一行 (多了此文件，并且有一行差异) 。</li><li><code>git diff HEAD</code> 列出首行差异，因为此时工作目录比当前仓库版本多一行 (多了此文件，并且有一行差异) 。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama hello-git % git add compare.txt</span><br><span class="line">yukiyama@yukiyama hello-git % git diff</span><br><span class="line">yukiyama@yukiyama hello-git % git diff --staged compare.txt</span><br><span class="line">diff --git a/compare.txt b/compare.txt</span><br><span class="line">new file mode 100644</span><br><span class="line">index 0000000..80dd23d</span><br><span class="line">--- /dev/null</span><br><span class="line">+++ b/compare.txt</span><br><span class="line">@@ -0,0 +1 @@</span><br><span class="line">+only first line when created</span><br><span class="line">yukiyama@yukiyama hello-git % git diff HEAD compare.txt</span><br><span class="line">diff --git a/compare.txt b/compare.txt</span><br><span class="line">new file mode 100644</span><br><span class="line">index 0000000..80dd23d</span><br><span class="line">--- /dev/null</span><br><span class="line">+++ b/compare.txt</span><br><span class="line">@@ -0,0 +1 @@</span><br><span class="line">+only first line when created</span><br><span class="line">yukiyama@yukiyama hello-git %</span><br></pre></td></tr></table></figure><p>执行 <code>git commit -m &quot;add compare.txt&quot;</code> 提交 compare.txt 之后。可看到如下。此时工作目录、暂存区和当前版本均无差异。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama hello-git % git commit -m &quot;add compare.txt&quot;</span><br><span class="line">[master 1e05a4f] add compare.txt</span><br><span class="line"> 2 files changed, 1 insertion(+), 1 deletion(-)</span><br><span class="line"> create mode 100644 compare.txt</span><br><span class="line"> delete mode 100644 diff.txt</span><br><span class="line">yukiyama@yukiyama hello-git % git diff</span><br><span class="line">yukiyama@yukiyama hello-git % git diff --staged compare.txt</span><br><span class="line">yukiyama@yukiyama hello-git % git diff HEAD compare.txt</span><br><span class="line">yukiyama@yukiyama hello-git %</span><br></pre></td></tr></table></figure><p>增加第二行 「second line added」之后。可以看到如下。</p><ul><li><code>git diff</code> 列出第二行差异，因为此时工作目录下该文件多了一行 。</li><li><code>git diff --staged</code> 由于暂存区与当前仓库版本无差异，因此无回显。</li><li><code>git diff HEAD</code> 由于工作目录与当前仓库版本无差异，因此无回显。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama hello-git % git diff compare.txt</span><br><span class="line">diff --git a/compare.txt b/compare.txt</span><br><span class="line">index 80dd23d..3d555a6 100644</span><br><span class="line">--- a/compare.txt</span><br><span class="line">+++ b/compare.txt</span><br><span class="line">@@ -1 +1,2 @@</span><br><span class="line"> only first line when created</span><br><span class="line">+second line added</span><br><span class="line">yukiyama@yukiyama hello-git % git diff --staged compare.txt</span><br><span class="line">yukiyama@yukiyama hello-git % git diff HEAD compare.txt</span><br><span class="line">diff --git a/compare.txt b/compare.txt</span><br><span class="line">index 80dd23d..3d555a6 100644</span><br><span class="line">--- a/compare.txt</span><br><span class="line">+++ b/compare.txt</span><br><span class="line">@@ -1 +1,2 @@</span><br><span class="line"> only first line when created</span><br><span class="line">+second line added</span><br><span class="line">yukiyama@yukiyama hello-git %</span><br></pre></td></tr></table></figure><p>「版本号」的不同写法。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama hello-git % git diff HEAD~1 compare.txt</span><br><span class="line">diff --git a/compare.txt b/compare.txt</span><br><span class="line">new file mode 100644</span><br><span class="line">index 0000000..3d555a6</span><br><span class="line">--- /dev/null</span><br><span class="line">+++ b/compare.txt</span><br><span class="line">@@ -0,0 +1,2 @@</span><br><span class="line">+only first line when created</span><br><span class="line">+second line added</span><br><span class="line">yukiyama@yukiyama hello-git % git diff HEAD^ compare.txt</span><br><span class="line">diff --git a/compare.txt b/compare.txt</span><br><span class="line">new file mode 100644</span><br><span class="line">index 0000000..3d555a6</span><br><span class="line">--- /dev/null</span><br><span class="line">+++ b/compare.txt</span><br><span class="line">@@ -0,0 +1,2 @@</span><br><span class="line">+only first line when created</span><br><span class="line">+second line added</span><br><span class="line">yukiyama@yukiyama hello-git % git reflog -2</span><br><span class="line">1e05a4f (HEAD -&gt; master) HEAD@&#123;0&#125;: commit: add compare.txt</span><br><span class="line">f08b6a1 HEAD@&#123;1&#125;: commit: add diff.txt</span><br><span class="line">yukiyama@yukiyama hello-git % git diff f08b6a1 compare.txt</span><br><span class="line">diff --git a/compare.txt b/compare.txt</span><br><span class="line">new file mode 100644</span><br><span class="line">index 0000000..3d555a6</span><br><span class="line">--- /dev/null</span><br><span class="line">+++ b/compare.txt</span><br><span class="line">@@ -0,0 +1,2 @@</span><br><span class="line">+only first line when created</span><br><span class="line">+second line added</span><br><span class="line">yukiyama@yukiyama hello-git %</span><br></pre></td></tr></table></figure><br /><h3 id="git-rm"><a href="#git-rm" class="headerlink" title="git rm"></a>git rm</h3><p>使用 <code>git rm &lt;filename&gt;</code> 从已跟踪的文件清单中移除指定文件 (即从暂存区域移除) 并提交，同时删除该文件。如果只是 使用 <code>rm</code> ，虽然文件被删除，但 <code>git status</code> 后还是能看到已被删除的文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama git-demo % git rm hello.txt</span><br><span class="line">error: the following file has staged content different from both the</span><br><span class="line">file and the HEAD:</span><br><span class="line">    hello.txt</span><br><span class="line">(use -f to force removal)</span><br><span class="line">yukiyama@yukiyama git-demo % git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage)</span><br><span class="line">modified:   hello.txt</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">modified:   .DS_Store</span><br><span class="line">modified:   hello.txt</span><br><span class="line"></span><br><span class="line">yukiyama@yukiyama git-demo %</span><br></pre></td></tr></table></figure><p>如上，在 <code>git rm</code> 删除指定文件前，若该文件有过修改，则拒绝删除，这样做的目的是防止删除未添加到仓库中的数据，这样的数据无法被 git 恢复。确定要删除时可以使用 <code>-f</code> 参数强制删除 (force) 。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama git-demo % git rm -f hello.txt</span><br><span class="line">rm &#x27;hello.txt&#x27;</span><br><span class="line">yukiyama@yukiyama git-demo % git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage)</span><br><span class="line">deleted:    hello.txt</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">modified:   .DS_Store</span><br><span class="line"></span><br><span class="line">yukiyama@yukiyama git-demo %</span><br></pre></td></tr></table></figure><br /><h3 id="git-mv"><a href="#git-mv" class="headerlink" title="git mv"></a>git mv</h3><p>使用 <code>git mv</code> 命令修改文件名，例如 <code>git mv a.txt b.txt</code> 相当于如下三行命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mv a.txt b.txt</span><br><span class="line">git rm a.txt</span><br><span class="line">git add b.txt</span><br></pre></td></tr></table></figure><br /><h3 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h3><p>使用 <code>git log</code> 查看提交历史。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama git-demo % git log</span><br><span class="line">commit b8d829123843fe1d760983ed5bfc9f2cbcc22d13 (HEAD -&gt; master)</span><br><span class="line">Author: iyukiyama &lt;youremail@yama.com&gt;</span><br><span class="line">Date:   Mon Sep 26 19:54:50 2022 +0800</span><br><span class="line"></span><br><span class="line">    modified one line</span><br><span class="line"></span><br><span class="line">commit 5f3d03819d450b534153b90531393efd38e6a0a1</span><br><span class="line">Author: iyukiyama &lt;youremail@yama.com&gt;</span><br><span class="line">Date:   Mon Sep 26 19:53:32 2022 +0800</span><br><span class="line"></span><br><span class="line">    first commit</span><br></pre></td></tr></table></figure><p>使用 <code>git log -p</code> 查看每次提交的差异，使用 <code>git log -p -2</code> 查看最近 2 次提交的差异。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama git-demo % git log -p</span><br><span class="line">commit b8d829123843fe1d760983ed5bfc9f2cbcc22d13 (HEAD -&gt; master)</span><br><span class="line">Author: iyukiyama &lt;youremail@yama.com&gt;</span><br><span class="line">Date:   Mon Sep 26 19:54:50 2022 +0800</span><br><span class="line"></span><br><span class="line">    modified one line</span><br><span class="line"></span><br><span class="line">diff --git a/hello.txt b/hello.txt</span><br><span class="line">index 40f4dc0..06227ce 100644</span><br><span class="line">--- a/hello.txt</span><br><span class="line">+++ b/hello.txt</span><br><span class="line">@@ -1,3 +1,3 @@</span><br><span class="line">-hello 1</span><br><span class="line">+hello 1 modified</span><br><span class="line"> hello 2</span><br><span class="line"> hello 3</span><br><span class="line"></span><br><span class="line">commit 5f3d03819d450b534153b90531393efd38e6a0a1</span><br><span class="line">Author: iyukiyama &lt;youremail@yama.com&gt;</span><br><span class="line">Date:   Mon Sep 26 19:53:32 2022 +0800</span><br><span class="line"></span><br><span class="line">    first commit</span><br><span class="line"></span><br><span class="line">diff --git a/hello.txt b/hello.txt</span><br><span class="line">new file mode 100644</span><br><span class="line">index 0000000..40f4dc0</span><br><span class="line">--- /dev/null</span><br><span class="line">+++ b/hello.txt</span><br><span class="line">@@ -0,0 +1,3 @@</span><br><span class="line">+hello 1</span><br><span class="line">+hello 2</span><br><span class="line">+hello 3</span><br></pre></td></tr></table></figure><p><code>git log</code> 命令有许多参数可用于调整输出历史记录的信息。</p><br /><h3 id="git-reflog"><a href="#git-reflog" class="headerlink" title="git reflog"></a>git reflog</h3><p>也可以使用 <code>git reflog</code> 查看缩略的提交历史信息。<code>git reflog -p</code>, <code>git reflog -2</code> 的作用与 <code>git log -p</code> 和 <code>git log -2</code> 类似。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama git-demo % git reflog</span><br><span class="line">b8d8291 (HEAD -&gt; master) HEAD@&#123;0&#125;: commit: modified one line</span><br><span class="line">5f3d038 HEAD@&#123;1&#125;: commit: first commit</span><br></pre></td></tr></table></figure><br /><h2 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h2><table><thead><tr><th>撤销操作</th><th>执行前状态</th><th>区域变化</th><th>描述</th></tr></thead><tbody><tr><td>git commit –amend</td><td>未修改</td><td>暂存区 &gt; 仓库</td><td>修改 message 后提交暂存区，替换掉最后一次提交，即提交数不变 (commit id不同)。</td></tr><tr><td>git commit –amend -m “&lt;提交信息&gt;”</td><td>未修改</td><td>暂存区 &gt; 仓库</td><td>同上，但不会打开编辑器编辑提交信息，而是直接写上提交信息。</td></tr><tr><td>git restore –staged &lt;文件名&gt;</td><td>已暂存</td><td>暂存区 &gt; 工作区</td><td>将指定文件移出暂存区<br />※ 必须指定文件名</td></tr><tr><td>git restore &lt;文件名&gt;</td><td>已修改</td><td>不变</td><td>都在工作目录下，将已修改状态的指定文件回退到未修改的状态，即丢弃指定文件的所有修改。</td></tr><tr><td>git rest HEAD &lt;文件名&gt;</td><td>已暂存</td><td>暂存区 &gt; 工作区</td><td>同 <code>git restore --staged &lt;文件名&gt;</code><br />※ 若不指定文件名，则清空暂存区</td></tr><tr><td>git checkout – &lt;文件名&gt;</td><td>已修改</td><td>不变</td><td>同 <code>git restore &lt;文件名&gt;</code><br />※ 必须指定文件名</td></tr></tbody></table><br /><h3 id="git-commit-–amend"><a href="#git-commit-–amend" class="headerlink" title="git commit –amend"></a>git commit –amend</h3><p>在某次提交后发现该提交的 message 描述有误，想要修改该 message ，或者想要再 add 一些文件，可以使用 <code>git commit --amend</code> 。</p><p>如下先完成两次提交。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">commit 6d70b38bd6becddcd2b70fb1a5bc3ee929070497 (HEAD -&gt; master)</span><br><span class="line">Author: yukiyama &lt;yukiyama@163.com&gt;</span><br><span class="line">iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiijjjiiiiiiiiiiiixx</span><br><span class="line">Date:   Wed Sep 28 20:11:01 2022 +0800</span><br><span class="line"></span><br><span class="line">    first commit</span><br><span class="line">yukiyama@yukiyama hello-git % vim hello.txt</span><br><span class="line">yukiyama@yukiyama hello-git % git add .</span><br><span class="line">yukiyama@yukiyama hello-git % git commit -m &quot;second commit&quot;</span><br><span class="line">[master 6eefb40] second commit</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br><span class="line">yukiyama@yukiyama hello-git % git log</span><br><span class="line">commit 6eefb4065d6b3f02cedf9edce05d3de2afaace87 (HEAD -&gt; master)</span><br><span class="line">Author: yukiyama &lt;yukiyama@163.com&gt;</span><br><span class="line">Date:   Wed Sep 28 20:11:37 2022 +0800</span><br><span class="line"></span><br><span class="line">    second commit</span><br><span class="line"></span><br><span class="line">commit 6d70b38bd6becddcd2b70fb1a5bc3ee929070497</span><br><span class="line">Author: yukiyama &lt;yukiyama@163.com&gt;</span><br><span class="line">Date:   Wed Sep 28 20:11:01 2022 +0800</span><br><span class="line"></span><br><span class="line">    first commit</span><br><span class="line">yukiyama@yukiyama hello-git % git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line">yukiyama@yukiyama hello-git %</span><br></pre></td></tr></table></figure><p>修改文件并执行 <code>git add</code> 后，将 message 修改为 “second commit (amend)” 来取代上一次提交。再次执行 <code>git log</code> 可以看到前次提交 (6eefb) 已不显示，取而代之的是新提交 (b299e) ，message 发生变化但提交时间和作者信息与之前是一致的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama hello-git % vim hello.txt</span><br><span class="line">yukiyama@yukiyama hello-git % git add hello.txt</span><br><span class="line">yukiyama@yukiyama hello-git % git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage)</span><br><span class="line">modified:   hello.txt</span><br><span class="line"></span><br><span class="line">yukiyama@yukiyama hello-git % git commit --amend -m &quot;second commit (amend)&quot;</span><br><span class="line">[master b299e54] second commit (amend)</span><br><span class="line"> Date: Wed Sep 28 20:11:37 2022 +0800</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br><span class="line">yukiyama@yukiyama hello-git % git log</span><br><span class="line">commit b299e542f8677f2c1e55b17cd9aa24bb2241ebad (HEAD -&gt; master)</span><br><span class="line">Author: yukiyama &lt;yukiyama@163.com&gt;</span><br><span class="line">Date:   Wed Sep 28 20:11:37 2022 +0800</span><br><span class="line"></span><br><span class="line">    second commit (amend)</span><br><span class="line"></span><br><span class="line">commit 6d70b38bd6becddcd2b70fb1a5bc3ee929070497</span><br><span class="line">Author: yukiyama &lt;yukiyama@163.com&gt;</span><br><span class="line">Date:   Wed Sep 28 20:11:01 2022 +0800</span><br><span class="line"></span><br><span class="line">    first commit</span><br><span class="line">yukiyama@yukiyama hello-git %</span><br></pre></td></tr></table></figure><p>每次提交时都可以使用 <code>git commit --amend -m &quot;&lt;message&gt;&quot;</code> 来取代上一次提交，这样无论有多少次提交， <code>git log</code> 都只显示最后一次提交。(但是 <code>git reflog</code> 仍会显示每一次提交) 。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama hello-git % git reflog</span><br><span class="line">b299e54 (HEAD -&gt; master) HEAD@&#123;0&#125;: commit (amend): second commit (amend)</span><br><span class="line">6eefb40 HEAD@&#123;1&#125;: commit: second commit</span><br><span class="line">6d70b38 HEAD@&#123;2&#125;: commit (initial): first commit</span><br><span class="line">yukiyama@yukiyama hello-git %</span><br></pre></td></tr></table></figure><br /><h3 id="git-restore"><a href="#git-restore" class="headerlink" title="git restore"></a>git restore</h3><p>主要有两种用法，两种用法都必须指定文件名，可以一次指定多个文件 (文件名用空格分开) 。</p><ul><li>使用 <code>git restore --staged &lt;文件名&gt;</code> 将指定的暂存区中的文件移出暂存区。</li><li>使用 <code>git restore &lt;文件名&gt;</code> 将工作目录下的「已修改」文件恢复为未修改状态。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama hello-git % git add hello.txt</span><br><span class="line">yukiyama@yukiyama hello-git % git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage)</span><br><span class="line">modified:   hello.txt</span><br><span class="line"></span><br><span class="line">yukiyama@yukiyama hello-git % git restore --staged hello.txt</span><br><span class="line">yukiyama@yukiyama hello-git % git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">modified:   hello.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br><span class="line">yukiyama@yukiyama hello-git % git restore hello.txt</span><br><span class="line">yukiyama@yukiyama hello-git % git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line">yukiyama@yukiyama hello-git %</span><br></pre></td></tr></table></figure><br /><h3 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h3><p>使用 <code>git rest HEAD &lt;filename&gt;</code> 将指定的已暂存的文件移出暂存区 (同 <code>git restore --staged &lt;filename&gt;</code> )， 若不指定文件，则取消所有文件的暂存内容 (清空暂存区)。其中，<code>HEAD</code> 表示当前版本，退回到上一个版本可用 <code>HEAD^ </code>。</p><p><code>git rest HEAD &lt;filename&gt;</code> 与 <code>git restore --staged &lt;filename&gt;</code> 效果相同，但 git 的提示推荐使用 <code>git restore &lt;文件名&gt;</code> 用法。</p><p>如下展示 <code>hello.txt</code> 加入暂存区后，执行 <code>git rest HEAD</code> 取消暂存的过程。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama hello-git % git add hello.txt</span><br><span class="line">yukiyama@yukiyama hello-git % git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage)</span><br><span class="line">modified:   hello.txt</span><br><span class="line"></span><br><span class="line">yukiyama@yukiyama hello-git % git reset HEAD hello.txt</span><br><span class="line">Unstaged changes after reset:</span><br><span class="line">Mhello.txt</span><br><span class="line">yukiyama@yukiyama hello-git % git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">modified:   hello.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br><span class="line">yukiyama@yukiyama hello-git %</span><br></pre></td></tr></table></figure><br /><h3 id="git-checkout-–"><a href="#git-checkout-–" class="headerlink" title="git checkout –"></a>git checkout –</h3><p>使用 <code>git checkout -- &lt;filename&gt;</code> 将工作目录下的「已修改」文件恢复为未修改状态，同 <code>git restore &lt;文件名&gt;</code> ，git 的提示推荐使用 <code>git restore &lt;文件名&gt;</code> 用法。</p><p>如下，接上一节的操作。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama hello-git % git checkout -- hello.txt</span><br><span class="line">yukiyama@yukiyama hello-git % git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line">yukiyama@yukiyama hello-git %</span><br></pre></td></tr></table></figure><br /><h2 id="切换操作"><a href="#切换操作" class="headerlink" title="切换操作"></a>切换操作</h2><p>切换操作也属于广义上的撤销，但更强调在版本间穿梭的特点。<code>git reset</code> 的主要能力特点就是能够实现版本之间穿梭的操作，即「切换操作」。</p><p>在介绍命令之前有必要先说明如下三个「切换目标」的概念。</p><table><thead><tr><th>切换目标</th><th>描述</th></tr></thead><tbody><tr><td>HEAD</td><td>指向当前分支的当前版本 (commit) 的指针，可以理解为就是当前版本。</td></tr><tr><td>index</td><td>可以理解为当前暂存区</td></tr><tr><td>working tree</td><td>可以理解为当前工作目录</td></tr></tbody></table><p><code>git reset</code> 命令有三种常用模式 <code>--mixed</code> (默认，不显式写出时即为此模式)、<code>--soft</code> 以及 <code>--hard</code> ，分别实现对不同「切换目标」的操作。</p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>git reset –soft &lt;版本号&gt;</td><td>将 HEAD 指向指定的版本 (commit) ，不改动 index 和 working tree。<br />※ 不可指定文件名 (指定则报错)。</td></tr><tr><td>git reset –mixed  &lt;版本号&gt;</td><td>不指定文件。将 HEAD 指向指定的版本 (commit) ，并使得暂存区与指定版本一致，即在指定版本之后加入暂存区的所有文件都移出暂存区。<br />※ <code>--mixed</code> 参数是默认的，也可不写。</td></tr><tr><td>git reset –mixed  &lt;版本号&gt; &lt;文件名&gt;</td><td>指定文件。HEAD 指针不变，但指定的文件对应的暂存区内容将切换到指定版本的状态，其他文件在暂存区的内容不变。</td></tr><tr><td>git reset –hard &lt;版本号&gt;</td><td>将 HEAD, index 和 working tree 都切换到指定版本号的状态。<br />※ 不可指定文件名 (指定则报错)。</td></tr></tbody></table><p>※ 「版本号」可以用 HEAD, HEAD^, HEAD^^, HEAD<del>1, HEAD</del>2 等形式表示。HEAD 表示当前版本，HEAD^ 表示当前版本的前一个版本，有多少个 <code>^</code> 就往前多少个版本，<code>~1</code> 表示当前版本的前一个版本，数字是多少，就表示往前多少个版本。</p><p>※ 在「撤销操作」中，我们说过 <a href="https://github.blog/2019-08-16-highlights-from-git-2-23/">git 2.23</a> 版本加入 <code>git restore</code> 命令后，推荐使用 <code>git restore --staged &lt;文件名&gt;</code> 来代替 <code>git reset HEAD &lt;filename&gt;</code> ，原因之一就是 <code>git reset</code> 承担的功能太多，有必要引入新的更直观的命令来取代一部分功能。</p><br /><h3 id="git-reset-–soft"><a href="#git-reset-–soft" class="headerlink" title="git reset –soft"></a>git reset –soft</h3><p><code>git reset --soft &lt;commit id&gt;</code> 将 HEAD 指向指定的版本 (commit) ，不改动 index 和 working tree。简单直观的理解即执行后，在版本历史中的第一条 (当前版本) 即为指定的那个版本，除此之外无其他变化。</p><p>如下演示 <code>--soft</code> 模式的效果。</p><p>首先，依次提交 1.txt , 2.txt 和 3.txt 之后<code>git add</code> 4.txt 但不提交，则当前有 3 个版本，暂存区中有四个文件 (通过 <code>git ls-files</code> 查看)。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama hello-git % git reflog</span><br><span class="line">5bff39f (HEAD -&gt; master) HEAD@&#123;0&#125;: commit: add 3</span><br><span class="line">d287e4b HEAD@&#123;1&#125;: commit: add 2</span><br><span class="line">c97c40e HEAD@&#123;2&#125;: commit (initial): add 1</span><br><span class="line">yukiyama@yukiyama hello-git %</span><br><span class="line">yukiyama@yukiyama hello-git %</span><br><span class="line">yukiyama@yukiyama hello-git %</span><br><span class="line">yukiyama@yukiyama hello-git % git ls-files</span><br><span class="line">1.txt</span><br><span class="line">2.txt</span><br><span class="line">3.txt</span><br><span class="line">yukiyama@yukiyama hello-git % vim 4.txt</span><br><span class="line">yukiyama@yukiyama hello-git % git add 4.txt</span><br><span class="line">yukiyama@yukiyama hello-git % git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage)</span><br><span class="line">new file:   4.txt</span><br><span class="line"></span><br><span class="line">yukiyama@yukiyama hello-git % git ls-files</span><br><span class="line">1.txt</span><br><span class="line">2.txt</span><br><span class="line">3.txt</span><br><span class="line">4.txt</span><br><span class="line">yukiyama@yukiyama hello-git %</span><br></pre></td></tr></table></figure><p>然后软切换回  (<code>--soft</code>) 第一个版本 (c97c40e)，此时当前分支 (master) 的 HEAD 确实指向了指定的版本。通过 <code>git status</code> 和 <code>git ls-files</code> 可以看到，在暂存区的内容无变化，只不过因为切回了若干个版本，暂存区「领先」了当前版本 (c97c40e) ，因此 2.txt, 3.txt, 4.txt 都是「Changes to be committed」。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama hello-git % git reset --soft c97c40e</span><br><span class="line">yukiyama@yukiyama hello-git % git reflog</span><br><span class="line">c97c40e (HEAD -&gt; master) HEAD@&#123;0&#125;: reset: moving to c97c40e</span><br><span class="line">5bff39f HEAD@&#123;1&#125;: commit: add 3</span><br><span class="line">d287e4b HEAD@&#123;2&#125;: commit: add 2</span><br><span class="line">c97c40e (HEAD -&gt; master) HEAD@&#123;3&#125;: commit (initial): add 1</span><br><span class="line">yukiyama@yukiyama hello-git % git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage)</span><br><span class="line">new file:   2.txt</span><br><span class="line">new file:   3.txt</span><br><span class="line">new file:   4.txt</span><br><span class="line"></span><br><span class="line">yukiyama@yukiyama hello-git % git ls-files</span><br><span class="line">1.txt</span><br><span class="line">2.txt</span><br><span class="line">3.txt</span><br><span class="line">4.txt</span><br><span class="line">yukiyama@yukiyama hello-git %</span><br></pre></td></tr></table></figure><p>由此我们验证了 <code>--soft</code> 模式确实只是将 HEAD 指向指定的版本，暂存区与工作目录无变化。</p><br /><h3 id="git-reset-–mixed"><a href="#git-reset-–mixed" class="headerlink" title="git reset –mixed"></a>git reset –mixed</h3><p><code>git reset --mixed &lt;commit id&gt;</code> 命令，可以指定文件或不指定文件，效果不同。</p><ul><li>不指定文件时。即包含了 <code>--soft</code> 实现的功能，即 <code>HEAD</code> 指针指向指定的版本，又实现了「暂存区」的切换，即使得暂存区与指定版本一致。</li><li>指定文件时。<code>HEAD</code> 指针不变，但指定的文件对应的暂存区内容将切换到指定版本的状态。</li></ul><p>首先，提交 1.txt 作为第一个版本 (fc746eb) ，提交 2-1.txt 和 2-2.txt 作为第二个版本 (d3f6a97) ，提交 3.txt 作为第三个版本 (23a6441) ，将 4.txt 放入暂存区但不提交。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama hello-git % vim 1.txt</span><br><span class="line">yukiyama@yukiyama hello-git % git add 1.txt</span><br><span class="line">yukiyama@yukiyama hello-git % git commit -m &quot;add 1.txt&quot;</span><br><span class="line">[master (root-commit) fc746eb] add 1.txt</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 1.txt</span><br><span class="line">yukiyama@yukiyama hello-git % vim 2-1.txt</span><br><span class="line">yukiyama@yukiyama hello-git % vim 2-2.txt</span><br><span class="line">yukiyama@yukiyama hello-git % git add 2-1.txt 2-2.txt</span><br><span class="line">yukiyama@yukiyama hello-git % git commit -m &quot;add 2-1.txt 2-2.txt&quot;</span><br><span class="line">[master d3f6a97] add 2-1.txt 2-2.txt</span><br><span class="line"> 2 files changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 2-1.txt</span><br><span class="line"> create mode 100644 2-2.txt</span><br><span class="line">yukiyama@yukiyama hello-git % vim 3.txt</span><br><span class="line">yukiyama@yukiyama hello-git % git add 3.txt</span><br><span class="line">yukiyama@yukiyama hello-git % git commit -m &quot;add 3.txt&quot;</span><br><span class="line">[master 23a6441] add 3.txt</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 3.txt</span><br><span class="line">yukiyama@yukiyama hello-git % vim 4.txt</span><br><span class="line">yukiyama@yukiyama hello-git % git add 4.txt</span><br><span class="line">yukiyama@yukiyama hello-git % git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage)</span><br><span class="line">new file:   4.txt</span><br><span class="line"></span><br><span class="line">yukiyama@yukiyama hello-git %</span><br></pre></td></tr></table></figure><p>可以看到暂存区中有五个文件，提交历史有三次，当前 HEAD 指向的是提交了 3.txt 的版本。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama hello-git % git ls-files</span><br><span class="line">1.txt</span><br><span class="line">2-1.txt</span><br><span class="line">2-2.txt</span><br><span class="line">3.txt</span><br><span class="line">4.txt</span><br><span class="line">yukiyama@yukiyama hello-git % git reflog</span><br><span class="line">23a6441 (HEAD -&gt; master) HEAD@&#123;0&#125;: commit: add 3.txt</span><br><span class="line">d3f6a97 HEAD@&#123;1&#125;: commit: add 2-1.txt 2-2.txt</span><br><span class="line">fc746eb HEAD@&#123;2&#125;: commit (initial): add 1.txt</span><br><span class="line">yukiyama@yukiyama hello-git %</span><br></pre></td></tr></table></figure><p>接着执行混合切换 (<code>--mixed</code>) 到第二个版本，即提交了 2-1.txt 和 2-2.txt 的版本 (d3f6a97) ，由于未指定文件，因此实现的效果是 HEAD 指向 d3f6a97 ，且暂存区也恢复到 d3f6a97 的状态。查看提交历史，HEAD 确实为 d3f6a97，且 message 提示了是通过 reset 切换而来的。通过 <code>git ls-files</code> 看到此时暂存区里的文件也确实是第二个版本对应的三个文件 1.txt, 2-1.txt, 2-2.txt ，即相当于把指定版本之后才放到暂存区的文件都移出了暂存区，导致这些文件出现在 <code>git status</code> 的提示中，即他们此时是 「Untracked files」(在指定版本之后才创建的)。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama hello-git % git reset --mixed d3f6a97</span><br><span class="line">yukiyama@yukiyama hello-git % git reflog</span><br><span class="line">d3f6a97 (HEAD -&gt; master) HEAD@&#123;0&#125;: reset: moving to d3f6a97</span><br><span class="line">23a6441 HEAD@&#123;1&#125;: commit: add 3.txt</span><br><span class="line">d3f6a97 (HEAD -&gt; master) HEAD@&#123;2&#125;: commit: add 2-1.txt 2-2.txt</span><br><span class="line">fc746eb HEAD@&#123;3&#125;: commit (initial): add 1.txt</span><br><span class="line">yukiyama@yukiyama hello-git % git status</span><br><span class="line">On branch master</span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line">3.txt</span><br><span class="line">4.txt</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</span><br><span class="line">yukiyama@yukiyama hello-git % git ls-files</span><br><span class="line">1.txt</span><br><span class="line">2-1.txt</span><br><span class="line">2-2.txt</span><br><span class="line">yukiyama@yukiyama hello-git %</span><br></pre></td></tr></table></figure><p>接着再测试指定文件的效果，如下，由于 <code>--mixed</code> 是默认的参数，可以省略。执行 <code>git reset fc746eb 2-1.txt</code> 将指定文件 2-1.txt 对应的暂存区内容切换回 <code>fc746eb</code> 版本 (提交了 1.txt 的第一个版本) ，即只将此文件对应暂存区的内容移除对应到指定的版本状态 (对这个例子来说，即移除，因为 1.txt 提交的时候尚未创建 2-1.txt)，其他文件在暂存区的内容保留。</p><p>首先通过 <code>git reflog</code> 可以看到 HEAD 不变。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama hello-git % git reset fc746eb 2-1.txt</span><br><span class="line">yukiyama@yukiyama hello-git % git reflog</span><br><span class="line">d3f6a97 (HEAD -&gt; master) HEAD@&#123;0&#125;: reset: moving to d3f6a97</span><br><span class="line">23a6441 HEAD@&#123;1&#125;: commit: add 3.txt</span><br><span class="line">d3f6a97 (HEAD -&gt; master) HEAD@&#123;2&#125;: commit: add 2-1.txt 2-2.txt</span><br><span class="line">fc746eb HEAD@&#123;3&#125;: commit (initial): add 1.txt</span><br><span class="line">yukiyama@yukiyama hello-git % </span><br></pre></td></tr></table></figure><p>接着，通过 <code>git ls-files</code> 看到当前暂存区已无 2-1.txt ，但却有 2-2.txt ，说明只是移除了指定的文件对应的暂存区内容。另外执行 <code>git status</code> 可以看到移出的 2-1.txt 以及在前一次不带文件名的混合切换后移出的 3.txt 和 4.txt 都变为了 「Untracked files」。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama hello-git % git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage)</span><br><span class="line">deleted:    2-1.txt</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line">2-1.txt</span><br><span class="line">3.txt</span><br><span class="line">4.txt</span><br><span class="line"></span><br><span class="line">yukiyama@yukiyama hello-git % git ls-files</span><br><span class="line">1.txt</span><br><span class="line">2-2.txt</span><br><span class="line">yukiyama@yukiyama hello-git %</span><br></pre></td></tr></table></figure><br /><h3 id="git-reset-–hard"><a href="#git-reset-–hard" class="headerlink" title="git reset –hard"></a>git reset –hard</h3><p><code>git reset --hard &lt;commit id&gt;</code> 命令将 HEAD, index 和 working tree 都切换到指定版本号的状态</p><p>接着之前 <code>git reset --mixed</code> 的操作后继续演示，首先执行 <code>git reset 23a6441</code> 恢复到提交了 3.txt 之后的版本状态。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama hello-git % git reset 23a6441</span><br><span class="line">yukiyama@yukiyama hello-git % git status</span><br><span class="line">On branch master</span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line">4.txt</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</span><br><span class="line">yukiyama@yukiyama hello-git % git ls-files</span><br><span class="line">1.txt</span><br><span class="line">2-1.txt</span><br><span class="line">2-2.txt</span><br><span class="line">3.txt</span><br><span class="line">yukiyama@yukiyama hello-git % git log --oneline</span><br><span class="line">23a6441 (HEAD -&gt; master) add 3.txt</span><br><span class="line">d3f6a97 add 2-1.txt 2-2.txt</span><br><span class="line">fc746eb add 1.txt</span><br><span class="line">yukiyama@yukiyama hello-git %</span><br></pre></td></tr></table></figure><p>然后执行 <code>git reset --hard fc746eb</code> 硬切换回提交了 1.txt 之后的版本。可以看到如下效果，即 HEAD, index (暂存区) 和工作目录确实都切换到了 fc746eb 的状态。略有不同的是此时还存在新建状态但未 <code>git add</code> 的 4.txt，这是因为执行此次硬切换时 4.txx 是未 <code>git add</code> 的状态，不被 git 所管控。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama hello-git % git reset --hard fc746eb</span><br><span class="line">HEAD is now at fc746eb add 1.txt</span><br><span class="line">yukiyama@yukiyama hello-git % git log --oneline</span><br><span class="line">fc746eb (HEAD -&gt; master) add 1.txt</span><br><span class="line">yukiyama@yukiyama hello-git % git reflog</span><br><span class="line">fc746eb (HEAD -&gt; master) HEAD@&#123;0&#125;: reset: moving to fc746eb</span><br><span class="line">23a6441 HEAD@&#123;1&#125;: reset: moving to 23a6441</span><br><span class="line">d3f6a97 HEAD@&#123;2&#125;: reset: moving to d3f6a97</span><br><span class="line">23a6441 HEAD@&#123;3&#125;: commit: add 3.txt</span><br><span class="line">d3f6a97 HEAD@&#123;4&#125;: commit: add 2-1.txt 2-2.txt</span><br><span class="line">fc746eb (HEAD -&gt; master) HEAD@&#123;5&#125;: commit (initial): add 1.txt</span><br><span class="line">yukiyama@yukiyama hello-git % git status</span><br><span class="line">On branch master</span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line">4.txt</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</span><br><span class="line">yukiyama@yukiyama hello-git % git ls-files</span><br><span class="line">1.txt</span><br><span class="line">yukiyama@yukiyama hello-git % ls -al</span><br><span class="line">total 16</span><br><span class="line">drwxr-xr-x@  5 yukiyama  staff  160 Sep 29 16:21 .</span><br><span class="line">drwxr-xr-x@ 10 yukiyama  staff  320 Sep 29 16:21 ..</span><br><span class="line">drwxr-xr-x@ 13 yukiyama  staff  416 Sep 29 16:20 .git</span><br><span class="line">-rw-r--r--   1 yukiyama  staff    3 Sep 29 15:34 1.txt</span><br><span class="line">-rw-r--r--   1 yukiyama  staff    4 Sep 29 15:35 4.txt</span><br><span class="line">yukiyama@yukiyama hello-git %</span><br></pre></td></tr></table></figure><p>如果这时候我们再次硬切换回提交了 3.txt 的版本 (23a6441)，可以看到如下效果，即恢复到了该版本状态，不同的也是 4.txt 仍然存在，原因同前述。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama hello-git % git reset --hard 23a6441</span><br><span class="line">HEAD is now at 23a6441 add 3.txt</span><br><span class="line">yukiyama@yukiyama hello-git % ls -al</span><br><span class="line">total 40</span><br><span class="line">drwxr-xr-x@  8 yukiyama  staff  256 Sep 29 16:21 .</span><br><span class="line">drwxr-xr-x@ 10 yukiyama  staff  320 Sep 29 16:21 ..</span><br><span class="line">drwxr-xr-x@ 13 yukiyama  staff  416 Sep 29 16:21 .git</span><br><span class="line">-rw-r--r--   1 yukiyama  staff    3 Sep 29 15:34 1.txt</span><br><span class="line">-rw-r--r--   1 yukiyama  staff    2 Sep 29 16:21 2-1.txt</span><br><span class="line">-rw-r--r--   1 yukiyama  staff    4 Sep 29 16:21 2-2.txt</span><br><span class="line">-rw-r--r--   1 yukiyama  staff    4 Sep 29 16:21 3.txt</span><br><span class="line">-rw-r--r--   1 yukiyama  staff    4 Sep 29 15:35 4.txt</span><br><span class="line">yukiyama@yukiyama hello-git % git status</span><br><span class="line">On branch master</span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line">4.txt</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</span><br><span class="line">yukiyama@yukiyama hello-git % git ls-files</span><br><span class="line">1.txt</span><br><span class="line">2-1.txt</span><br><span class="line">2-2.txt</span><br><span class="line">3.txt</span><br><span class="line">yukiyama@yukiyama hello-git % git log --oneline</span><br><span class="line">23a6441 (HEAD -&gt; master) add 3.txt</span><br><span class="line">d3f6a97 add 2-1.txt 2-2.txt</span><br><span class="line">fc746eb add 1.txt</span><br><span class="line">yukiyama@yukiyama hello-git % git reflog</span><br><span class="line">23a6441 (HEAD -&gt; master) HEAD@&#123;0&#125;: reset: moving to 23a6441</span><br><span class="line">fc746eb HEAD@&#123;1&#125;: reset: moving to fc746eb</span><br><span class="line">23a6441 (HEAD -&gt; master) HEAD@&#123;2&#125;: reset: moving to 23a6441</span><br><span class="line">d3f6a97 HEAD@&#123;3&#125;: reset: moving to d3f6a97</span><br><span class="line">23a6441 (HEAD -&gt; master) HEAD@&#123;4&#125;: commit: add 3.txt</span><br><span class="line">d3f6a97 HEAD@&#123;5&#125;: commit: add 2-1.txt 2-2.txt</span><br><span class="line">fc746eb HEAD@&#123;6&#125;: commit (initial): add 1.txt</span><br><span class="line">yukiyama@yukiyama hello-git %</span><br></pre></td></tr></table></figure><br /><h2 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h2><p>分支本质上是指向提交对象的可变指针。</p><br /><h3 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h3><p>新建分支本质上是 git 创建了一个可以移动的指向当前提交对象的新指针。</p><p>使用 <code>git branch &lt;分支名&gt;</code> 创建分支。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama hello-git % git branch testing</span><br><span class="line">yukiyama@yukiyama hello-git % git branch -a</span><br><span class="line">* master</span><br><span class="line">  remote</span><br><span class="line">  testing</span><br><span class="line">  remotes/origin/master</span><br><span class="line">yukiyama@yukiyama hello-git %</span><br></pre></td></tr></table></figure><p>使用  <code>git branch -d &lt;分支名&gt;</code> 删除分支，执行 <code>git branch</code> 查看本地仓库分支列表， <code>*</code> 表示当前分支。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama hello-git % git branch -d testing</span><br><span class="line">Deleted branch testing (was 070472d).</span><br><span class="line">yukiyama@yukiyama hello-git % git branch</span><br><span class="line">* master</span><br><span class="line">  remote</span><br><span class="line">yukiyama@yukiyama hello-git %</span><br></pre></td></tr></table></figure><br /><h3 id="git-switch"><a href="#git-switch" class="headerlink" title="git switch"></a>git switch</h3><p>使用 <code>git switch &lt;分支名&gt;</code> 切换分支。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama hello-git % git branch testing</span><br><span class="line">yukiyama@yukiyama hello-git % git branch</span><br><span class="line">* master</span><br><span class="line">  testing</span><br><span class="line">yukiyama@yukiyama hello-git % git switch testing</span><br><span class="line">Switched to branch &#x27;testing&#x27;</span><br><span class="line">yukiyama@yukiyama hello-git % git status</span><br><span class="line">On branch testing</span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line">yukiyama@yukiyama hello-git % git switch -c fix</span><br><span class="line">Switched to a new branch &#x27;fix&#x27;</span><br><span class="line">yukiyama@yukiyama hello-git % git branch</span><br><span class="line">* fix</span><br><span class="line">  master</span><br><span class="line">  testing</span><br><span class="line">yukiyama@yukiyama hello-git %</span><br></pre></td></tr></table></figure><p>使用 <code>git switch -c &lt;分支名&gt;</code> 创建并切换分支。</p><br /><h3 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h3><p>使用 <code>git checkout &lt;分支名&gt;</code> 切换分支。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama hello-git % git checkout testing</span><br><span class="line">Switched to branch &#x27;testing&#x27;</span><br><span class="line">yukiyama@yukiyama hello-git % git status</span><br><span class="line">On branch testing</span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line">yukiyama@yukiyama hello-git %</span><br></pre></td></tr></table></figure><p>使用 <code>git checkout -b &lt;分支名&gt;</code> 创建并切换分支。</p><br /><h3 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a>git merge</h3><p><code>git merge &lt;分支名&gt;</code> 将指定分支合并到当前分支中。合并通常有「快进」和</p><p>新建并切换到 testing 分支后，在 testing 分支上完成若干次 commit，且 master 无新的 commit，此时切回 master 分支，并执行 <code>git merge</code> 将 testing 合并到当前分支中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama hello-git % git checkout master</span><br><span class="line">Switched to branch &#x27;master&#x27;</span><br><span class="line">Your branch is ahead of &#x27;origin/master&#x27; by 3 commits.</span><br><span class="line">  (use &quot;git push&quot; to publish your local commits)</span><br><span class="line">yukiyama@yukiyama hello-git % git merge testing</span><br><span class="line">Updating 44f99a2..b4552ad</span><br><span class="line">Fast-forward</span><br><span class="line"> hello.txt | 2 +-</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br><span class="line">yukiyama@yukiyama hello-git %</span><br></pre></td></tr></table></figure><p>由于 master 是 testing 的直接祖先，master 可顺着 testing 分支的历次 commit 直接到达当前 testing，此情况下的合并无需解决分歧，因此 master 可以「快进」直达 testing，而不会产生新的版本 (快照)，回显中的 <code>Fast-forwad</code> 反映了这一特点。</p><p>若从分歧点开始 master 和 testing 都各自前进了若干个 commit，则此时合并为「三方合并」。若产生冲突，则有如下提示。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama hello-git % git log --oneline --graph --all</span><br><span class="line">* 4a3e876 (HEAD -&gt; testing) testing 1</span><br><span class="line">| * b6c50b9 (master) master 1</span><br><span class="line">|/</span><br><span class="line">* b4552ad modified hello.txt 3</span><br><span class="line">...(略)...</span><br><span class="line">yukiyama@yukiyama hello-git % git merge testing</span><br><span class="line">Auto-merging hello.txt</span><br><span class="line">CONFLICT (content): Merge conflict in hello.txt</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br><span class="line">yukiyama@yukiyama hello-git %</span><br></pre></td></tr></table></figure><p>解决冲突后，执行 <code>git status</code> 可以看到 <code>All conflicts fixed but you are still merging.</code> ，即说明冲突已解决，根据提示再次提交即完成合并。与「快进」合并不同的是，「三方合并」会生成一个新的快照。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama hello-git % git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is ahead of &#x27;origin/master&#x27; by 7 commits.</span><br><span class="line">  (use &quot;git push&quot; to publish your local commits)</span><br><span class="line"></span><br><span class="line">All conflicts fixed but you are still merging.</span><br><span class="line">  (use &quot;git commit&quot; to conclude merge)</span><br><span class="line"></span><br><span class="line">yukiyama@yukiyama hello-git %</span><br><span class="line">yukiyama@yukiyama hello-git % git commit</span><br><span class="line">[master b8da922] Merge branch &#x27;testing&#x27;</span><br><span class="line">yukiyama@yukiyama hello-git % git log --oneline --graph --all</span><br><span class="line">*   b8da922 (HEAD -&gt; master) Merge branch &#x27;testing&#x27;</span><br><span class="line">|\</span><br><span class="line">| * 4a3e876 (testing) testing 1</span><br><span class="line">* | b6c50b9 master 1</span><br><span class="line">|/</span><br><span class="line">* b4552ad modified hello.txt 3</span><br><span class="line">...(略)...</span><br></pre></td></tr></table></figure><p>使用如下命令随时以图形形式查看不同分支的前进和合并过程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --oneline --decorate --graph --all</span><br></pre></td></tr></table></figure><br /><h3 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h3><p>两分支从分叉处开始各自有若干提交，合并这两个分支的另一种方式是 <code>git rebase</code> (变基)，与 <code>git merge</code> 执行「三方合并」不同的是，<code>git rebase</code> 会在当前分支下重放另一个分支在分叉处后的历次提交，最终得到一个新提交，结果与 <code>git merge</code> 相同，但提交历史更整洁，分支虽并行，但变基之后的提交历史是一条串行的直线。</p><p>当前分叉后 master 分支和 testing 分支各有一个提交版本。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama hello-git % git log --oneline --decorate --graph --all</span><br><span class="line">* e2f517c (HEAD -&gt; testing) testing modified 1</span><br><span class="line">| * ae47d2e (master) master modified 1</span><br><span class="line">| *   b8da922 Merge branch &#x27;testing&#x27;</span><br><span class="line">| |\</span><br><span class="line">| |/</span><br><span class="line">|/|</span><br><span class="line">* | 4a3e876 testing 1</span><br><span class="line">...(略)...</span><br></pre></td></tr></table></figure><p>切回 master ，执行变基，如下，有冲突，根据提示先解决冲突。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama hello-git % git checkout master</span><br><span class="line">Switched to branch &#x27;master&#x27;</span><br><span class="line">yukiyama@yukiyama hello-git % git rebase testing</span><br><span class="line">Auto-merging hello.txt</span><br><span class="line">CONFLICT (content): Merge conflict in hello.txt</span><br><span class="line">error: could not apply b6c50b9... master 1</span><br><span class="line">hint: Resolve all conflicts manually, mark them as resolved with</span><br><span class="line">hint: &quot;git add/rm &lt;conflicted_files&gt;&quot;, then run &quot;git rebase --continue&quot;.</span><br><span class="line">hint: You can instead skip this commit: run &quot;git rebase --skip&quot;.</span><br><span class="line">hint: To abort and get back to the state before &quot;git rebase&quot;, run &quot;git rebase --abort&quot;.</span><br><span class="line">Could not apply b6c50b9... master 1</span><br></pre></td></tr></table></figure><p>解决冲突后，对冲突文件执行 <code>git add</code> 后，再次执行变基 <code>git rebase --continue</code> 。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama hello-git % git rebase --continue</span><br><span class="line">Successfully rebased and updated refs/heads/master.</span><br><span class="line">yukiyama@yukiyama hello-git % git log --oneline --decorate --graph --all</span><br><span class="line">* e2f517c (HEAD -&gt; master, testing) testing modified 1</span><br><span class="line">* 4a3e876 testing 1</span><br><span class="line">...(略)...</span><br></pre></td></tr></table></figure><p>也可以直接执行 <code>git rebase &lt;basebranch&gt; &lt;topicbranch&gt;</code> 将 topicbranch 分叉后的修改在 basebranch 上重放，省去了 <code>git checkout</code> 切换到 basebranch 的操作。</p><p><strong>变基的原则</strong>：只对尚未推送的本地修改执行变基，而不对本地仓库外有副本的分支执行变基。</p><br /><h2 id="远程操作"><a href="#远程操作" class="headerlink" title="远程操作"></a>远程操作</h2><p>本地仓库与远程仓库之间建立关联的方式如下。</p><ul><li>方式一(本地到远程)：先建立本地仓库，然后将本地仓库推送到远程仓库。</li><li>方式二(远程到本地)：先建立远程仓库，然后在本地克隆远程仓库。</li></ul><br /><h3 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a>git remote</h3><p>实现从本地到远程的方式一，首先要使用 <code>git remote add &lt;仓库别名&gt; &lt;url/ssh&gt;</code> 关联本地仓库与远程 github 仓库。根据通信协议的不同，分为 https 方式和 ssh 方式。</p><br /><h4 id="https方式"><a href="#https方式" class="headerlink" title="https方式"></a>https方式</h4><p>【1. 关联本地仓库与远程仓库】</p><p>执行如下命令完成关联，并检查关联结果。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama git-demo % git remote add origin https://github.com/iyukiyama/git-demo.git</span><br><span class="line">yukiyama@yukiyama git-demo % git remote</span><br><span class="line">origin</span><br><span class="line">yukiyama@yukiyama git-demo % git remote -v</span><br><span class="line">originhttps://github.com/iyukiyama/git-demo.git (fetch)</span><br><span class="line">originhttps://github.com/iyukiyama/git-demo.git (push)</span><br><span class="line">yukiyama@yukiyama git-demo %</span><br></pre></td></tr></table></figure><br /><p>【2. 在 github 上创建远程仓库】</p><p>仓库名通常与本地仓库相同，但也可以不同。</p><br /><p>【3. 推送】</p><p>关联后执行 <code>git push -u origin master</code> 推送本地仓库到远程仓库中。其中 <code>-u</code> 参数是 <code>--set-upstream</code> 的缩略，使得当前本地分支 <code>master</code>  与远程仓库分支 <code>master</code> 关联起来，后续再推送，就只需要执行 <code>git push</code> 即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama git-demo % git push -u origin master</span><br><span class="line">Username for &#x27;https://github.com&#x27;: iyukiyama</span><br><span class="line">Password for &#x27;https://iyukiyama@github.com&#x27;:</span><br><span class="line">remote: Support for password authentication was removed on August 13, 2021.</span><br><span class="line">remote: Please see https://docs.github.com/en/get-started/getting-started-with-git/about-remote-repositories#cloning-with-https-urls for information on currently recommended modes of authentication.</span><br><span class="line">fatal: Authentication failed for &#x27;https://github.com/iyukiyama/git-demo.git/&#x27;</span><br><span class="line">yukiyama@yukiyama git-demo %</span><br></pre></td></tr></table></figure><p>注意，根据如上提示，github 从 2021年8月13日起，https 方式的接入校验不再支持使用 <strong>普通密码</strong> 的方式，目前支持使用 <strong>Personal Access Token</strong> 来完成认证，即 <code>Password for &#39;https://...&#39;</code> 处应当填写目标 github 账号的 Personal Access Token (PAT) ，设置方式在 <a href="https://docs.github.com/cn/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token">这里</a> 查看。</p><p>填入正确的 PAT 后即可成功推送，如下。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama git-demo % git push -u origin master</span><br><span class="line">Username for &#x27;https://github.com&#x27;: iyukiyama</span><br><span class="line">Password for &#x27;https://iyukiyama@github.com&#x27;:</span><br><span class="line">Enumerating objects: 57, done.</span><br><span class="line">Counting objects: 100% (57/57), done.</span><br><span class="line">Delta compression using up to 8 threads</span><br><span class="line">Compressing objects: 100% (37/37), done.</span><br><span class="line">Writing objects: 100% (57/57), 5.02 KiB | 642.00 KiB/s, done.</span><br><span class="line">Total 57 (delta 5), reused 0 (delta 0), pack-reused 0</span><br><span class="line">remote: Resolving deltas: 100% (5/5), done.</span><br><span class="line">To https://github.com/iyukiyama/git-demo.git</span><br><span class="line"> * [new branch]      master -&gt; master</span><br><span class="line">branch &#x27;master&#x27; set up to track &#x27;origin/master&#x27;.</span><br><span class="line">yukiyama@yukiyama git-demo %</span><br></pre></td></tr></table></figure><p>注意，如果没有事先在 github 上创建目标关联远程仓库的话，推送将会失败，并显示失败原因是找不到指定的远程仓库。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama git-demo % git push -u origin master</span><br><span class="line">remote: Repository not found.</span><br><span class="line">fatal: repository &#x27;https://github.com/iyukiyama/git-demo.git/&#x27; not found</span><br><span class="line">yukiyama@yukiyama git-demo</span><br></pre></td></tr></table></figure><br /><p>【4. 查看远程库信息】</p><p>执行 <code>git remote show origin</code> 查看远程库信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama hello-git % git remote show origin</span><br><span class="line">* remote origin</span><br><span class="line">  Fetch URL: https://github.com/iyukiyama/hello-git.git</span><br><span class="line">  Push  URL: https://github.com/iyukiyama/hello-git.git</span><br><span class="line">  HEAD branch: master</span><br><span class="line">  Remote branch:</span><br><span class="line">    master tracked</span><br><span class="line">  Local branch configured for &#x27;git pull&#x27;:</span><br><span class="line">    master merges with remote master</span><br><span class="line">  Local ref configured for &#x27;git push&#x27;:</span><br><span class="line">    master pushes to master (up to date)</span><br><span class="line">yukiyama@yukiyama hello-git %</span><br></pre></td></tr></table></figure><br /><h4 id="ssh方式"><a href="#ssh方式" class="headerlink" title="ssh方式"></a>ssh方式</h4><p>https 方式每次推送都需要认证，可以采用 ssh 方式约定本地仓库与远程仓库的公私钥，即可自动认证。</p><p>通常情况下客户端环境只需要一对公私钥建立到 github 远程库的 ssh 通信。若希望在同一个客户端下与多个 github 账号下的仓库建立 ssh 通信，则由于 github 不同账号下的公钥必须不同，相应地，在本地创建公私钥对时，也需要创建多对。</p><p>如下演示如何创建两对不同的公私钥，并应用到对不同的 github 账号的 ssh 连接中。</p><p>【1. ssh-keygen 命令生成公私钥对】</p><p>执行 <code>ssh-keygen -t rsa -C &quot;yuki.com&quot;</code> 命令生成公私钥对。<code>-t</code> 选择加密算法， <code>-C</code> 添加备注，习惯上会填写一个邮箱地址，也可以填写其他字符串。</p><table><thead><tr><th>设置</th><th>描述</th></tr></thead><tbody><tr><td>Enter file in which to save the key ()</td><td>括号后是默认公私钥路径和名称<br />私钥默认名: id_rsa<br />公钥默认名: id_rsa.pub</td></tr><tr><td>Enter passphrase</td><td>加密串，即 ssh 通信时的口令，通常不使用，回车即可</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama ~ % ssh-keygen -t rsa -C &quot;yuki.com&quot;</span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file in which to save the key (/Users/yukiyama/.ssh/id_rsa): /Users/yukiyama/.ssh/id_rsa_163</span><br><span class="line">Enter passphrase (empty for no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br><span class="line">Your identification has been saved in /Users/yukiyama/.ssh/id_rsa_163</span><br><span class="line">Your public key has been saved in /Users/yukiyama/.ssh/id_rsa_163.pub</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:rS6a3ou3HauNl0w+1Y5v6oTzbVo7xu/PKaOVIQbMCoI yuki.com</span><br><span class="line">The key&#x27;s randomart image is:</span><br><span class="line">+---[RSA 3072]----+</span><br><span class="line">|                 |</span><br><span class="line">|  .     o        |</span><br><span class="line">| E . .   +       |</span><br><span class="line">|    . . ...      |</span><br><span class="line">|       .S .+ .   |</span><br><span class="line">|        .oo o o  |</span><br><span class="line">|       +=o.+.o   |</span><br><span class="line">|     +o=**.oO+ ..|</span><br><span class="line">|   .=o**=o=O=+=oo|</span><br><span class="line">+----[SHA256]-----+</span><br><span class="line">yukiyama@yukiyama ~ % </span><br></pre></td></tr></table></figure><p>接着执行 <code>ssh-keygen -t rsa -C &quot;yama.com&quot;</code> 生成另一对公私钥对，在 <code>~/.ssh</code> 下可以看到如下两对公私钥对。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">id_rsa_163</span><br><span class="line">id_rsa_163.pub</span><br><span class="line">id_rsa_outlook</span><br><span class="line">id_rsa_outlook.pub</span><br></pre></td></tr></table></figure><p>【2. 在 <code>.ssh</code> 下创建 <code>config</code> 文件】</p><p>创建如下 <code>config</code> 文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># github-163</span><br><span class="line">Host github.com.163</span><br><span class="line">HostName github.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/id_rsa_163</span><br><span class="line"></span><br><span class="line"># github-outlook</span><br><span class="line">Host github.com.outlook</span><br><span class="line">HostName github.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/id_rsa_outlook</span><br></pre></td></tr></table></figure><p>后面我们会看到，将指定的公私钥对与指定的账户的 github 相关联的关键时 <code>Host</code> ，它是服务器端的别名，在使用 <code>git@&lt;host&gt;</code> 方式执行 ssh 连接时，<code>&lt;host&gt;</code> 填入的即 <code>Host</code> 。</p><p><code>Host</code> 与 <code>IdentityFile</code> 决定了公私钥对与具体账户的对应 (该账户下用公钥与 <code>IdentifyFile</code> 中指定的一样) ，而实际上会连接 <code>Hostname</code> 。</p><p>【3. 将公钥添加对应的 github 账户中】</p><p>在 github 的 <code>setting &gt; SSH and GPG keys &gt; SSH keys</code> 中点击 <code>New SSH key</code> 添加。</p><p>使用 <code>ssh -T git@github.com.outlook</code> 命令测试 ssh 连接，出现如下提示即说明可通过 ssh 方式通信。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama hello-git % ssh -T git@github.com.outlook</span><br><span class="line">Hi iyukiyama! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span><br><span class="line">yukiyama@yukiyama hello-git %</span><br></pre></td></tr></table></figure><p>【4. 关联本地仓库与远程仓库】</p><p>使用 <code>git remote add</code> 命令关联本地仓库与远程仓库。若当前存在 https 方式的关联，先执行 <code>git remote rm origin</code> 删除。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama hello-git % git remote add origin git@github.com.outlook:iyukiyama/hello-git.git</span><br><span class="line">yukiyama@yukiyama hello-git % git remote -v</span><br><span class="line">origingit@github.com.outlook:iyukiyama/hello-git.git (fetch)</span><br><span class="line">origingit@github.com.outlook:iyukiyama/hello-git.git (push)</span><br></pre></td></tr></table></figure><p>【5. 推送】</p><p>与 https 方式一样，推送前也要提前在 github 中创建好目标远程仓库，否则会报如下错 <code>ERROR: Repository not found.</code> 。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama hello-git % git push -u origin master</span><br><span class="line">ERROR: Repository not found.</span><br><span class="line">fatal: Could not read from remote repository.</span><br></pre></td></tr></table></figure><p>创建后再次推送成功，远程库中也出现了本地库推送的文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama hello-git % git push -u origin master</span><br><span class="line">Enumerating objects: 57, done.</span><br><span class="line">Counting objects: 100% (57/57), done.</span><br><span class="line">Delta compression using up to 8 threads</span><br><span class="line">Compressing objects: 100% (32/32), done.</span><br><span class="line">Writing objects: 100% (57/57), 5.02 KiB | 5.02 MiB/s, done.</span><br><span class="line">Total 57 (delta 5), reused 57 (delta 5), pack-reused 0</span><br><span class="line">remote: Resolving deltas: 100% (5/5), done.</span><br><span class="line">To github.com.outlook:iyukiyama/hello-git.git</span><br><span class="line"> * [new branch]      master -&gt; master</span><br><span class="line">branch &#x27;master&#x27; set up to track &#x27;origin/master&#x27;.</span><br><span class="line">yukiyama@yukiyama hello-git %</span><br></pre></td></tr></table></figure><p>【6. 查看远程库信息】</p><p>执行 <code>git remote show origin</code> 查看远程库信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama hello-git % git remote show origin</span><br><span class="line">* remote origin</span><br><span class="line">  Fetch URL: git@github.com.outlook:iyukiyama/hello-git.git</span><br><span class="line">  Push  URL: git@github.com.outlook:iyukiyama/hello-git.git</span><br><span class="line">  HEAD branch: master</span><br><span class="line">  Remote branch:</span><br><span class="line">    master tracked</span><br><span class="line">  Local branch configured for &#x27;git pull&#x27;:</span><br><span class="line">    master merges with remote master</span><br><span class="line">  Local ref configured for &#x27;git push&#x27;:</span><br><span class="line">    master pushes to master (up to date)</span><br><span class="line">yukiyama@yukiyama hello-git %</span><br></pre></td></tr></table></figure><br /><h4 id="rename"><a href="#rename" class="headerlink" title="rename"></a>rename</h4><p>可以通过 <code>git remote rename &lt;当前别名&gt; &lt;新别名&gt;</code> 来修改远程仓库地址别名。下面是一些修改后的操作，可以看到远程仓库地址别名已经变为 <code>main</code> ，原先的 <code>origin</code> 已不可用，且远程仓库分支也相应变为 <code>main/master</code> 。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama hello-git % git remote rename origin main</span><br><span class="line">Renaming remote references: 100% (1/1), done.</span><br><span class="line">yukiyama@yukiyama hello-git % git remote</span><br><span class="line">main</span><br><span class="line">yukiyama@yukiyama hello-git % git remote -v</span><br><span class="line">maingit@github.com.outlook:iyukiyama/hello-git.git (fetch)</span><br><span class="line">maingit@github.com.outlook:iyukiyama/hello-git.git (push)</span><br><span class="line">yukiyama@yukiyama hello-git % git branch -r</span><br><span class="line">  main/master</span><br><span class="line">yukiyama@yukiyama hello-git % git branch -a</span><br><span class="line">* master</span><br><span class="line">  remote</span><br><span class="line">  remotes/main/master</span><br><span class="line">yukiyama@yukiyama hello-git % git push</span><br><span class="line">Everything up-to-date</span><br><span class="line">yukiyama@yukiyama hello-git % git push main master</span><br><span class="line">Everything up-to-date</span><br><span class="line">yukiyama@yukiyama hello-git % git remote show origin</span><br><span class="line">fatal: &#x27;origin&#x27; does not appear to be a git repository</span><br><span class="line">fatal: Could not read from remote repository.</span><br><span class="line"></span><br><span class="line">Please make sure you have the correct access rights</span><br><span class="line">and the repository exists.</span><br><span class="line">yukiyama@yukiyama hello-git % git remote show main</span><br><span class="line">* remote main</span><br><span class="line">  Fetch URL: git@github.com.outlook:iyukiyama/hello-git.git</span><br><span class="line">  Push  URL: git@github.com.outlook:iyukiyama/hello-git.git</span><br><span class="line">  HEAD branch: master</span><br><span class="line">  Remote branch:</span><br><span class="line">    master tracked</span><br><span class="line">  Local branch configured for &#x27;git pull&#x27;:</span><br><span class="line">    master merges with remote master</span><br><span class="line">  Local ref configured for &#x27;git push&#x27;:</span><br><span class="line">    master pushes to master (up to date)</span><br><span class="line">yukiyama@yukiyama hello-git % git reflog main/master</span><br><span class="line">be33e38 (HEAD -&gt; master, main/master) refs/remotes/main/master@&#123;0&#125;: remote: renamed refs/remotes/origin/master to refs/remotes/main/master</span><br><span class="line">be33e38 (HEAD -&gt; master, main/master) refs/remotes/main/master@&#123;1&#125;: update by push</span><br><span class="line">ad50bf4 refs/remotes/main/master@&#123;2&#125;: fetch: fast-forward</span><br><span class="line">edf13a1 refs/remotes/main/master@&#123;3&#125;: fetch: fast-forward</span><br><span class="line">b0c4efa (remote) refs/remotes/main/master@&#123;4&#125;: update by push</span><br><span class="line">de2bb32 refs/remotes/main/master@&#123;5&#125;: fetch: fast-forward</span><br><span class="line">a343286 refs/remotes/main/master@&#123;6&#125;: update by push</span><br><span class="line">eeeea6f refs/remotes/main/master@&#123;7&#125;: pull: fast-forward</span><br><span class="line">2464feb refs/remotes/main/master@&#123;8&#125;: update by push</span><br><span class="line">yukiyama@yukiyama hello-git %</span><br></pre></td></tr></table></figure><br /><h4 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h4><p>使用 <code>git remote remove &lt;远程仓库地址别名&gt;</code> 来解除本地仓库与远程仓库的关联。<code>remove</code> 也可以简写为 <code>rm</code> 。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama hello-git % git remote remove main</span><br><span class="line">yukiyama@yukiyama hello-git % git remote</span><br><span class="line">yukiyama@yukiyama hello-git % git branch -r</span><br><span class="line">yukiyama@yukiyama hello-git % git reflog main/master</span><br><span class="line">fatal: ambiguous argument &#x27;main/master&#x27;: unknown revision or path not in the working tree.</span><br><span class="line">Use &#x27;--&#x27; to separate paths from revisions, like this:</span><br><span class="line">&#x27;git &lt;command&gt; [&lt;revision&gt;...] -- [&lt;file&gt;...]&#x27;</span><br><span class="line">yukiyama@yukiyama hello-git %</span><br></pre></td></tr></table></figure><br /><h3 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h3><p>使用 <code>git clone</code> 命令将远程仓库克隆到当前本地目录下。可以看到该命令将远程仓库拉取到当前路径下 (即相当于下载了 hello-git) ，并且完成了 <code>git init</code> 管理已经下载到本地的 <code>hello-git</code> (有 <code>.git</code> 隐藏文件夹)，也完成了 <code>git remote add</code> 关联，并且远程仓库地址也已简写也已自动设置为 <code>origin</code> 。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama git % git clone https://github.com/iyukiyama/hello-git.git</span><br><span class="line">Cloning into &#x27;hello-git&#x27;...</span><br><span class="line">remote: Enumerating objects: 57, done.</span><br><span class="line">remote: Counting objects: 100% (57/57), done.</span><br><span class="line">remote: Compressing objects: 100% (32/32), done.</span><br><span class="line">remote: Total 57 (delta 5), reused 57 (delta 5), pack-reused 0</span><br><span class="line">Receiving objects: 100% (57/57), 5.02 KiB | 733.00 KiB/s, done.</span><br><span class="line">Resolving deltas: 100% (5/5), done.</span><br><span class="line">yukiyama@yukiyama git % cd hello-git</span><br><span class="line">yukiyama@yukiyama hello-git % ls -la</span><br><span class="line">total 24</span><br><span class="line">drwxr-xr-x@  5 yukiyama  staff   160 Sep 27 05:53 .</span><br><span class="line">drwxr-xr-x@ 10 yukiyama  staff   320 Sep 27 05:53 ..</span><br><span class="line">-rw-r--r--   1 yukiyama  staff  6148 Sep 27 05:53 .DS_Store</span><br><span class="line">drwxr-xr-x@ 12 yukiyama  staff   384 Sep 27 05:53 .git</span><br><span class="line">-rw-r--r--   1 yukiyama  staff    31 Sep 27 05:53 hello.txt</span><br><span class="line">yukiyama@yukiyama hello-git % git remote -v</span><br><span class="line">originhttps://github.com/iyukiyama/hello-git.git (fetch)</span><br><span class="line">originhttps://github.com/iyukiyama/hello-git.git (push)</span><br><span class="line">yukiyama@yukiyama hello-git %</span><br></pre></td></tr></table></figure><br /><h3 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h3><p>执行 <code>git push &lt;远程仓库地址&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</code> 推送当前仓库到远程库。</p><ul><li>远程仓库地址在 <code>git remote add</code> 命令中已经设置了 <code>origin</code> 别名，因此可以填入 <code>origin</code> 。</li><li>当「本地分支名」与「远程分支名」相同时，本例中为 <code>master</code> ，可以写为 <code>git push origin master</code> 。</li><li>在第一次推送时，我们使用了 <code>-u</code> 参数指定了本地分支到指定远程分支的通道 (master -&gt; master) 。因此可以直接执行 <code>git push</code> ，效果等同如下。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push git@github.com.outlook:iyukiyama/hello-git.git master:master</span><br></pre></td></tr></table></figure><p>如果本地仓库当前分支比远程分支要落后，例如远程分支上的文件有更新，本地在尚未拉取合并该更新的情况下尝试推送本地的新提交，则会出现失败，如下。可以使用 <code>git pull</code> 先行拉取合并，或者执行 <code>git merger &lt;远程仓库地址&gt;/&lt;远程分支&gt;</code> 来将「本地的远程分支」合并到本地当前分支。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">To github.com.outlook:iyukiyama/hello-git.git</span><br><span class="line"> ! [rejected]        master -&gt; master (non-fast-forward)</span><br><span class="line">error: failed to push some refs to &#x27;github.com.outlook:iyukiyama/hello-git.git&#x27;</span><br><span class="line">hint: Updates were rejected because the tip of your current branch is behind</span><br><span class="line">hint: its remote counterpart. Integrate the remote changes (e.g.</span><br><span class="line">hint: &#x27;git pull ...&#x27;) before pushing again.</span><br><span class="line">hint: See the &#x27;Note about fast-forwards&#x27; in &#x27;git push --help&#x27; for details.</span><br><span class="line">yukiyama@yukiyama hello-git %</span><br></pre></td></tr></table></figure><p>如果本地和远程分支是同一个版本，即无更新，则推送后显示 <code>Everything up-to-date</code> 。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama hello-git % git push</span><br><span class="line">Everything up-to-date</span><br></pre></td></tr></table></figure><p>若有更新，且正常推送，则显示如下。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama hello-git % git push</span><br><span class="line">Enumerating objects: 5, done.</span><br><span class="line">Counting objects: 100% (5/5), done.</span><br><span class="line">Delta compression using up to 8 threads</span><br><span class="line">Compressing objects: 100% (3/3), done.</span><br><span class="line">Writing objects: 100% (3/3), 312 bytes | 312.00 KiB/s, done.</span><br><span class="line">Total 3 (delta 0), reused 0 (delta 0), pack-reused 0</span><br><span class="line">To github.com.outlook:iyukiyama/hello-git.git</span><br><span class="line">   eeeea6f..a343286  master -&gt; master</span><br><span class="line">yukiyama@yukiyama hello-git %</span><br></pre></td></tr></table></figure><br /><h3 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h3><p>将远程库当前版本拉取到本地，但不合并 (<code>git merge</code>) 。若本地分支与远程分支版本相同，则无回显，若不同，则如下。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama hello-git % git fetch</span><br><span class="line">remote: Enumerating objects: 5, done.</span><br><span class="line">remote: Counting objects: 100% (5/5), done.</span><br><span class="line">remote: Compressing objects: 100% (3/3), done.</span><br><span class="line">remote: Total 3 (delta 1), reused 0 (delta 0), pack-reused 0</span><br><span class="line">Unpacking objects: 100% (3/3), 683 bytes | 170.00 KiB/s, done.</span><br><span class="line">From github.com.outlook:iyukiyama/hello-git</span><br><span class="line">   edf13a1..ad50bf4  master     -&gt; origin/master</span><br><span class="line">yukiyama@yukiyama hello-git %</span><br></pre></td></tr></table></figure><p>可通过 <code>git log origin/master</code> 或 <code>git reflog origin/master</code> 查看本地的远程分支提交历史来确认确实拉取了远程分支当前版本。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama hello-git % git reflog origin/master</span><br><span class="line">ad50bf4 (origin/master) refs/remotes/origin/master@&#123;0&#125;: fetch: fast-forward</span><br><span class="line">edf13a1 (HEAD -&gt; master) refs/remotes/origin/master@&#123;1&#125;: fetch: fast-forward</span><br><span class="line">b0c4efa (remote) refs/remotes/origin/master@&#123;2&#125;: update by push</span><br><span class="line">de2bb32 refs/remotes/origin/master@&#123;3&#125;: fetch: fast-forward</span><br><span class="line">a343286 refs/remotes/origin/master@&#123;4&#125;: update by push</span><br><span class="line">eeeea6f refs/remotes/origin/master@&#123;5&#125;: pull: fast-forward</span><br><span class="line">2464feb refs/remotes/origin/master@&#123;6&#125;: update by push</span><br><span class="line">yukiyama@yukiyama hello-git %</span><br></pre></td></tr></table></figure><p>可通过 <code>git branch -a</code> 查看本地和远程分支，或者通过 <code>git branch -r</code> 查看远程分支。</p><br /><h3 id="git-merge-1"><a href="#git-merge-1" class="headerlink" title="git merge"></a>git merge</h3><p><code>git fetch</code> 之后要通过 <code>git merge</code> 将远程分支合并到本地分支，相当于 <code>git merge origin/master</code> 。从回显中还能看到这是一次「快进」 (Fast-forward) 合并。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama hello-git % git merge</span><br><span class="line">Updating b0c4efa..edf13a1</span><br><span class="line">Fast-forward</span><br><span class="line"> hello.txt | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line">yukiyama@yukiyama hello-git %</span><br></pre></td></tr></table></figure><br /><h3 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h3><p>将远程库当前版本拉取到本地并合并 (<code>git merge</code>) 。格式如下。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull &lt;远程仓库别名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span><br></pre></td></tr></table></figure><p>若远程分支名与本地分支名相同，可简写如下。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull &lt;远程仓库别名&gt; &lt;分支名&gt;</span><br></pre></td></tr></table></figure><p>若已经配置过 upstream ，可简写如下。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure><p>若版本相同，则显示 <code>Already up to date.</code> 。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama hello-git % git pull</span><br><span class="line">Already up to date.</span><br><span class="line">yukiyama@yukiyama hello-git %</span><br></pre></td></tr></table></figure><p>若有冲突，则显示如下。此时需要先解决冲突，接着 <code>git add</code>, <code>git commit</code> ，然后再 <code>git pull</code> 。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama hello-git % git pull</span><br><span class="line">error: Pulling is not possible because you have unmerged files.</span><br><span class="line">hint: Fix them up in the work tree, and then use &#x27;git add/rm &lt;file&gt;&#x27;</span><br><span class="line">hint: as appropriate to mark resolution and make a commit.</span><br><span class="line">fatal: Exiting because of an unresolved conflict.</span><br><span class="line">yukiyama@yukiyama hello-git %</span><br></pre></td></tr></table></figure><p>若拉取后可正常合并，则显示如下。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama hello-git % git pull</span><br><span class="line">remote: Enumerating objects: 5, done.</span><br><span class="line">remote: Counting objects: 100% (5/5), done.</span><br><span class="line">remote: Compressing objects: 100% (2/2), done.</span><br><span class="line">remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0</span><br><span class="line">Unpacking objects: 100% (3/3), 686 bytes | 171.00 KiB/s, done.</span><br><span class="line">From github.com.outlook:iyukiyama/hello-git</span><br><span class="line">   2464feb..eeeea6f  master     -&gt; origin/master</span><br><span class="line">Updating 2464feb..eeeea6f</span><br><span class="line">Fast-forward</span><br><span class="line"> hello.txt | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line">yukiyama@yukiyama hello-git %</span><br></pre></td></tr></table></figure><p>使用 <code>git fetch</code> 是更好的实践 (<a href="https://www.oschina.net/translate/git-fetch-and-merge?print">参考</a>) 。</p><br /><h2 id="IDEA-Git"><a href="#IDEA-Git" class="headerlink" title="IDEA Git"></a>IDEA Git</h2><p>在 idea 上使用 git。</p><h3 id="集成Git"><a href="#集成Git" class="headerlink" title="集成Git"></a>集成Git</h3><h4 id="添加Git"><a href="#添加Git" class="headerlink" title="添加Git"></a>添加Git</h4><p>在 IntellJ IDEA &gt; Preferences &gt; Version Control &gt; Git 中设置 git 执行文件路径 <code>Path to Git executable</code> 。例如 &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;git&#x2F;2.37.3.bin&#x2F;git 。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/git_in_action/idea-set-git.png" alt="idea-set-git"></p><br /><h4 id="git-init-1"><a href="#git-init-1" class="headerlink" title="git init"></a>git init</h4><p>点击 VCS &gt; Create Git Repository ，选择项目根目录，即可将项目根目录作为本地 git 仓库 (即 idea 在该目录下创建了 <code>.git</code> 文件夹)。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/git_in_action/idea-git-init.png" alt="idea-git-init"></p><br /><h4 id="gitignore"><a href="#gitignore" class="headerlink" title=".gitignore"></a>.gitignore</h4><p>在项目根目录下创建 <code>.gitignore</code> 文件，设置忽略文件和忽略文件夹。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/git_in_action/idea-gitignore.png" alt="idea-gitignore"></p><p>可以手动编辑该文件，也可以选中希望忽略的文件或文件夹，右键选择 Git &gt; Add to .gitignore &gt; .gitignore ，则选中的文件或文件夹会自动配置到 <code>.gitignore</code> 文件中。</p><br /><h4 id="git-add-1"><a href="#git-add-1" class="headerlink" title="git add"></a>git add</h4><p>选中希望加入到暂存区的文件或文件夹 (如项目根文件夹)，右键 Git &gt; Add ，即可将已追踪的已修改状态的文件加入到暂存区中。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/git_in_action/idea-git-add.png" alt="idea-git-add"></p><br /><h4 id="git-commit-1"><a href="#git-commit-1" class="headerlink" title="git commit"></a>git commit</h4><p>选中要提交的文件或文件夹 (如项目根文件夹)，右键 Git &gt; Commit Directory ，即可提交暂存区中对应的文件 (见上一张图，Add 的上一条菜单即为 Commit Directory) 。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/git_in_action/idea-git-commit.png" alt="idea-git-commit"></p><br /><h4 id="git-reset-–soft-1"><a href="#git-reset-–soft-1" class="headerlink" title="git reset –soft"></a>git reset –soft</h4><p>左下角 <code>Git</code> 栏目中的 <code>Log</code> 页签下，选择需要切换的版本，右键 <code>Checkout Revision &lt;commit id&gt;</code> 即可移动 <code>HEAD</code> 指针到该提交版本，等同于命令行 <code>git reset --soft</code> 。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/git_in_action/idea-git-reset-soft.png" alt="idea-git-reset-soft"></p><br /><h4 id="git-branch-1"><a href="#git-branch-1" class="headerlink" title="git branch"></a>git branch</h4><p>右键 Git &gt; Branches 或者点击页面右下角当前分支栏目，例如 <code>master</code> ，可以看到一些分支操作的选项。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/git_in_action/idea-git-branch.png" alt="idea-git-branch"></p><br /><h4 id="git-switch-1"><a href="#git-switch-1" class="headerlink" title="git switch"></a>git switch</h4><p>通过 New Branch 创建新分支后，上述弹窗界面会多出该分支的菜单选项。例如创建一个 <code>hotfix</code> 分支，进行若改修并提交后，选择 master &gt; checkout 切回 <code>master</code> 分支。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/git_in_action/idea-git-switch.png" alt="idea-git-switch"></p><br /><h4 id="git-merge-2"><a href="#git-merge-2" class="headerlink" title="git merge"></a>git merge</h4><p>再次打开 Branches 界面，选择 hotfix &gt; Merge “hotfix” into “master” 完成合并。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/git_in_action/idea-git-merge.png" alt="idea-git-merge"></p><p>可以看到完成合并后 <code>HEAD</code>, <code>master</code>, <code>hotfix</code> 指针都指向当前最新版本。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/git_in_action/idea-after-merge.png" alt="idea-after-merge"></p><p>若出现冲突，则弹出「Conflicts」界面，点击「Merge…」解决冲突。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/git_in_action/idea-merge-conflicts.png" alt="idea-merge-conflicts"></p><p>在如下冲突解决界面中解决冲突。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/git_in_action/idea-conflicts-detail.png" alt="idea-conflicts-detail"></p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/git_in_action/idea-solve-conflicts.png" alt="idea-solve-conflicts"></p><p>解决冲突后。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/git_in_action/idea-solved-conflicts.png" alt="idea-solved-conflicts"></p><br /><h3 id="集成Github"><a href="#集成Github" class="headerlink" title="集成Github"></a>集成Github</h3><h4 id="添加github账号"><a href="#添加github账号" class="headerlink" title="添加github账号"></a>添加github账号</h4><p>在 IntellJ IDEA &gt; Preferences &gt; Version Control &gt; Github 中添加 Github 账号。「Log in via GitHub… 」方式是通过账号密码方式登陆，「Log in with Token…」 是通过 Token 方式登陆。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/git_in_action/idea-add-github.png" alt="idea-add-github"></p><p>若选择通过账号密码方式登陆，则弹出认证界面，点击「Authorize in GitHub」 在 GitHub 关联第三方的界面中完成认证即可。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/git_in_action/idea-login-github-acc-pw.png" alt="idea-login-github-acc-pw"></p><p>若选择 Token 方式，则需要填写已经在 Github 账户中生成过的 Token 。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/git_in_action/idea-login-github-token.png" alt="idea-login-github-token"></p><p>完成登陆后。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/git_in_action/idea-logined-github.png" alt="idea-logined-github"></p><br /><h4 id="首次推送"><a href="#首次推送" class="headerlink" title="首次推送"></a>首次推送</h4><p>在登陆 Github 的状态下，一级菜单栏中的 VCS 变为了 Git ，点击 Git &gt; Github &gt; Share Project on GitHub 将所选项目关联并推送到远程 Github 仓库。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/git_in_action/idea-share-to-github.png" alt="idea-share-to-github"></p><p>设置仓库名称，远程仓库别名，仓库描述，以及选择是否设置为私有仓库 (Private) 后，点击「Share」完成推送。</p><p>需要注意的是，使用命令行完成本地仓库和远程仓库的关联操作时，必须先在 Github 个人页面中创建好远程仓库，否则推送失败。但是在 idea 中首次推送时，远程仓库可不必提前创建，若无远程仓库，则 idea 会帮我们创建和关联远程仓库，并完成首次推送。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/git_in_action/idea-share-to-github-init.png" alt="idea-share-to-github-init"></p><br /><h4 id="git-push-1"><a href="#git-push-1" class="headerlink" title="git push"></a>git push</h4><p>通过 Git &gt; Push 菜单推送当前版本到远程仓库。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/git_in_action/idea-git-push.png" alt="idea-git-push"></p><p>在 「Push Commits to xxx」 界面中确认推送的本地分支和远程分支以及推送内容，点击「Push」完成推送。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/git_in_action/idea-git-push-confirm.png" alt="idea-git-push-confirm"></p><br /><h4 id="git-fetch-1"><a href="#git-fetch-1" class="headerlink" title="git fetch"></a>git fetch</h4><p>通过 Git &gt; Push 菜单抓取 (fetch) 远程仓库到本地 (但不合并)。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/git_in_action/idea-git-fetch-finished.png" alt="idea-git-fetch"></p><br /><h4 id="git-merge-3"><a href="#git-merge-3" class="headerlink" title="git merge"></a>git merge</h4><p>Fetch 之后通过 Git &gt; Merge 菜单完成合并。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/git_in_action/idea-git-merge2.png" alt="idea-git-merge2"></p><br /><h4 id="git-pull-1"><a href="#git-pull-1" class="headerlink" title="git pull"></a>git pull</h4><p>通过 Git &gt; Pull 菜单拉取 (pull) 远程仓库到本地 (并完成合并) 。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/git_in_action/idea-git-pull.png" alt="idea-git-pull"></p><p>若有冲突，则需像之前介绍的那样，先解决冲突。</p><br /><h4 id="git-clone-1"><a href="#git-clone-1" class="headerlink" title="git clone"></a>git clone</h4><p>通过 File &gt; New &gt; Project from Version Control.. 或者在打开 idea 时选择 「Get from VCS」 来克隆远程仓库到本地。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/git_in_action/idea-project-from-vcs.png" alt="idea-project-from-vcs"></p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/git_in_action/idea-get-from-vcs.png" alt="idea-get-from-vcs"></p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/git_in_action/idea-get-from-vcs-select.png" alt="idea-get-from-vcs-select"></p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/git_in_action/idea-clone-finished.png" alt="idea-clone-finished"></p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/git_in_action/git-cloned-project.png" alt="git-cloned-project"></p><br />]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaWeb学习实战</title>
      <link href="/2022/08/31/JavaWeb%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98_yukiyama/"/>
      <url>/2022/08/31/JavaWeb%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98_yukiyama/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaWeb学习实战-yukiyama"><a href="#JavaWeb学习实战-yukiyama" class="headerlink" title="JavaWeb学习实战_yukiyama"></a>JavaWeb学习实战_yukiyama</h1><blockquote><p>学习自: <a href="https://www.bilibili.com/video/BV1AS4y177xJ/?spm_id_from=333.999.0.0&vd_source=c56ec421dded765a52ade50885eaab60">尚硅谷丨2022版JavaWeb教程(全新技术栈,全程实战)</a>， <a href="https://heavy_code_industry.gitee.io/code_heavy_industry/pro001-javaweb/lecture/">配套文档</a>。</p><p>本文是基于上述视频教程和视频配套文档的文字总结，本文所有代码及其他实验演示素材均存放于 <a href="https://github.com/iyukiyama/javaweb_in_action">javaweb_in_action</a> 仓库中。</p><p>建议先克隆该仓库到本地，一边阅读本文，一边对照每一个工程代码进行学习。</p></blockquote><p>JavaWeb 一般指使用 Java 开发 Web 服务的 <strong>技术栈</strong>。</p><p>所谓「Web 服务」即泛指客户端以 HTTP&#x2F;HTTPS 协议与服务端通信以获得服务端提供的服务。服务的形式是多样的，例如搜索信息服务 (百度)、资料存储服务 (网盘)、网购服务 (淘宝) 、影音娱乐资源 (音乐视频网站) 等等。无论具体的服务形式为何，交互的方式都是类似的，即通常由浏览器 (客户端) 发起请求，由服务提供商的服务器 (服务端) 处理请求，或返回相应的数据、资源，或处理计算，或存储数据等等，这种交互形式通常称为 Browser&#x2F;Server (BS) 架构。</p><p>当采用 Java 来实现 Web 服务时，所涉及的技术即可统称为 JavaWeb 技术，包括但不限于 <strong>Web 服务器 (如 Tomcat)</strong> 、<strong>Servlet</strong> 、<strong>JSP</strong> 、<strong>HTTP协议</strong> 、<strong>框架 (如 SpringMVC)</strong> 等等。</p><p>以在浏览器上输入 <code>http://www.baidu.com</code> 访问百度为例，概述最简单的 Web 服务场景：</p><blockquote><p>从客户端浏览器发出的请求，通过 URL ，找到提供百度首页的服务器 (略过包封装、ARP、路由、DNS等底层过程)。该服务器针对请求，返回百度首页资源 (页面) 给浏览器，浏览器解析后呈现首页搜索框等元素。</p></blockquote><p>本文后续内容，我们将以 Servlet 技术为重点，讲解 JavaWeb 相关技术，展示包括客户端浏览器发起请求，服务器响应请求，服务器与数据库交互等过程及其代码实现。</p><br /><h2 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h2><p><a href="https://tomcat.apache.org/">Tomcat</a> 是 Apache 开源基金会维护的项目，该项目提供支持 jsp 和 Servlet 的轻量级的 <a href="https://en.wikipedia.org/wiki/Web_server">Web 服务器</a> (即 Tomcat Server)。Tomcat Server 是当前最流行的 Web 服务器之一。</p><br /><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>通过 <a href="https://tomcat.apache.org/">tomcat官网</a> 首页左侧导航栏找到需要的 Tomcat 版本，下载解压即可。如下一般选择 zip 或 tar.gz 下载到本地解压即完成安装 (绿色安装)。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/javaweb_in_action/tomcat-download.png" alt="tomcat-download"></p><p>解压后根目录 (如 <code>apache-tomcat-8.5.82</code>) 下的主要子目录及其存放内容如下。</p><table><thead><tr><th>子目录</th><th>存放内容</th></tr></thead><tbody><tr><td>bin</td><td>存放 Tomcat 的可执行程序</td></tr><tr><td>conf</td><td>存放 Tomcat 的配置文件</td></tr><tr><td>lib</td><td>存放 Tomcat 用到的 jar 包</td></tr><tr><td>logs</td><td>存放 Tomcat 运行时的日志</td></tr><tr><td>temp</td><td>存放 Tomcat 运行时产生的临时数据</td></tr><tr><td>webapps</td><td>存放部署到 Tomcat 的 Web 工程</td></tr><tr><td>work</td><td>Tomcat 工作时的目录</td></tr></tbody></table><p>bin 目录下的 <code>startup.sh</code> 和 <code>shutdown.sh</code> 分别为 (MacOS 和 Linux) 启动和关闭 Tomcat 的脚本 (若为 Windows 系统，则为 <code>startup.bat</code> 和 <code>shutdown.bat</code> ) 。执行相应的文件即可启动或关闭 Tomcat 服务器。例如 MacOS 上在启动脚本目录下执行 <code>./startup.sh</code> 启动 Tomcat 服务器如下。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama bin % pwd</span><br><span class="line">/Users/yukiyama/apache-tomcat-8.5.82/bin</span><br><span class="line">yukiyama@yukiyama bin % ./startup.sh</span><br><span class="line">Using CATALINA_BASE:   /Users/yukiyama/apache-tomcat-8.5.82</span><br><span class="line">Using CATALINA_HOME:   /Users/yukiyama/apache-tomcat-8.5.82</span><br><span class="line">Using CATALINA_TMPDIR: /Users/yukiyama/apache-tomcat-8.5.82/temp</span><br><span class="line">Using JRE_HOME:        /Library/Java/JavaVirtualMachines/jdk-16.0.1.jdk/Contents/Home</span><br><span class="line">Using CLASSPATH:       /Users/yukiyama/apache-tomcat-8.5.82/bin/bootstrap.jar:/Users/yukiyama/apache-tomcat-8.5.82/bin/tomcat-juli.jar</span><br><span class="line">Using CATALINA_OPTS:</span><br><span class="line">Tomcat started.</span><br><span class="line">yukiyama@yukiyama bin %</span><br></pre></td></tr></table></figure><p>出现 <code>Tomcat started</code> 表示启动成功，此时访问 <code>http://localhost:8080/</code> ，可打开如下页面。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/javaweb_in_action/startup-webpage.png" alt="startup-webpage"></p><p>执行 <code>./shutdown.sh</code> 可停止 Tomcat 服务器。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama bin % ./shutdown.sh</span><br><span class="line">Using CATALINA_BASE:   /Users/yukiyama/apache-tomcat-8.5.82</span><br><span class="line">Using CATALINA_HOME:   /Users/yukiyama/apache-tomcat-8.5.82</span><br><span class="line">Using CATALINA_TMPDIR: /Users/yukiyama/apache-tomcat-8.5.82/temp</span><br><span class="line">Using JRE_HOME:        /Library/Java/JavaVirtualMachines/jdk-16.0.1.jdk/Contents/Home</span><br><span class="line">Using CLASSPATH:       /Users/yukiyama/apache-tomcat-8.5.82/bin/bootstrap.jar:/Users/yukiyama/apache-tomcat-8.5.82/bin/tomcat-juli.jar</span><br><span class="line">Using CATALINA_OPTS:</span><br><span class="line">NOTE: Picked up JDK_JAVA_OPTIONS:  --add-opens=java.base/java.lang=ALL-UNNAMED --add-opens=java.base/java.io=ALL-UNNAMED --add-opens=java.base/java.util=ALL-UNNAMED --add-opens=java.base/java.util.concurrent=ALL-UNNAMED --add-opens=java.rmi/sun.rmi.transport=ALL-UNNAMED</span><br><span class="line">yukiyama@yukiyama bin %</span><br></pre></td></tr></table></figure><p>由于 Tomcat 需要 JRE 环境的支持，因此 Tomcat 能够正常运行的前提是已经安装了 JDK (或 JRE) ，并配置好了 <code>JAVA_HOME</code> 环境变量。</p><br /><h3 id="部署应用"><a href="#部署应用" class="headerlink" title="部署应用"></a>部署应用</h3><h4 id="手动"><a href="#手动" class="headerlink" title="手动"></a>手动</h4><p>将创建好的应用项目 (application) 文件夹放置在 Tomcat 安装目录 (解压缩目录) 下的 <code>webapps</code> 子目录中。例如 web 应用项目 <code>demo</code> 如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">demo</span><br><span class="line">├── css</span><br><span class="line">│   └── demo05.css</span><br><span class="line">├── demo09.html</span><br><span class="line">├── imgs</span><br><span class="line">│   └── del.jpg</span><br><span class="line">└── js</span><br><span class="line">    └── demo09.js</span><br></pre></td></tr></table></figure><p>将 <code>demo</code> 放置到 <code>~/apache-tomcat-8.5.82/webapps</code> 中，此时的 <code>demo</code> 为一个 context root，接着在 <code>demo</code> 下新建一个 <code>WEB-INF</code> 目录，如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">webapps</span><br><span class="line">├── demo</span><br><span class="line">    ├── WEB-INF</span><br><span class="line">    ├── css</span><br><span class="line">    │   └── demo05.css</span><br><span class="line">    ├── demo09.html</span><br><span class="line">    ├── imgs</span><br><span class="line">    │   └── del.jpg</span><br><span class="line">    └── js</span><br><span class="line">        └── demo09.js</span><br></pre></td></tr></table></figure><p>Tomcat 服务运行状态下，在浏览器中输入 <code>http://localhost:8080/demo/demo09.html</code> ，Tomcat 会在 <code>webapps</code> 目录下寻找相应的 context root <code>demo</code>，然后找到 <code>demo09.html</code> ， 即可以 http 方式访问该页面。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/javaweb_in_action/demo09.png"></p><p>这个简单的例子反映了「Web Server」的核心，即 <strong>基于 HTTP 协议对外提供资源</strong> 。主要过程如下。</p><ul><li>浏览器 URL 中的 <code>http</code> 明确了客户端与 Web 服务器交互的协议。</li><li><code>localhost</code> 即本机 IP (因为 Tomcat 此时运行在本机上)。如果运行在其他主机上，则需为该主机 IP 地址。</li><li><code>8080</code> 是 Tomcat 服务端口，浏览器的请求报文到达 Tomcat 所在主机后 (本机) ，根据该端口找到具体的 Tomcat 程序。</li><li>Tomcat 程序继续根据 URL 中的 <code>demo</code> 在 <code>webapp</code> 目录下找到对应的 <code>demo</code> 目录，然后进一步找到 <code>demo09.html</code> ，最终将此「资源」发回到客户端浏览器，由浏览器解析呈现出上述页面。</li></ul><br /><h4 id="自动"><a href="#自动" class="headerlink" title="自动"></a>自动</h4><p>使用 idea 自动部署。</p><p>首先在 idea 中创建 <code>javaweb_in_action</code> 父工程 (archetype: quickstart) ，然后再创建名为 <code>pro07-javaweb-begin</code> 的 web 子工程 (archetype: webapp)。在该子工程的 <code>webapp</code> 目录下创建名为 <code>hello01.html</code> 的 html 文件。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们将以 <code>pro07-javaweb-begin</code> 项目演示部署和运行过程。首先在项目界面右上侧选择 「Edit Configurations…」，在弹出的页面中完成部署。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/javaweb_in_action/edit-configurations.png" alt="edit-configurations"></p><p>在弹出页面的左上侧点击「+」，选择「Tomcat Server &gt; Local」。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/javaweb_in_action/tomcat-server-local.png" alt="tomcat-server-local"></p><p>选择本地 Tomcat Server，即 「Name: Tomcat 8.5.82」 。接着先在「Deployment」页签下添加 <code>pro07-javaweb-begin</code> ，可以将 「Application context」改为较简短的「&#x2F;pro07」(此处即为用于与浏览器 URL 端口号后的字符串对应的 context root) 。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/javaweb_in_action/tomcat-deployment.png" alt="tomcat-deployment"></p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/javaweb_in_action/tomcat-deployment1.png" alt="tomcat-deployment1"></p><p>接着在「Server」页签中完成如下设置。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/javaweb_in_action/tomcat-server-tab.png" alt="tomcat-server-tab"></p><p>上述主要设置的详细说明 (<a href="https://www.jetbrains.com/help/idea/updating-applications-on-application-servers.html">参考1</a>, <a href="http://t.zoukankan.com/labimeilexin-p-13404213.html">参考2</a>) 。</p><table><thead><tr><th>设置</th><th>描述</th><th></th></tr></thead><tbody><tr><td>Open browser</td><td>After launch</td><td>勾选 After launch ，选择一个浏览器，表示在启动 Tomcat 运行指定的 web 项目后，自动唤起指定浏览器</td></tr><tr><td></td><td>URL</td><td>唤起浏览器时指定打开的 URL</td></tr><tr><td>On ‘Update’ action</td><td></td><td>若项目代码有更新，采取何种动作</td></tr><tr><td></td><td>Update Resources</td><td>若更新的是资源文件 (.jsp，.xml等，不包括 java 文件) ，则这些更新立即生效</td></tr><tr><td></td><td>Update classes and resources</td><td>包括资源文件和 java 文件在内，若有更新，则立即生效</td></tr><tr><td></td><td>Redeploy</td><td>重新部署应用</td></tr><tr><td></td><td>Restart Server</td><td>重启 Tomcat 服务器</td></tr><tr><td>On frame deactivation</td><td></td><td>失去焦点时 (例如最小化 IDEA 窗口），采取何种动作</td></tr><tr><td></td><td>Do nothing</td><td>无动作</td></tr><tr><td></td><td>Update resources</td><td>资源文件 (.jsp，.xml等，不包括 java 文件) 的更新立即生效</td></tr><tr><td></td><td>Update classes and resources</td><td>包括资源文件和 java 文件在内的更新立即生效</td></tr></tbody></table><p>接着运行 (或 debug) 。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/javaweb_in_action/tomcat-run-debug.png" alt="tomcat-run-debug"></p><p>正常情况下，默认浏览器会弹出「hello01.html」页面，如下表示部署成功。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/javaweb_in_action/web-project-open-webpage.png" alt="web-project-open-webpage"></p><br /><h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><p>现在我们已经知道如何部署一个最简单的 web 项目，并看到 Tomcat 作为 Web 服务器，在浏览器发起请求后能够处理请求并发回对应的资源。实际上 <strong>真正处理请求的是 Servlet</strong> 。</p><p>Servlet (<strong>Serv</strong>er App<strong>let</strong>): Server 与 Applet 的合成词，即「服务器小程序」。Server 即 Web Server，也即我们使用的 Tomcat Server，所谓「小程序」，本质上是  <strong>Servlet 接口实现类的对象实例</strong> 。当 Tomcat 接收到浏览器请求时，会根据请求信息创建预先对应了此请求的 Servlet 实现类实例。详细过程后述。</p><p>相比此前介绍的简单的请求，对于一般的 web 项目，Tomcat 需要响应的资源远不止静态页面，它还会与数据库交互，使得我们可以在浏览器页面的操作 (请求)，经由不同的 Servlet，向数据库中写入数据或获取数据库信息发回到浏览器页面等，因此 Servlet 通常会由开发人员针对具体请求编写。</p><p>在前面的例子中我们并没有编写具体的 Servlet 类，这是因为当 Tomcat 找不到与请求相对应的 Servlet 时，会使用一个名为 <code>default</code> 的默认 Servlet 来处理请求。关于这一点后续也会详细说明。</p><br /><h3 id="入门示例"><a href="#入门示例" class="headerlink" title="入门示例"></a>入门示例</h3><p>我们通过实现下述功能，讲解如何针对具体的请求编写相对应的 servlet ，并说明 servlet 处理该请求的过程。我们在前面已经创建的 <code>pro07-javaweb-begin</code> 项目中实现该功能。</p><blockquote><p>功能：通过「水果库存信息」页面，输入水果名称、价格、库存以及备注信息，点击提交后将这些信息加入到后台水果库存数据库中。</p></blockquote><br /><h4 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h4><p>在本示例中我们使用的 Servlet 需要依赖第三方库 <code>javax.servlet-api</code> 的类，需引入 <a href="https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api">该依赖</a>。此外连接 MySQL 数据库要引入 <code>mysql-connector-java</code> 依赖。在 「Tomcat」一节中，我们已经创建了 <code>javaweb_in_action</code> 这个 Maven 项目，也创建了 <code>pro07-javaweb-begin</code> 这个子项目，maven 会自动将前者作为父工程，后者作为子工程，我们在父工程的 <code>pom.xml</code> 文件中使用 <code>&lt;dependenciesManager&gt;</code> 标签统一管理子工程的依赖。</p><p>※ Maven 的使用以及父子工程间依赖继承相关的知识可参考 <a href="https://github.com/iyukiyama/maven_in_action">该仓库</a> 的 <a href="https://github.com/iyukiyama/maven_in_action/blob/master/Maven%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98_yukiyama.md">Maven学习实战_yukiyama</a> 教程。</p><p>父工程 <code>javaweb_in_action</code> 的 <code>pom.xml</code> 。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.yukiyama.javaweb<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javaweb_in_action<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>pro07-javaweb-begin<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>javaweb_in_action<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.13.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">&lt;!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">&lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--      &lt;dependency&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;groupId&gt;mysql&lt;/groupId&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;version&gt;8.0.11&lt;/version&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--      &lt;/dependency&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>子工程 <code>pro07-javaweb-begin</code> 的 <code>pom.xml</code> 。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javaweb_in_action<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.yukiyama.javaweb<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pro07-javaweb-begin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>pro07-javaweb-begin Maven Webapp<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;dependency&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;groupId&gt;mysql&lt;/groupId&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;/dependency&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>pro07-javaweb-begin<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但是在实际使用中，通过父工程继承的 <code>mysql-connector-java</code> 依赖并不生效，会报此错 <code>java.lang.ClassNotFoundException: com.mysql.jdbc.Driver</code> 。作者暂时还不知道为什么引用无法生效，即便直接在子工程中添加完整坐标的依赖也存在同样的问题。目前解决这个问题的办法是在 <code>WEB-INF</code> 下新建一个 <code>lib</code> 文件夹，将 <code>mysql-connector-java-x.x.x.jar</code> 放入其中，并手动添加到依赖中 (若使用的 IDE 为 idea，选中该 jar 包，右键，点击 「Add as Library…」，或者在 File &gt; Project Structure &gt; Modules 的 Dependencies 页签下完成添加) 。</p><br /><h4 id="准备数据库"><a href="#准备数据库" class="headerlink" title="准备数据库"></a>准备数据库</h4><p>按如下 SQL 语句准备数据库 <code>fruitdb</code> 以及 <code>t_fruit</code> 表。</p><p>TODO: 导入方法和DBeaver软件</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE fruitdb charset utf8;</span><br><span class="line">USE fruitdb;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t_fruit` (</span><br><span class="line">  `fid` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `fname` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `price` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `fcount` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `remark` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`fid`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">33</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span>  <span class="keyword">into</span> `t_fruit`(`fid`,`fname`,`price`,`fcount`,`remark`) </span><br><span class="line"><span class="keyword">values</span> </span><br><span class="line">(<span class="number">1</span>,<span class="string">&#x27;红富士&#x27;</span>,<span class="number">5</span>,<span class="number">16</span>,<span class="string">&#x27;红富士也是苹果!&#x27;</span>),</span><br><span class="line">(<span class="number">2</span>,<span class="string">&#x27;大瓜&#x27;</span>,<span class="number">5</span>,<span class="number">100</span>,<span class="string">&#x27;王校长的瓜真香&#x27;</span>),</span><br><span class="line">(<span class="number">3</span>,<span class="string">&#x27;南瓜&#x27;</span>,<span class="number">4</span>,<span class="number">456</span>,<span class="string">&#x27;水果真好吃&#x27;</span>),</span><br><span class="line">(<span class="number">4</span>,<span class="string">&#x27;苦瓜&#x27;</span>,<span class="number">5</span>,<span class="number">55</span>,<span class="string">&#x27;苦瓜很好吃&#x27;</span>),</span><br><span class="line">(<span class="number">5</span>,<span class="string">&#x27;莲雾&#x27;</span>,<span class="number">9</span>,<span class="number">99</span>,<span class="string">&#x27;莲雾是一种神奇的水果&#x27;</span>),</span><br><span class="line">(<span class="number">6</span>,<span class="string">&#x27;羊角蜜&#x27;</span>,<span class="number">4</span>,<span class="number">30</span>,<span class="string">&#x27;羊角蜜是一种神奇的瓜&#x27;</span>),</span><br><span class="line">(<span class="number">7</span>,<span class="string">&#x27;啃大瓜&#x27;</span>,<span class="number">13</span>,<span class="number">123</span>,<span class="string">&#x27;孤瓜&#x27;</span>);</span><br></pre></td></tr></table></figure><br /><h4 id="编写浏览器页面"><a href="#编写浏览器页面" class="headerlink" title="编写浏览器页面"></a>编写浏览器页面</h4><p>首先编写如下浏览器页面 <code>add.html</code> 。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;add&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">        名称：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;fname&quot;</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        价格：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;price&quot;</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        库存：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;fcount&quot;</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        备注：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;remark&quot;</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;添加&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>该页面如下。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/javaweb_in_action/add_html_empty.png" alt="add_html_empty"></p><br /><h4 id="编写FruitDao相关类"><a href="#编写FruitDao相关类" class="headerlink" title="编写FruitDao相关类"></a>编写FruitDao相关类</h4><p>从浏览器输入的水果库存信息要保存到数据库中，就要操作数据库，即需要编写 <code>Fruit</code> ORM 类、<code>BaseDao</code>、 <code>FruitDao</code> 接口、<code>FruitDaoImpl</code> 实现类。这部分需要 JDBC 的知识，读者可先阅读 <a href="https://github.com/iyukiyama/jdbc_in_action">此仓库</a> 中的 <a href="https://github.com/iyukiyama/jdbc_in_action/blob/master/jdbc%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98_yukiyama.md">jdbc学习实战_yukiyama</a> 一文完成相关知识的学习，当然也可以跳过这部分内容直接使用已经提供好的相关实现。</p><br /><h4 id="编写AddServlet"><a href="#编写AddServlet" class="headerlink" title="编写AddServlet"></a>编写AddServlet</h4><p>创建一个继承 <code>HttpServlet</code> 的 <code>AddServlet</code> 类，用于响应通过 <code>add.html</code> 页面添加数据的请求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukiyama.servlets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.yukiyama.fruit.dao.FruitDAO;</span><br><span class="line"><span class="keyword">import</span> com.yukiyama.fruit.dao.impl.FruitDaoImpl;</span><br><span class="line"><span class="keyword">import</span> com.yukiyama.fruit.pojo.Fruit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AddServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        req.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>); <span class="comment">// post请求时，添加此句支持中文 (get请求无需此句)</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fname</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;fname&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">priceStr</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;price&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">price</span> <span class="operator">=</span> Integer.parseInt(priceStr);</span><br><span class="line">        <span class="type">String</span> <span class="variable">fcountStr</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;fcount&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> Integer.parseInt(fcountStr);</span><br><span class="line">        <span class="type">String</span> <span class="variable">remark</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;remark&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">FruitDAO</span> <span class="variable">fruitDAO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FruitDAOImpl</span>();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> fruitDAO.addFruit(<span class="keyword">new</span> <span class="title class_">Fruit</span>(<span class="number">0</span>, fname, price, count, remark));</span><br><span class="line">        System.out.println(flag ? <span class="string">&quot;添加成功&quot;</span> : <span class="string">&quot;添加失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h4 id="配置web-xml"><a href="#配置web-xml" class="headerlink" title="配置web.xml"></a>配置web.xml</h4><p>将项目部署到 Tomcat 后，我们能够在浏览器中以 http 方式打开 <code>add.html</code> ，并能够填写相关信息。并且我们也编写好了 <code>FruitDao</code> 及相关的 JDBC 实现，能够将 <code>Addservlet</code> 通过 <code>doPost</code> 方法获取到的数据写入到数据库中。但目前 <code>add.html</code> 页面提交数据的请求，是无法找到 <code>AddServlet</code> 的，或者说 <code>AddServlet</code> 还不知道自己应该拦截什么请求。</p><p>我们还需要在 web.xml 中完成具体的 Servlet (<code>AddServlet</code>) 与具体的请求动作 (<code>action=&quot;add&quot;</code>) 的映射配置，Tomcat 通过该配置使得指定的 Servlet 拦截映射绑定的请求。</p><p><code>web.xml</code> 如下。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置 AddServelet --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>AddServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.yukiyama.servlets.AddServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 映射 AddServlet 与 add --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>AddServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/add<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><br /><h4 id="配置Tomcat"><a href="#配置Tomcat" class="headerlink" title="配置Tomcat"></a>配置Tomcat</h4><p>参考「Tomcat」-「部署应用」-「自动」，一个 web 项目要部署到 Web 服务器中才能运行，因此我们要将 <code>pro07-javaweb-begin</code> 这个 artifact 部署到 Tomcat 中。</p><p>若指定打开的 URL 未写上 <code>add.html</code> ，则 Tomcat 会寻找 <code>index.html</code> ，找不到则报 <code>404</code> 错误。若在 <code>webapp</code> 目录下存在 <code>index.html</code> ，则 URL 中可以省略 <code>index.html</code> 。实际上，在 Tomcat 程序安装路径下的 <code>conf</code> 目录的 <code>web.xml</code> 配置文件中，有如下配置及注释说明。可以看到，若是前述情形，则 Tomcat 会在相应文件夹中依次寻找 <code>index.html</code>, <code>index.htm</code>, <code>index.jsp</code> 。</p><p>也可以在具体的 web 项目的 <code>web.xml</code> 下添加 <code>&lt;welcome-file-list&gt;</code> 标签，使得 URL 访问时不必写出资源文件名。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- ==================== Default Welcome File List ===================== --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- When a request URI refers to a directory, the default servlet looks  --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- for a &quot;welcome file&quot; within that directory and, if present, to the   --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- corresponding resource URI for display.                              --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- If no welcome files are present, the default servlet either serves a --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- directory listing (see default servlet configuration on how to       --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- customize) or returns a 404 status, depending on the value of the    --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- listings setting.                                                    --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--                                                                      --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- If you define welcome files in your own application&#x27;s web.xml        --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- deployment descriptor, that list *replaces* the list configured      --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- here, so be sure to include any of the default values that you wish  --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- to use within your application.                                       --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.html<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.htm<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.jsp<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">welcome-file-list</span>&gt;</span></span><br></pre></td></tr></table></figure><br /><h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><p>完成上述步骤后，<code>pro07-javaweb-begin</code> 子工程目录如下，相关的文件都可以在 <a href="https://github.com/iyukiyama/javaweb_in_action">javaweb_in_action</a> 仓库中获取。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">pro07-javaweb-begin</span><br><span class="line">├── pom.xml</span><br><span class="line">└── src</span><br><span class="line">    ├── main</span><br><span class="line">    │   ├── java</span><br><span class="line">    │   │   ├── com</span><br><span class="line">    │   │   │   └── yukiyama</span><br><span class="line">    │   │   │       └── servlets</span><br><span class="line">    │   │   │           └── AddServlet.java</span><br><span class="line">    │   │   └── com.yukiyama.fruit</span><br><span class="line">    │   │       ├── dao</span><br><span class="line">    │   │       │   ├── FruitDAO.java</span><br><span class="line">    │   │       │   ├── base</span><br><span class="line">    │   │       │   │   └── BaseDAO.java</span><br><span class="line">    │   │       │   └── impl</span><br><span class="line">    │   │       │       └── FruitDAOImpl.java</span><br><span class="line">    │   │       └── pojo</span><br><span class="line">    │   │           └── Fruit.java</span><br><span class="line">    │   ├── resources</span><br><span class="line">    │   └── webapp</span><br><span class="line">    │       ├── WEB-INF</span><br><span class="line">    │       │   ├── lib</span><br><span class="line">    │       │   │   └── mysql-connector-java-8.0.11.jar</span><br><span class="line">    │       │   └── web.xml</span><br><span class="line">    │       ├── add.html</span><br><span class="line">    │       └── hello01.html</span><br><span class="line">    └── test</span><br><span class="line">        ├── java</span><br><span class="line">        └── resources</span><br></pre></td></tr></table></figure><p>至此，我们完成了实现目标功能所需的所有工作。运行该工程，浏览器自动弹出 <code>add.html</code> 页面，填入相关信息后，如下。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/javaweb_in_action/add_html.png" alt="add_html"></p><p>正常情况下该请求 (名为 <code>add</code> 的 Post 请求) 会被 <code>AddServlet</code> 处理，根据请求类型为 Post ，调用其 <code>doPost</code> 方法，在方法中将通过 Tomcat 传入的 <code>HttpServletRequest</code> 实例的 <code>getParameter</code> 方法得到的数据，经由 <code>FruitDao</code> 实例方法 <code>addFruit</code> 写入到数据库中对应的表中。</p><p>此时查看数据库，可以看到数据已经被成功写入。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_fruit;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----+-----------+-------+--------+--------------------------------+</span></span><br><span class="line"><span class="operator">|</span> fid <span class="operator">|</span> fname     <span class="operator">|</span> price <span class="operator">|</span> fcount <span class="operator">|</span> remark                         <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----+-----------+-------+--------+--------------------------------+</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">1</span> <span class="operator">|</span> 红富士    <span class="operator">|</span>     <span class="number">5</span> <span class="operator">|</span>     <span class="number">16</span> <span class="operator">|</span> 红富士也是苹果！               <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">2</span> <span class="operator">|</span> 大瓜      <span class="operator">|</span>     <span class="number">5</span> <span class="operator">|</span>    <span class="number">100</span> <span class="operator">|</span> 王校长的瓜真香                 <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">3</span> <span class="operator">|</span> 南瓜      <span class="operator">|</span>     <span class="number">4</span> <span class="operator">|</span>    <span class="number">456</span> <span class="operator">|</span> 水果真好吃                     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">4</span> <span class="operator">|</span> 苦瓜      <span class="operator">|</span>     <span class="number">5</span> <span class="operator">|</span>     <span class="number">55</span> <span class="operator">|</span> 苦瓜很好吃                     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">5</span> <span class="operator">|</span> 莲雾      <span class="operator">|</span>     <span class="number">9</span> <span class="operator">|</span>     <span class="number">99</span> <span class="operator">|</span> 莲雾是一种神奇的水果           <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">6</span> <span class="operator">|</span> 羊角蜜    <span class="operator">|</span>     <span class="number">4</span> <span class="operator">|</span>     <span class="number">30</span> <span class="operator">|</span> 羊角蜜是一种神奇的瓜           <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">7</span> <span class="operator">|</span> 啃大瓜    <span class="operator">|</span>    <span class="number">13</span> <span class="operator">|</span>    <span class="number">123</span> <span class="operator">|</span> 孤瓜                           <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">38</span> <span class="operator">|</span> apple     <span class="operator">|</span>    <span class="number">10</span> <span class="operator">|</span>    <span class="number">100</span> <span class="operator">|</span> apple added                    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----+-----------+-------+--------+--------------------------------+</span></span><br><span class="line"><span class="number">8</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.07</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><br /><h3 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h3><p>为了看清 servlet 是如何工作的，我们首先查看如下从具体实现类 <code>AddServlet</code> 上溯到 <code>Servlet</code> 接口的继承关系。可以看到继承路径为 <code>Servlet</code> 接口 &gt; <code>GenericServlet</code> 抽象类 &gt; <code>HttpServlet</code> 抽象类 &gt; <code>Servlet</code> 具体实现类。</p><p>※ 继承关系图打开方法：在 idea 环境中选中类，右键菜单栏底部选择 Diagrams &gt; Show Diagrams… 或 Show Diagrams Popup… 。此功能依赖「Diagrams」插件 (idea 已内置)，需开启。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/javaweb_in_action/servlet-extend-diagram.png" alt="servlet-extend-diagram"></p><p>在 <code>Servlet</code> 接口中，声明了如下五个抽象方法。我们指出，其中的 <code>init</code>, <code>service</code>, <code>destroy</code> 正是 servlet 工作的核心方法。这五个方法有些在 <code>GenericServlet</code> 或 <code>HttpServlet</code> 中已实现，有的需要在具体的  Servlet 实现类中重写实现，后续详细说明。</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>init</code></td><td>初始化方法。</td></tr><tr><td><code>getServletConfig</code></td><td>获取包含 servlet 的初始化和启动参数的 <code>ServletConfig</code> 对象。</td></tr><tr><td><code>service</code></td><td>服务方法。</td></tr><tr><td><code>getServletInfo</code></td><td>获取有关 servlet 的信息，如作者、版本和版权等。</td></tr><tr><td><code>destroy</code></td><td>销毁方法。</td></tr></tbody></table><br /><h3 id="接口方法"><a href="#接口方法" class="headerlink" title="接口方法"></a>接口方法</h3><p>如下详细描述 <code>Servlet</code> 接口中的五个抽象方法。</p><br /><h4 id="init"><a href="#init" class="headerlink" title="init"></a>init</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException;</span><br></pre></td></tr></table></figure><ul><li>由 servlet 容器调用，调用即表明该 servlet 正在服务。</li><li>实例化 servlet 之后，<code>init</code> 方法 <strong>只会被调用一次</strong> (因此 servlet 是单例的)。</li><li>servlet 处理请求前要求 <code>init</code> 方法必须已成功执行。</li><li><code>init</code> 方法已在 <code>GenericServlet</code> 抽象类中实现，将 Servlet 容器 (Tomcat) 传入的 <code>ServletConfig</code> 实例赋值给类字段 <code>config</code> 。</li><li><code>GenericServlet</code> 中实现 <code>Servlet</code> 的 <code>init</code> 方法中还会调用一个无参 <code>init</code> 方法，可以具体的 Servlet 实现类中重写 <code>init</code> 方法 (无参) ，以扩展初始化动作。</li><li><code>HttpServlet</code> 抽象类未实现该方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GenericServlet 抽象类中的 init 实现。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line"><span class="built_in">this</span>.config = config;</span><br><span class="line"><span class="built_in">this</span>.init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GenericServlet 抽象类中的无参 init</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException &#123;&#125;</span><br></pre></td></tr></table></figure><br /><h4 id="getServletConifg"><a href="#getServletConifg" class="headerlink" title="getServletConifg"></a>getServletConifg</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ServletConfig <span class="title function_">getServletConfig</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><ul><li>返回包含 servlet 的初始化和启动参数的 <code>ServletConfig</code> 对象。</li><li>返回的 <code>ServletConfig</code> 对象就是传递给 <code>init</code> 方法的对象。</li><li><code>GenericServlet</code> 类已经实现了这个方法。因此具体的 servlet 实现类不必重写该方法。</li><li><code>HttpServlet</code> 抽象类未实现该方法 (因为<code>GenericServlet</code> 类已经实现了)。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GenericServlet 抽象类中的 getServletConfig 实现。</span></span><br><span class="line"><span class="keyword">public</span> ServletConfig <span class="title function_">getServletConfig</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> config;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h4 id="service"><a href="#service" class="headerlink" title="service"></a>service</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest req, ServletResponse res)</span> <span class="keyword">throws</span> ServletException, IOException;</span><br></pre></td></tr></table></figure><ul><li>由 servlet 容器调用，以允许 servlet 响应请求。</li><li>此方法只在 <code>init</code> 方法成功完成后才会被调用。</li><li>对于抛出或发送错误的 servlet，应设置响应的状态代码。</li><li>servlet 通常在多线程的 servlet 容器内运行，以同时处理多个请求。因此必须注意任何共享资源，如文件、网络连接以及 servlet 实例等的同步访问。</li><li>该方法在 <code>GenericServlet</code> 中也是抽象方法，因此必须在后续子类 (例如 <code>HttpServlet</code>) 中重写。</li><li>实际上由于 <code>HttpServlet</code> 重写实现了该方法，具体的 <code>Servlet</code> 实现类不必重写该方法 (源码注释中有言：There’s no need to override this method.)。</li></ul><p>如下是 <code>HttpServlet</code> 抽象类中的 <code>service</code> 方法的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HttpServlet 抽象类中的 service(ServletRequest req, ServletResponse res) 实现。</span></span><br><span class="line"><span class="comment">// 源码注释中写道：</span></span><br><span class="line"><span class="comment">// Dispatches client requests to the protected service method. </span></span><br><span class="line"><span class="comment">// There&#x27;s no need to override this method.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest req, ServletResponse res)</span></span><br><span class="line">    <span class="keyword">throws</span> ServletException, IOException</span><br><span class="line">&#123;</span><br><span class="line">    HttpServletRequest  request;</span><br><span class="line">    HttpServletResponse response;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(req <span class="keyword">instanceof</span> HttpServletRequest &amp;&amp;</span><br><span class="line">            res <span class="keyword">instanceof</span> HttpServletResponse)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServletException</span>(<span class="string">&quot;non-HTTP request or response&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    request = (HttpServletRequest) req;</span><br><span class="line">    response = (HttpServletResponse) res;</span><br><span class="line"></span><br><span class="line">    service(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，该实现先判断传入的 <code>ServletRequest</code> 、<code>ServletResponse</code> 实例能向下转型为 <code>HttpServletRequest</code> 、<code>HttpServletResponse</code> ，若不能，则抛出 <code>ServletException</code> 异常，并告知此请求或响应是「非 HTTP 的」(non-HTTP) 。若能向下转型，则转型后执行如下方法。</p><p>可以看到，下述 service 方法才是核心内容。该方法首先获取请求类型 (GET &#x2F; HEAD &#x2F; POST &#x2F; PUT &#x2F; DELET &#x2F; OPTIONS &#x2F; TRACE &#x2F; 不属于列出的任何类型)，然后通过 <code>if-else</code> 分支根据具体类型执行相应的 <code>doXXX</code> 方法或发送错误信息 (不属于列出的任何类型时)。</p><p>关于 <code>lastModified</code> </p><p>TODO</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HttpServlet 抽象类中的 service(HttpServletRequest req, HttpServletResponse resp) 实现。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span><br><span class="line">    <span class="keyword">throws</span> ServletException, IOException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> req.getMethod();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (method.equals(METHOD_GET)) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">lastModified</span> <span class="operator">=</span> getLastModified(req);</span><br><span class="line">        <span class="keyword">if</span> (lastModified == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// servlet doesn&#x27;t support if-modified-since, no reason</span></span><br><span class="line">            <span class="comment">// to go through further expensive logic</span></span><br><span class="line">            doGet(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">ifModifiedSince</span> <span class="operator">=</span> req.getDateHeader(HEADER_IFMODSINCE);</span><br><span class="line">            <span class="keyword">if</span> (ifModifiedSince &lt; lastModified) &#123;</span><br><span class="line">                <span class="comment">// If the servlet mod time is later, call doGet()</span></span><br><span class="line">                <span class="comment">// Round down to the nearest second for a proper compare</span></span><br><span class="line">                <span class="comment">// A ifModifiedSince of -1 will always be less</span></span><br><span class="line">                maybeSetLastModified(resp, lastModified);</span><br><span class="line">                doGet(req, resp);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_HEAD)) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">lastModified</span> <span class="operator">=</span> getLastModified(req);</span><br><span class="line">        maybeSetLastModified(resp, lastModified);</span><br><span class="line">        doHead(req, resp);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_POST)) &#123;</span><br><span class="line">        doPost(req, resp);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_PUT)) &#123;</span><br><span class="line">        doPut(req, resp);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_DELETE)) &#123;</span><br><span class="line">        doDelete(req, resp);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_OPTIONS)) &#123;</span><br><span class="line">        doOptions(req,resp);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_TRACE)) &#123;</span><br><span class="line">        doTrace(req,resp);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Note that this means NO servlet supports whatever</span></span><br><span class="line">        <span class="comment">// method was requested, anywhere on this server.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">errMsg</span> <span class="operator">=</span> lStrings.getString(<span class="string">&quot;http.method_not_implemented&quot;</span>);</span><br><span class="line">        Object[] errArgs = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">1</span>];</span><br><span class="line">        errArgs[<span class="number">0</span>] = method;</span><br><span class="line">        errMsg = MessageFormat.format(errMsg, errArgs);</span><br><span class="line"></span><br><span class="line">        resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h4 id="getServletInfo"><a href="#getServletInfo" class="headerlink" title="getServletInfo"></a>getServletInfo</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getServletInfo</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><ul><li>返回有关 servlet 的信息，如作者、版本和版权。</li><li>该方法返回的字符串应该是纯文本，而不是任何形式的标记 (如HTML、XML等)。</li><li><code>GenericServlet</code> 抽象类中实现了该方法，但只返回了 <code>&quot;&quot;</code> 。</li><li><code>HttpServlet</code> 抽象类未实现该方法。具体的 Servlet 实现类可根据实际需要重写该方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GenericServlet 抽象类中的 getServletInfo 实现。</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getServletInfo</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h4 id="destroy"><a href="#destroy" class="headerlink" title="destroy"></a>destroy</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><ul><li>由 servlet 容器调用，表明该 servlet 正在退出服务。</li><li>只有在 servlet 的 <code>service</code> 方法中的所有线程都退出或超时后，才会调用这个方法。</li><li>在 servlet 容器调用此方法后，它将不再调用此 servlet 的 <code>service</code> 方法。</li><li>该方法给了 servlet 一个机会来清理任何被保留的资源 (例如内存、文件句柄、线程)，并确保任何持久化状态与 servlet 在内存中的当前状态同步。</li><li><code>GenericServlet</code> 抽象类中实现了该方法，但无任何动作。</li><li><code>HttpServlet</code> 抽象类未实现该方法。具体的 Servlet 实现类可根据实际需要重写该方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GenericServlet 抽象类中的 destroy 实现。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;&#125;</span><br></pre></td></tr></table></figure><br /><h3 id="HttpServlet"><a href="#HttpServlet" class="headerlink" title="HttpServlet"></a>HttpServlet</h3><p>现在我们知道，响应请求的核心方法是 <code>service</code> ，该方法在 <code>HttpServlet</code> 已被实现。我们也已展示过 <code>HttpServlet</code> 中 <code>service</code> 方法的内部实现，其中对应不同请求的 <code>doXxx</code> 方法是响应请求的具体动作。虽然 JDK 建议具体 <code>Servlet</code> 实现类不必再重写 <code>service</code> 方法，但却必须重写从 <code>HttpServlet</code> 继承的 <code>doXxx</code> 方法，以根据实际情况处理具体的请求。例如我们在「入门示例」中展示过的那样，从 post 请求中获取表单信息写入数据库中。实际上，当具体的 <code>Servlet</code> 实现类处理请求时，若未重写对应该请求的 <code>doXxx</code> 方法，则会返回 405 错误。</p><br /><h4 id="doXxx"><a href="#doXxx" class="headerlink" title="doXxx"></a>doXxx</h4><p>以 <code>doPost</code> 作为例子说明。如下是 <code>HttpServlet</code> 实现的 <code>doPost</code> 方法。传入由 Tomcat 根据请求创建和维护的 <code>HttpServletRequest</code> 和 <code>HttpServletResponse</code> 。首先获取请求协议字符串，例如 <code>HTTP/1.1</code> ，接着获取 <code>msg</code> 字符串 (定义在 <code>LocalStrings.properties</code> 文件中) 。判断请求协议是否为 <code>HTTP/1.1</code> ，若是则发送 405 错误 (<code>HttpServletResponse.SC_METHOD_NOT_ALLOWED</code> 即 <code>int 405</code>) ，否则发送 400 错误 (<code>HttpServletResponse.SC_BAD_REQUEST </code> 即  <code>int 400</code>) 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span><br><span class="line">    <span class="keyword">throws</span> ServletException, IOException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">protocol</span> <span class="operator">=</span> req.getProtocol();</span><br><span class="line">    <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> lStrings.getString(<span class="string">&quot;http.method_post_not_supported&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (protocol.endsWith(<span class="string">&quot;1.1&quot;</span>)) &#123;</span><br><span class="line">        resp.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED, msg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resp.sendError(HttpServletResponse.SC_BAD_REQUEST, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>※ <code>LocalStrings.properties</code> 文件中定义的字符串，如下只展示其中的两条。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">http.method_get_not_supported</span>=<span class="string">HTTP method GET is not supported by this URL</span></span><br><span class="line"><span class="attr">http.method_post_not_supported</span>=<span class="string">HTTP method POST is not supported by this URL</span></span><br></pre></td></tr></table></figure><br /><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>新建一个 <code>pro08-javaweb-servlet</code> web 子工程，创建 <code>Demo01Servlet</code> 类继承 <code>HttpServlet</code> ，在 <code>Demo01Servlet</code> 中重写 <code>doPost</code> 方法 (只简单调用父类 <code>doPost</code> 方法)，如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukiyama.servlets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01Servlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">super</span>.doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着按照我们已经熟悉的过程，在 <code>web.xml</code> 中配置该 servlet 与请求的映射关系。接着将该工程部署到 Tomcat 中，并使该项目运行后浏览器自动弹出指定页面 (将上下文设置为 <code>/pro08</code>) 。</p><p><code>web.xml</code> 的相关配置。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>Demo01Servlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.yukiyama.servlets.Demo01Servlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>Demo01Servlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/demo01<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Tomcat 设置中勾选 Server 页签下的 Open Browser 设置项下的「After launch」，并将 URL 设置为 <code>http://localhost:8080/pro08/demo01</code> 。</p><p>运行后我们将发现页面显示 405 错误。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/javaweb_in_action/405page.png" alt="405page"></p><p>出现 <code>405</code> 的原因就在于默认请求为 Get 方式，而我们重写的是 <code>doPost</code> 方法 (我们并没有编写页面发送 <code>method=&quot;post&quot;</code> 的请求) ，因此在执行 <code>service</code> 方法时，会调用 <code>Demo01Servlet</code> 的父类 <code>doGet</code> 方法。最终执行如下语句，其中的 <code>HttpServletResponse.SC_METHOD_NOT_ALLOWED</code> 常量即 405。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (protocol.endsWith(<span class="string">&quot;1.1&quot;</span>)) &#123;</span><br><span class="line">    resp.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>HttpServletResponse</code> 中定义的 <code>SC_METHOD_NOT_ALLOWED</code> 常量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SC_METHOD_NOT_ALLOWED</span> <span class="operator">=</span> <span class="number">405</span>;</span><br></pre></td></tr></table></figure><p>接着我们在 <code>Demo01Servlet</code> 中重写 <code>doGet</code> 方法，如下。重新运行后不会报之前的 405 错，且能够顺利打印出 <code>doGet...</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;doGet...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过该实例，我们看到 <code>HttpServlet</code> 中实现的 <code>doXxx</code> 方法会返回 405 错误，<strong>因此必须根据实际请求编写对应的 <code>doXxx</code> 方法</strong>。</p><br /><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>servlet 的生命周期从实例创建开始，到 <code>destroy</code> 方法执行结束为止。主要有以下四个阶段。</p><ol><li>创建 <code>Servlet</code> 实例。<ol><li>当 Tomcat 服务接收到请求后，读取该请求 URL，根据预先配置在 <code>web.xml</code> 的「具体 servlet 实现类与 url-pattern 的映射关系」，通过反射创建对应的 Servlet 实现类的示例。</li><li>创建实例的过程会执行无参构造器。</li><li>对于相同的请求，相应的 Servlet 实例只会创建一个 (单例模式)，此后均由此实例响应后续相同请求。</li></ol></li><li>调用 <code>init</code> 。<ol><li>接着 Tomcat 会调用该实例的 <code>init</code> 方法。由于 <code>GenericServlet</code> 抽象类中的 <code>init</code> 方法实现将 <code>ServletConfig</code> 实例赋值给实例字段 <code>config</code> ，因此 <code>init</code> 执行后， Servlet 实例就会持有该 <code>config</code> 字段。</li><li>如果 Servlet 实例重写了 <code>init</code> ，将继续执行重写的内容。</li><li>该方法在 Servlet 实例创建后只会执行一次。</li></ol></li><li>调用 <code>service</code> 。<ol><li>若 <code>init</code> 执行成功，Tomcat 继续调用 <code>service</code> 。由于 <code>HttpServlet</code> 实现了该方法，具体的 <code>Servlet</code> 实现类不必重写 (JDK 注释中即建议不必重写) 。</li><li>该方法最终会根据传入的请求执行对应的 <code>doXXX</code> 方法或发送错误信息 (请参考前文「接口方法」一节)。</li><li>该方法每次接收到新的请求后都会相应执行一次。</li></ol></li><li>调用 <code>destroy</code> 。<ol><li><code>service</code> 方法中的所有线程都退出或超时后，调用 <code>destroy</code> 方法。</li><li>此方法在 servlet 结束服务前提供一个清理任何被保留的资源 (例如内存、文件句柄、线程) 的机会，并确保任何持久化状态与 servlet 在内存中的当前状态同步。</li><li>此方法已在 <code>GenericServlet</code> 中实现，无方法体，即不执行任何动作。因此若无需清理，则具体 Servlet 实现类不必重写该方法。若需要执行某些动作，重写即可。</li></ol></li></ol><p>我们在 <code>pro08-javaweb-servlet</code> web 子项目下创建 <code>Demo02Servlet</code> 类演示 servlet 的生命周期。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukiyama.servlets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02Servlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Demo02Servlet</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Constructor Demo02Servlet() is running.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Method init() is running.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest req, ServletResponse res)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Method service() is running.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Method destroy() is running.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与之前一样，在 <code>web.xml</code> 中配置该 servlet 与请求的映射关系。接着将该项目部署到 Tomcat 并在 Tomcat 的设置界面 Server 页签下的 「Open browser」中，不勾选「After launch」，即运行后不让浏览器自动弹出对应该 URL 的页面，而是手动输入访问。由于没有指定资源，所有方法都未调用对应的父类方法 (例如 <code>super.init()</code>) ，因此不会出现 405 错误。idea 下方的 Tomcat 信息栏中的 Server 页签中显示如下内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">com.yukiyama.servlets.Demo02Servlet@2f6691b4 Constructor Demo02Servlet() is running.</span><br><span class="line">com.yukiyama.servlets.Demo02Servlet@2f6691b4 Method init() is running.</span><br><span class="line">com.yukiyama.servlets.Demo02Servlet@2f6691b4 Method service() is running.</span><br></pre></td></tr></table></figure><p>每刷新一次页面，就会打印一次如下信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.yukiyama.servlets.Demo02Servlet@2f6691b4 Method service() is running.</span><br></pre></td></tr></table></figure><p>停止 Tomcat 服务时，如下信息被打印。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.yukiyama.servlets.Demo02Servlet@2f6691b4Method destroy() is running.</span><br></pre></td></tr></table></figure><p>由此我们清晰地看到 servlet 生命周期的四个阶段，并且确认了生命周期内只有一个 Servlet 实例，<code>init</code> 方法只被调用一次，每次请求都会调用一次 <code>service</code> 方法，servlet 停止服务前调用 <code>destroy</code> 方法。</p><p>值得注意的是，因为 <code>Servlet</code> 实例是单例的，同一个实例响应多个对应此 servlet 的请求时，该实例是「线程不安全」的。因此应尽量避免在 Servlet 实例中声明字段。</p><br /><h4 id="实例创建时机"><a href="#实例创建时机" class="headerlink" title="实例创建时机"></a>实例创建时机</h4><p>通过观察 servlet 的生命周期，我们看到 Servlet 实例是在请求到达 Tomcat 时才被创建。由于需要创建实例，第一次请求的响应会比之后的请求的响应要更耗时。我们想，如果 <code>Servlet</code> 实例不是在第一次请求时才被创建，而是在此前就已经创建好，那么第一次请求也会被快速响应。实际上这一点可以通过在 <code>web.xml</code> 中为指定的 servlet 添加 <code>&lt;load-on-starup&gt;</code> 标签来实现。如下为 <code>Demo02Servlet</code> 配置该标签。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>Demo02Servlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.yukiyama.servlets.Demo02Servlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>0<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure><p>该标签的值必须是整数，即只能取 <strong>负整数、零或正整数</strong> ，不同取值的作用如下。</p><ul><li>0 或正整数：在 Tomcat 启动该 servlet 所在工程时，即实例化该 servlet。 <strong>数字越小，优先级越高</strong> ，即当有多个 servlet 设置了此标签时，数字较小的先被其实例先被创建。若数字相同，servlet 容器 (即 Tomcat) 将自行决定创建实例的顺序。</li><li>负数：与无此标签相同，即 servlet 容器 (即 Tomcat) 在接收到相应请求时才创建 <code>Servlet</code> 实例。</li></ul><p>在 idea 中，点击 <code>&lt;load-on-startup&gt;</code> (同时按住 command 键) ，会跳转到 <code>xsd</code> 文件该标签的定义处，可以查看到如下详细说明。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The load-on-startup element indicates that this servlet should be loaded (instantiated and have its init() called) on the startup of the web application. The optional contents of these element must be an integer indicating the order in which the servlet should be loaded. If the value is a negative integer, or the element is not present, the container is free to load the servlet whenever it chooses. If the value is a positive integer or 0, the container must load and initialize the servlet as the application is deployed. The container must guarantee that servlets marked with lower integers are loaded before servlets marked with higher integers. The container may choose the order of loading of servlets with the same load-on-start-up value.</span><br></pre></td></tr></table></figure><br /><h3 id="session"><a href="#session" class="headerlink" title="session"></a>session</h3><p>session，即「会话」。会话出现是为了弥补 HTTP 协议无状态的缺陷，因为在很多「事务性」操作场景下，我们希望服务端识别一连串的请求是有关联的。最常被提到的例子是「购物操作」，即如果保持 HTTP 无状态的特点，每一次将商品加入购物车的请求都视作新的请求，那么一个购物车总是对应一件商品 (不考虑购物网站用户绑定购物车的关系)，如果服务端能够标识请求，使得多次将商品加入购物车的请求都有相同标识，那么就可以将该多次请求的商品加入同一个购物车中。</p><p>上述例子容易让我们将「会话」与「客户端服务端之间的连续通信」联系在一起，这是一种很模糊的理解。我们指出，针对 Tomcat 的 servlet 来说，session 的本质是 Java 对象，即 <code>javax.servlet.http.HttpSession</code> 类的实例，也即当我们在说 session (会话) 时，本质上是在谈论 <code>HttpSession</code> 实例对象。</p><br /><h4 id="生命周期-1"><a href="#生命周期-1" class="headerlink" title="生命周期"></a>生命周期</h4><p>session 的生命周期为创建、存活与结束。</p><ul><li><p>session 创建，即 <code>HttpSession</code> 实例对象的创建。</p><ul><li>对于 Servlet 而言，只有执行 <code>req.getSession()</code> 或 <code>req.getSession(true)</code> 才会创建 <code>HttpSession</code> 实例。但若请求携带了 sessionID，且此时服务器存在对应该 sessionID 的 <code>HttpSession</code> 实例时，不会创建。</li></ul></li><li><p>session 存活，即 session 在创建与结束之间的过程。session 存活期间可通过 <code>req.getSession()</code> 获取，并可执行 <code>getId()</code>, <code>isNew()</code> 等一系列相关方法。</p></li><li><p>session 结束，即 <code>HttpSession</code> 实例对象的销毁。</p><ul><li><code>HttpSession</code> 实例对象超时。</li><li>调用了实例方法 <code>invalidate()</code> 。</li><li>服务器 (Tomcat) 关闭或卸载了 <code>HttpSession</code> 实例所在的 web 应用。</li></ul></li></ul><p><strong>超时时间</strong></p><p><code>HttpSession</code> 实例的 <strong>超时时间默认为 1800 秒</strong> ，即 30 分钟，可通过其实例方法 <code>getMaxInactiveInterval()</code> 查询。可以通过 <code>setMaxInactiveInterval(int interval)</code> 来设置 <strong>当前 session</strong> 的超时时间，<code>int interval</code> 单位为秒，若设置为 0 或 负数，则为永不超时。</p><p>也可以通过在 <code>web.xml</code> 文件中加入如下配置来设置当前 <strong>web 应用全局 session 的超时时间</strong> ，单位为分钟，若设置为 0 或 负数，则为永不超时。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 设置 HttpSession 超时时间 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>60<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>invalidate</strong></p><p><code>HttpSession</code>  接口的 <code>invalidate()</code> 抽象方法有如下注释，这表明会话实例调用该方法时，JVM 不会直接回收该对象 (在堆中) 的内存，而是清除所有对该实例的引用，这样在下一次 GC 时该对象会被回收。</p><blockquote><p><a href="https://stackoverflow.com/questions/7484856/will-session-invalidate-remove-the-attribute-set-to-the-session">参考1</a>, <a href="https://blog.csdn.net/wzumath/article/details/6214287?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1-6214287-blog-2205658.pc_relevant_aa&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1-6214287-blog-2205658.pc_relevant_aa&utm_relevant_index=1">参考2</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invalidates this session then unbinds any objects bound to it.</span><br></pre></td></tr></table></figure><p><strong>session与cookie</strong></p><p>当服务端处理请求时创建了 <code>HttpSession</code> 实例后，对应该实例，会有一个唯一的 sessionID，可通过 <code>HttpSession</code> 实例方法 <code>getId()</code> 获取。此 sessionID 会附加到返回信息中，使得浏览器的该次请求的「Response Headers」中具有该 sessionID (set-cookie 字段)，且浏览器会以 cookie 的形式记录在本地，并将其加入到下一次请求中。于是服务器在处理下一次请求时，即可根据此 sessionID 判断此次请求与第一次请求为「同一次会话」。具体过程看下例。</p><br /><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><p>在 <code>pro08-javaweb-servlet</code> web 子工程中创建如下 <code>Demo03Servlet</code> 类，在重写的 <code>service</code> 方法中获取 <code>session</code> 信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukiyama.servlets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpSession;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03Servlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> req.getSession();</span><br><span class="line">        System.out.println(<span class="string">&quot;session.getId() = &quot;</span> + session.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与之前一样，在 <code>web.xml</code> 中配置 <code>Demo03Servlet</code> 与请求 <code>/demo03</code> 的映射关系，确保 <code>pro08-javaweb-servlet</code> 已经部署在 Tomcat 中 (之前已部署) 。运行此应用，可以看到 Tomcat 打印了如下 sessionID 信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">session.getId() = 9B41CA00381B384676117432AA6C2F4A</span><br></pre></td></tr></table></figure><p>确保在浏览器页面中打开 <code>http://localhost:8080/demo03</code> 时，调试控制台 (按 <code>F12</code>) 已打开，即可以看到如下「Response Headers」中记录了上述 SessionID ，即 Set-Cookie 字段。这表示服务器针对 <code>/demo03</code> 这个 Get 请求，发回给浏览器的响应报文中携带了 SessionID (此时已保存到浏览器的 Cookie 中) 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200</span><br><span class="line">Set-Cookie: JSESSIONID=9B41CA00381B384676117432AA6C2F4A; Path=/pro08; HttpOnly</span><br><span class="line">Content-Length: 0</span><br><span class="line">Date: Wed, 12 Oct 2022 08:28:06 GMT</span><br><span class="line">Keep-Alive: timeout=20</span><br><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure><p>此时我们注意到，在调试控制台下查看「Request Headers」，其中并未出现上述 SessionID 。这进一步说明首次请求时浏览器并未携带会话标记，是 <strong>服务端首次处理该请求时生成并返回给浏览器的</strong> 。</p><p>接着我们刷新页面，发送第二次 <code>/demo03</code> Get 请求。此时「Request Headers」中可看到其携带了前述 SessionID ，即其中的 Cookie 字段。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">GET /pro08/demo03 HTTP/1.1</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Accept-Language: en,zh-CN;q=0.9,zh;q=0.8,ko-KR;q=0.7,ko;q=0.6,ja;q=0.5</span><br><span class="line">Cache-Control: max-age=0</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Cookie: JSESSIONID=9B41CA00381B384676117432AA6C2F4A</span><br><span class="line">Host: localhost:8080</span><br><span class="line">Sec-Fetch-Dest: document</span><br><span class="line">Sec-Fetch-Mode: navigate</span><br><span class="line">Sec-Fetch-Site: none</span><br><span class="line">Sec-Fetch-User: ?1</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36</span><br><span class="line">sec-ch-ua: &quot;Chromium&quot;;v=&quot;106&quot;, &quot;Google Chrome&quot;;v=&quot;106&quot;, &quot;Not;A=Brand&quot;;v=&quot;99&quot;</span><br><span class="line">sec-ch-ua-mobile: ?0</span><br></pre></td></tr></table></figure><p>而「Response Headers」中无 SessionID 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200</span><br><span class="line">Content-Length: 0</span><br><span class="line">Date: Wed, 12 Oct 2022 08:43:18 GMT</span><br><span class="line">Keep-Alive: timeout=20</span><br><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure><p>这是因为第一次请求后，服务器发回的响应报文中的 SesionID 已经记录在浏览器中，再次请求时，如我们看到的第二次请求的「Request Headers」那样，SessionID 携带于其中，服务端在处理第二次请求时，根据此 SessionID 得知这是同一次「会话」，也就不必再发回 SessionID 了。</p><p>从此示例中我们还可以得出如下结论。</p><ul><li><code>HttpSession</code> 实例对象只存在于服务器中。</li><li>cookie 本质是 <code>HttpSession</code> 实例的 ID，在服务器端生成，由服务器响应第一次请求时发回给浏览器。浏览器保存为本地 cookie，在此后的请求中携带该 sessionID ，以告知服务器当前请求属于哪一次会话，sessionID 相同的请求均为同一会话。</li></ul><br /><h4 id="相关方法"><a href="#相关方法" class="headerlink" title="相关方法"></a>相关方法</h4><p>与 session 相关的方法总结如下。</p><table><thead><tr><th>session 相关常用方法</th><th>描述</th></tr></thead><tbody><tr><td><code>req.getSession()</code></td><td>获取当前请求对应的会话，若无则创建一个新的会话。</td></tr><tr><td><code>req.getSession(true)</code></td><td>同 <code>req.getSession()</code></td></tr><tr><td><code>req.getSession(false)</code></td><td>获取当前请求对应的会话，若无则返回 <code>null</code>。</td></tr><tr><td><code>session.getId()</code></td><td>获取 SessionID</td></tr><tr><td><code>session.isNew()</code></td><td>判断是否为新创建的 session 。</td></tr><tr><td><code>session.getMaxInactiveInterval()</code></td><td>最大非激活间隔时长 (默认 1800s，即 30m) 。</td></tr><tr><td><code>session.setMaxInactiveInterval()</code></td><td>设置最大非激活间隔时长。</td></tr><tr><td><code>session.invalidate()</code></td><td>使会话立即失效。</td></tr><tr><td><code>session.getCreationTime()</code></td><td>获取会话创建时间。</td></tr><tr><td><code>session.getLastAccessedTime()</code></td><td>获取最近一次访问时间。</td></tr><tr><td><code>session.setAttribute()</code></td><td>保存指定数据到 session 作用域空间中</td></tr><tr><td><code>session.getAttribute()</code></td><td>从 session 作用域空间中获取指定数据</td></tr><tr><td><code>session.removeAttribute()</code></td><td>删除 session 作用域空间中的指定数据</td></tr></tbody></table><br /><h3 id="转发与重定向"><a href="#转发与重定向" class="headerlink" title="转发与重定向"></a>转发与重定向</h3><p>TODO: 示意图</p><br /><h4 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h4><p>转发 (forward) 。浏览器将请求发送到服务器，服务器根据请求信息找到对应的 servlet A，但 A 并不处理该请求，而是将其转发给 servlet B，这就是服务器端的请求转发，服务器端内的转发可经历多次，由具体实现决定。</p><p>在 <code>pro08-javaweb-servlet</code> 中新建 <code>Demo04Servlet</code> 和 <code>Demo05Servlet</code> 类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukiyama.servlets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 演示转发与重定向</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04Servlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;demo04...&quot;</span>);</span><br><span class="line">        <span class="comment">// 服务器端内部转发</span></span><br><span class="line">        req.getRequestDispatcher(<span class="string">&quot;demo07&quot;</span>).forward(req,resp);</span><br><span class="line">        <span class="comment">// resp.sendRedirect(&quot;demo05&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukiyama.servlets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 演示转发与重定向</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo05Servlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;demo05...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>web.xml</code> 及 Tomcat 设置不再赘述。运行后，访问 <code>http://localhost:8080/pro08/demo04</code> ，Tomcat 首先打印 <code>demo04...</code> ，接着打印 <code>demo05...</code> ，表明请求首先 <code>Demo04Servlet</code> 处理，随后通过 <code>servie</code> 方法中的 <code>getRequestDispatcher(&quot;demo05&quot;).forward(req, resp)</code> 转发给 <code>Demo05Servlet</code> 。虽被转发，但服务端的转发过程对浏览器不可见，浏览器地址栏无变化。</p><br /><h4 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h4><p>重定向 (redirect) 。浏览器将请求发送到服务器，服务器根据请求信息找到对应的 servlet A，但 A 并不处理该请求，而是发回一个响应，该响应告知客户端浏览器应访问一指定页面 (告知浏览器发起一个指定的请求)，这就是服务器端的请求重定向。</p><p>仍然利用 <code>Demo04Servlet</code> 和 <code>Demo05Servlet</code> 观察，将 <code>Demo04Servlet</code> 的 <code>service</code> 方法中的 <code>req.getRequestDispatcher(&quot;demo05&quot;).forward(req,resp);</code> 替换为 <code>resp.sendRedirect(&quot;demo05&quot;);</code> 。运行应用后也将依次打印 <code>demo04...</code> 和 <code>demo05...</code> 。但与转发不同的是，在浏览器调试控制台中可以看到请求了两次 (<code>demo04</code> 和 <code>demo05</code>) ，且第一次请求 (<code>demo04</code>) 的响应报文头 Respond Headers 中，可看到响应状态码为 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status">302</a> ，意为重定向，重定向到 <code>Location: demo05</code> 。 我们还能看到浏览器地址栏从 <code>http://localhost:8080/pro08/demo04</code> 变为了 <code>http://localhost:8080/pro08/demo05</code> 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 302</span><br><span class="line">Location: demo05</span><br><span class="line">Content-Length: 0</span><br><span class="line">Date: Wed, 12 Oct 2022 10:40:33 GMT</span><br><span class="line">Keep-Alive: timeout=20</span><br><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure><br /><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>Servlet <a href="https://docs.oracle.com/javaee/7/tutorial/servlets003.htm#BNAFO">作用域 (Scope) </a> 。web 应用各组件需要共享数据，这些共享的数据可共享的范围即此处讨论的「作用域」。这是一个不太容易理解的概念，详细说明如下。</p><p>「共享的数据」本质上是 web 应用中的基本数据类型数据或引用类型的对象实例。「共享范围」即所谓「作用域 (scope)」，从小到大可分为 <strong>page</strong> &#x2F; <strong>request</strong> &#x2F; <strong>session</strong> &#x2F; <strong>web context (application)</strong> 这四种，它们的本质是四种类对象 ( scope object, 见后表) ，即 <strong>「域对象」</strong> 。「作用域」不是一个确定的内存空间域，也不是一个明确的「时间域」，而是与四个具体的类对象相绑定的概念。当我们说一个被共享的实例 (例如 <code>String str</code> ) 的作用域是 session，我们指的是该 <code>str</code> 实例与一个具体的 <code>HttpSession</code> 实例 <code>httpSession</code> 产生了关联，要使用 <code>str</code> ，需要通过这个 <code>httpSession</code> 来获取。回想「session」一节中的例子，当 <code>httpSession</code> 不可用时，<code>str</code> 也即不可用，其他作用域同理。总之四种作用域分别表示共享的对象实例可在同一 <strong>JSP页面</strong> &#x2F; <strong>请求</strong> &#x2F; <strong>会话</strong> &#x2F; <strong>应用</strong> (对象实例) 中共享。</p><p>更详细地，对于一个对象实例 <code>Object value</code>，当我们要共享它时，先确定要共享的范围，即作用域，例如要在 session 作用域下共享，那么就要明确是在哪个 <code>HttpSession</code> 实例下共享，例如在实例 <code>httpSession</code> 中共享，于是我们通过 <code>httpSeesion.setAttribute(String name, Object value)</code> 来将 <code>value</code> 与 <code>httpSession</code> 绑定。当我们要使用 <code>value</code> 时，通过 <code>httpSession.getAttribute(String name)</code> 来获取。 <code>httpSeesion</code> 是执行 <code>setAttribute</code> 方法时的 <code>httpSession</code> ， <code>name</code> 是执行 <code>setAttribute</code> 方法时的参数 <code>String name</code> 。</p><p>如下是四种作用域及其对应的类，后续我们以一些场景展示对象实例如何在不同的作用域中共享。</p><table><thead><tr><th align="left">Scope Object</th><th align="left">Class</th><th align="left">Accessible From</th></tr></thead><tbody><tr><td align="left">Web context  (Application)</td><td align="left"><code>javax.servlet.ServletContext</code></td><td align="left">Web components within a web context. See <a href="https://docs.oracle.com/javaee/7/tutorial/servlets008.htm#BNAGL">Accessing the Web Context</a>.</td></tr><tr><td align="left">Session</td><td align="left"><code>javax.servlet.http.HttpSession</code></td><td align="left">Web components handling a request that belongs to the session. See <a href="https://docs.oracle.com/javaee/7/tutorial/servlets009.htm#BNAGM">Maintaining Client State</a>.</td></tr><tr><td align="left">Request</td><td align="left">Subtype of <code>javax.servlet.ServletRequest</code></td><td align="left">Web components handling the request.</td></tr><tr><td align="left">Page</td><td align="left"><code>javax.servlet.jsp.JspContext</code></td><td align="left">The JSP page that creates the object.</td></tr></tbody></table><br /><h4 id="request作用域"><a href="#request作用域" class="headerlink" title="request作用域"></a>request作用域</h4><p>在 <code>pro08-java-servlet</code> web子项目中创建 <code>Demo06Servlet</code> 和 <code>Demo07Servlet</code> 类演示 session 作用域。</p><p>在 <code>Demo06Servlet</code> 类的 <code>service</code> 方法内，向 request 作用域中设置属性名为 <code>name</code> 的数据，该数据 (属性值) 为字符串 <code>yukiyama</code> ，随后打印该字符串。并将请求转发给 <code>demo07</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukiyama.servlets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 演示 request 作用域</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo06Servlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        req.setAttribute(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;yukiyama&quot;</span>);</span><br><span class="line">        <span class="comment">// System.out.println(&quot;request: &quot; + req);</span></span><br><span class="line">        System.out.println(<span class="string">&quot;demo06:&quot;</span> + req.getAttribute(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">        <span class="comment">// 转发</span></span><br><span class="line">        req.getRequestDispatcher(<span class="string">&quot;demo07&quot;</span>).forward(req, resp);</span><br><span class="line">        <span class="comment">// 重定向</span></span><br><span class="line">        <span class="comment">// resp.sendRedirect(&quot;demo07&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>Demo07Servlet</code> 类的 <code>service</code> 方法中，按属性名 <code>name</code> ，从 request 作用域中获取相应的数据 (属性值) 并打印。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukiyama.servlets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 演示 request 作用域</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo07Servlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// System.out.println(&quot;request: &quot; + req);</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">name</span> <span class="operator">=</span> req.getAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;demo07: &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>web.xml</code> 完成相关配置，运行该 web 子工程，在浏览器中首先访问 <code>http://localhost:8080/demo06</code> ，可以看到在 Tomcat 控制台分别打印了 <code>demo06: yukiyama</code> 以及 <code>demo07: yukiyama</code> 。如我们所知，转发请求仍是同一请求，两次获取 <code>name</code> 都是在同一 request 作用域下，符合预期。</p><p>接着在 <code>Demo06Servlet</code> 的 <code>service</code> 方法中将转发语句替换为重定向语句 <code>resp.sendRedirect(&quot;demo07&quot;);</code> ，再次访问 <code>http://localhost:8080/demo06</code> ，可以看到 Tomcat 控制台分别打印了 <code>demo06: yukiyama</code> 以及 <code>demo07: null</code> 。这是重定向后的请求与第一次请求是两次不同的请求，因此第一次请求时的 request 作用域下的 <code>name</code> 无法在第二次请求的作用域中取到。</p><p>【我的疑惑。。。】</p><p>但是打印 request 实例的时候，正好相反。「转发」时两个 servlet 打印的 request 实例是不同的，但是「重定向」时两个 servlet 打印的 request 实例是相同的。</p><br /><h4 id="session作用域"><a href="#session作用域" class="headerlink" title="session作用域"></a>session作用域</h4><p>在 <code>pro08-java-servlet</code> web子项目中创建 <code>Demo08Servlet</code> 和 <code>Demo09Servlet</code> 类演示 session 作用域。</p><p>在 <code>Demo08Servlet</code> 类的 <code>service</code> 方法内，向 session 作用域中属性名为 <code>userName</code> 的数据，该数据 (属性值) 为字符串 <code>yukiyama</code> ，随后打印该字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukiyama.servlets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 演示 session 作用域</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo08Servlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        req.getSession().setAttribute(<span class="string">&quot;userName&quot;</span>, <span class="string">&quot;yukiyama&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">userName</span> <span class="operator">=</span> req.getSession().getAttribute(<span class="string">&quot;userName&quot;</span>);</span><br><span class="line">        System.out.println(userName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>Demo09Servlet</code> 类的 <code>service</code> 方法中获取 session 后，从该 session 作用域中，按属性名 <code>userName</code> 获取相应的数据 (属性值) 并打印。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukiyama.servlets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 演示 session 作用域</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo09Servlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">userName</span> <span class="operator">=</span> req.getSession().getAttribute(<span class="string">&quot;userName&quot;</span>);</span><br><span class="line">        System.out.println(userName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>web.xml</code> 完成相关配置，运行该 web 子工程，在浏览器中首先访问 <code>http://localhost:8080/demo08</code> ，可以在 Tomcat 控制台看到打印了 <code>yukiyama</code> 。此时我们将 URL 改为 <code>http://localhost:8080/demo09</code> ，可以看到 <code>yukiyama</code> 再次被打印。这是因为两次请求为同一次会话，而 <code>userName</code> 属性值保存在 session 作用域中。</p><p>但若此时我们打开另一个浏览器 (对于服务端 Tomcat 来说，这是另一个客户端) ，则会创建新的会话，由于 <code>yukiyama</code> 的是 session 作用域下的属性值，因此在另一个浏览器中访问 <code>http://localhost:8080/demo09</code> ，打印的是 <code>null</code> 。</p><br /><h4 id="web-context作用域"><a href="#web-context作用域" class="headerlink" title="web context作用域"></a>web context作用域</h4><p>在 <code>pro08-java-servlet</code> web子项目中创建 <code>Demo10Servlet</code> 和 <code>Demo11Servlet</code> 类演示 web context (application) 作用域。</p><p>在 <code>Demo10Servlet</code> 类的 <code>service</code> 方法内，向 web context 作用域中属性名为 <code>userName</code> 的数据，该数据 (属性值) 为字符串 <code>yukiyama</code> ，随后打印该字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukiyama.servlets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletContext;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 演示 web context (application) 作用域</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo10Servlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">app</span> <span class="operator">=</span> req.getServletContext();</span><br><span class="line">        app.setAttribute(<span class="string">&quot;userName&quot;</span>, <span class="string">&quot;yukiyama&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">userName</span> <span class="operator">=</span> app.getAttribute(<span class="string">&quot;userName&quot;</span>);</span><br><span class="line">        System.out.println( <span class="string">&quot;demo10&quot;</span> + userName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>Demo11Servlet</code> 类的 <code>service</code> 方法中获取 web context 后，从该 web context 作用域中，按属性名 <code>userName</code> 获取相应的数据 (属性值) 并打印。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukiyama.servlets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletContext;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 演示 session 作用域</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo11Servlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">app</span> <span class="operator">=</span> req.getServletContext();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">userName</span> <span class="operator">=</span> app.getAttribute(<span class="string">&quot;userName&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;demo11&quot;</span> + userName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>web.xml</code> 完成相关配置，运行该 web 子工程，在浏览器中首先访问 <code>http://localhost:8080/demo10</code> ，可以在 Tomcat 控制台看到打印了 <code>yukiyama</code> 。接着我们用另一个浏览器打开 <code>http://localhost:8080/demo11</code> ，可以看到 <code>yukiyama</code> 再次被打印。</p><p>只要该应用仍在运行，则处于该作用域的共享数据就一直能够获取到。</p><br /><h3 id="路径问题"><a href="#路径问题" class="headerlink" title="路径问题"></a>路径问题</h3><p>在 webapp 下的某个 html 文件中，若引用其他路径下的资源文件，有相对路径与绝对路径写法，建议写为绝对路径。在 html 页面中使用 <code>base</code> 标签定义绝对路径，则该页面中的其他路径自动拼接到 <code>base</code> 标签定义的路径之后，形成绝对路径。</p><p><img src="/Users/lixueshan/Library/Application%20Support/typora-user-images/image-20221013214718528.png" alt="image-20221013214718528"></p><br /><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>在 「HttpServlet」小结中我们通过一个示例观察了</p><br /><p>标签含义如下。</p><table><thead><tr><th>标签</th><th></th></tr></thead><tbody><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table><p><img src="/Users/lixueshan/Library/Application%20Support/typora-user-images/image-20221011171815593.png" alt="image-20221011171815593"></p><h2 id="Thymeleaf"><a href="#Thymeleaf" class="headerlink" title="Thymeleaf"></a>Thymeleaf</h2><p><a href="https://www.thymeleaf.org/">Thymeleaf</a> 是一种「视图模版」技术，支持在 Web 应用 (基于 servlet) 以及在非 Web 环境中工作。Thymeleaf 旨在完全取代 JSP，相比 JSP 的一大特点是实现了「自然模版 (natural tamplate)」，即利用 Thymeleaf 编写的 html 模版仍是一个 html 文件，且看起来以及工作起来均与 html 类似。当它工作在 Web 环境中时，能够动态渲染数据，在非 Web 环境中时就像静态 html 页面那样能够被浏览器解析。</p><br /><h3 id="入门示例-1"><a href="#入门示例-1" class="headerlink" title="入门示例"></a>入门示例</h3><p>创建 <code>pro09-fruit4-thymeleaf</code> 子工程演示 Thymeleaf 的使用。</p><br /><h4 id="引入Thymeleaf依赖"><a href="#引入Thymeleaf依赖" class="headerlink" title="引入Thymeleaf依赖"></a>引入Thymeleaf依赖</h4><p>首先在父工程中 <code>javaweb_in_action</code> 的 <code>pom.xml</code> 中引入 Thymeleaf 依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.thymeleaf<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.12.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接着在子工程子工程 <code>pro09-fruit4-thymeleaf</code> 的 <code>pom.xml</code> 中引用。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.thymeleaf<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意 mysql-connector 要像之前一样手动加入 (在 <code>WEB-INF</code> 目录中添加 <code>lib</code> 文件夹，导入 <code>mysql-connector-java-8.0.11.jar</code>)。</p><br /><h4 id="准备数据库-1"><a href="#准备数据库-1" class="headerlink" title="准备数据库"></a>准备数据库</h4><p>使用已在「Servlet」-「入门示例」-「准备数据库」中准备好的数据库 <code>fruitdb</code> 。</p><br /><h4 id="编写浏览器页面-1"><a href="#编写浏览器页面-1" class="headerlink" title="编写浏览器页面"></a>编写浏览器页面</h4><p>编写如下 <code>index.html</code> 页面，放在 <code>webapp &gt; WEB-INF</code> 目录下。可以看到引入了 Thymeleaf 的命名空间，<code>th</code> 即为 Thymeleaf 标签。</p><p>此外还有相应的 css 与图片资源文件，均可在 <a href="https://github.com/iyukiyama/javaweb_in_action">javaweb_in_action</a> 仓库中获取，此处不列出。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;css/index.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div_container&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div_fruit_list&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;center f30&quot;</span>&gt;</span>欢迎使用水果库存后台管理系统<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">id</span>=<span class="string">&quot;tbl_fruit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">&quot;w20&quot;</span>&gt;</span>名称<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">&quot;w20&quot;</span>&gt;</span>单价<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">&quot;w20&quot;</span>&gt;</span>库存<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">th</span>&gt;</span>操作<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;#lists.isEmpty(session.fruitList)&#125;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">&quot;4&quot;</span>&gt;</span>对不起，库存为空！<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span> <span class="attr">th:unless</span>=<span class="string">&quot;$&#123;#lists.isEmpty(session.fruitList)&#125;&quot;</span> <span class="attr">th:each</span>=<span class="string">&quot;fruit : $&#123;session.fruitList&#125;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;fruit.fname&#125;&quot;</span>&gt;</span>苹果<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;fruit.price&#125;&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;fruit.fcount&#125;&quot;</span>&gt;</span>20<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;imgs/del.jpg&quot;</span> <span class="attr">class</span>=<span class="string">&quot;delImg&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><br /><h4 id="编写FruitDao相关类-1"><a href="#编写FruitDao相关类-1" class="headerlink" title="编写FruitDao相关类"></a>编写FruitDao相关类</h4><p>与已在「Servlet」-「入门示例」-「编写FruitDao相关类」写好的相关类类似，不在此处列出，相关文件可以在 <a href="https://github.com/iyukiyama/javaweb_in_action">javaweb_in_action</a> 仓库中获取。</p><br /><h4 id="编写IndexServlet"><a href="#编写IndexServlet" class="headerlink" title="编写IndexServlet"></a>编写IndexServlet</h4><p>如下是 Servlet 具体实现类 <code>IndexServlet</code> 。需要注意的是，这里继承的不是 <code>HttpServlet</code> 而是 <code>ViewBaseServlet</code> 。 <code>ViewBaseServlet</code> 来自 Thymeleaf 源码，该类继承了 <code>HttpServlet</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukiyama.fruit.servlets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.yukiyama.fruit.dao.FruitDao;</span><br><span class="line"><span class="keyword">import</span> com.yukiyama.fruit.dao.impl.FruitDaoImpl;</span><br><span class="line"><span class="keyword">import</span> com.yukiyama.fruit.pojo.Fruit;</span><br><span class="line"><span class="keyword">import</span> com.yukiyama.myssm.myspringmvc.ViewBaseServlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpSession;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Servlet 从 3.0 版本开始支持注解方式的注册</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/index&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IndexServlet</span> <span class="keyword">extends</span> <span class="title class_">ViewBaseServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">FruitDao</span> <span class="variable">fruitDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FruitDaoImpl</span>();</span><br><span class="line">        List&lt;Fruit&gt; fruitList = fruitDao.getFruitList();</span><br><span class="line">        <span class="comment">// 保存到 session 作用域</span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> req.getSession();</span><br><span class="line">        session.setAttribute(<span class="string">&quot;fruitList&quot;</span>, fruitList);</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="built_in">super</span>.processTemplate(<span class="string">&quot;index&quot;</span>, req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ViewBaseServlet</code> 类。</p><p>该类中的 <code>processTemplate</code> 方法完成资源转发与数据渲染。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukiyama.myssm.myspringmvc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.thymeleaf.TemplateEngine;</span><br><span class="line"><span class="keyword">import</span> org.thymeleaf.context.WebContext;</span><br><span class="line"><span class="keyword">import</span> org.thymeleaf.templatemode.TemplateMode;</span><br><span class="line"><span class="keyword">import</span> org.thymeleaf.templateresolver.ServletContextTemplateResolver;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletContext;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ViewBaseServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> TemplateEngine templateEngine;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        <span class="comment">// 1. 获取 ServletContext 对象</span></span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> <span class="built_in">this</span>.getServletContext();</span><br><span class="line">        <span class="comment">// 2. 创建 Thymeleaf 解析器对象</span></span><br><span class="line">        <span class="type">ServletContextTemplateResolver</span> <span class="variable">templateResolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletContextTemplateResolver</span>(servletContext);</span><br><span class="line">        <span class="comment">// 3. 给解析器对象设置参数</span></span><br><span class="line">        <span class="comment">// ① HTML 是默认模式，明确设置是为了代码更容易理解</span></span><br><span class="line">        templateResolver.setTemplateMode(TemplateMode.HTML);</span><br><span class="line">        <span class="comment">// ② 设置前缀</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">viewPrefix</span> <span class="operator">=</span> servletContext.getInitParameter(<span class="string">&quot;view-prefix&quot;</span>);</span><br><span class="line">        templateResolver.setPrefix(viewPrefix);</span><br><span class="line">        <span class="comment">// ③ 设置后缀</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">viewSuffix</span> <span class="operator">=</span> servletContext.getInitParameter(<span class="string">&quot;view-suffix&quot;</span>);</span><br><span class="line">        templateResolver.setSuffix(viewSuffix);</span><br><span class="line">        <span class="comment">// ④ 设置缓存过期时间（毫秒）</span></span><br><span class="line">        templateResolver.setCacheTTLMs(<span class="number">60000L</span>);</span><br><span class="line">        <span class="comment">// ⑤ 设置是否缓存</span></span><br><span class="line">        templateResolver.setCacheable(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// ⑥ 设置服务器端编码方式</span></span><br><span class="line">        templateResolver.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 4. 创建模板引擎对象</span></span><br><span class="line">        templateEngine = <span class="keyword">new</span> <span class="title class_">TemplateEngine</span>();</span><br><span class="line">        <span class="comment">// 5. 给模板引擎对象设置模板解析器</span></span><br><span class="line">        templateEngine.setTemplateResolver(templateResolver);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">processTemplate</span><span class="params">(String templateName, HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 1. 设置响应体内容类型和字符集</span></span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 2. 创建WebContext对象</span></span><br><span class="line">        <span class="type">WebContext</span> <span class="variable">webContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WebContext</span>(req, resp, getServletContext());</span><br><span class="line">        <span class="comment">// 3. 处理模板数据</span></span><br><span class="line">        templateEngine.process(templateName, webContext, resp.getWriter());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h4 id="配置web-xml-1"><a href="#配置web-xml-1" class="headerlink" title="配置web.xml"></a>配置web.xml</h4><p>要将浏览器请求映射到具体的 Servlet 实现类，此前都是通过在 <code>web.xml</code> 中配置 <code>&lt;servlet&gt;</code> 以及 <code>&lt;servlet-mapping&gt;</code> 标签来完成。Servlet 3.0 版本开始支持 <strong>注解方式映射</strong> ，即在 Servlet 实现类上添加 <code>@WebServlet</code> 类注解完成与请求的映射，其 <code>value</code> 属性为请求路径字符串。在前面给出的 <code>IndexServlet</code> 中已写好。因此这部分配置无需借助 web.xml 完成。但需要在 web.xml  中配置「上下文参数」。</p><p>配置「上下文参数」，设置 <strong>视图前缀 (view-prefix)</strong> 与 <strong>视图后缀 (view-suffix)</strong> 。这两个参数在 <code>ViewBaseServlet</code> 类的 <code>init</code> 方法中被获取。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置上下文参数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>view-prefix<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>view-suffix<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>.html<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><br /><h4 id="配置Tomcat-1"><a href="#配置Tomcat-1" class="headerlink" title="配置Tomcat"></a>配置Tomcat</h4><p>请参考「Tomcat」-「部署应用」-「自动」。</p><br /><h4 id="运行-1"><a href="#运行-1" class="headerlink" title="运行"></a>运行</h4><p>完成上述步骤后，<code>pro09-fruit4-thymeleaf</code> 子工程目录如下，相关的文件都可以在 <a href="https://github.com/iyukiyama/javaweb_in_action">javaweb_in_action</a> 仓库中获取。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">pro09-fruit4-thymeleaf</span><br><span class="line">├── pom.xml</span><br><span class="line">└── src</span><br><span class="line">    └── main</span><br><span class="line">        ├── java</span><br><span class="line">        │   └── com</span><br><span class="line">        │       └── yukiyama</span><br><span class="line">        │           ├── fruit</span><br><span class="line">        │           │   ├── dao</span><br><span class="line">        │           │   │   ├── FruitDao.java</span><br><span class="line">        │           │   │   └── impl</span><br><span class="line">        │           │   │       └── FruitDaoImpl.java</span><br><span class="line">        │           │   ├── pojo</span><br><span class="line">        │           │   │   └── Fruit.java</span><br><span class="line">        │           │   └── servlets</span><br><span class="line">        │           │       └── IndexServlet.java</span><br><span class="line">        │           └── myssm</span><br><span class="line">        │               ├── basedao</span><br><span class="line">        │               │   └── BaseDAO.java</span><br><span class="line">        │               └── myspringmvc</span><br><span class="line">        │                   └── ViewBaseServlet.java</span><br><span class="line">        ├── resources</span><br><span class="line">        └── webapp</span><br><span class="line">            ├── WEB-INF</span><br><span class="line">            │   ├── lib</span><br><span class="line">            │   │   └── mysql-connector-java-8.0.11.jar</span><br><span class="line">            │   └── web.xml</span><br><span class="line">            ├── css</span><br><span class="line">            │   └── index.css</span><br><span class="line">            ├── imgs</span><br><span class="line">            │   └── del.jpg</span><br><span class="line">            └── index.html</span><br><span class="line"></span><br><span class="line">19 directories, 12 files</span><br></pre></td></tr></table></figure><p>至此，我们完成了实现目标功能所需的所有工作。运行该工程，浏览器自动弹出 <code>index.html</code> 页面。注意此时 URL 为 <code>http://localhost:8080/pro09/index</code> (无 <code>.html</code> 文件名后缀)，但能够打开 <code>index.html</code> 页面。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/javaweb_in_action/pro09_index.png" alt="pro09_index"></p><br /><h3 id="编辑和更新示例"><a href="#编辑和更新示例" class="headerlink" title="编辑和更新示例"></a>编辑和更新示例</h3><p>创建 <code>pro10-fruit5-thymeleaf</code> 子工程，演示使用 Thymeleaf 编写 html 页面，实现在浏览器页面上编辑获取到的数据库信息，并将编辑后的结果更新到数据库中。</p><p>该子工程直接拷贝「入门示例」的 <code>pro09-fruit4-thymeleaf</code> ，并在此之上扩展。首先增加 <code>edit.html</code> 页面，使得点击 <code>index</code> 页面表格中的「名称」，例如「红富士」，可以跳转到「红富士」的编辑页面，编辑页面也为一表格，自动获取数据库中关于红富士的水果信息显示在文本框中，即「名称」、「价格」、「库存」、「备注」。编辑文本框修改字段后点击底部的「修改」按钮使修改反映到数据库中。预先展示编辑页面如下。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/javaweb_in_action/edit-page.png" alt="edit-page"></p><p>后续的「删除和添加示例」章节会继续在 <code>pro10-fruit5-thymeleaf</code> 子工程中演示增删条目、分页和按关键字查询的功能，预先列出完成这些演示后对应的后续的 <code>pro12-fruit7-keyword</code> 工程的文件结构，如下。所有文件均可在 <a href="https://github.com/iyukiyama/javaweb_in_action">javaweb_in_action</a> 仓库中获取。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">pro12-fruit7-keyword</span><br><span class="line">├── pom.xml</span><br><span class="line">└── src</span><br><span class="line">    └── main</span><br><span class="line">        ├── java</span><br><span class="line">        │   └── com</span><br><span class="line">        │       └── yukiyama</span><br><span class="line">        │           ├── fruit</span><br><span class="line">        │           │   ├── dao</span><br><span class="line">        │           │   │   ├── FruitDao.java</span><br><span class="line">        │           │   │   └── impl</span><br><span class="line">        │           │   │       └── FruitDaoImpl.java</span><br><span class="line">        │           │   ├── pojo</span><br><span class="line">        │           │   │   └── Fruit.java</span><br><span class="line">        │           │   └── servlets</span><br><span class="line">        │           │       ├── AddServlet.java</span><br><span class="line">        │           │       ├── DelServlet.java</span><br><span class="line">        │           │       ├── EditServlet.java</span><br><span class="line">        │           │       ├── IndexServlet.java</span><br><span class="line">        │           │       └── UpdateServlet.java</span><br><span class="line">        │           └── myssm</span><br><span class="line">        │               ├── basedao</span><br><span class="line">        │               │   └── BaseDAO.java</span><br><span class="line">        │               ├── myspringmvc</span><br><span class="line">        │               │   └── ViewBaseServlet.java</span><br><span class="line">        │               └── util</span><br><span class="line">        │                   └── StringUtils.java</span><br><span class="line">        ├── resources</span><br><span class="line">        └── webapp</span><br><span class="line">            ├── WEB-INF</span><br><span class="line">            │   ├── lib</span><br><span class="line">            │   │   └── mysql-connector-java-8.0.11.jar</span><br><span class="line">            │   └── web.xml</span><br><span class="line">            ├── add.html</span><br><span class="line">            ├── css</span><br><span class="line">            │   ├── add.css</span><br><span class="line">            │   ├── edit.css</span><br><span class="line">            │   └── index.css</span><br><span class="line">            ├── edit.html</span><br><span class="line">            ├── imgs</span><br><span class="line">            │   └── del.jpg</span><br><span class="line">            ├── index.html</span><br><span class="line">            ├── js</span><br><span class="line">            │   └── index.js</span><br><span class="line">            └── web</span><br><span class="line">                └── WEB-INF</span><br><span class="line">                    └── web.xml</span><br><span class="line"></span><br><span class="line">23 directories, 23 files</span><br></pre></td></tr></table></figure><br /><h4 id="引入Thymeleaf依赖-1"><a href="#引入Thymeleaf依赖-1" class="headerlink" title="引入Thymeleaf依赖"></a>引入Thymeleaf依赖</h4><p>同「入门示例」。父工程已引入，在子工程 <code>pro10-fruit5-thymeleaf</code> 的 <code>pom.xml</code> 中引入。mysql-connector 依赖的处理也同前。</p><br /><h4 id="准备数据库-2"><a href="#准备数据库-2" class="headerlink" title="准备数据库"></a>准备数据库</h4><p>「入门示例」中已完成。</p><br /><h4 id="编写浏览器页面-2"><a href="#编写浏览器页面-2" class="headerlink" title="编写浏览器页面"></a>编写浏览器页面</h4><h5 id="index-html"><a href="#index-html" class="headerlink" title="index.html"></a>index.html</h5><p>在「入门示例」的基础上主要多了如下一行。用于跳转到编辑页。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;fruit.fname&#125;&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/edit.do(fid=$&#123;fruit.fid&#125;)&#125;&quot;</span>&gt;</span>苹果<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>index.html</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;css/index.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div_container&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div_fruit_list&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;center f30&quot;</span>&gt;</span>欢迎使用水果库存后台管理系统<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">id</span>=<span class="string">&quot;tbl_fruit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">&quot;w20&quot;</span>&gt;</span>名称<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">&quot;w20&quot;</span>&gt;</span>单价<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">&quot;w20&quot;</span>&gt;</span>库存<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">th</span>&gt;</span>操作<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;#lists.isEmpty(session.fruitList)&#125;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">&quot;4&quot;</span>&gt;</span>对不起，库存为空！<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span> <span class="attr">th:unless</span>=<span class="string">&quot;$&#123;#lists.isEmpty(session.fruitList)&#125;&quot;</span> <span class="attr">th:each</span>=<span class="string">&quot;fruit : $&#123;session.fruitList&#125;&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  &lt;td&gt;&lt;a th:text=&quot;$&#123;fruit.fname&#125;&quot; th:href=&quot;@&#123;&#x27;/edit.do?fid=&#x27;+$&#123;fruit.fid&#125;&#125;&quot;&gt;苹果&lt;/a&gt;&lt;/td&gt;  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;fruit.fname&#125;&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/edit.do(fid=$&#123;fruit.fid&#125;)&#125;&quot;</span>&gt;</span>苹果<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;fruit.price&#125;&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;fruit.fcount&#125;&quot;</span>&gt;</span>20<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;imgs/del.jpg&quot;</span> <span class="attr">class</span>=<span class="string">&quot;delImg&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><br /><h5 id="edit-html"><a href="#edit-html" class="headerlink" title="edit.html"></a>edit.html</h5><p>编写如下 <code>edit.html</code> 页面，放在 <code>webapp &gt; WEB-INF</code> 目录下。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;css/edit.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div_container&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div_fruit_list&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;center f30&quot;</span>&gt;</span>编辑库存信息<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/update.do&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">th:object</span>=<span class="string">&quot;$&#123;fruit&#125;&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 隐藏域 ： 功能类似于文本框 ， 它的值会随着表单的发送也会发送给服务器，但是界面上用户看不到 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;fid&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;*&#123;fid&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">id</span>=<span class="string">&quot;tbl_fruit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">&quot;w20&quot;</span>&gt;</span>名称：<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;fname&quot; th:value=&quot;$&#123;fruit.fname&#125;&quot;/&gt;&lt;/td&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;fname&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;*&#123;fname&#125;&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">&quot;w20&quot;</span>&gt;</span>单价：<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;price&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;*&#123;price&#125;&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">&quot;w20&quot;</span>&gt;</span>库存：<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;fcount&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;*&#123;fcount&#125;&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">&quot;w20&quot;</span>&gt;</span>备注：<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;remark&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;*&#123;remark&#125;&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">th</span> <span class="attr">colspan</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;修改&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><br /><h4 id="编写FruitDao相关类-2"><a href="#编写FruitDao相关类-2" class="headerlink" title="编写FruitDao相关类"></a>编写FruitDao相关类</h4><p>「入门示例」中已完成。有部分调整，请参考仓库。</p><br /><h4 id="编写Servlet具体实现类"><a href="#编写Servlet具体实现类" class="headerlink" title="编写Servlet具体实现类"></a>编写Servlet具体实现类</h4><h5 id="IndexServlet"><a href="#IndexServlet" class="headerlink" title="IndexServlet"></a>IndexServlet</h5><p>「入门示例」中已完成。</p><br /><h5 id="EditServlet"><a href="#EditServlet" class="headerlink" title="EditServlet"></a>EditServlet</h5><p>与 <code>/edit.do</code> 绑定。</p><p>TODO：说明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukiyama.fruit.servlets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.yukiyama.fruit.dao.FruitDao;</span><br><span class="line"><span class="keyword">import</span> com.yukiyama.fruit.dao.impl.FruitDaoImpl;</span><br><span class="line"><span class="keyword">import</span> com.yukiyama.fruit.pojo.Fruit;</span><br><span class="line"><span class="keyword">import</span> com.yukiyama.myssm.myspringmvc.ViewBaseServlet;</span><br><span class="line"><span class="keyword">import</span> com.yukiyama.myssm.util.StringUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpSession;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(&quot;/edit.do&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EditServlet</span> <span class="keyword">extends</span> <span class="title class_">ViewBaseServlet</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">FruitDao</span> <span class="variable">fruitDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FruitDaoImpl</span>();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">fidStr</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;fid&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isNotEmpty(fidStr))&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">fid</span> <span class="operator">=</span> Integer.parseInt(fidStr);</span><br><span class="line">            <span class="type">Fruit</span> <span class="variable">fruit</span> <span class="operator">=</span> fruitDao.getFruitByFid(fid);</span><br><span class="line">            req.setAttribute(<span class="string">&quot;fruit&quot;</span>, fruit);</span><br><span class="line">            <span class="built_in">super</span>.processTemplate(<span class="string">&quot;edit&quot;</span>, req, resp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h5 id="UpdateServlet"><a href="#UpdateServlet" class="headerlink" title="UpdateServlet"></a>UpdateServlet</h5><p>与 <code>/update.do</code> 绑定。</p><p>TODO：说明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukiyama.fruit.servlets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.yukiyama.fruit.dao.FruitDao;</span><br><span class="line"><span class="keyword">import</span> com.yukiyama.fruit.dao.impl.FruitDaoImpl;</span><br><span class="line"><span class="keyword">import</span> com.yukiyama.fruit.pojo.Fruit;</span><br><span class="line"><span class="keyword">import</span> com.yukiyama.myssm.myspringmvc.ViewBaseServlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(&quot;/update.do&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UpdateServlet</span> <span class="keyword">extends</span> <span class="title class_">ViewBaseServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">FruitDao</span> <span class="variable">fruitDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FruitDaoImpl</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//1.设置编码</span></span><br><span class="line">        request.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.获取参数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fidStr</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;fid&quot;</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">fid</span> <span class="operator">=</span> Integer.parseInt(fidStr);</span><br><span class="line">        <span class="type">String</span> <span class="variable">fname</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;fname&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">priceStr</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;price&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">price</span> <span class="operator">=</span> Integer.parseInt(priceStr);</span><br><span class="line">        <span class="type">String</span> <span class="variable">fcountStr</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;fcount&quot;</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">fcount</span> <span class="operator">=</span> Integer.parseInt(fcountStr);</span><br><span class="line">        <span class="type">String</span> <span class="variable">remark</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;remark&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.执行更新</span></span><br><span class="line">        fruitDao.updateFruit(<span class="keyword">new</span> <span class="title class_">Fruit</span>(fid,fname, price ,fcount ,remark ));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.资源跳转</span></span><br><span class="line">        <span class="comment">//super.processTemplate(&quot;index&quot;,request,response); // 想到于跳转</span></span><br><span class="line">        <span class="comment">//request.getRequestDispatcher(&quot;index.html&quot;).forward(request,response);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//此处需要重定向，目的是重新给IndexServlet发请求，重新获取furitList，然后覆盖到session中，这样index.html页面上显示的session中的数据才是最新的</span></span><br><span class="line">        response.sendRedirect(<span class="string">&quot;index&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h4 id="配置web-xml-2"><a href="#配置web-xml-2" class="headerlink" title="配置web.xml"></a>配置web.xml</h4><p>同「入门示例」。</p><br /><h4 id="配置Tomcat-2"><a href="#配置Tomcat-2" class="headerlink" title="配置Tomcat"></a>配置Tomcat</h4><p>方法同前，略。</p><br /><h4 id="运行-2"><a href="#运行-2" class="headerlink" title="运行"></a>运行</h4><p>完成上述步骤后，运行 <code>pro10-fruit5-thymeleaf</code> 应用。浏览器自动弹出 <code>index.html</code> 页面。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/javaweb_in_action/pro10-index-link.png" alt="pro10-index-link"></p><p>可以看到所有「名称」都变为了链接，点击后跳转到编辑页。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/javaweb_in_action/edit-page.png" alt="edit-page"></p><p>编辑并提交后，回到 index 页面，这是通过 <code>UpdateServlet</code> 类 <code>doPost</code> 方法中的 <code>response.sendRedirect(&quot;index&quot;);</code> 做到的 。页面显示正确 (单价改成了 55，库存改成了 160) 。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/javaweb_in_action/after-added-index.png" alt="after-added-index"></p><p>接着查看到数据库，相关项确实更新了。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_fruit;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----+-----------+-------+--------+--------------------------------+</span></span><br><span class="line"><span class="operator">|</span> fid <span class="operator">|</span> fname     <span class="operator">|</span> price <span class="operator">|</span> fcount <span class="operator">|</span> remark                         <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----+-----------+-------+--------+--------------------------------+</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">1</span> <span class="operator">|</span> 红富士    <span class="operator">|</span>    <span class="number">55</span> <span class="operator">|</span>    <span class="number">160</span> <span class="operator">|</span> 红富士也是苹果！               <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">2</span> <span class="operator">|</span> 大瓜      <span class="operator">|</span>     <span class="number">5</span> <span class="operator">|</span>    <span class="number">100</span> <span class="operator">|</span> 王校长的瓜真香                 <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">3</span> <span class="operator">|</span> 南瓜      <span class="operator">|</span>     <span class="number">4</span> <span class="operator">|</span>    <span class="number">456</span> <span class="operator">|</span> 水果真好吃                     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">4</span> <span class="operator">|</span> 苦瓜      <span class="operator">|</span>     <span class="number">5</span> <span class="operator">|</span>     <span class="number">55</span> <span class="operator">|</span> 苦瓜很好吃                     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">5</span> <span class="operator">|</span> 莲雾      <span class="operator">|</span>     <span class="number">9</span> <span class="operator">|</span>     <span class="number">99</span> <span class="operator">|</span> 莲雾是一种神奇的水果           <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">6</span> <span class="operator">|</span> 羊角蜜    <span class="operator">|</span>     <span class="number">4</span> <span class="operator">|</span>     <span class="number">30</span> <span class="operator">|</span> 羊角蜜是一种神奇的瓜           <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">7</span> <span class="operator">|</span> 啃大瓜    <span class="operator">|</span>    <span class="number">13</span> <span class="operator">|</span>    <span class="number">123</span> <span class="operator">|</span> 孤瓜                           <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">38</span> <span class="operator">|</span> apple     <span class="operator">|</span>    <span class="number">10</span> <span class="operator">|</span>    <span class="number">100</span> <span class="operator">|</span> apple added                    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----+-----------+-------+--------+--------------------------------+</span></span><br><span class="line"><span class="number">8</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.04</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><br /><h3 id="删除和添加示例"><a href="#删除和添加示例" class="headerlink" title="删除和添加示例"></a>删除和添加示例</h3><p>继续在 <code>pro10-fruit5-thymeleaf</code> 子工程中为库存系统增加「删除」和「新增」数据的功能。</p><br /><h4 id="增加删除功能"><a href="#增加删除功能" class="headerlink" title="增加删除功能"></a>增加删除功能</h4><p>更新 <code>index.html</code>， 为删除 icon 添加点击事件。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;css/index.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">language</span>=<span class="string">&quot;JavaScript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;js/index.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div_container&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div_fruit_list&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;center f30&quot;</span>&gt;</span>欢迎使用水果库存后台管理系统<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">id</span>=<span class="string">&quot;tbl_fruit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">&quot;w20&quot;</span>&gt;</span>名称<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">&quot;w20&quot;</span>&gt;</span>单价<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">&quot;w20&quot;</span>&gt;</span>库存<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">th</span>&gt;</span>操作<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;#lists.isEmpty(session.fruitList)&#125;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">&quot;4&quot;</span>&gt;</span>对不起，库存为空！<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span> <span class="attr">th:unless</span>=<span class="string">&quot;$&#123;#lists.isEmpty(session.fruitList)&#125;&quot;</span> <span class="attr">th:each</span>=<span class="string">&quot;fruit : $&#123;session.fruitList&#125;&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  &lt;td&gt;&lt;a th:text=&quot;$&#123;fruit.fname&#125;&quot; th:href=&quot;@&#123;&#x27;/edit.do?fid=&#x27;+$&#123;fruit.fid&#125;&#125;&quot;&gt;苹果&lt;/a&gt;&lt;/td&gt;  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;fruit.fname&#125;&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/edit.do(fid=$&#123;fruit.fid&#125;)&#125;&quot;</span>&gt;</span>苹果<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;fruit.price&#125;&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;fruit.fcount&#125;&quot;</span>&gt;</span>20<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--  &lt;td&gt;&lt;img src=&quot;imgs/del.jpg&quot; class=&quot;delImg&quot; th:onclick=&quot;&#x27;delFruit(&#x27;+$&#123;fruit.fid&#125;+&#x27;)&#x27;&quot;/&gt;&lt;/td&gt;  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;imgs/del.jpg&quot;</span> <span class="attr">class</span>=<span class="string">&quot;delImg&quot;</span> <span class="attr">th:onclick</span>=<span class="string">&quot;|delFruit($&#123;fruit.fid&#125;)|&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中， <code>index.js</code> 如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">delFruit</span>(<span class="params">fid</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_">confirm</span>(<span class="string">&#x27;是否确认删除？&#x27;</span>))&#123;</span><br><span class="line">        <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span>=<span class="string">&#x27;del.do?fid=&#x27;</span>+fid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h4 id="新增DelServlet实现类"><a href="#新增DelServlet实现类" class="headerlink" title="新增DelServlet实现类"></a>新增DelServlet实现类</h4><p>如下，新增 <code>DelServlet</code> 实现类。<code>FruitDao</code> 和 <code>FruitDaoImpl</code> 增加 <code>delFruit</code> 方法。</p><p>TODO：说明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukiyama.fruit.servlets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.yukiyama.fruit.dao.FruitDao;</span><br><span class="line"><span class="keyword">import</span> com.yukiyama.fruit.dao.impl.FruitDaoImpl;</span><br><span class="line"><span class="keyword">import</span> com.yukiyama.myssm.myspringmvc.ViewBaseServlet;</span><br><span class="line"><span class="keyword">import</span> com.yukiyama.myssm.util.StringUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(&quot;/del.do&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DelServlet</span> <span class="keyword">extends</span> <span class="title class_">ViewBaseServlet</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">FruitDao</span> <span class="variable">fruitDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FruitDaoImpl</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">fidStr</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;fid&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isNotEmpty(fidStr))&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">fid</span> <span class="operator">=</span> Integer.parseInt(fidStr);</span><br><span class="line">            fruitDao.delFruit(fid);</span><br><span class="line">            response.sendRedirect(<span class="string">&quot;index&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行该子工程，点击最后一行的删除 icon，弹出提示信息，点击「OK」删除。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/javaweb_in_action/index-delete.png" alt="index-delete"></p><p>与编辑功能类似，删除后跳转回 index 页面，可以看到删除完成。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/javaweb_in_action/index-after-deletion.png" alt="index-after-deletion"></p><br /><h4 id="增加新增功能"><a href="#增加新增功能" class="headerlink" title="增加新增功能"></a>增加新增功能</h4><p>继续在 <code>index.html</code> 中增加新增库存条目的功能，如下。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;css/index.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">language</span>=<span class="string">&quot;JavaScript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;js/index.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div_container&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div_fruit_list&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;center f30&quot;</span>&gt;</span>欢迎使用水果库存后台管理系统<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;border:0px solid red;width:60%;margin-left:20%;text-align:right;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/add.html&#125;&quot;</span> <span class="attr">style</span>=<span class="string">&quot;border:0px solid blue;margin-bottom:4px;&quot;</span>&gt;</span>添加新库存记录<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">id</span>=<span class="string">&quot;tbl_fruit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">&quot;w20&quot;</span>&gt;</span>名称<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">&quot;w20&quot;</span>&gt;</span>单价<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">&quot;w20&quot;</span>&gt;</span>库存<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">th</span>&gt;</span>操作<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;#lists.isEmpty(session.fruitList)&#125;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">&quot;4&quot;</span>&gt;</span>对不起，库存为空！<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span> <span class="attr">th:unless</span>=<span class="string">&quot;$&#123;#lists.isEmpty(session.fruitList)&#125;&quot;</span> <span class="attr">th:each</span>=<span class="string">&quot;fruit : $&#123;session.fruitList&#125;&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  &lt;td&gt;&lt;a th:text=&quot;$&#123;fruit.fname&#125;&quot; th:href=&quot;@&#123;&#x27;/edit.do?fid=&#x27;+$&#123;fruit.fid&#125;&#125;&quot;&gt;苹果&lt;/a&gt;&lt;/td&gt;  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;fruit.fname&#125;&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/edit.do(fid=$&#123;fruit.fid&#125;)&#125;&quot;</span>&gt;</span>苹果<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;fruit.price&#125;&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;fruit.fcount&#125;&quot;</span>&gt;</span>20<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--  &lt;td&gt;&lt;img src=&quot;imgs/del.jpg&quot; class=&quot;delImg&quot; th:onclick=&quot;&#x27;delFruit(&#x27;+$&#123;fruit.fid&#125;+&#x27;)&#x27;&quot;/&gt;&lt;/td&gt;  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;imgs/del.jpg&quot;</span> <span class="attr">class</span>=<span class="string">&quot;delImg&quot;</span> <span class="attr">th:onclick</span>=<span class="string">&quot;|delFruit($&#123;fruit.fid&#125;)|&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><br /><h4 id="新增AddServlet实现类"><a href="#新增AddServlet实现类" class="headerlink" title="新增AddServlet实现类"></a>新增AddServlet实现类</h4><p>如下，新增 <code>AddServlet</code> 实现类。<code>FruitDao</code> 和 <code>FruitDaoImpl</code> 增加 <code>addFruit</code> 方法。</p><p>TODO：说明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukiyama.fruit.servlets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.yukiyama.fruit.dao.FruitDao;</span><br><span class="line"><span class="keyword">import</span> com.yukiyama.fruit.dao.impl.FruitDaoImpl;</span><br><span class="line"><span class="keyword">import</span> com.yukiyama.fruit.pojo.Fruit;</span><br><span class="line"><span class="keyword">import</span> com.yukiyama.myssm.myspringmvc.ViewBaseServlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(&quot;/add.do&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AddServlet</span> <span class="keyword">extends</span> <span class="title class_">ViewBaseServlet</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">FruitDao</span> <span class="variable">fruitDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FruitDaoImpl</span>();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//1.设置编码</span></span><br><span class="line">        req.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.获取参数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fname</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;fname&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">priceStr</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;price&quot;</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">price</span> <span class="operator">=</span> Integer.parseInt(priceStr);</span><br><span class="line">        <span class="type">String</span> <span class="variable">fcountStr</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;fcount&quot;</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">fcount</span> <span class="operator">=</span> Integer.parseInt(fcountStr);</span><br><span class="line">        <span class="type">String</span> <span class="variable">remark</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;remark&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Fruit</span> <span class="variable">fruit</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Fruit</span>(<span class="number">0</span>, fname, price, fcount, remark);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.执行添加</span></span><br><span class="line">        fruitDao.addFruit(fruit);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.资源跳转</span></span><br><span class="line">        <span class="comment">//super.processTemplate(&quot;index&quot;,request,response); // 想到于跳转</span></span><br><span class="line">        <span class="comment">//request.getRequestDispatcher(&quot;index.html&quot;).forward(request,response);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//此处需要重定向，目的是重新给IndexServlet发请求，重新获取furitList，然后覆盖到session中，这样index.html页面上显示的session中的数据才是最新的</span></span><br><span class="line">        resp.sendRedirect(<span class="string">&quot;index&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行该子工程，可以看到 index 页表格右上角出现了「添加新库存记录」的可点击链接。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/javaweb_in_action/index-add.png" alt="index-add"></p><p>点击后跳转到新增库存信息编辑页面。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/javaweb_in_action/add-page.png" alt="add-page"></p><p>编辑后点击「添加」。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/javaweb_in_action/add-editing.png" alt="add-editing"></p><p>跳转到 index 页面，可以看到新增的库存信息已经更新到该页面表格中。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/javaweb_in_action/index-after-addition.png" alt="index-after-addition"></p><br /><h3 id="分页示例"><a href="#分页示例" class="headerlink" title="分页示例"></a>分页示例</h3><p>复制一份 <code>pro10-fruit5-thymeleaf</code> ，重命名为 <code>pro11-fruit6-pagination</code> ，使用此子工程中为库存系统增加表格分页展示的功能。</p><br /><h4 id="增加分页功能"><a href="#增加分页功能" class="headerlink" title="增加分页功能"></a>增加分页功能</h4><p>更新 <code>index.html</code>， 在 <code>&lt;table&gt;</code> 标签下新增分页用的按钮，并设置点击事件。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;css/index.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">language</span>=<span class="string">&quot;JavaScript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;js/index.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div_container&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div_fruit_list&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;center f30&quot;</span>&gt;</span>欢迎使用水果库存后台管理系统<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;border:0px solid red;width:60%;margin-left:20%;text-align:right;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/add.html&#125;&quot;</span> <span class="attr">style</span>=<span class="string">&quot;border:0px solid blue;margin-bottom:4px;&quot;</span>&gt;</span>添加新库存记录<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">id</span>=<span class="string">&quot;tbl_fruit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">&quot;w20&quot;</span>&gt;</span>名称1<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">&quot;w20&quot;</span>&gt;</span>单价<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">&quot;w20&quot;</span>&gt;</span>库存<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">th</span>&gt;</span>操作<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;#lists.isEmpty(session.fruitList)&#125;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">&quot;4&quot;</span>&gt;</span>对不起，库存为空！<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span> <span class="attr">th:unless</span>=<span class="string">&quot;$&#123;#lists.isEmpty(session.fruitList)&#125;&quot;</span> <span class="attr">th:each</span>=<span class="string">&quot;fruit : $&#123;session.fruitList&#125;&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;td&gt;&lt;a th:text=&quot;$&#123;fruit.fname&#125;&quot; th:href=&quot;@&#123;&#x27;/edit.do?fid=&#x27;+$&#123;fruit.fid&#125;&#125;&quot;&gt;苹果&lt;/a&gt;&lt;/td&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;fruit.fname&#125;&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/edit.do(fid=$&#123;fruit.fid&#125;)&#125;&quot;</span>&gt;</span>苹果<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;fruit.price&#125;&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;fruit.fcount&#125;&quot;</span>&gt;</span>20<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;td&gt;&lt;img src=&quot;imgs/del.jpg&quot; class=&quot;delImg&quot; th:onclick=&quot;&#x27;delFruit(&#x27;+$&#123;fruit.fid&#125;+&#x27;)&#x27;&quot;/&gt;&lt;/td&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;imgs/del.jpg&quot;</span> <span class="attr">class</span>=<span class="string">&quot;delImg&quot;</span> <span class="attr">th:onclick</span>=<span class="string">&quot;|delFruit($&#123;fruit.fid&#125;)|&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;width:60%;margin-left:20%;border:0px solid red;padding-top:4px;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;center&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;首  页&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn&quot;</span> <span class="attr">th:onclick</span>=<span class="string">&quot;|page(1)|&quot;</span> <span class="attr">th:disabled</span>=<span class="string">&quot;$&#123;session.pageNo==1&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;上一页&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn&quot;</span> <span class="attr">th:onclick</span>=<span class="string">&quot;|page($&#123;session.pageNo-1&#125;)|&quot;</span> <span class="attr">th:disabled</span>=<span class="string">&quot;$&#123;session.pageNo==1&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;下一页&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn&quot;</span> <span class="attr">th:onclick</span>=<span class="string">&quot;|page($&#123;session.pageNo+1&#125;)|&quot;</span> <span class="attr">th:disabled</span>=<span class="string">&quot;$&#123;session.pageNo==session.pageCount&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;尾  页&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn&quot;</span> <span class="attr">th:onclick</span>=<span class="string">&quot;|page($&#123;session.pageCount&#125;)|&quot;</span> <span class="attr">th:disabled</span>=<span class="string">&quot;$&#123;session.pageNo==session.pageCount&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>为实现分页，<code>IndexServlet</code> 的 <code>doGet</code> 方法以及 <code>FruitDao</code>, <code>FruitDaoImpl</code> 都需要相应新增一些内容，详细请看代码文件。</p><p>完成修改后运行工程，可以看到如下分页效果。四个按钮的状态和点击后的效果也如预期。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/javaweb_in_action/index-pagination.png" alt="index-pagination"></p><br /><h3 id="查询示例"><a href="#查询示例" class="headerlink" title="查询示例"></a>查询示例</h3><p>复制一份 <code>pro11-fruit6-pagination</code> ，重命名为 <code>pro12-fruit7-keyword</code> ，使用此子工程中为库存系统增加按关键字查询功能。</p><br /><h4 id="增加查询功能"><a href="#增加查询功能" class="headerlink" title="增加查询功能"></a>增加查询功能</h4><p>更新 <code>index.html</code>， 新增查询用的关键字文本框和按钮。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;css/index.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">language</span>=<span class="string">&quot;JavaScript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;js/index.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div_container&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div_fruit_list&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;center f30&quot;</span>&gt;</span>欢迎使用水果库存后台管理系统<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;border:0px solid red;width:60%;margin-left:20%;text-align:right;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/index&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">style</span>=<span class="string">&quot;float:left;width:60%;margin-left:20%;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;oper&quot;</span> <span class="attr">value</span>=<span class="string">&quot;search&quot;</span>/&gt;</span></span><br><span class="line">请输入关键字：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;keyword&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;$&#123;session.keyword&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;查询&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/add.html&#125;&quot;</span> <span class="attr">style</span>=<span class="string">&quot;border:0px solid blue;margin-bottom:4px;&quot;</span>&gt;</span>添加新库存记录<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">id</span>=<span class="string">&quot;tbl_fruit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">&quot;w20&quot;</span>&gt;</span>名称<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">&quot;w20&quot;</span>&gt;</span>单价<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">&quot;w20&quot;</span>&gt;</span>库存<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">th</span>&gt;</span>操作<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;#lists.isEmpty(session.fruitList)&#125;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">&quot;4&quot;</span>&gt;</span>对不起，库存为空！<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span> <span class="attr">th:unless</span>=<span class="string">&quot;$&#123;#lists.isEmpty(session.fruitList)&#125;&quot;</span> <span class="attr">th:each</span>=<span class="string">&quot;fruit : $&#123;session.fruitList&#125;&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;td&gt;&lt;a th:text=&quot;$&#123;fruit.fname&#125;&quot; th:href=&quot;@&#123;&#x27;/edit.do?fid=&#x27;+$&#123;fruit.fid&#125;&#125;&quot;&gt;苹果&lt;/a&gt;&lt;/td&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;fruit.fname&#125;&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/edit.do(fid=$&#123;fruit.fid&#125;)&#125;&quot;</span>&gt;</span>苹果<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;fruit.price&#125;&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;fruit.fcount&#125;&quot;</span>&gt;</span>20<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;td&gt;&lt;img src=&quot;imgs/del.jpg&quot; class=&quot;delImg&quot; th:onclick=&quot;&#x27;delFruit(&#x27;+$&#123;fruit.fid&#125;+&#x27;)&#x27;&quot;/&gt;&lt;/td&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;imgs/del.jpg&quot;</span> <span class="attr">class</span>=<span class="string">&quot;delImg&quot;</span> <span class="attr">th:onclick</span>=<span class="string">&quot;|delFruit($&#123;fruit.fid&#125;)|&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;width:60%;margin-left:20%;border:0px solid red;padding-top:4px;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;center&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;首  页&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn&quot;</span> <span class="attr">th:onclick</span>=<span class="string">&quot;|page(1)|&quot;</span> <span class="attr">th:disabled</span>=<span class="string">&quot;$&#123;session.pageNo==1&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;上一页&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn&quot;</span> <span class="attr">th:onclick</span>=<span class="string">&quot;|page($&#123;session.pageNo-1&#125;)|&quot;</span> <span class="attr">th:disabled</span>=<span class="string">&quot;$&#123;session.pageNo==1&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;下一页&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn&quot;</span> <span class="attr">th:onclick</span>=<span class="string">&quot;|page($&#123;session.pageNo+1&#125;)|&quot;</span> <span class="attr">th:disabled</span>=<span class="string">&quot;$&#123;session.pageNo==session.pageCount&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;尾  页&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn&quot;</span> <span class="attr">th:onclick</span>=<span class="string">&quot;|page($&#123;session.pageCount&#125;)|&quot;</span> <span class="attr">th:disabled</span>=<span class="string">&quot;$&#123;session.pageNo==session.pageCount&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>为实现关键字查询，<code>IndexServlet</code> 的需要新增 <code>doPost</code> 方法 (内部调用 <code>doGet</code> 方法)， <code>doGet</code> 方法以及 <code>FruitDao</code>, <code>FruitDaoImpl</code> 都需要相应修改一些内容，详细请看代码文件。</p><p>完成修改后运行工程，可以看到如下关键字查询框如下，查询效果也符合预期。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/javaweb_in_action/index-keyword.png" alt="index-keyword"></p><br /><h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><p>MVC : Model（模型）、View（视图）、Controller（控制器）<br>视图层：用于做数据展示以及和用户交互的一个界面<br>控制层：能够接受客户端的请求，具体的业务功能还是需要借助于模型组件来完成<br>模型层：模型分为很多种：有比较简单的pojo&#x2F;vo(value object)，有业务模型组件，有数据访问层组件</p><ol><li><p>pojo &#x2F; vo : 值对象</p></li><li><p>DAO ： 数据访问对象</p></li><li><p>BO ： 业务对象</p></li><li><p>区分业务对象和数据访问对象：<br>  1） DAO中的方法都是单精度方法或者称之为细粒度方法。什么叫单精度？一个方法只考虑一个操作，比如添加，那就是insert操作、查询那就是select操作….<br>2） BO中的方法属于业务方法，也实际的业务是比较复杂的，因此业务方法的粒度是比较粗的<br>   注册这个功能属于业务功能，也就是说注册这个方法属于业务方法。<br>   那么这个业务方法中包含了多个DAO方法。也就是说注册这个业务功能需要通过多个DAO方法的组合调用，从而完成注册功能的开发。<br>   注册：<br>     1. 检查用户名是否已经被注册 - DAO中的select操作<br>            2. 向用户表新增一条新用户记录 - DAO中的insert操作<br>            3. 向用户积分表新增一条记录（新用户默认初始化积分100分） - DAO中的insert操作<br>                   4. 向系统消息表新增一条记录（某某某新用户注册了，需要根据通讯录信息向他的联系人推送消息） - DAO中的insert操作<br>                   5. 向系统日志表新增一条记录（某用户在某IP在某年某月某日某时某分某秒某毫秒注册） - DAO中的insert操作<br>                          6. ….</p></li><li><p>在库存系统中添加业务层组件</p></li></ol><br /><h3 id="优化一：引入-Controller"><a href="#优化一：引入-Controller" class="headerlink" title="优化一：引入 Controller"></a>优化一：引入 Controller</h3><p>复制 <code>pro12-fruit7-keyword</code> 子工程，更名为 <code>pro13-fruit8-mvc</code> ，在此基础上优化原有代码，将多个 Servlet 具体实现类的功能集中于一个 FruitServlet 实现类中。FruitServlet 实际上对应的是 MVC 结构中的 Controller 。</p><br /><h4 id="FruitServlet"><a href="#FruitServlet" class="headerlink" title="FruitServlet"></a>FruitServlet</h4><p>将 <code>IndexServlet</code>, <code>AddServlet</code>, <code>EditServlet</code>, <code>DelServlet</code>, <code>UpdateServlet</code> 的主要方法 (<code>doGet</code>, <code>doPost</code>) 都写入一个新建的 <code>FruitServlet</code> 类中，分别对应 <code>index</code>, <code>add</code>, <code>edit</code>, <code>del</code>, <code>update</code> 方法。在该类中的 <code>service</code> 方法中使用 <code>switch-case</code> 来将具体请求匹配执行具体方法。</p><p>这样即可由 <code>FruitServlet</code> 这一个 servlet 来取代之前的多个 servlet ，此一设计正是 controller (控制器) 的概念，即一个控制器对应一个模块的功能。仍以水果库存系统为例，该系统可以存在多个功能模块，例如「用户注册登陆」模块，「用户权限管理」模块等，每个模块对应一个 Controller，由 Controller 调用具体的方法处理对应模块的具体请求。</p><p>TODO: 图</p><p>本例是「水果库存信息」模块，负责水果库存信息的增删改查等功能，具体的增删改查操作由此控制器通过调用对应的方法执行。</p><p>在后续的优化中我们会看到在浏览器和 Controller 之间还会设置一个「中央控制器」用于统一调度所有请求，根据请求信息将其分配到不同的 Controller 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukiyama.fruit.servlets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.yukiyama.fruit.dao.FruitDao;</span><br><span class="line"><span class="keyword">import</span> com.yukiyama.fruit.dao.impl.FruitDaoImpl;</span><br><span class="line"><span class="keyword">import</span> com.yukiyama.fruit.pojo.Fruit;</span><br><span class="line"><span class="keyword">import</span> com.yukiyama.myssm.myspringmvc.ViewBaseServlet;</span><br><span class="line"><span class="keyword">import</span> com.yukiyama.myssm.util.StringUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpSession;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(&quot;/fruit.do&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FruitServlet</span> <span class="keyword">extends</span> <span class="title class_">ViewBaseServlet</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">FruitDao</span> <span class="variable">fruitDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FruitDaoImpl</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        req.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">operate</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;operate&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isEmpty(operate))&#123;</span><br><span class="line">            operate = <span class="string">&quot;index&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">switch</span> (operate)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;index&quot;</span>:</span><br><span class="line">                index(req, resp);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;add&quot;</span>:</span><br><span class="line">                add(req, resp);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;del&quot;</span>:</span><br><span class="line">                del(req, resp);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;edit&quot;</span>:</span><br><span class="line">                edit(req, resp);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;update&quot;</span>:</span><br><span class="line">                update(req, resp);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;operate值非法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//1.设置编码</span></span><br><span class="line">        request.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.获取参数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fidStr</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;fid&quot;</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">fid</span> <span class="operator">=</span> Integer.parseInt(fidStr);</span><br><span class="line">        <span class="type">String</span> <span class="variable">fname</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;fname&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">priceStr</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;price&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">price</span> <span class="operator">=</span> Integer.parseInt(priceStr);</span><br><span class="line">        <span class="type">String</span> <span class="variable">fcountStr</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;fcount&quot;</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">fcount</span> <span class="operator">=</span> Integer.parseInt(fcountStr);</span><br><span class="line">        <span class="type">String</span> <span class="variable">remark</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;remark&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.执行更新</span></span><br><span class="line">        fruitDao.updateFruit(<span class="keyword">new</span> <span class="title class_">Fruit</span>(fid,fname, price ,fcount ,remark ));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.资源跳转</span></span><br><span class="line">        <span class="comment">//super.processTemplate(&quot;index&quot;,request,response); // 想到于跳转</span></span><br><span class="line">        <span class="comment">//request.getRequestDispatcher(&quot;index.html&quot;).forward(request,response);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//此处需要重定向，目的是重新给IndexServlet发请求，重新获取furitList，然后覆盖到session中，这样index.html页面上显示的session中的数据才是最新的</span></span><br><span class="line">        response.sendRedirect(<span class="string">&quot;fruit.do&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">edit</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">fidStr</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;fid&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isNotEmpty(fidStr))&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">fid</span> <span class="operator">=</span> Integer.parseInt(fidStr);</span><br><span class="line">            <span class="type">Fruit</span> <span class="variable">fruit</span> <span class="operator">=</span> fruitDao.getFruitByFid(fid);</span><br><span class="line">            req.setAttribute(<span class="string">&quot;fruit&quot;</span>, fruit);</span><br><span class="line">            <span class="built_in">super</span>.processTemplate(<span class="string">&quot;edit&quot;</span>, req, resp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">del</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">fidStr</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;fid&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isNotEmpty(fidStr))&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">fid</span> <span class="operator">=</span> Integer.parseInt(fidStr);</span><br><span class="line">            fruitDao.delFruit(fid);</span><br><span class="line">            response.sendRedirect(<span class="string">&quot;fruit.do&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">operate</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;operate&quot;</span>);</span><br><span class="line">            <span class="comment">//1.设置编码</span></span><br><span class="line">            req.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2.获取参数</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">fname</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;fname&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">priceStr</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;price&quot;</span>);</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">price</span> <span class="operator">=</span> Integer.parseInt(priceStr);</span><br><span class="line">            <span class="type">String</span> <span class="variable">fcountStr</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;fcount&quot;</span>);</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">fcount</span> <span class="operator">=</span> Integer.parseInt(fcountStr);</span><br><span class="line">            <span class="type">String</span> <span class="variable">remark</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;remark&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">Fruit</span> <span class="variable">fruit</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Fruit</span>(<span class="number">0</span>, fname, price, fcount, remark);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3.执行添加</span></span><br><span class="line">            fruitDao.addFruit(fruit);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//4.资源跳转</span></span><br><span class="line">            <span class="comment">//super.processTemplate(&quot;index&quot;,request,response); // 想到于跳转</span></span><br><span class="line">            <span class="comment">//request.getRequestDispatcher(&quot;index.html&quot;).forward(request,response);</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//此处需要重定向，目的是重新给IndexServlet发请求，重新获取furitList，然后覆盖到session中，这样index.html页面上显示的session中的数据才是最新的</span></span><br><span class="line">            resp.sendRedirect(<span class="string">&quot;fruit.do&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">index</span><span class="params">(HttpServletRequest req , HttpServletResponse resp)</span><span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> req.getSession() ;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">pageNo</span> <span class="operator">=</span> <span class="number">1</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">oper</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;oper&quot;</span>);</span><br><span class="line">        <span class="comment">//如果oper!=null 说明 通过表单的查询按钮点击过来的</span></span><br><span class="line">        <span class="comment">//如果oper是空的，说明 不是通过表单的查询按钮点击过来的</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">keyword</span> <span class="operator">=</span> <span class="literal">null</span> ;</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isNotEmpty(oper) &amp;&amp; <span class="string">&quot;search&quot;</span>.equals(oper))&#123;</span><br><span class="line">            <span class="comment">//说明是点击表单查询发送过来的请求</span></span><br><span class="line">            <span class="comment">//此时，pageNo应该还原为1 ， keyword应该从请求参数中获取</span></span><br><span class="line">            pageNo = <span class="number">1</span> ;</span><br><span class="line">            keyword = req.getParameter(<span class="string">&quot;keyword&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(StringUtils.isEmpty(keyword))&#123;</span><br><span class="line">                keyword = <span class="string">&quot;&quot;</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            session.setAttribute(<span class="string">&quot;keyword&quot;</span>,keyword);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//说明此处不是点击表单查询发送过来的请求（比如点击下面的上一页下一页或者直接在地址栏输入网址）</span></span><br><span class="line">            <span class="comment">//此时keyword应该从session作用域获取</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">pageNoStr</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;pageNo&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(StringUtils.isNotEmpty(pageNoStr))&#123;</span><br><span class="line">                pageNo = Integer.parseInt(pageNoStr);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">keywordObj</span> <span class="operator">=</span> session.getAttribute(<span class="string">&quot;keyword&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(keywordObj!=<span class="literal">null</span>)&#123;</span><br><span class="line">                keyword = (String)keywordObj ;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                keyword = <span class="string">&quot;&quot;</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        session.setAttribute(<span class="string">&quot;pageNo&quot;</span>,pageNo);</span><br><span class="line"></span><br><span class="line">        <span class="type">FruitDao</span> <span class="variable">fruitDAO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FruitDaoImpl</span>();</span><br><span class="line">        List&lt;Fruit&gt; fruitList = fruitDAO.getFruitList(keyword , pageNo);</span><br><span class="line"></span><br><span class="line">        session.setAttribute(<span class="string">&quot;fruitList&quot;</span>,fruitList);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//总记录条数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">fruitCount</span> <span class="operator">=</span> fruitDAO.getFruitCount(keyword);</span><br><span class="line">        <span class="comment">//总页数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pageCount</span> <span class="operator">=</span> (fruitCount+ <span class="number">2</span> -<span class="number">1</span>) / <span class="number">2</span> ;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        总记录条数       总页数</span></span><br><span class="line"><span class="comment">        1               1</span></span><br><span class="line"><span class="comment">        5               1</span></span><br><span class="line"><span class="comment">        6               2</span></span><br><span class="line"><span class="comment">        10              2</span></span><br><span class="line"><span class="comment">        11              3</span></span><br><span class="line"><span class="comment">        fruitCount      (fruitCount+5-1)/5</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        session.setAttribute(<span class="string">&quot;pageCount&quot;</span>,pageCount);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//此处的视图名称是 index</span></span><br><span class="line">        <span class="comment">//那么thymeleaf会将这个 逻辑视图名称 对应到 物理视图 名称上去</span></span><br><span class="line">        <span class="comment">//逻辑视图名称 ：   index</span></span><br><span class="line">        <span class="comment">//物理视图名称 ：   view-prefix + 逻辑视图名称 + view-suffix</span></span><br><span class="line">        <span class="comment">//所以真实的视图名称是：      /       index       .html</span></span><br><span class="line">        <span class="built_in">super</span>.processTemplate(<span class="string">&quot;index&quot;</span>,req,resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h4 id="其他修改"><a href="#其他修改" class="headerlink" title="其他修改"></a>其他修改</h4><p>由于引入了 <code>FruitServlet</code> ，对应的请求为 <code>fruit.do</code> ，与此相关的各处 js, html 文件均要相应修改，具体请看源文件。</p><p>完成修改后运行，效果与修改前一致，不再展示。</p><br /><h3 id="优化二：利用反射"><a href="#优化二：利用反射" class="headerlink" title="优化二：利用反射"></a>优化二：利用反射</h3><p>在 <code>FruitServlet</code> 的 <code>service</code> 中使用了 <code>switch-case</code> 来匹配请求与处理该请求的方法，不同的请求越多，<code>switch-case</code> 就会越长，更重要的是，让需要新增一个请求时，必须新增一个 case，不符合开闭原则。我们可以使用反射技术来实现 <code>switch-case</code> 的功能。</p><p>拷贝 <code>pro13-fruit8-mvc</code> 子项目，更名为 <code>pro14-fruit9-mvc-reflection</code> ，在此子项目中实现本节优化。</p><br /><h4 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h4><p>在 <code>FruitServlet</code> 中将 <code>service</code> 方法修改为如下。通过反射获取具体的方法名，根据 operate 的名称与方法名称的匹配关系通过 <code>method.invoke()</code> 执行对应的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    req.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">operate</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;operate&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isEmpty(operate))&#123;</span><br><span class="line">        operate = <span class="string">&quot;index&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取当前类的所有方法</span></span><br><span class="line">    Method[] methods = <span class="built_in">this</span>.getClass().getDeclaredMethods();</span><br><span class="line">    <span class="keyword">for</span> (Method method : methods)&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> method.getName();</span><br><span class="line">        <span class="keyword">if</span>(operate.equals(methodName))&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                method.invoke(<span class="built_in">this</span>, req,resp);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;operate值非法&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h3 id="优化三：DispatcherServlet"><a href="#优化三：DispatcherServlet" class="headerlink" title="优化三：DispatcherServlet"></a>优化三：DispatcherServlet</h3><p>在「优化一」中我们提到过系统中的多个功能模块对应多个 Controller ，可以在浏览器请求发起端和 Controller 之间再设计一个「中央控制器」，用于统一调度所有请求。此「中央控制器」是一个 servlet，即 <code>DispatcherServlet</code> 。见名知义，该 servlet 是一个针对请求的 <code>dispatcher</code> (分派器) 。在「优化二」中，我们利用反射技术代替了 <code>FruitServlet</code> 中不符合开闭原则的 <code>switch-case</code> 写法，但对于每一个 servlet (即 controller) ，都需要同样的反射代码，因此 <code>DispatcherServlet</code> 的另一个作用是可以在其中实现反射代码，而不必在每一个 controller 中重复实现。</p><p>拷贝 <code>pro14-fruit9-mvc-reflection</code> 子项目，更名为 <code>pro15-fruit10-mvc-dispatcherServlet</code> ，在此子项目中实现本节优化。</p><br /><h4 id="DispatcherServlet"><a href="#DispatcherServlet" class="headerlink" title="DispatcherServlet"></a>DispatcherServlet</h4><p>如下 <code>DispacherServlet</code> 的实现，可知其工作流程如下。</p><ol><li>类注解 <code>@WebServlet(&quot;*.do&quot;)</code> 表示处理所有请求。</li><li>当 Web 服务器 (Tomcat) 接受到请求后，调用 <code>DispatcherServlet</code> 的 <code>init</code> 方法，解析 <code>applicationCOntext.xml</code> 文件，获取 xml 文件所有 <code>&lt;bean&gt;</code> 标签中的 <code>id</code> 和 <code>class</code>，通过反射创建所有 <code>class</code> 对应的类对象实例 (即 Controller 对象实例)，将 <code>id</code> 作为 key，对象实例作为 value ，放入对象容器中 (map) 。</li><li>执行 <code>service</code> ，通过 <code>req.getServletPath()</code> 方法获取到的 URL 中的请求目的地名，如 <code>/hello.do</code> ，解析出 <code>hello</code> 。通过 <code>req.getParameter()</code> 获取到请求动作名 (如 <code>edit</code>) 。由 <code>hello</code> 从 bean 容器 map 中获取相应的 Controller 对象 <code>controllerBeanObj</code> ，再由 <code>controllerBeanObj.getClass().getDeclaredMethod</code> 反射方法和已经得到的 <code>edit</code> 来最终执行对应浏览器请求的方法。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukiyama.myssm.myspringmvc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.yukiyama.myssm.util.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.w3c.dom.Document;</span><br><span class="line"><span class="keyword">import</span> org.w3c.dom.Element;</span><br><span class="line"><span class="keyword">import</span> org.w3c.dom.Node;</span><br><span class="line"><span class="keyword">import</span> org.w3c.dom.NodeList;</span><br><span class="line"><span class="keyword">import</span> org.xml.sax.SAXException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletContext;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.xml.parsers.DocumentBuilder;</span><br><span class="line"><span class="keyword">import</span> javax.xml.parsers.DocumentBuilderFactory;</span><br><span class="line"><span class="keyword">import</span> javax.xml.parsers.ParserConfigurationException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(&quot;*.do&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DispatcherServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Object&gt; beanMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DispatcherServlet</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> getClass().getClassLoader().getResourceAsStream(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">            <span class="comment">//1.创建DocumentBuilderFactory</span></span><br><span class="line">            <span class="type">DocumentBuilderFactory</span> <span class="variable">documentBuilderFactory</span> <span class="operator">=</span> DocumentBuilderFactory.newInstance();</span><br><span class="line">            <span class="comment">//2.创建DocumentBuilder对象</span></span><br><span class="line">            <span class="type">DocumentBuilder</span> <span class="variable">documentBuilder</span> <span class="operator">=</span> documentBuilderFactory.newDocumentBuilder() ;</span><br><span class="line">            <span class="comment">//3.创建Document对象</span></span><br><span class="line">            <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> documentBuilder.parse(inputStream);</span><br><span class="line">            <span class="comment">//4.获取所有的bean节点</span></span><br><span class="line">            <span class="type">NodeList</span> <span class="variable">beanNodeList</span> <span class="operator">=</span> document.getElementsByTagName(<span class="string">&quot;bean&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i&lt;beanNodeList.getLength() ; i++)&#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">beanNode</span> <span class="operator">=</span> beanNodeList.item(i);</span><br><span class="line">                <span class="keyword">if</span>(beanNode.getNodeType() == Node.ELEMENT_NODE)&#123;</span><br><span class="line">                    <span class="type">Element</span> <span class="variable">beanElement</span> <span class="operator">=</span> (Element)beanNode ;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">beanId</span> <span class="operator">=</span>  beanElement.getAttribute(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">                    <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> beanElement.getAttribute(<span class="string">&quot;class&quot;</span>);</span><br><span class="line">                    <span class="type">Class</span> <span class="variable">controllerBeanClass</span> <span class="operator">=</span> Class.forName(className);</span><br><span class="line">                    <span class="type">Object</span> <span class="variable">beanObj</span> <span class="operator">=</span> controllerBeanClass.newInstance() ;</span><br><span class="line">                    <span class="type">Method</span> <span class="variable">setServletContextMethod</span> <span class="operator">=</span> controllerBeanClass.getDeclaredMethod(<span class="string">&quot;setServletContext&quot;</span>, ServletContext.class);</span><br><span class="line">                    setServletContextMethod.invoke(beanObj , <span class="built_in">this</span>.getServletContext());</span><br><span class="line">                    beanMap.put(beanId , beanObj) ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParserConfigurationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SAXException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 设置编码</span></span><br><span class="line">        req.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 若 url 为: http://localhost:8080/pro15/hello.do</span></span><br><span class="line">        <span class="comment">// 则 servletPath = &quot;/hello.do&quot;</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">servletPath</span> <span class="operator">=</span> req.getServletPath();</span><br><span class="line">        servletPath = servletPath.substring(<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">lastDotIndex</span> <span class="operator">=</span> servletPath.lastIndexOf(<span class="string">&quot;.do&quot;</span>);</span><br><span class="line">        servletPath = servletPath.substring(<span class="number">0</span>, lastDotIndex);</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">controllerBeanObj</span> <span class="operator">=</span> beanMap.get(servletPath);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">operate</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;operate&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isEmpty(operate))&#123;</span><br><span class="line">            operate = <span class="string">&quot;index&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> controllerBeanObj.getClass().getDeclaredMethod(operate, HttpServletRequest.class, HttpServletResponse.class);</span><br><span class="line">            method.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">if</span>(method != <span class="literal">null</span>)&#123;</span><br><span class="line">                method.invoke(controllerBeanObj, req, resp);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;operate值非法&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h4 id="applicationContext-xml"><a href="#applicationContext-xml" class="headerlink" title="applicationContext.xml"></a>applicationContext.xml</h4><p>在 <code>resources</code> 文件夹中新建 <code>applicationContext.xml</code> 文件，用于配置 bean (即 Java 类) 。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;fruit&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.yukiyama.fruit.controllers.FruitController&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><br /><h4 id="FruitController"><a href="#FruitController" class="headerlink" title="FruitController"></a>FruitController</h4><p>将原先的 <code>FruitServlet</code> 改名为 <code>FruitController</code> ，其所在包名也从 <code>servlets</code> 改成 <code>controllers</code> 。由于所有请求均由 <code>DispatcherServlet</code> 统一处理，因此 <code>FruitController</code> 不再是一个 servlet，应删除其类注解 <code>@WebServlet</code> 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><br /><h3 id="优化四：提取视图资源通用代码"><a href="#优化四：提取视图资源通用代码" class="headerlink" title="优化四：提取视图资源通用代码"></a>优化四：提取视图资源通用代码</h3><p>对于一个 controller ，例如 <code>FruitController</code> ，其中每一个具体的方法最后会涉及到重定向到某个页面 (<code>resp.sendRedirect()</code> 方法) 或者执行视图模版方法 (<code>processTemplate()</code>) 。可以提取这部分代码到 <code>DispatcherServlet</code> 中实现。</p><p>拷贝 <code>pro15-fruit10-mvc-dispatcherServlet</code> 子项目，更名为 <code>pro16-fruit11-mvc-controller</code> ，在此子项目中实现本节优化。</p><br /><h4 id="FruitController-1"><a href="#FruitController-1" class="headerlink" title="FruitController"></a>FruitController</h4><p>在 <code>FruitController</code> 中修改针对请求执行的方法，用返回字符串的方式取代最后的重定向或执行视图模版方法。</p><p>例如 <code>update</code> 中的重定向可改为返回 <code>&quot;redirect:fruit.do&quot;</code> 字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String <span class="title function_">update</span><span class="params">(HttpServletRequest request)</span>&#123;</span><br><span class="line">    <span class="comment">//2.获取参数</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">fidStr</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;fid&quot;</span>);</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">fid</span> <span class="operator">=</span> Integer.parseInt(fidStr);</span><br><span class="line">    <span class="type">String</span> <span class="variable">fname</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;fname&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">priceStr</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;price&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">price</span> <span class="operator">=</span> Integer.parseInt(priceStr);</span><br><span class="line">    <span class="type">String</span> <span class="variable">fcountStr</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;fcount&quot;</span>);</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">fcount</span> <span class="operator">=</span> Integer.parseInt(fcountStr);</span><br><span class="line">    <span class="type">String</span> <span class="variable">remark</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;remark&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.执行更新</span></span><br><span class="line">    fruitDao.updateFruit(<span class="keyword">new</span> <span class="title class_">Fruit</span>(fid,fname, price ,fcount ,remark ));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.资源跳转</span></span><br><span class="line">    <span class="comment">// response.sendRedirect(&quot;fruit.do&quot;);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:fruit.do&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>edit</code> 方法中的执行视图模版方法改为返回 <code>&quot;edit&quot;</code> 字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String <span class="title function_">edit</span><span class="params">(HttpServletRequest req)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">fidStr</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;fid&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isNotEmpty(fidStr))&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fid</span> <span class="operator">=</span> Integer.parseInt(fidStr);</span><br><span class="line">        <span class="type">Fruit</span> <span class="variable">fruit</span> <span class="operator">=</span> fruitDao.getFruitByFid(fid);</span><br><span class="line">        req.setAttribute(<span class="string">&quot;fruit&quot;</span>, fruit);</span><br><span class="line">        <span class="comment">// super.processTemplate(&quot;edit&quot;, req, resp);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;edit&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;error&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些字符串将返回到 <code>DispatcherServlet</code> 的中统一处理。</p><br /><h4 id="DispatcherServlet-1"><a href="#DispatcherServlet-1" class="headerlink" title="DispatcherServlet"></a>DispatcherServlet</h4><p>针对 <code>FruitController</code> 类中方法的字符串返回值，在 <code>service</code> 方法中，根据返回的字符串是否以 <code>&quot;redirect:&quot;</code> 为前缀，分别处理。若有此前缀，则执行重定向方法，若无，则执行视图模版方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    req.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">servletPath</span> <span class="operator">=</span> req.getServletPath();</span><br><span class="line">    servletPath = servletPath.substring(<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">lastDotIndex</span> <span class="operator">=</span> servletPath.lastIndexOf(<span class="string">&quot;.do&quot;</span>);</span><br><span class="line">    servletPath = servletPath.substring(<span class="number">0</span>, lastDotIndex);</span><br><span class="line"></span><br><span class="line">    <span class="type">Object</span> <span class="variable">controllerBeanObj</span> <span class="operator">=</span> beanMap.get(servletPath);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">operate</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;operate&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isEmpty(operate))&#123;</span><br><span class="line">        operate = <span class="string">&quot;index&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> controllerBeanObj.getClass().getDeclaredMethod(operate, HttpServletRequest.class);</span><br><span class="line">        <span class="keyword">if</span>(method != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 2. controller 组件方法调用</span></span><br><span class="line">            method.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">returnObj</span> <span class="operator">=</span> method.invoke(controllerBeanObj, req);</span><br><span class="line">            <span class="type">String</span> <span class="variable">methodReturnStr</span> <span class="operator">=</span> (String) returnObj;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3. 视图处理</span></span><br><span class="line">            <span class="keyword">if</span>(methodReturnStr.startsWith(<span class="string">&quot;redirect:&quot;</span>))&#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">redirectStr</span> <span class="operator">=</span> methodReturnStr.substring(<span class="string">&quot;redirect:&quot;</span>.length());</span><br><span class="line">                resp.sendRedirect(redirectStr);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">super</span>.processTemplate(methodReturnStr, req, resp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;operate值非法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h3 id="优化五：提取参数获取通用代码"><a href="#优化五：提取参数获取通用代码" class="headerlink" title="优化五：提取参数获取通用代码"></a>优化五：提取参数获取通用代码</h3><p>对于一个 controller ，例如 <code>FruitController</code> ，其中每一个具体的方法都会获取请求中的参数，可以参数获取的代码统一到 <code>DispatcherServlet</code> 中实现。</p><p>拷贝 <code>pro16-fruit11-mvc-controller</code> 子项目，更名为 <code>pro16-fruit11-mvc-controller-param</code> ，在此子项目中实现本节优化。</p><br /><h4 id="FruitController-2"><a href="#FruitController-2" class="headerlink" title="FruitController"></a>FruitController</h4><p><code>FruitController</code> 中的方法均改为直接传入参数，这些参数在 <code>DispatcherServlet</code> 中获取并在反射调用 <code>FruitController</code> 相关方法时传入。</p><p>例如 <code>update</code> 改为如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String <span class="title function_">update</span><span class="params">(Integer fid, String fname, Integer price, Integer fcount, String remark)</span>&#123;</span><br><span class="line">    fruitDao.updateFruit(<span class="keyword">new</span> <span class="title class_">Fruit</span>(fid,fname, price ,fcount ,remark ));</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:fruit.do&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>edit</code> 方法改为如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String <span class="title function_">edit</span><span class="params">(Integer fid, HttpServletRequest request)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fid!=<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="type">Fruit</span> <span class="variable">fruit</span> <span class="operator">=</span> fruitDao.getFruitByFid(fid);</span><br><span class="line">        request.setAttribute(<span class="string">&quot;fruit&quot;</span>,fruit);</span><br><span class="line">        <span class="comment">//super.processTemplate(&quot;edit&quot;,request,response);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;edit&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;error&quot;</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h4 id="DispatcherServlet-2"><a href="#DispatcherServlet-2" class="headerlink" title="DispatcherServlet"></a>DispatcherServlet</h4><p>在 <code>DispatcherServlet</code> 的 <code>service</code> 方法中通过反射获取对应请求方法所需的参数值，在反射调用 controller 相关方法时传入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    <span class="comment">//设置编码</span></span><br><span class="line">    request.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">    <span class="comment">//假设url是：  http://localhost:8080/pro15/hello.do</span></span><br><span class="line">    <span class="comment">//那么servletPath是：    /hello.do</span></span><br><span class="line">    <span class="comment">// 我的思路是：</span></span><br><span class="line">    <span class="comment">// 第1步： /hello.do -&gt;   hello   或者  /fruit.do  -&gt; fruit</span></span><br><span class="line">    <span class="comment">// 第2步： hello -&gt; HelloController 或者 fruit -&gt; FruitController</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">servletPath</span> <span class="operator">=</span> request.getServletPath();</span><br><span class="line">    servletPath = servletPath.substring(<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">lastDotIndex</span> <span class="operator">=</span> servletPath.lastIndexOf(<span class="string">&quot;.do&quot;</span>) ;</span><br><span class="line">    servletPath = servletPath.substring(<span class="number">0</span>,lastDotIndex);</span><br><span class="line"></span><br><span class="line">    <span class="type">Object</span> <span class="variable">controllerBeanObj</span> <span class="operator">=</span> beanMap.get(servletPath);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">operate</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;operate&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isEmpty(operate))&#123;</span><br><span class="line">        operate = <span class="string">&quot;index&quot;</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Method[] methods = controllerBeanObj.getClass().getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span>(Method method : methods)&#123;</span><br><span class="line">            <span class="keyword">if</span>(operate.equals(method.getName()))&#123;</span><br><span class="line">                <span class="comment">//1.统一获取请求参数</span></span><br><span class="line">                <span class="comment">//1-1.获取当前方法的参数，返回参数数组</span></span><br><span class="line">                Parameter[] parameters = method.getParameters();</span><br><span class="line">                <span class="comment">//1-2.parameterValues 用来承载参数的值</span></span><br><span class="line">                Object[] parameterValues = <span class="keyword">new</span> <span class="title class_">Object</span>[parameters.length];</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; parameters.length; i++) &#123;</span><br><span class="line">                    <span class="type">Parameter</span> <span class="variable">parameter</span> <span class="operator">=</span> parameters[i];</span><br><span class="line">                    <span class="type">String</span> <span class="variable">parameterName</span> <span class="operator">=</span> parameter.getName() ;</span><br><span class="line">                    <span class="comment">//如果参数名是request,response,session 那么就不是通过请求中获取参数的方式了</span></span><br><span class="line">                    <span class="keyword">if</span>(<span class="string">&quot;request&quot;</span>.equals(parameterName))&#123;</span><br><span class="line">                        parameterValues[i] = request ;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;response&quot;</span>.equals(parameterName))&#123;</span><br><span class="line">                        parameterValues[i] = response ;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;session&quot;</span>.equals(parameterName))&#123;</span><br><span class="line">                        parameterValues[i] = request.getSession() ;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">//从请求中获取参数值</span></span><br><span class="line">                        <span class="type">String</span> <span class="variable">parameterValue</span> <span class="operator">=</span> request.getParameter(parameterName);</span><br><span class="line">                        <span class="type">String</span> <span class="variable">typeName</span> <span class="operator">=</span> parameter.getType().getName();</span><br><span class="line"></span><br><span class="line">                        <span class="type">Object</span> <span class="variable">parameterObj</span> <span class="operator">=</span> parameterValue ;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span>(parameterObj!=<span class="literal">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (<span class="string">&quot;java.lang.Integer&quot;</span>.equals(typeName)) &#123;</span><br><span class="line">                                parameterObj = Integer.parseInt(parameterValue);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        parameterValues[i] = parameterObj ;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//2.controller组件中的方法调用</span></span><br><span class="line">                method.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                <span class="type">Object</span> <span class="variable">returnObj</span> <span class="operator">=</span> method.invoke(controllerBeanObj, parameterValues);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//3.视图处理</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">methodReturnStr</span> <span class="operator">=</span> (String)returnObj ;</span><br><span class="line">                <span class="keyword">if</span>(methodReturnStr.startsWith(<span class="string">&quot;redirect:&quot;</span>))&#123;        <span class="comment">//比如：  redirect:fruit.do</span></span><br><span class="line">                    <span class="type">String</span> <span class="variable">redirectStr</span> <span class="operator">=</span> methodReturnStr.substring(<span class="string">&quot;redirect:&quot;</span>.length());</span><br><span class="line">                    response.sendRedirect(redirectStr);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="built_in">super</span>.processTemplate(methodReturnStr,request,response);    <span class="comment">// 比如：  &quot;edit&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h3 id="优化六：引入-Service"><a href="#优化六：引入-Service" class="headerlink" title="优化六：引入 Service"></a>优化六：引入 Service</h3><p>在之前的实现中，controller 中直接操作 dao 来获取数据，但在实际的业务中，与数据库交互的逻辑相比当前实现会更为复杂，有必要在 controller 层与 dao 层之间再引入 service 层，controller 执行具体方法时，通过其持有的 service 实例完成与数据库的交互，controller 不必关系 service 的具体实现。</p><p>拷贝 <code>pro16-fruit11-mvc-controller-param</code> 子项目，更名为 <code>pro17-fruit12-mvc-ioc-service</code> ，在此子项目中实现本节优化。</p><br /><h4 id="FruitService"><a href="#FruitService" class="headerlink" title="FruitService"></a>FruitService</h4><p>新增 service 包，在该包下新建 <code>FruitService</code> 接口，声明服务方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukiyama.fruit.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.yukiyama.fruit.pojo.Fruit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FruitService</span> &#123;</span><br><span class="line">    <span class="comment">//获取指定页面的库存列表信息</span></span><br><span class="line">    List&lt;Fruit&gt; <span class="title function_">getFruitList</span><span class="params">(String keyword , Integer pageNo)</span>;</span><br><span class="line">    <span class="comment">//添加库存记录信息</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addFruit</span><span class="params">(Fruit fruit)</span>;</span><br><span class="line">    <span class="comment">//根据id查看指定库存记录</span></span><br><span class="line">    Fruit <span class="title function_">getFruitByFid</span><span class="params">(Integer fid)</span>;</span><br><span class="line">    <span class="comment">//删除特定库存记录</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">delFruit</span><span class="params">(Integer fid)</span>;</span><br><span class="line">    <span class="comment">//获取总页数</span></span><br><span class="line">    Integer <span class="title function_">getPageCount</span><span class="params">(String keyword)</span>;</span><br><span class="line">    <span class="comment">//修改特定库存记录</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">updateFruit</span><span class="params">(Fruit fruit)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建 <code>FruitServiceImpl</code> 实现类实现 <code>FruitService</code> 接口，在其内持用 dao 实例，并完成与 dao 的交互来获取数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukiyama.fruit.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.yukiyama.fruit.service.FruitService;</span><br><span class="line"><span class="keyword">import</span> com.yukiyama.fruit.dao.FruitDao;</span><br><span class="line"><span class="keyword">import</span> com.yukiyama.fruit.dao.impl.FruitDaoImpl;</span><br><span class="line"><span class="keyword">import</span> com.yukiyama.fruit.pojo.Fruit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FruitServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">FruitService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">FruitDao</span> <span class="variable">fruitDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FruitDaoImpl</span>();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Fruit&gt; <span class="title function_">getFruitList</span><span class="params">(String keyword, Integer pageNo)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fruitDao.getFruitList(keyword,pageNo);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFruit</span><span class="params">(Fruit fruit)</span> &#123;</span><br><span class="line">        fruitDao.addFruit(fruit);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Fruit <span class="title function_">getFruitByFid</span><span class="params">(Integer fid)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fruitDao.getFruitByFid(fid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delFruit</span><span class="params">(Integer fid)</span> &#123;</span><br><span class="line">        fruitDao.delFruit(fid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getPageCount</span><span class="params">(String keyword)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> fruitDao.getFruitCount(keyword);</span><br><span class="line">        <span class="type">int</span> <span class="variable">pageCount</span> <span class="operator">=</span> (count + <span class="number">2</span> - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> pageCount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateFruit</span><span class="params">(Fruit fruit)</span> &#123;</span><br><span class="line">        fruitDao.updateFruit(fruit);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h4 id="FruitController-3"><a href="#FruitController-3" class="headerlink" title="FruitController"></a>FruitController</h4><p><code>FruitController</code> 不再直接操作 dao，而是持有一个 <code>FruitService</code> 实例，由 <code>FruitService</code> 来提供服务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukiyama.fruit.controllers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.yukiyama.fruit.service.FruitService;</span><br><span class="line"><span class="keyword">import</span> com.yukiyama.fruit.service.impl.FruitServiceImpl;</span><br><span class="line"><span class="keyword">import</span> com.yukiyama.fruit.pojo.Fruit;</span><br><span class="line"><span class="keyword">import</span> com.yukiyama.myssm.util.StringUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpSession;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FruitController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">FruitService</span> <span class="variable">fruitService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FruitServiceImpl</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">update</span><span class="params">(Integer fid, String fname, Integer price, Integer fcount, String remark)</span>&#123;</span><br><span class="line">        fruitService.updateFruit(<span class="keyword">new</span> <span class="title class_">Fruit</span>(fid,fname, price ,fcount ,remark ));</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:fruit.do&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">edit</span><span class="params">(Integer fid, HttpServletRequest request)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(fid!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">Fruit</span> <span class="variable">fruit</span> <span class="operator">=</span> fruitService.getFruitByFid(fid);</span><br><span class="line">            request.setAttribute(<span class="string">&quot;fruit&quot;</span>,fruit);</span><br><span class="line">            <span class="comment">//super.processTemplate(&quot;edit&quot;,request,response);</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;edit&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;error&quot;</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">del</span><span class="params">(Integer fid  )</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(fid!=<span class="literal">null</span>)&#123;</span><br><span class="line">            fruitService.delFruit(fid);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;redirect:fruit.do&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;error&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">add</span><span class="params">(String fname , Integer price , Integer fcount , String remark )</span> &#123;</span><br><span class="line">        <span class="type">Fruit</span> <span class="variable">fruit</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Fruit</span>(<span class="number">0</span>,fname , price , fcount , remark ) ;</span><br><span class="line">        fruitService.addFruit(fruit);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:fruit.do&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">index</span><span class="params">(String oper , String keyword , Integer pageNo , HttpServletRequest request )</span> &#123;</span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession() ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pageNo==<span class="literal">null</span>)&#123;</span><br><span class="line">            pageNo = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isNotEmpty(oper) &amp;&amp; <span class="string">&quot;search&quot;</span>.equals(oper))&#123;</span><br><span class="line">            pageNo = <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">if</span>(StringUtils.isEmpty(keyword))&#123;</span><br><span class="line">                keyword = <span class="string">&quot;&quot;</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            session.setAttribute(<span class="string">&quot;keyword&quot;</span>,keyword);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">keywordObj</span> <span class="operator">=</span> session.getAttribute(<span class="string">&quot;keyword&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(keywordObj!=<span class="literal">null</span>)&#123;</span><br><span class="line">                keyword = (String)keywordObj ;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                keyword = <span class="string">&quot;&quot;</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新更新当前页的值</span></span><br><span class="line">        session.setAttribute(<span class="string">&quot;pageNo&quot;</span>,pageNo);</span><br><span class="line"></span><br><span class="line">        List&lt;Fruit&gt; fruitList = fruitService.getFruitList(keyword , pageNo);</span><br><span class="line">        session.setAttribute(<span class="string">&quot;fruitList&quot;</span>,fruitList);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">pageCount</span> <span class="operator">=</span> fruitService.getPageCount(keyword);</span><br><span class="line"></span><br><span class="line">        session.setAttribute(<span class="string">&quot;pageCount&quot;</span>,pageCount);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;index&quot;</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h3 id="优化七：IoC"><a href="#优化七：IoC" class="headerlink" title="优化七：IoC"></a>优化七：IoC</h3><p>当前的实现中，controller 持有 service 实例，service 实例持有 dao 实例。A 类持有 B 类的实例使得在 A 类中必须引入 B 类，于是这两个类产生了耦合。我们希望去掉这样的耦合，即当 A 类需要用到 B 类时，再实时地为 A 类提供 B 类的实例。实现这种解耦合的技术称为 IoC (Inversion of Control) ，即「依赖反转」。所谓依赖即前述耦合，反转指的是原先由 A 类管理 B 类的实例，但解耦之后 A 类不再管理其所依赖的对象，而是交给外界管理，在 IoC 的实现中，由一个专门的对象容器来产生以及管理对象实例。</p><p>IoC 有时根据其实现方式也被称作 DI (Dependency Injection) ，即「依赖注入」，也就是前面说到的，当 A 类需要 B 类时，由对象容器将 B 类实例 (作为 A 类字段) 「注入」到 A 类 (实例) 中。</p><p>拷贝 <code>pro17-fruit12-mvc-ioc-service</code> 子项目，更名为 <code>pro17-fruit12-mvc-ioc-beanFactory</code> ，在此子项目中实现本节优化。</p><br /><h4 id="类的解耦"><a href="#类的解耦" class="headerlink" title="类的解耦"></a>类的解耦</h4><p>对于原先持有 <code>FruitDaoImpl</code> 实例的 <code>FruitServiceImpl</code> 类，持有 <code>FruitServiceImpl</code> 实例的 <code>FruitController</code> 类，我们将其中的字段值声明为 <code>null</code> 以去除耦合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FruitServiceImpl 类中的 FruitDao 的声明，不再通过 new 持有 FruitDaoImpl 实例，而是声明为 null</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">FruitDao</span> <span class="variable">fruitDao</span> <span class="operator">=</span> <span class="literal">null</span> ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FruitController 类中 FruitService 的声明，不再通过 new 持有 FruitServiceImpl 实例，而是声明为 null</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">FruitService</span> <span class="variable">fruitService</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><br /><h4 id="applicationContext-xml-1"><a href="#applicationContext-xml-1" class="headerlink" title="applicationContext.xml"></a>applicationContext.xml</h4><p>在「优化三」中我们引入过「applicationContext.xml」，在该文件中以 <code>&lt;bean&gt;</code> 标签声明了 <code>FruitController</code> 类。在 <code>DispatcherServlet</code> 类中，通过解析 <code>applicationContext.xml</code> ，利用反射技术将 <code>FruitController</code> 实例放入 <code>map</code> 容器中，并在需要时 (在 <code>service</code> 方法中)  使用将 <code>map</code> 容器中的 <code>FruitController</code> 实例。</p><p>类似地，我们在前面已经接触了类的耦合，因此有必要通过相同的方式将后续需要用到的对象放入到容器中，因此在 <code>applicationContext.xml</code> 文件中新增两个 bean 标签，记录 <code>FruitServiceImpl</code> 类及 <code>FruitController</code> 类的信息，通常称作「配置 bean」。所谓「bean」，即指由 IoC 容器管理的类或类对象。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;fruitDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.yukiyama.fruit.dao.impl.FruitDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;fruitService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.yukiyama.fruit.service.impl.FruitServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;fruitDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;fruitDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;fruit&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.yukiyama.fruit.controllers.FruitController&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;fruitService&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;fruitService&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><br /><h4 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h4><p><code>BeanFactory</code> 接口中声明 <code>Object getBean(String id);</code> 方法，参数中的 <code>id</code> 对应了 <code>applicationContext.xml</code> 中 <code>&lt;bean&gt;</code> 标签的 <code>id</code> 属性。<code>BeanFactory</code> 具体实现类将实现 <code>getBean</code> 方法，解析 xml 配置文件，根据 <code>id</code> 从 IoC 容器 (<code>map</code>) 中获取相应的类对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukiyama.myssm.io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanFactory</span> &#123;</span><br><span class="line">    Object <span class="title function_">getBean</span><span class="params">(String id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h4 id="ClassPathXmlApplicationContext"><a href="#ClassPathXmlApplicationContext" class="headerlink" title="ClassPathXmlApplicationContext"></a>ClassPathXmlApplicationContext</h4><p><code>ClassPathXmlApplicationContext</code> 是 <code>BeanFactory</code> 的实现类。该实现类解析 <code>applicationContext.xml</code> 文件，通过反射得到每个 <code>&lt;bean&gt;</code> 标签对应的类对象，并放入其持用的对象容器 <code>map</code> 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukiyama.myssm.io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.w3c.dom.Document;</span><br><span class="line"><span class="keyword">import</span> org.w3c.dom.Element;</span><br><span class="line"><span class="keyword">import</span> org.w3c.dom.Node;</span><br><span class="line"><span class="keyword">import</span> org.w3c.dom.NodeList;</span><br><span class="line"><span class="keyword">import</span> org.xml.sax.SAXException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.xml.parsers.DocumentBuilder;</span><br><span class="line"><span class="keyword">import</span> javax.xml.parsers.DocumentBuilderFactory;</span><br><span class="line"><span class="keyword">import</span> javax.xml.parsers.ParserConfigurationException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassPathXmlApplicationContext</span> <span class="keyword">implements</span> <span class="title class_">BeanFactory</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; beanMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ClassPathXmlApplicationContext</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> getClass().getClassLoader().getResourceAsStream(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">            <span class="comment">//1.创建DocumentBuilderFactory</span></span><br><span class="line">            <span class="type">DocumentBuilderFactory</span> <span class="variable">documentBuilderFactory</span> <span class="operator">=</span> DocumentBuilderFactory.newInstance();</span><br><span class="line">            <span class="comment">//2.创建DocumentBuilder对象</span></span><br><span class="line">            <span class="type">DocumentBuilder</span> <span class="variable">documentBuilder</span> <span class="operator">=</span> documentBuilderFactory.newDocumentBuilder() ;</span><br><span class="line">            <span class="comment">//3.创建Document对象</span></span><br><span class="line">            <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> documentBuilder.parse(inputStream);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//4.获取所有的bean节点</span></span><br><span class="line">            <span class="type">NodeList</span> <span class="variable">beanNodeList</span> <span class="operator">=</span> document.getElementsByTagName(<span class="string">&quot;bean&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i&lt;beanNodeList.getLength() ; i++)&#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">beanNode</span> <span class="operator">=</span> beanNodeList.item(i);</span><br><span class="line">                <span class="keyword">if</span>(beanNode.getNodeType() == Node.ELEMENT_NODE)&#123;</span><br><span class="line">                    <span class="type">Element</span> <span class="variable">beanElement</span> <span class="operator">=</span> (Element)beanNode ;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">beanId</span> <span class="operator">=</span>  beanElement.getAttribute(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">                    <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> beanElement.getAttribute(<span class="string">&quot;class&quot;</span>);</span><br><span class="line">                    <span class="type">Class</span> <span class="variable">beanClass</span> <span class="operator">=</span> Class.forName(className);</span><br><span class="line">                    <span class="type">Object</span> <span class="variable">beanObj</span> <span class="operator">=</span> beanClass.newInstance() ;</span><br><span class="line">                    beanMap.put(beanId , beanObj) ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//5.组装bean之间的依赖关系</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i&lt;beanNodeList.getLength() ; i++)&#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">beanNode</span> <span class="operator">=</span> beanNodeList.item(i);</span><br><span class="line">                <span class="keyword">if</span>(beanNode.getNodeType() == Node.ELEMENT_NODE) &#123;</span><br><span class="line">                    <span class="type">Element</span> <span class="variable">beanElement</span> <span class="operator">=</span> (Element) beanNode;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">beanId</span> <span class="operator">=</span> beanElement.getAttribute(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">                    <span class="type">NodeList</span> <span class="variable">beanChildNodeList</span> <span class="operator">=</span> beanElement.getChildNodes();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; beanChildNodeList.getLength() ; j++) &#123;</span><br><span class="line">                        <span class="type">Node</span> <span class="variable">beanChildNode</span> <span class="operator">=</span> beanChildNodeList.item(j);</span><br><span class="line">                        <span class="keyword">if</span>(beanChildNode.getNodeType()==Node.ELEMENT_NODE &amp;&amp; <span class="string">&quot;property&quot;</span>.equals(beanChildNode.getNodeName()))&#123;</span><br><span class="line">                            <span class="type">Element</span> <span class="variable">propertyElement</span> <span class="operator">=</span> (Element) beanChildNode;</span><br><span class="line">                            <span class="type">String</span> <span class="variable">propertyName</span> <span class="operator">=</span> propertyElement.getAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">                            <span class="type">String</span> <span class="variable">propertyRef</span> <span class="operator">=</span> propertyElement.getAttribute(<span class="string">&quot;ref&quot;</span>);</span><br><span class="line">                            <span class="comment">//1) 找到propertyRef对应的实例</span></span><br><span class="line">                            <span class="type">Object</span> <span class="variable">refObj</span> <span class="operator">=</span> beanMap.get(propertyRef);</span><br><span class="line">                            <span class="comment">//2) 将refObj设置到当前bean对应的实例的property属性上去</span></span><br><span class="line">                            <span class="type">Object</span> <span class="variable">beanObj</span> <span class="operator">=</span> beanMap.get(beanId);</span><br><span class="line">                            <span class="type">Class</span> <span class="variable">beanClazz</span> <span class="operator">=</span> beanObj.getClass();</span><br><span class="line">                            <span class="type">Field</span> <span class="variable">propertyField</span> <span class="operator">=</span> beanClazz.getDeclaredField(propertyName);</span><br><span class="line">                            propertyField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                            propertyField.set(beanObj,refObj);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParserConfigurationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SAXException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getBean</span><span class="params">(String id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> beanMap.get(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h4 id="DispatcherServlet-3"><a href="#DispatcherServlet-3" class="headerlink" title="DispatcherServlet"></a>DispatcherServlet</h4><p>引入 bean 工厂后，<code>DispatcherServlet</code> 不必再直接持有 bean 容器，而是持有一个 beanFactory ，并在 <code>init()</code> 方法中以 <code>ClassPathXmlApplicationContext</code> 实例化该 beanFactory，这样当 <code>DispatcherServlet</code> 相应请求执行 <code>init()</code> 方法时就会创建 xml 配置文件中配置的 bean ，并放入 beanFactory 持有的 <code>map</code> 中 (IoC 容器)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukiyama.myssm.myspringmvc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.yukiyama.myssm.io.BeanFactory;</span><br><span class="line"><span class="keyword">import</span> com.yukiyama.myssm.io.ClassPathXmlApplicationContext;</span><br><span class="line"><span class="keyword">import</span> com.yukiyama.myssm.util.StringUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Parameter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(&quot;*.do&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DispatcherServlet</span> <span class="keyword">extends</span> <span class="title class_">ViewBaseServlet</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BeanFactory beanFactory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DispatcherServlet</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        <span class="built_in">super</span>.init();</span><br><span class="line">        beanFactory = <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//设置编码</span></span><br><span class="line">        request.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="comment">//假设url是：  http://localhost:8080/pro15/hello.do</span></span><br><span class="line">        <span class="comment">//那么servletPath是：    /hello.do</span></span><br><span class="line">        <span class="comment">// 我的思路是：</span></span><br><span class="line">        <span class="comment">// 第1步： /hello.do -&gt;   hello   或者  /fruit.do  -&gt; fruit</span></span><br><span class="line">        <span class="comment">// 第2步： hello -&gt; HelloController 或者 fruit -&gt; FruitController</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">servletPath</span> <span class="operator">=</span> request.getServletPath();</span><br><span class="line">        servletPath = servletPath.substring(<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">lastDotIndex</span> <span class="operator">=</span> servletPath.lastIndexOf(<span class="string">&quot;.do&quot;</span>) ;</span><br><span class="line">        servletPath = servletPath.substring(<span class="number">0</span>,lastDotIndex);</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">controllerBeanObj</span> <span class="operator">=</span> beanFactory.getBean(servletPath);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">operate</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;operate&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isEmpty(operate))&#123;</span><br><span class="line">            operate = <span class="string">&quot;index&quot;</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Method[] methods = controllerBeanObj.getClass().getDeclaredMethods();</span><br><span class="line">            <span class="keyword">for</span>(Method method : methods)&#123;</span><br><span class="line">                <span class="keyword">if</span>(operate.equals(method.getName()))&#123;</span><br><span class="line">                    <span class="comment">//1.统一获取请求参数</span></span><br><span class="line">                    <span class="comment">//1-1.获取当前方法的参数，返回参数数组</span></span><br><span class="line">                    Parameter[] parameters = method.getParameters();</span><br><span class="line">                    <span class="comment">//1-2.parameterValues 用来承载参数的值</span></span><br><span class="line">                    Object[] parameterValues = <span class="keyword">new</span> <span class="title class_">Object</span>[parameters.length];</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; parameters.length; i++) &#123;</span><br><span class="line">                        <span class="type">Parameter</span> <span class="variable">parameter</span> <span class="operator">=</span> parameters[i];</span><br><span class="line">                        <span class="type">String</span> <span class="variable">parameterName</span> <span class="operator">=</span> parameter.getName() ;</span><br><span class="line">                        <span class="comment">//如果参数名是request,response,session 那么就不是通过请求中获取参数的方式了</span></span><br><span class="line">                        <span class="keyword">if</span>(<span class="string">&quot;request&quot;</span>.equals(parameterName))&#123;</span><br><span class="line">                            parameterValues[i] = request ;</span><br><span class="line">                        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;response&quot;</span>.equals(parameterName))&#123;</span><br><span class="line">                            parameterValues[i] = response ;</span><br><span class="line">                        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;session&quot;</span>.equals(parameterName))&#123;</span><br><span class="line">                            parameterValues[i] = request.getSession() ;</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                            <span class="comment">//从请求中获取参数值</span></span><br><span class="line">                            <span class="type">String</span> <span class="variable">parameterValue</span> <span class="operator">=</span> request.getParameter(parameterName);</span><br><span class="line">                            <span class="type">String</span> <span class="variable">typeName</span> <span class="operator">=</span> parameter.getType().getName();</span><br><span class="line"></span><br><span class="line">                            <span class="type">Object</span> <span class="variable">parameterObj</span> <span class="operator">=</span> parameterValue ;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span>(parameterObj!=<span class="literal">null</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (<span class="string">&quot;java.lang.Integer&quot;</span>.equals(typeName)) &#123;</span><br><span class="line">                                    parameterObj = Integer.parseInt(parameterValue);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            parameterValues[i] = parameterObj ;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//2.controller组件中的方法调用</span></span><br><span class="line">                    method.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                    <span class="type">Object</span> <span class="variable">returnObj</span> <span class="operator">=</span> method.invoke(controllerBeanObj,parameterValues);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//3.视图处理</span></span><br><span class="line">                    <span class="type">String</span> <span class="variable">methodReturnStr</span> <span class="operator">=</span> (String)returnObj ;</span><br><span class="line">                    <span class="keyword">if</span>(methodReturnStr.startsWith(<span class="string">&quot;redirect:&quot;</span>))&#123;        <span class="comment">//比如：  redirect:fruit.do</span></span><br><span class="line">                        <span class="type">String</span> <span class="variable">redirectStr</span> <span class="operator">=</span> methodReturnStr.substring(<span class="string">&quot;redirect:&quot;</span>.length());</span><br><span class="line">                        response.sendRedirect(redirectStr);</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="built_in">super</span>.processTemplate(methodReturnStr,request,response);    <span class="comment">// 比如：  &quot;edit&quot;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常见错误： IllegalArgumentException: argument type mismatch</span></span><br></pre></td></tr></table></figure><br /><h3 id="初始化参数"><a href="#初始化参数" class="headerlink" title="初始化参数"></a>初始化参数</h3><p>可以预先设置 servlet 的初始化参数。 <code>ServletConfig</code> 实例持有该参数，并可通过实例方法 <code>getInitParameters</code> 来获取该参数。可通过在 <code>web.xml</code> 中配置 <code>&lt;init-param&gt;</code> 标签来实现，也可以采用注解方式来实现。</p><p>新建 <code>pro18-servlet-api</code> webapp 子项目，新增如下 <code>Demo01Servlet</code> 类。通过该子工程演示如何设置和获取初始化参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukiyama.servlets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletConfig;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebInitParam;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01Servlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        <span class="type">ServletConfig</span> <span class="variable">config</span> <span class="operator">=</span> getServletConfig();</span><br><span class="line">        <span class="type">String</span> <span class="variable">hello</span> <span class="operator">=</span> config.getInitParameter(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> config.getInitParameter(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;hello = &quot;</span> + hello);</span><br><span class="line">        System.out.println(<span class="string">&quot;name = &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h4 id="web-xml配置方式"><a href="#web-xml配置方式" class="headerlink" title="web.xml配置方式"></a>web.xml配置方式</h4><p>在 <code>web.xml</code> 文件中增加 <code>&lt;init-param&gt;</code> 标签并按如下设置参数名及其值，可设置多个。启动 Tomcat 运行 <code>pro18-servlet-api</code> 应用，即可在控制台看到 <code>hello</code> 及 <code>name</code> 的值被打印输出。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.yukiyama.servlets.Demo01Servlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>world<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>name<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>yukiyama<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/demo01<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><br /><h4 id="注解方式"><a href="#注解方式" class="headerlink" title="注解方式"></a>注解方式</h4><p>为 <code>Demo01Servlet</code> 添加如下类注解，即可在无 <code>web.xml</code> 文件的情况下设置和获取初始化参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(urlPatterns = &#123;&quot;/demo01&quot;&#125;,</span></span><br><span class="line"><span class="meta">        initParams = &#123;</span></span><br><span class="line"><span class="meta">        @WebInitParam(name = &quot;hello&quot;, value = &quot;world&quot;),</span></span><br><span class="line"><span class="meta">        @WebInitParam(name = &quot;name&quot;, value = &quot;yukiyama&quot;),</span></span><br><span class="line"><span class="meta">        &#125;</span></span><br><span class="line"><span class="meta">)</span></span><br></pre></td></tr></table></figure><br />]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaWeb </tag>
            
            <tag> Web开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDBC学习实战</title>
      <link href="/2022/08/31/jdbc%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98_yukiyama/"/>
      <url>/2022/08/31/jdbc%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98_yukiyama/</url>
      
        <content type="html"><![CDATA[<h1 id="JDBC学习实战-yukiyama"><a href="#JDBC学习实战-yukiyama" class="headerlink" title="JDBC学习实战_yukiyama"></a>JDBC学习实战_yukiyama</h1><blockquote><p>本文总结自: <a href="https://www.bilibili.com/video/BV1eJ411c7rf?spm_id_from=333.999.0.0&vd_source=c56ec421dded765a52ade50885eaab60">尚硅谷JDBC核心技术视频教程（康师傅带你一站式搞定jdbc）</a> 。</p></blockquote><br /><h2 id="JDBC概述"><a href="#JDBC概述" class="headerlink" title="JDBC概述"></a>JDBC概述</h2><p>JDBC (Java Database Connectivity): <strong>独立于特定数据库管理系统的通用的数据库存取和操作的公共接口</strong>（ 一组API）。JDBC 定义了用来访问数据库的标准 Java 类库（java.sql, javax.sql），使用这些类库可以以一种 <strong>标准</strong> 的方法、方便地访问数据库资源。</p><p>JDBC接口包括两个层次：</p><ul><li><strong>面向应用的API</strong>：Java API，抽象接口，供应用程序开发人员使用（连接数据库，执行SQL语句，获得结果）。</li><li><strong>面向数据库的API</strong>：Java Driver API，供开发商开发数据库驱动程序用。</li></ul><p><strong>使用JDBC的步骤</strong></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h5yevhl5qhj20lo0a80u5.jpg" alt="image-20220907223000787"></p><p>通过以下步骤使用 JDBC 连接并操作数据库。</p><ul><li>添加依赖，例如 <code>mysql-connector-java-8.0.11.jar</code> 。</li><li>使用 <code>Driver</code> 或 <code>DriverManage</code> 来获取连接实例 <code>Connection</code> 。</li><li>通过连接实例获取 <code>Statement</code> 实例 (使用 <code>PreparedStatement</code>) 。 </li><li>通过 <code>Statement</code> 实例执行 sql 语句。若是查询则可获取结果集。</li><li>关闭连接和资源。</li></ul><br /><h2 id="获取数据库连接"><a href="#获取数据库连接" class="headerlink" title="获取数据库连接"></a>获取数据库连接</h2><h3 id="必要信息"><a href="#必要信息" class="headerlink" title="必要信息"></a>必要信息</h3><p>JDBC 连接数据库需要如下信息。</p><ul><li><strong>Driver 接口实现类</strong><ul><li><code>java.sql.Driver</code> 接口是所有 JDBC 驱动程序需要实现的接口，不同的数据库厂商实现类不同。</li><li>连接时可通过 Driver 实现类的 <code>connect()</code> 方法获取连接实例，但通常采用将 Driver 实现类注册到驱动程序管理器类 <code>java.sql.DriverManager</code> 中，再由 <code>DriverManager</code> 对象的静态方法 <code>getConnection()</code> 来取得连接实例。</li></ul></li><li><strong>URL</strong>：用于标识一个被注册的驱动程序，驱动程序管理器通过这个 URL 选择正确的驱动程序，从而建立到数据库的连接。</li><li><strong>用户名和密码</strong></li></ul><p>不同 DBMS 以及同一 DBMS 的不同版本，所需的信息不同，连接 MySQL 8.0.x 所需信息如下。</p><table><thead><tr><th>连接所需信息</th><th>描述</th></tr></thead><tbody><tr><td>Driver 接口实现类</td><td><code>com.mysql.cj.jdbc.Driver</code></td></tr><tr><td>URL</td><td>jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test?characterEncoding&#x3D;utf8&amp;useSSL&#x3D;false</td></tr><tr><td>用户名</td><td>连接 MySQL 的用户名</td></tr><tr><td>密码</td><td>连接 MySQL 的用户密码</td></tr></tbody></table><blockquote><p>URL 中各参数意义可参考官方文档 <a href="https://dev.mysql.com/doc/connector-j/8.0/en/connector-j-reference-configuration-properties.html">6.3 Configuration Properties</a> 。</p></blockquote><p>使用 <code>DriverManager</code> 来获取连接时，要完成 <code>Driver</code> 对象的加载，并将其注册到 <code>DriverManager</code> 中。</p><ul><li><p>加载驱动：加载 JDBC 驱动需调用 Class 类的静态方法 forName()，向其传递要加载的 JDBC 驱动的类名</p><ul><li><strong>Class.forName(“com.mysql.cj.jdbc.Driver”);</strong></li></ul></li><li><p>注册驱动：<code>DriverManager</code> 类是驱动程序管理器类，负责管理驱动程序</p><ul><li><p>使用 <code>DriverManager.registerDriver(driver)</code> 来注册驱动 ，<code>driver</code> 是具体驱动对象。</p></li><li><p>通常不必显式调用 <code>DriverManager</code> 类的 <code>registerDriver()</code> 方法来注册驱动程序类的实例，因为 <code>Driver</code> 接口的驱动程序类 <strong>都包含了静态代码块</strong>，在这个静态代码块中，会调用 <code>DriverManager.registerDriver()</code> 方法来注册自身的实例。例如下面的 MySQL <code>Driver</code> 实现类的源码的静态代码块。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        DriverManager.registerDriver(<span class="keyword">new</span> <span class="title class_">Driver</span>());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException var1) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Can&#x27;t register driver!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><br /><h3 id="连接实现举例"><a href="#连接实现举例" class="headerlink" title="连接实现举例"></a>连接实现举例</h3><h4 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h4><p>此方式显式调用了第三方数据库的API。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 提供 java.sql.Driver 接口实现类的对象</span></span><br><span class="line">        <span class="type">Driver</span> <span class="variable">driver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">com</span>.mysql.cj.jdbc.Driver();</span><br><span class="line">        <span class="comment">// 2. 提供 url</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/test?characterEncoding=utf8&amp;useSSL=false&quot;</span>;</span><br><span class="line">        <span class="comment">// 3. 提供 properties (用户名密码)</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">info</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        info.setProperty(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;root&quot;</span>);</span><br><span class="line">        info.setProperty(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;xxxxxxxx&quot;</span>);</span><br><span class="line">        <span class="comment">// 4. 调用 driver 的 connect() 方法获取连接实例</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connect</span> <span class="operator">=</span> driver.connect(url, info);</span><br><span class="line">        System.out.println(<span class="string">&quot;方式一：&quot;</span> + connect);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h4 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h4><p>相较于方式一，这里使用反射实例化 <code>Driver</code>，不在代码中体现第三方数据库的API，体现了面向接口编程思想。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 利用反射得到 Driver 实例</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> <span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(className);</span><br><span class="line">        <span class="type">Driver</span> <span class="variable">driver</span> <span class="operator">=</span> (Driver) clazz.newInstance();</span><br><span class="line">        <span class="comment">// 2. 提供 url</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/test?characterEncoding=utf8&amp;useSSL=false&quot;</span>;</span><br><span class="line">        <span class="comment">// 3. 提供 properties (用户名密码)</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">info</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        info.setProperty(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;root&quot;</span>);</span><br><span class="line">        info.setProperty(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;xxxxxxxx&quot;</span>);</span><br><span class="line">        <span class="comment">// 4. 调用 driver 的 connect() 方法获取连接实例</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connect</span> <span class="operator">=</span> driver.connect(url, info);</span><br><span class="line">        System.out.println(<span class="string">&quot;方式二：&quot;</span> + connect);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h4 id="方式三"><a href="#方式三" class="headerlink" title="方式三"></a>方式三</h4><p>使用 <code>DriverManager</code> 获取连接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 提供连接数据库需要的信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> <span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/test?characterEncoding=utf8&amp;useSSL=false&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>, pw = <span class="string">&quot;xxxxxxxx&quot;</span>;</span><br><span class="line">        <span class="comment">// 2. 通过反射提供 Driver 实现类对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(className);</span><br><span class="line">        <span class="type">Driver</span> <span class="variable">driver</span> <span class="operator">=</span> (Driver) clazz.newInstance();</span><br><span class="line">        <span class="comment">// 3. 注册 driver</span></span><br><span class="line">        DriverManager.registerDriver(driver);</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connect</span> <span class="operator">=</span> DriverManager.getConnection(url, user, pw);</span><br><span class="line">        System.out.println(<span class="string">&quot;方式三：&quot;</span> + connect);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h4 id="方式四"><a href="#方式四" class="headerlink" title="方式四"></a>方式四</h4><p>不必显式注册驱动，因为在 <code>DriverManager</code> 的源码中的静态代码块中已实现了驱动的注册。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 提供连接数据库需要的信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">driverName</span> <span class="operator">=</span> <span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/test?characterEncoding=utf8&amp;useSSL=false&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>, pw = <span class="string">&quot;lxs911227&quot;</span>;</span><br><span class="line">        <span class="comment">// 2. 通过反射提供 Driver 实现类对象，在加载该对象类的时候，静态代码块完成注册</span></span><br><span class="line">        Class.forName(driverName);</span><br><span class="line">        <span class="comment">// 3. 获取连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(url, user, pw);</span><br><span class="line">        System.out.println(<span class="string">&quot;方式四：&quot;</span> + connection);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h4 id="方式五-最终版"><a href="#方式五-最终版" class="headerlink" title="方式五(最终版)"></a>方式五(最终版)</h4><p>使用配置文件的方式保存配置信息，在代码中加载配置文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.加载配置文件</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> ConnectionTest.class.getClassLoader().</span><br><span class="line">          getResourceAsStream(<span class="string">&quot;jdbc.properties&quot;</span>);</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">pros</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        pros.load(is);</span><br><span class="line">        <span class="comment">// 2. 读取配置信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">driverName</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;driver&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;user&quot;</span>), pw = pros.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        <span class="comment">// 3. 通过反射提供 Driver 实现类对象，在加载该对象类的时候，静态代码块完成注册</span></span><br><span class="line">        Class.forName(driverName);</span><br><span class="line">        <span class="comment">// 4. 获取连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(url, user, pw);</span><br><span class="line">        System.out.println(<span class="string">&quot;方式五：&quot;</span> + connection);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，配置文件声明在工程的src目录下：<code>jdbc.properties</code></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">driver</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/test?characterEncoding=utf8&amp;useSSL=false</span></span><br><span class="line"><span class="attr">user</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">xxxx</span></span><br></pre></td></tr></table></figure><p><strong>使用配置文件的好处：</strong></p><ul><li>实现了代码和数据的分离，如果需要修改配置信息，直接在配置文件中修改，不需要修改源码。</li><li>由于配置信息不是写在源码中的，配置修改无需重新编译源码。</li></ul><br /><h2 id="操作数据库"><a href="#操作数据库" class="headerlink" title="操作数据库"></a>操作数据库</h2><p>JDBC 获取数据库连接实例后，由该实例返回 <code>Statement</code> 对象，再由该对象解析 sql 语句，完成增删改查操作。 java.sql 包中有 3 个接口分别定义了对数据库的调用的不同方式。</p><table><thead><tr><th>Statement</th><th>描述</th></tr></thead><tbody><tr><td>Statement</td><td>执行静态 SQL 语句并返回它所生成结果的对象。</td></tr><tr><td>PrepatedStatement</td><td>继承了 Statement ，预编译 SQL 语句并存储在对象中，使用此对象可多次高效地执行 SQL 语句。</td></tr><tr><td>CallableStatement</td><td>继承了 Statement ，用于执行 SQL 存储过程。</td></tr></tbody></table><br /><h3 id="Java与SQL数据类型"><a href="#Java与SQL数据类型" class="headerlink" title="Java与SQL数据类型"></a>Java与SQL数据类型</h3><p>如下是 Java 类型与 SQL 数据类型的对应关系。</p><table><thead><tr><th>Java类型</th><th>SQL类型</th></tr></thead><tbody><tr><td>boolean</td><td>BIT</td></tr><tr><td>byte</td><td>TINYINT</td></tr><tr><td>short</td><td>SMALLINT</td></tr><tr><td>int</td><td>INTEGER</td></tr><tr><td>long</td><td>BIGINT</td></tr><tr><td>String</td><td>CHAR,VARCHAR,LONGVARCHAR</td></tr><tr><td>byte   array</td><td>BINARY &#x2F; VAR BINARY</td></tr><tr><td>java.sql.Date</td><td>DATE</td></tr><tr><td>java.sql.Time</td><td>TIME</td></tr><tr><td>java.sql.Timestamp</td><td>TIMESTAMP</td></tr></tbody></table><br /><h3 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h3><p>ORM (Object-relational mapping) ，对象关系映射。<strong>即将数据库中的表映射成一个类</strong>，简单来说，有如下关系。</p><ul><li>一个数据表对应一个 java 类。</li><li>表中的一条记录对应 java 类的一个对象实例。</li><li>表中的一个字段 (列) 对应 java 类的一个字段。</li></ul><p>如下是一张表 <code>user_table</code> (表名) 与其对应的 ORM 类 <code>User</code>，后续演示会使用。</p><table><thead><tr><th>user</th><th>password</th><th>balance</th></tr></thead><tbody><tr><td>AA</td><td>123456</td><td>1000</td></tr><tr><td>BB</td><td>654321</td><td>1000</td></tr><tr><td>CC</td><td>abcd</td><td>2000</td></tr><tr><td>DD</td><td>abcder</td><td>3000</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukiyama.jdbc.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String user;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> balance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String user, String password)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.user = user;</span><br><span class="line">        <span class="built_in">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;user=&#x27;&quot;</span> + user + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, password=&#x27;&quot;</span> + password + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, balance=&quot;</span> + balance +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUser</span><span class="params">(String user)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.user = user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPassword</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPassword</span><span class="params">(String password)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBalance</span><span class="params">(<span class="type">int</span> balance)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h3 id="Statement"><a href="#Statement" class="headerlink" title="Statement"></a>Statement</h3><p>通过调用 <code>Connection</code> 对象的 <code>createStatement()</code> 方法创建该对象。该对象用于执行静态的 SQL 语句，并且返回执行结果。Statement 接口中定义了下列方法用于执行 SQL 语句。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行增删改操作 INSERT、UPDATE、DELETE</span></span><br><span class="line"><span class="comment">// 返回值表示受影响的行数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">excuteUpdate</span><span class="params">(String sql)</span></span><br><span class="line"><span class="comment">// 执行查询操作 SELECT，返回结果集</span></span><br><span class="line">ResultSet <span class="title function_">executeQuery</span><span class="params">(String sql)</span></span><br></pre></td></tr></table></figure><p>使用 Statement 操作数据表存在弊端：</p><ul><li><strong>问题一：繁琐的拼串操作</strong></li><li><strong>问题二：存在SQL注入问题</strong></li></ul><p>SQL 注入：在用户输入数据中注入非法的 SQL 语句段或命令 ，若系统未对用户输入的数据进行检查，则该注入可能导致意料外的结果。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 原 SQL</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">user</span>, password <span class="keyword">FROM</span> user_table <span class="keyword">WHERE</span> <span class="keyword">user</span> <span class="operator">=</span> <span class="string">&#x27;&#x27;</span> <span class="keyword">AND</span> password <span class="operator">=</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="comment">-- 被恶意注入的 SQL</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">user</span>, password <span class="keyword">FROM</span> user_table <span class="keyword">WHERE</span> <span class="keyword">user</span><span class="operator">=</span><span class="string">&#x27;a&#x27;</span> <span class="keyword">OR</span> <span class="number">1</span> <span class="operator">=</span> <span class="string">&#x27; AND password = &#x27;</span> <span class="keyword">OR</span> <span class="string">&#x27;1&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>解决 SQL 注入问题： 使用 PreparedStatement 代替从 Statement。</strong></p><p>Statement 完成 SQL 操作示例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukiyama.jdbc.statement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSetMetaData;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.yukiyama.jdbc.bean.User;</span><br><span class="line"><span class="keyword">import</span> com.yukiyama.jdbc.utils.JDBCUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StatementTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用Statement的弊端：需要拼写sql语句，并且存在SQL注入的问题</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.print(<span class="string">&quot;please input username: &quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">        System.out.print(<span class="string">&quot;please input password: &quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">pw</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT user, password FROM user_table WHERE user = &#x27;&quot;</span> + user + <span class="string">&quot;&#x27; AND password = &#x27;&quot;</span> + pw + <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">        <span class="type">User</span> <span class="variable">returnUser</span> <span class="operator">=</span> get(sql, User.class);</span><br><span class="line">        <span class="keyword">if</span>(returnUser != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Login OK!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Login Failed!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用Statement实现对数据表的查询操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">get</span><span class="params">(String sql, Class&lt;T&gt; clazz)</span> &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Statement</span> <span class="variable">st</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1. 获取连接</span></span><br><span class="line">            conn = JDBCUtils.getConnection();</span><br><span class="line">            <span class="comment">// 2. 获取 statement</span></span><br><span class="line">            st = conn.createStatement();</span><br><span class="line">            <span class="comment">// 3. statement 执行 sql 语句</span></span><br><span class="line">            rs = st.executeQuery(sql);</span><br><span class="line">            <span class="comment">// 4. 获取结果集的元数据</span></span><br><span class="line">            <span class="type">ResultSetMetaData</span> <span class="variable">rsmd</span> <span class="operator">=</span> rs.getMetaData();</span><br><span class="line">            <span class="comment">// 5. 获取结果集的列数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">columnCount</span> <span class="operator">=</span> rsmd.getColumnCount();</span><br><span class="line">            <span class="keyword">if</span> (rs.next()) &#123;</span><br><span class="line">                t = clazz.newInstance();</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; columnCount; i++) &#123;</span><br><span class="line">                    <span class="comment">// 获取列的名称</span></span><br><span class="line">                    <span class="comment">// String columnName = rsmd.getColumnName(i+1);</span></span><br><span class="line">                    <span class="comment">// 获取列的别名</span></span><br><span class="line">                    <span class="type">String</span> <span class="variable">columnName</span> <span class="operator">=</span> rsmd.getColumnLabel(i + <span class="number">1</span>);</span><br><span class="line">                    <span class="comment">// 根据列名获取对应数据表中的数据</span></span><br><span class="line">                    <span class="type">Object</span> <span class="variable">columnVal</span> <span class="operator">=</span> rs.getObject(columnName);</span><br><span class="line">                    <span class="comment">// 将数据表中得到的数据，封装进对象</span></span><br><span class="line">                    <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getDeclaredField(columnName);</span><br><span class="line">                    field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                    field.set(t, columnVal);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123; <span class="comment">// 关闭资源</span></span><br><span class="line">            JDBCUtils.closeResource(conn, st, rs);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">please input username: AA</span><br><span class="line">please input password: 123456</span><br><span class="line">Login OK!</span><br></pre></td></tr></table></figure><p>将连接过程和关闭过程抽取为 <code>JDBCUtils</code> 类的静态方法，如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukiyama.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDBCUtils</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//1.加载配置文件</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader().getResourceAsStream(<span class="string">&quot;jdbc.properties&quot;</span>);</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">pros</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        pros.load(is);</span><br><span class="line">        <span class="comment">// 2. 读取配置信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">driverName</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;driver&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;user&quot;</span>), pw = pros.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        <span class="comment">// 3. 通过反射提供 Driver 实现类对象，在加载该对象类的时候，静态代码块完成注册</span></span><br><span class="line">        Class.forName(driverName);</span><br><span class="line">        <span class="comment">// 4. 获取连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(url, user, pw);</span><br><span class="line">        <span class="keyword">return</span> connection;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关闭statement和连接</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">closeResource</span><span class="params">(Connection connection, Statement ps)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(ps != <span class="literal">null</span>) ps.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(connection != <span class="literal">null</span>) connection.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关闭连接，statement和结果集</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">closeResource</span><span class="params">(Connection connection, Statement st, ResultSet rs)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(st != <span class="literal">null</span>) st.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(connection != <span class="literal">null</span>) connection.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(rs != <span class="literal">null</span>) rs.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h3 id="PreparedStatement"><a href="#PreparedStatement" class="headerlink" title="PreparedStatement"></a>PreparedStatement</h3><p>调用 Connection 对象的 <code>preparedStatement(String sql)</code> 方法获取 PreparedStatement 对象。PreparedStatement 本身是接口，继承了 Statement ，它相比 Statement 有如下几个优点。</p><ul><li>预编译 SQL 语句，防止 SQL 注入。</li><li>可以通过占位符传入流，实现对大文件的操作。</li><li>预编译 SQL 语句，实现高效的批量操作。</li></ul><p>占位符：PreparedStatement 对象所代表的 SQL 语句中的参数用问号 <code>?</code> 来表示，调用其实例方法 <code>setXxx()</code> 。<code>setXxx()</code> 方法有两个参数，第一个参数是要设置的 SQL 语句中的参数的索引 (从 1 开始)，第二个是设置的 SQL 语句中的参数的值。</p><p>预编译：DBServer 会对预编译语句提供性能优化。因为预编译语句有可能被重复调用，所以语句在被 DBServer 的编译器编译后的执行代码被缓存下来，那么下次调用时只要是相同的预编译语句就不需要编译，只要将参数直接传入编译过的语句执行代码中就会得到执行。而使用 Statement 时，即使是相同操作但因为数据内容不一样，整个语句本身不能匹配，没有缓存语句的意义。事实是没有数据库会对普通语句编译后的执行代码缓存。这样每执行一次都要对传入的语句编译一次。</p><p>后续代码实例将展示：</p><ul><li>从非通用的「增删改」改进为通用的「增删改」。</li><li>对同一张表通用的「查」改进为对任意表通用的「查」。</li></ul><br /><h4 id="增删改操作"><a href="#增删改操作" class="headerlink" title="增删改操作"></a>增删改操作</h4><h6 id="非通用「增」"><a href="#非通用「增」" class="headerlink" title="非通用「增」"></a>非通用「增」</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testInsert</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1 获取数据库连接</span></span><br><span class="line">        conn = JDBCUtils.getConnection();</span><br><span class="line">        <span class="comment">// 2 预编译 sql 语句，获取 ps 实例</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into customers(name, email, birth) values(?,?,?)&quot;</span>;</span><br><span class="line">        ps = conn.prepareStatement(sql);</span><br><span class="line">        <span class="comment">// 3 填充占位符</span></span><br><span class="line">        ps.setObject(<span class="number">1</span>, <span class="string">&quot;yukiyama&quot;</span>);</span><br><span class="line">        ps.setObject(<span class="number">2</span>, <span class="string">&quot;yukiyama@gmail.com&quot;</span>);</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">        java.util.<span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> sdf.parse(<span class="string">&quot;1111-11-11&quot;</span>);</span><br><span class="line">        ps.setObject(<span class="number">3</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(date.getTime()));</span><br><span class="line">        <span class="comment">// 4 执行</span></span><br><span class="line">        ps.execute();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 5 关闭资源</span></span><br><span class="line">        JDBCUtils.closeResource(conn, ps);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h6 id="非通用「改」"><a href="#非通用「改」" class="headerlink" title="非通用「改」"></a>非通用「改」</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testUpdate</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1 获取数据库连接</span></span><br><span class="line">        conn = JDBCUtils.getConnection();</span><br><span class="line">        <span class="comment">// 2 预编译 sql 语句，获取 ps 实例</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update customers set name = ? where id = ?&quot;</span>;</span><br><span class="line">        ps = conn.prepareStatement(sql);</span><br><span class="line">        <span class="comment">// 3 填充占位符</span></span><br><span class="line">        ps.setObject(<span class="number">1</span>, <span class="string">&quot;莫扎特&quot;</span>);</span><br><span class="line">        ps.setObject(<span class="number">2</span>, <span class="number">18</span>);</span><br><span class="line">        <span class="comment">// 4 执行</span></span><br><span class="line">        ps.execute();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 5 关闭资源</span></span><br><span class="line">        JDBCUtils.closeResource(conn, ps);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述两例的非通用性体现在于 SQL 语句在方法之内，不同的操作需对应不同的 SQL。</p><br /><h6 id="通用增删改"><a href="#通用增删改" class="headerlink" title="通用增删改"></a>通用增删改</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCommonUpdate</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;delete from customers where id = ?&quot;</span>;</span><br><span class="line">    update(sql, <span class="number">21</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String sql, Object ... args)</span>&#123;</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        conn = JDBCUtils.getConnection();</span><br><span class="line">        ps = conn.prepareStatement(sql);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">            ps.setObject(i + <span class="number">1</span>, args[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        ps.execute();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        JDBCUtils.closeResource(conn, ps);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h4 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h4><p>查询操作与增删改操作的不同之处在于前者有查询结果而后者没有，因此查询操作将返回「结果集」，即 <code>ResultSet</code> 类的对象。</p><h6 id="单表通用「查」"><a href="#单表通用「查」" class="headerlink" title="单表通用「查」"></a>单表通用「查」</h6><p>如下是对同一张表通用的查询操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select id, name, birth, email from customers where id = ?&quot;</span>;</span><br><span class="line">    <span class="type">Customer</span> <span class="variable">customer</span> <span class="operator">=</span> queryForCustomerTest(sql, <span class="number">18</span>);</span><br><span class="line">    System.out.println(customer);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> Customer <span class="title function_">queryForCustomerTest</span><span class="params">(String sql, Object...args)</span>&#123;</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        conn = JDBCUtils.getConnection();</span><br><span class="line">        ps = conn.prepareStatement(sql);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">            ps.setObject(i + <span class="number">1</span>, args[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        rs = ps.executeQuery();</span><br><span class="line">        <span class="keyword">if</span>(rs.next())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> rs.getInt(<span class="number">1</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> rs.getString(<span class="number">2</span>);</span><br><span class="line">            <span class="type">Date</span> <span class="variable">birth</span> <span class="operator">=</span> rs.getDate(<span class="number">3</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">email</span> <span class="operator">=</span> rs.getString(<span class="number">4</span>);</span><br><span class="line">            <span class="type">Customer</span> <span class="variable">customer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Customer</span>(id, name, email, birth);</span><br><span class="line">            <span class="keyword">return</span> customer;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        JDBCUtils.closeResource(conn, ps, rs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该上述代码实例中，在 <code>if(rs.next())</code> 中将获取的结果集 (一条) 组装为 ORM 对象并返回。该方式需要事先知道表的列数并依次获取各字段。更好的办法是通过「结果集元数据」<code>ResultMetaData</code> 获取列数信息，再通过反射确定结果集对应的 ORM 对象各字段的值，得到最终的对象。</p><br /><h6 id="利用反射"><a href="#利用反射" class="headerlink" title="利用反射"></a>利用反射</h6><p>对同一张表通用的查询 –– 利用反射返回行数据的 ORM 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select id, name, birth, email from customers where id = ?&quot;</span>;</span><br><span class="line">    <span class="type">Customer</span> <span class="variable">customer</span> <span class="operator">=</span> queryForCustomer(sql, <span class="number">18</span>);</span><br><span class="line">    System.out.println(customer);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> Customer <span class="title function_">queryForCustomer</span><span class="params">(String sql, Object...args)</span>&#123;</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        conn = JDBCUtils.getConnection();</span><br><span class="line">        ps = conn.prepareStatement(sql);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">            ps.setObject(i + <span class="number">1</span>, args[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        rs = ps.executeQuery();</span><br><span class="line">        <span class="keyword">if</span>(rs.next())&#123;</span><br><span class="line">            <span class="type">ResultSetMetaData</span> <span class="variable">rsmd</span> <span class="operator">=</span> rs.getMetaData();</span><br><span class="line">            <span class="type">Customer</span> <span class="variable">customer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Customer</span>();</span><br><span class="line">            <span class="type">int</span> <span class="variable">colCount</span> <span class="operator">=</span> rsmd.getColumnCount();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; colCount; i++) &#123;</span><br><span class="line">                <span class="type">Object</span> <span class="variable">colValue</span> <span class="operator">=</span> rs.getObject(i + <span class="number">1</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">colName</span> <span class="operator">=</span> rsmd.getColumnName(i + <span class="number">1</span>);</span><br><span class="line">                <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> Customer.class.getDeclaredField(colName);</span><br><span class="line">                field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                field.set(customer, colValue);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> customer;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        JDBCUtils.closeResource(conn, ps, rs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码需要根据列名反射得到行数据，采用结果集元数据 <code>ResultSetMetaData</code> 的实例方法 <code>getColumnName()</code> 时，得到的是真实的列名，而 ORM 对象中的字段名不一定与数据库中的列名相同。为解决这个问题，可在 SQL 语句中列名之后写上别名，该别名与 ORM 对象中的字段名相同，并采用 <code>getColumnLabel()</code> 方法取代 <code>getColumnName()</code> 来获取列的别名，即可反射到 ORM 对象中的字段。</p><p>上述代码的 ORM 对象 <code>Customer</code> 如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukiyama.jdbc.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="keyword">private</span> Date birth;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Customer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Customer</span><span class="params">(<span class="type">int</span> id, String name, String email, Date birth)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.email = email;</span><br><span class="line">        <span class="built_in">this</span>.birth = birth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getEmail</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEmail</span><span class="params">(String email)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.email = email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Date <span class="title function_">getBirth</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> birth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBirth</span><span class="params">(Date birth)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.birth = birth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Customer [id=&quot;</span> + id + <span class="string">&quot;, name=&quot;</span> + name + <span class="string">&quot;, email=&quot;</span> + email + <span class="string">&quot;, birth=&quot;</span> + birth + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h6 id="使用列的别名"><a href="#使用列的别名" class="headerlink" title="使用列的别名"></a>使用列的别名</h6><p>对同一张表通用的查询 –– 使用列的别名而非列名。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukiyama.jdbc.preparedstatement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.Date;</span><br><span class="line"><span class="keyword">import</span> java.sql.PreparedStatement;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSetMetaData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.yukiyama.jdbc.bean.Order;</span><br><span class="line"><span class="keyword">import</span> com.yukiyama.jdbc.utils.JDBCUtils;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderForQuery</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testOrderForQuery</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select order_id orderId,order_name orderName,order_date orderDate from `order` where order_id = ?&quot;</span>;</span><br><span class="line">        <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> orderForQuery(sql, <span class="number">1</span>);</span><br><span class="line">        System.out.println(order);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Order <span class="title function_">orderForQuery</span><span class="params">(String sql, Object...args)</span> &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            conn = JDBCUtils.getConnection();</span><br><span class="line">            ps = conn.prepareStatement(sql);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">                ps.setObject(i + <span class="number">1</span>, args[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            rs = ps.executeQuery();</span><br><span class="line">            <span class="type">ResultSetMetaData</span> <span class="variable">rsmd</span> <span class="operator">=</span> rs.getMetaData();</span><br><span class="line">            <span class="type">int</span> <span class="variable">columnCount</span> <span class="operator">=</span> rsmd.getColumnCount();</span><br><span class="line">            <span class="keyword">if</span>(rs.next()) &#123;</span><br><span class="line">                <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; columnCount; i++) &#123;</span><br><span class="line">                    <span class="type">Object</span> <span class="variable">columnValue</span> <span class="operator">=</span> rs.getObject(i + <span class="number">1</span>);</span><br><span class="line"><span class="comment">//String columnName = rsmd.getColumnName(i + 1); // 不推荐使用列名</span></span><br><span class="line">                    <span class="type">String</span> <span class="variable">columnLabel</span> <span class="operator">=</span> rsmd.getColumnLabel(i + <span class="number">1</span>); <span class="comment">// 推荐使用别名</span></span><br><span class="line">                    <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> Order.class.getDeclaredField(columnLabel);</span><br><span class="line">                    field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                    field.set(order, columnValue);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> order;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JDBCUtils.closeResource(conn, ps, rs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testQuery1</span><span class="params">()</span>  &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            conn = JDBCUtils.getConnection();</span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select order_id, order_name, order_date from `order` where order_id = ?&quot;</span>;</span><br><span class="line">            ps = conn.prepareStatement(sql);</span><br><span class="line">            ps.setObject(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">            rs = ps.executeQuery();</span><br><span class="line">            <span class="keyword">if</span>(rs.next()) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> (<span class="type">int</span>) rs.getObject(<span class="number">1</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> (String) rs.getObject(<span class="number">2</span>);</span><br><span class="line">                <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> (Date) rs.getObject(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">                <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>(id, name, date);</span><br><span class="line">                System.out.println(order);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JDBCUtils.closeResource(conn, ps, rs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的 ORM 对象 Order 如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukiyama.jdbc.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> orderId;</span><br><span class="line">    <span class="keyword">private</span> String orderName;</span><br><span class="line">    <span class="keyword">private</span> Date orderDate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Order</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Order</span><span class="params">(<span class="type">int</span> orderId, String orderName, Date orderDate)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.orderId = orderId;</span><br><span class="line">        <span class="built_in">this</span>.orderName = orderName;</span><br><span class="line">        <span class="built_in">this</span>.orderDate = orderDate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrderId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> orderId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOrderId</span><span class="params">(<span class="type">int</span> orderId)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.orderId = orderId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getOrderName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> orderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOrderName</span><span class="params">(String orderName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.orderName = orderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Date <span class="title function_">getOrderDate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> orderDate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOrderDate</span><span class="params">(Date orderDate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.orderDate = orderDate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Order [orderId=&quot;</span> + orderId + <span class="string">&quot;, orderName=&quot;</span> + orderName + <span class="string">&quot;, orderDate=&quot;</span> + orderDate + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h6 id="多表通用「查」"><a href="#多表通用「查」" class="headerlink" title="多表通用「查」"></a>多表通用「查」</h6><p>在「单表通用查」中，返回值类型对应一张具体的表，可以使用泛型将其改造为对不同表通用的查找方法。只需在方法中传入具体的类的 class 实例，并返回泛型即可。</p><blockquote><p>泛型方法的定义 <a href="https://www.cnblogs.com/iyangyuan/archive/2013/04/09/3011274.html">参考</a> 。</p></blockquote><p>如下代码给出返回一条 (一个 ORM 对象实例) 和返回多条结果 (多个 ORM 对象实例) 的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukiyama.jdbc.preparedstatement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.yukiyama.jdbc.bean.Customer;</span><br><span class="line"><span class="keyword">import</span> com.yukiyama.jdbc.bean.Order;</span><br><span class="line"><span class="keyword">import</span> com.yukiyama.jdbc.utils.JDBCUtils;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.PreparedStatement;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSetMetaData;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PreparedStatementQueryTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 查询单行</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql1</span> <span class="operator">=</span> <span class="string">&quot;select order_id orderId, order_name orderName from `order` where order_id = ?&quot;</span>;</span><br><span class="line">        <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> getResult(Order.class, sql1, <span class="number">1</span>);</span><br><span class="line">        System.out.println(order);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查询多行</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql2</span> <span class="operator">=</span> <span class="string">&quot;select id, name, email from customers where id &lt; ?&quot;</span>;</span><br><span class="line">        List&lt;Customer&gt; list = getResultList(Customer.class, sql2, <span class="number">12</span>);</span><br><span class="line">        list.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 针对不同表的通用查询操作，返回表中的多条记录</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">getResultList</span><span class="params">(Class&lt;T&gt; clazz, String sql, Object...args)</span> &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            conn = JDBCUtils.getConnection();</span><br><span class="line">            ps = conn.prepareStatement(sql);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">                ps.setObject(i + <span class="number">1</span>, args[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            rs = ps.executeQuery();</span><br><span class="line">            <span class="comment">// 获取结果集中的元数据</span></span><br><span class="line">            <span class="type">ResultSetMetaData</span> <span class="variable">rsmd</span> <span class="operator">=</span> rs.getMetaData();</span><br><span class="line">            <span class="type">int</span> <span class="variable">colCount</span> <span class="operator">=</span> rsmd.getColumnCount();</span><br><span class="line">            <span class="comment">// 创建集合对象</span></span><br><span class="line">            List&lt;T&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span>(rs.next()) &#123;</span><br><span class="line">                <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; colCount; i++) &#123;</span><br><span class="line">                    <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> rs.getObject(i + <span class="number">1</span>);</span><br><span class="line">                    <span class="comment">// 获取列名</span></span><br><span class="line">                    <span class="comment">// String colName = rsmd.getColumnName(i + 1);</span></span><br><span class="line">                    <span class="type">String</span> <span class="variable">colName</span> <span class="operator">=</span> rsmd.getColumnLabel(i + <span class="number">1</span>);</span><br><span class="line">                    <span class="comment">// 给 t 对象指定的某个属性赋值</span></span><br><span class="line">                    <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getDeclaredField(colName);</span><br><span class="line">                    field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                    field.set(t, value);</span><br><span class="line">                &#125;</span><br><span class="line">                list.add(t);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JDBCUtils.closeResource(conn, ps, rs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 针对不同表的通用查询操作，返回表中的一条记录</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getResult</span><span class="params">(Class&lt;T&gt; clazz, String sql, Object...args)</span> &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            conn = JDBCUtils.getConnection();</span><br><span class="line">            ps = conn.prepareStatement(sql);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">                ps.setObject(i + <span class="number">1</span>, args[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            rs = ps.executeQuery();</span><br><span class="line">            <span class="comment">// 获取结果集中的元数据</span></span><br><span class="line">            <span class="type">ResultSetMetaData</span> <span class="variable">rsmd</span> <span class="operator">=</span> rs.getMetaData();</span><br><span class="line">            <span class="type">int</span> <span class="variable">colCount</span> <span class="operator">=</span> rsmd.getColumnCount();</span><br><span class="line">            <span class="keyword">if</span>(rs.next()) &#123;</span><br><span class="line">                <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; colCount; i++) &#123;</span><br><span class="line">                    <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> rs.getObject(i + <span class="number">1</span>);</span><br><span class="line">                    <span class="type">String</span> <span class="variable">colName</span> <span class="operator">=</span> rsmd.getColumnLabel(i + <span class="number">1</span>);</span><br><span class="line">                    <span class="comment">// 给 t 对象指定的某个属性赋值</span></span><br><span class="line">                    <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getDeclaredField(colName);</span><br><span class="line">                    field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                    field.set(t, value);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JDBCUtils.closeResource(conn, ps, rs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h4 id="主要类及方法"><a href="#主要类及方法" class="headerlink" title="主要类及方法"></a>主要类及方法</h4><table><thead><tr><th>要点</th><th>描述</th></tr></thead><tbody><tr><td>prepareStatement()</td><td><code>Connection</code> 的实例方法，传入 String 类型的 SQL语句，得到预编译的 <code>PreparedStatement</code> 对象。</td></tr><tr><td>executeQuery()</td><td><code>PreparedStatement</code> 的实例方法，执行查询，返回结果集 <code>ResultSet</code> 。</td></tr><tr><td>ResultSet</td><td>结果集类，持有查询结果。</td></tr><tr><td>next()</td><td><code>ResultSet</code> 实例方法，返回值为 boolean 类型判断结果集当前行是否存在。每次调用，若存在，则当前行移动到下一行。</td></tr><tr><td>getXxx()</td><td><code>ResultSet</code> 实例方法，当前行存在时，<code>getXxx(int index)</code> 或 <code>getXxx(String columnName)</code> 获取列的值。<code>index</code> 表示第 <code>index</code> 列，从 1 开始。</td></tr><tr><td>getMetaData()</td><td><code>ResultSet</code> 的实例方法，返回结果集元数据类对象 <code>ResultSetMetaData</code> 。</td></tr><tr><td>ResultSetMetaData</td><td>结果集元数据类，持有结果集的元数据，如列数等。</td></tr><tr><td>getColumnCount()</td><td><code>ResultSetMetaData</code> 实例方法，返回列数。</td></tr><tr><td>getColumnName()</td><td><code>ResultSetMetaData</code> 实例方法，返回指定列的 <code>String</code> 类型列名。</td></tr><tr><td>getColumnLabel()</td><td><code>ResultSetMetaData</code> 实例方法，返回指定列的 <code>String</code> 类型列的别名。</td></tr></tbody></table><br /><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>两种思想</p><ul><li><p>面向接口编程的思想</p></li><li><p>ORM思想</p></li></ul><p>两种技术</p><ul><li>JDBC结果集的元数据：ResultSetMetaData<ul><li>获取列数：getColumnCount()</li><li>获取列的别名：getColumnLabel()</li></ul></li><li>通过反射，创建指定类的对象，获取指定的属性并赋值</li></ul><br /><h2 id="操作BLOB"><a href="#操作BLOB" class="headerlink" title="操作BLOB"></a>操作BLOB</h2><p>BLOB (Binary Large OBject)，二进制大型对象，用来存储存储照片视频等数据量较大的文件对象。</p><ul><li>插入BLOB 类型的数据必须使用 PreparedStatement ，因为 BLOB 类型的数据无法使用字符串拼接。</li><li>MySQL 提供四种 BLOB 类型，仅表现为支持的数据大小上限不同。</li></ul><p>BLOB 四种类型及大小限制。</p><table><thead><tr><th>BLOB类型</th><th>大小上限</th></tr></thead><tbody><tr><td>TinyBlob</td><td>255B</td></tr><tr><td>Blob</td><td>65KB</td></tr><tr><td>MediumBlob</td><td>16MB</td></tr><tr><td>LongBlob</td><td>4GB</td></tr></tbody></table><p>如下代码演示如何插入和查询 BLOB 文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukiyama.jdbc.blob;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.yukiyama.jdbc.bean.Customer;</span><br><span class="line"><span class="keyword">import</span> com.yukiyama.jdbc.utils.JDBCUtils;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlobTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入 blog</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testInsert</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> JDBCUtils.getConnection();</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into customers (name, email, birth, photo) values (?, ?, ?, ?)&quot;</span>;</span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line">        ps.setObject(<span class="number">1</span>, <span class="string">&quot;猫猫&quot;</span>);</span><br><span class="line">        ps.setObject(<span class="number">2</span>, <span class="string">&quot;cat@gmail.com&quot;</span>);</span><br><span class="line">        ps.setObject(<span class="number">3</span>, <span class="string">&quot;2022-01-01&quot;</span>);</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;src/img.png&quot;</span>));</span><br><span class="line">        ps.setObject(<span class="number">4</span>, is); <span class="comment">// 也可以用 setBlob 方法</span></span><br><span class="line">        ps.execute();</span><br><span class="line">        JDBCUtils.closeResource(conn, ps);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询 blob</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testQuery</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            conn = JDBCUtils.getConnection();</span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select id, name, email, birth, photo from customers where id = ?&quot;</span>;</span><br><span class="line">            ps = conn.prepareStatement(sql);</span><br><span class="line">            ps.setObject(<span class="number">1</span>, <span class="number">22</span>);</span><br><span class="line">            rs = ps.executeQuery();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(rs.next()) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> rs.getInt(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">email</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;email&quot;</span>);</span><br><span class="line">                <span class="type">Date</span> <span class="variable">birth</span> <span class="operator">=</span> rs.getDate(<span class="string">&quot;birth&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="type">Customer</span> <span class="variable">customer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Customer</span>(id, name, email, birth);</span><br><span class="line">                System.out.println(customer);</span><br><span class="line">                <span class="comment">// 以文件方式保存 blob 对象</span></span><br><span class="line">                <span class="type">Blob</span> <span class="variable">photo</span> <span class="operator">=</span> rs.getBlob(<span class="string">&quot;photo&quot;</span>);</span><br><span class="line">                is = photo.getBinaryStream();</span><br><span class="line">                fos = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;output.png&quot;</span>);</span><br><span class="line">                <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>((len = is.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                    fos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(is != <span class="literal">null</span>) is.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(fos != <span class="literal">null</span>) fos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            JDBCUtils.closeResource(conn, ps, rs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h2 id="批量插入"><a href="#批量插入" class="headerlink" title="批量插入"></a>批量插入</h2><h3 id="Statement-1"><a href="#Statement-1" class="headerlink" title="Statement"></a>Statement</h3><p>Statement 无预编译功能，每一次插入的 SQL 都作为一条新的 SQL 语句来处理，因此不使用 Statement 来执行批量插入操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> JDBCUtils.getConnection();</span><br><span class="line"><span class="type">Statement</span> <span class="variable">st</span> <span class="operator">=</span> conn.createStatement();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= <span class="number">20000</span>;i++)&#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into goods(name) values(&#x27;name_&#x27; + &quot;</span>+ i +<span class="string">&quot;)&quot;</span>;</span><br><span class="line">st.executeUpdate(sql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h3 id="PreparedStatement-1"><a href="#PreparedStatement-1" class="headerlink" title="PreparedStatement"></a>PreparedStatement</h3><h4 id="基本方式"><a href="#基本方式" class="headerlink" title="基本方式"></a>基本方式</h4><p>使用 PreparedStatement 预编译 SQL 语句后，简单地循环插入，每一次插入后执行 <code>execute()</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testInsert1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        conn = JDBCUtils.getConnection();</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into goods (name) values (?)&quot;</span>;</span><br><span class="line">        ps = conn.prepareStatement(sql);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">20000</span>; i++) &#123;</span><br><span class="line">            ps.setObject(<span class="number">1</span>, <span class="string">&quot;name_&quot;</span> + i);</span><br><span class="line">            ps.execute();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;time cost: &quot;</span> + (end - start));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        JDBCUtils.closeResource(conn, ps);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h4 id="批量方法"><a href="#批量方法" class="headerlink" title="批量方法"></a>批量方法</h4><p>预编译 SQL 语句后，每次填充占位符后不直接执行 <code>execute()</code> 方法，而是执行 <code>addBatch()</code> 方法累计 SQL 语句，之后可以设置一个较大的次数间隔，每隔一定次数后再执行 <code>executeBatch()</code> 方法批量执行，批量执行后及时执行 <code>clearBatch()</code> 方法清空 batch 。</p><p>MySQL 服务器默认关闭批处理，可在 URL 中传入 <code>?rewriteBatchedStatements=true</code> 参数开启批处理功能，如下。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jdbc</span>:<span class="string">mysql://localhost:3306/test?characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai&amp;rewriteBatchedStatements=true</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testInsert2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        conn = JDBCUtils.getConnection();</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into goods (name) values (?)&quot;</span>;</span><br><span class="line">        ps = conn.prepareStatement(sql);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">            ps.setObject(<span class="number">1</span>, <span class="string">&quot;name_&quot;</span> + i);</span><br><span class="line">            <span class="comment">// 1. 累计 sql</span></span><br><span class="line">            ps.addBatch();</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">500</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 2. 每500次执行一次</span></span><br><span class="line">                ps.executeBatch();</span><br><span class="line">                <span class="comment">// 3. 清空 batch</span></span><br><span class="line">                ps.clearBatch();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;time cost: &quot;</span> + (end - start));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        JDBCUtils.closeResource(conn, ps);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h4 id="非自动提交"><a href="#非自动提交" class="headerlink" title="非自动提交"></a>非自动提交</h4><p>通过 <code>conn.setAutoCommit(false);</code> 设置为非自动提交，在循环结束后再通过 <code>conn.commit();</code> 统一提交。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testInsert3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        conn = JDBCUtils.getConnection();</span><br><span class="line">        <span class="comment">// 设置不自动提交</span></span><br><span class="line">        conn.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into goods (name) values (?)&quot;</span>;</span><br><span class="line">        ps = conn.prepareStatement(sql);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">            ps.setObject(<span class="number">1</span>, <span class="string">&quot;name_&quot;</span> + i);</span><br><span class="line">            <span class="comment">// 1. 累计 sql</span></span><br><span class="line">            ps.addBatch();</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">500</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 2. 执行</span></span><br><span class="line">                ps.executeBatch();</span><br><span class="line">                <span class="comment">// 3. 清空 batch</span></span><br><span class="line">                ps.clearBatch();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 提交数据</span></span><br><span class="line">        conn.commit();</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;time cost: &quot;</span> + (end - start));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        JDBCUtils.closeResource(conn, ps);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><p>上述三种方式耗时比较。</p><table><thead><tr><th>方式</th><th>插入数据量</th><th>耗时 (ms)</th></tr></thead><tbody><tr><td>基本方式</td><td>20000</td><td>54805</td></tr><tr><td>批量方法</td><td>20000</td><td>1629</td></tr><tr><td>批量方法</td><td>1000000</td><td>38669</td></tr><tr><td>非自动提交</td><td>1000000</td><td>40908 (似乎不起作用，原因排查中)</td></tr></tbody></table><br /><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="事务及事务处理"><a href="#事务及事务处理" class="headerlink" title="事务及事务处理"></a>事务及事务处理</h3><p>事务: 一组逻辑操作，具体指一组 SQL 语句。</p><p>事务处理: 处理一个事务时保证该事务所包含的 SQL 语句要么完全执行，要么完全不执行。完全执行时，称该事务被 <strong>提交 (commit)</strong> ，执行过程中出错时，要 <strong>回滚 (rollback)</strong> 到最初状态。</p><p>MySQL 中数据自动提交的情形。</p><table><thead><tr><th>情形</th><th>描述</th></tr></thead><tbody><tr><td>DDL 操作</td><td><code>set autocommit = false</code> 对 DDL 操作不起作用。</td></tr><tr><td>DML 操作</td><td><code>set autocommit = false</code> 关闭 DML 操作的自动提交。</td></tr><tr><td>关闭连接时</td><td>关闭连接时会自动提交数据。</td></tr></tbody></table><p>SQL 语句一旦提交就不可回滚。通过如下方式实现事务处理。</p><ul><li>调用 <code>Connection</code> 对象的 <code>setAutoCommit(false);</code> 以取消自动提交事务。</li><li>在所有的 SQL 语句都成功执行后，调用 <code>commit();</code> 方法提交事务。</li><li>在出现异常时，调用 <code>rollback();</code> 方法回滚事务。</li><li>若此时 <code>Connection</code> 没有被关闭，还可能被重复使用，则需要恢复其自动提交状态 <code>setAutoCommit(true)</code>。尤其是在使用数据库连接池技术时，执行 <code>close()</code> 方法前，建议恢复自动提交状态。</li></ul><p>如下代码演示「转账操作」，展示如何将非事务处理改为事务处理。</p><p>非事务处理方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不考虑事务时，若中断，则数据不一致</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testUpdate</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">CommonDML</span> <span class="variable">dml</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CommonDML</span>();</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql1</span> <span class="operator">=</span> <span class="string">&quot;update user_table set balance = balance - 100 where user = ?&quot;</span>;</span><br><span class="line">    dml.update(sql1, <span class="string">&quot;AA&quot;</span>);</span><br><span class="line">    <span class="comment">// System.out.println(10 / 0); // 模拟异常</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">sql2</span> <span class="operator">=</span> <span class="string">&quot;update user_table set balance = balance + 100 where user = ?&quot;</span>;</span><br><span class="line">    dml.update(sql2, <span class="string">&quot;BB&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>update()</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通用增删改操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">update</span><span class="params">(String sql, Object ... args)</span>&#123;</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        conn = JDBCUtils.getConnection();</span><br><span class="line">        ps = conn.prepareStatement(sql);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">            ps.setObject(i + <span class="number">1</span>, args[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ps.executeUpdate();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        JDBCUtils.closeResource(conn, ps);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事务处理方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testUpdateTX</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        conn = JDBCUtils.getConnection();</span><br><span class="line">        <span class="comment">// 关闭自动提交</span></span><br><span class="line">        conn.setAutoCommit(<span class="literal">false</span>); <span class="comment">// 可通过 conn.getAutoCommit() 查看当前设置</span></span><br><span class="line">        <span class="type">CommonDML</span> <span class="variable">dml</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CommonDML</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql1</span> <span class="operator">=</span> <span class="string">&quot;update user_table set balance = balance - 100 where user = ?&quot;</span>;</span><br><span class="line">        dml.updateTX(conn, sql1, <span class="string">&quot;AA&quot;</span>);</span><br><span class="line">        <span class="comment">// System.out.println(10 / 0); // 模拟异常</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql2</span> <span class="operator">=</span> <span class="string">&quot;update user_table set balance = balance + 100 where user = ?&quot;</span>;</span><br><span class="line">        dml.updateTX(conn, sql2, <span class="string">&quot;BB&quot;</span>);</span><br><span class="line">        <span class="comment">// 最后提交数据</span></span><br><span class="line">        conn.commit();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">try</span> &#123; <span class="comment">// 回滚</span></span><br><span class="line">            conn.rollback();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException ex) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123; <span class="comment">// 恢复自动提交默认设置</span></span><br><span class="line">            conn.setAutoCommit(<span class="literal">true</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        JDBCUtils.closeResource(conn, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>updateTX()</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 考虑事务的通用增删改操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">updateTX</span><span class="params">(Connection conn, String sql, Object ... args)</span>&#123;</span><br><span class="line">    <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ps = conn.prepareStatement(sql);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">            ps.setObject(i + <span class="number">1</span>, args[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ps.executeUpdate();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        JDBCUtils.closeResource(<span class="literal">null</span>, ps);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h4 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h4><p>事务具有以下性质。</p><table><thead><tr><th>ACID</th><th>描述</th></tr></thead><tbody><tr><td>原子性 (Atomicity)</td><td>将单个事务中的所有 SQL 作为原子工作单元执行，要么全部执行，要么全部不执行。</td></tr><tr><td>一致性 (Consistency)</td><td>事务完成后，所有数据的状态都是一致的。例如 A 账户转账 100 元到 B 账户上，则 A 账户减少 100 元， B 账户必然多出 100元。</td></tr><tr><td>隔离性 (Isolation)</td><td>指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</td></tr><tr><td>持久性 (Durability)</td><td>事务完成后，对数据库数据的修改被持久化存储。</td></tr></tbody></table><br /><h3 id="并发问题及隔离级别"><a href="#并发问题及隔离级别" class="headerlink" title="并发问题及隔离级别"></a>并发问题及隔离级别</h3><p>并发问题: 多个并发事务访问数据库中相同的数据时, 可能导致如下问题 (现象)。</p><table><thead><tr><th>并发问题</th><th>描述</th></tr></thead><tbody><tr><td>脏读 (Dirty Read)</td><td>有事务 T1、T2。首先，T1 更新 <code>A</code> 为 <code>A&#39;</code>， 在 <strong>提交前</strong> T2 读取到 <code>A&#39;</code>，接着 T1 回滚，数据库中的  <code>A</code> 未改变，因此 T2 读取的 <code>A&#39;</code> 是错误的。</td></tr><tr><td>不可重复读 (Non Repeatable Read)</td><td>有事务 T1、T2。首先，T2 读取到数据 <code>A</code> ，接着 T1 <strong>更新</strong> <code>A</code> 为 <code>A&#39;</code> 并 <strong>提交</strong> ，数据库中的  <code>A</code> 更新为 <code>A&#39;</code>。T2 还在执行中，此时 <strong>再次读取</strong>，得到  <code>A&#39;</code> 。同一个事务 T2 两次读取的数据不一致，即为不可重复读。</td></tr><tr><td>幻读 (Phantom Read)</td><td>例子1:<br />有事务 T1、T2。首先，T2 读取到数据 <code>A</code> ，接着 T1 <strong>插入若干行数据并提交</strong> 。T2 还在执行中，此时 <strong>再次读取</strong>，由于新数据的插入，得到的结果相比 <code>A</code> 要多。<br />例子2: <br />有事务 T1、T2。首先，T2 <strong>更新</strong> 数据 <code>B</code> ，<code>B</code> 不存在，无法更新。接着 T1 <strong>插入数据<code>B</code></strong> 。T2 还在执行中，此时 <strong>再次更新</strong> <code>B</code>，可以更新成功，读取 <code>B</code> 也能成功。</td></tr></tbody></table><p>隔离级别: 产生上述并发问题的原因在于未保证事务的隔离性，即事务未完成时被其他事务介入。如下四种不同级别的隔离能力，隔离级别越高，数据一致性就越好，并发性越弱。</p><ul><li><p>Oracle 支持：READ COMMITED (默认)，SERIALIZABLE。 </p></li><li><p>Mysql 支持 ：4 种事务隔离级别，默认为 REPEATABLE READ。</p></li></ul><p>下表是四种隔离级别及对应的并发问题 (Y表示存在该问题，N表示不存在该问题)。</p><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>Read Uncommitted<br />(读未提交)</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>Read Committed<br />(读已提交)</td><td>N</td><td>Y</td><td>Y</td></tr><tr><td>Repeatable Read<br />(可重复读)</td><td>N</td><td>N</td><td>Y</td></tr><tr><td>Serializable<br />(串行化)</td><td>N</td><td>N</td><td>N</td></tr></tbody></table><br /><h4 id="隔离级别效果演示"><a href="#隔离级别效果演示" class="headerlink" title="隔离级别效果演示"></a>隔离级别效果演示</h4><p><strong>设置</strong></p><p>为演示不同隔离级别的效果，需要一些设置。</p><p>每启动一个 mysql 程序，就会获得一个单独的数据库连接。每个数据库连接都有一个全局变量 <code>@@transaction_isolation</code>，表示当前的事务隔离级别。</p><p>查看当前事务隔离级别</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select @@transaction_isolation;</span><br></pre></td></tr></table></figure><p>创建新用户</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 请把 &quot;xxxxxx&quot; 换成实际使用的密码</span><br><span class="line">create user yukiyama identified by &#x27;xxxxxx&#x27;;</span><br></pre></td></tr></table></figure><p>通过 root 用户给新用户赋予权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grant all on test.* to yukiyama@localhost;</span><br></pre></td></tr></table></figure><p>查看用户权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show grants for yukiyama@localhost;</span><br></pre></td></tr></table></figure><p>设置当前 mySQL 连接的隔离级别:  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set transaction isolation level read uncommitted;</span><br></pre></td></tr></table></figure><p>设置数据库系统的全局的隔离级别:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 重连后再查看</span><br><span class="line">set global transaction isolation level read uncommitted;</span><br></pre></td></tr></table></figure><p>取消自动提交</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 当前连接内有效</span><br><span class="line">set autocommit = false;</span><br></pre></td></tr></table></figure><p>手动提交</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">commit;</span><br></pre></td></tr></table></figure><br /><p><strong>演示</strong></p><p>演示 read uncommitted </p><ol><li>设置全局隔离级别为 read uncommitted，退出重连后再查看。</li><li>在两个连接下，关闭自动提交。</li><li>两个连接开始查询同一数据，是一致的，在提交前为两个事务 T1和T2。</li><li>T1修改该数据，此时T2再次查看同一数据，看到 <strong>修改后</strong> 的数据。</li><li>T1回滚数据，此时T2再次查看同一数据，看到修改前的数据。</li></ol><p>现象出现在第4步，T2查到了T1修改，但未提交的临时数据 (脏数据)，即「脏读」。</p><p>演示 read committed</p><ol><li>设置全局隔离级别为 read committed，退出重连后再查看。</li><li>在两个连接下，关闭自动提交。</li><li>两个连接开始查询同一数据，是一致的，在提交前为两个事务 T1和T2。</li><li>T1修改该数据，此时T2再次查看同一数据，看到 <strong>修改前</strong> 的数据。</li><li>T1提交数据，此时T2再次查看同一数据，看到 <strong>修改后</strong> 的数据。</li></ol><p>相比 read uncommitted ，在第4步中，T2不会查到「脏数据」。但在第5步中，由于 T1 提交了数据，T2再次查询得到的是T1修改后的数据，同一个事务中两次查询结果不同，即所谓「不可重复读」现象。</p><p>演示 repeatable read</p><ol><li>设置全局隔离级别为 repeatable read，退出重连后再查看。</li><li>在两个连接下，关闭自动提交。</li><li>两个连接开始查询同一数据，是一致的，在提交前为两个事务 T1和T2。</li><li>T1修改该数据，此时T2再次查看同一数据，看到 <strong>修改前</strong> 的数据。</li><li>T1提交数据，此时T2再次查看同一数据，看到 <strong>修改前</strong> 的数据。</li></ol><p>相比 read committed，第4, 5 步查到的都是修改前的数据，即保证了在同一事务中相同的查询总能查询到相同的结果。</p><p>演示 serializable</p><p>TODO</p><br /><h2 id="DAO"><a href="#DAO" class="headerlink" title="DAO"></a>DAO</h2><p>DAO (Data Access Object): 访问数据信息的类和接口，包括对数据的 CRUD (Create、Retrival、Update、Delete) 操作。</p><h3 id="BaseDAO"><a href="#BaseDAO" class="headerlink" title="BaseDAO"></a>BaseDAO</h3><p>用于表的 DML 操作的 DAO 类，后续操作具体表的 DAO 类继承该类。</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>getValue</td><td>泛型方法，获取单个值</td></tr><tr><td>update</td><td>增删改通用方法，传入连接</td></tr><tr><td>getInstanceList</td><td>泛型方法，以 <code>List&lt;T&gt;</code> 返回多行记录对应的对象列表</td></tr><tr><td>getInstance</td><td>泛型方法，返回一行记录对应的对象</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukiyama.jdbc.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.yukiyama.jdbc.utils.JDBCUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaseDAO</span> &#123;</span><br><span class="line">    <span class="comment">// 获取单个值，例如 count(*)</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getValue</span><span class="params">(Connection conn, String sql, Object...args)</span> &#123;</span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ps = conn.prepareStatement(sql);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">                ps.setObject(i + <span class="number">1</span>, args[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            rs = ps.executeQuery();</span><br><span class="line">            <span class="keyword">if</span>(rs.next())&#123;</span><br><span class="line">                <span class="keyword">return</span> (T) rs.getObject(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JDBCUtils.closeResource(<span class="literal">null</span>, ps, rs);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 考虑事务的通用增删改操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">update</span><span class="params">(Connection conn, String sql, Object ... args)</span>&#123;</span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ps = conn.prepareStatement(sql);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">                ps.setObject(i + <span class="number">1</span>, args[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ps.executeUpdate();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JDBCUtils.closeResource(<span class="literal">null</span>, ps);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通用增删改操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">updateBasic</span><span class="params">(String sql, Object ... args)</span>&#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            conn = JDBCUtils.getConnection();</span><br><span class="line">            ps = conn.prepareStatement(sql);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">                ps.setObject(i + <span class="number">1</span>, args[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ps.executeUpdate();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JDBCUtils.closeResource(conn, ps);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 考虑事务的针对不同表的通用查询操作，返回表中的多条记录</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">getInstanceList</span><span class="params">(Connection conn, Class&lt;T&gt; clazz, String sql, Object...args)</span> &#123;</span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ps = conn.prepareStatement(sql);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">                ps.setObject(i + <span class="number">1</span>, args[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            rs = ps.executeQuery();</span><br><span class="line">            <span class="comment">// 获取结果集中的元数据</span></span><br><span class="line">            <span class="type">ResultSetMetaData</span> <span class="variable">rsmd</span> <span class="operator">=</span> rs.getMetaData();</span><br><span class="line">            <span class="type">int</span> <span class="variable">colCount</span> <span class="operator">=</span> rsmd.getColumnCount();</span><br><span class="line">            <span class="comment">// 创建集合对象</span></span><br><span class="line">            List&lt;T&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span>(rs.next()) &#123;</span><br><span class="line">                <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; colCount; i++) &#123;</span><br><span class="line">                    <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> rs.getObject(i + <span class="number">1</span>);</span><br><span class="line">                    <span class="comment">// 获取列名</span></span><br><span class="line">                    <span class="comment">// String colName = rsmd.getColumnName(i + 1);</span></span><br><span class="line">                    <span class="type">String</span> <span class="variable">colName</span> <span class="operator">=</span> rsmd.getColumnLabel(i + <span class="number">1</span>);</span><br><span class="line">                    <span class="comment">// 给 t 对象指定的某个属性赋值</span></span><br><span class="line">                    <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getDeclaredField(colName);</span><br><span class="line">                    field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                    field.set(t, value);</span><br><span class="line">                &#125;</span><br><span class="line">                list.add(t);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JDBCUtils.closeResource(<span class="literal">null</span>, ps, rs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 针对不同表的通用查询操作，返回表中的多条记录</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">getInstanceListBasic</span><span class="params">(Class&lt;T&gt; clazz, String sql, Object...args)</span> &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            conn = JDBCUtils.getConnection();</span><br><span class="line">            ps = conn.prepareStatement(sql);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">                ps.setObject(i + <span class="number">1</span>, args[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            rs = ps.executeQuery();</span><br><span class="line">            <span class="comment">// 获取结果集中的元数据</span></span><br><span class="line">            <span class="type">ResultSetMetaData</span> <span class="variable">rsmd</span> <span class="operator">=</span> rs.getMetaData();</span><br><span class="line">            <span class="type">int</span> <span class="variable">colCount</span> <span class="operator">=</span> rsmd.getColumnCount();</span><br><span class="line">            <span class="comment">// 创建集合对象</span></span><br><span class="line">            List&lt;T&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span>(rs.next()) &#123;</span><br><span class="line">                <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; colCount; i++) &#123;</span><br><span class="line">                    <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> rs.getObject(i + <span class="number">1</span>);</span><br><span class="line">                    <span class="comment">// 获取列名</span></span><br><span class="line">                    <span class="comment">// String colName = rsmd.getColumnName(i + 1);</span></span><br><span class="line">                    <span class="type">String</span> <span class="variable">colName</span> <span class="operator">=</span> rsmd.getColumnLabel(i + <span class="number">1</span>);</span><br><span class="line">                    <span class="comment">// 给 t 对象指定的某个属性赋值</span></span><br><span class="line">                    <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getDeclaredField(colName);</span><br><span class="line">                    field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                    field.set(t, value);</span><br><span class="line">                &#125;</span><br><span class="line">                list.add(t);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JDBCUtils.closeResource(conn, ps, rs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 考虑事务的针对不同表的通用查询操作，返回表中的一条记录</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getInstance</span><span class="params">(Connection conn, Class&lt;T&gt; clazz, String sql, Object...args)</span> &#123;</span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ps = conn.prepareStatement(sql);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">                ps.setObject(i + <span class="number">1</span>, args[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            rs = ps.executeQuery();</span><br><span class="line">            <span class="comment">// 获取结果集中的元数据</span></span><br><span class="line">            <span class="type">ResultSetMetaData</span> <span class="variable">rsmd</span> <span class="operator">=</span> rs.getMetaData();</span><br><span class="line">            <span class="type">int</span> <span class="variable">colCount</span> <span class="operator">=</span> rsmd.getColumnCount();</span><br><span class="line">            <span class="keyword">if</span>(rs.next()) &#123;</span><br><span class="line">                <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; colCount; i++) &#123;</span><br><span class="line">                    <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> rs.getObject(i + <span class="number">1</span>);</span><br><span class="line">                    <span class="type">String</span> <span class="variable">colName</span> <span class="operator">=</span> rsmd.getColumnLabel(i + <span class="number">1</span>);</span><br><span class="line">                    <span class="comment">// 给 t 对象指定的某个属性赋值</span></span><br><span class="line">                    <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getDeclaredField(colName);</span><br><span class="line">                    field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                    field.set(t, value);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JDBCUtils.closeResource(<span class="literal">null</span>, ps, rs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 针对不同表的通用查询操作，返回表中的一条记录</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getInstanceBasic</span><span class="params">(Class&lt;T&gt; clazz, String sql, Object...args)</span> &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            conn = JDBCUtils.getConnection();</span><br><span class="line">            ps = conn.prepareStatement(sql);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">                ps.setObject(i + <span class="number">1</span>, args[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            rs = ps.executeQuery();</span><br><span class="line">            <span class="comment">// 获取结果集中的元数据</span></span><br><span class="line">            <span class="type">ResultSetMetaData</span> <span class="variable">rsmd</span> <span class="operator">=</span> rs.getMetaData();</span><br><span class="line">            <span class="type">int</span> <span class="variable">colCount</span> <span class="operator">=</span> rsmd.getColumnCount();</span><br><span class="line">            <span class="keyword">if</span>(rs.next()) &#123;</span><br><span class="line">                <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; colCount; i++) &#123;</span><br><span class="line">                    <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> rs.getObject(i + <span class="number">1</span>);</span><br><span class="line">                    <span class="type">String</span> <span class="variable">colName</span> <span class="operator">=</span> rsmd.getColumnLabel(i + <span class="number">1</span>);</span><br><span class="line">                    <span class="comment">// 给 t 对象指定的某个属性赋值</span></span><br><span class="line">                    <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getDeclaredField(colName);</span><br><span class="line">                    field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                    field.set(t, value);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JDBCUtils.closeResource(conn, ps, rs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h3 id="改进BaseDAO"><a href="#改进BaseDAO" class="headerlink" title="改进BaseDAO"></a>改进BaseDAO</h3><p>前面实现的 BaseDAO 的 getInstance 和 getInstanceList 方法中，传入了 <code>Class&lt;T&gt; clazz</code>，但在使用继承 BaseDAO 的具体表的 DAO 类 (如 CustomerDAO) 时，泛型 <code>T</code> 是确定的，因此可不必传入，可以在代码块中利用反射获取泛型类，如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukiyama.jdbc.dao2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.yukiyama.jdbc.utils.JDBCUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.ParameterizedType;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Type;</span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaseDAO</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;T&gt; clazz = <span class="literal">null</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取当前BaseDAO的子类继承的父类的泛型</span></span><br><span class="line">        <span class="type">Type</span> <span class="variable">genericSuperclass</span> <span class="operator">=</span> <span class="built_in">this</span>.getClass().getGenericSuperclass();</span><br><span class="line">        <span class="type">ParameterizedType</span> <span class="variable">paramType</span> <span class="operator">=</span> (ParameterizedType) genericSuperclass;</span><br><span class="line">        Type[] typeArguments = paramType.getActualTypeArguments();</span><br><span class="line">        clazz = (Class&lt;T&gt;) typeArguments[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取单个值，例如 count(*)</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getValue</span><span class="params">(Connection conn, String sql, Object...args)</span> &#123;</span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ps = conn.prepareStatement(sql);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">                ps.setObject(i + <span class="number">1</span>, args[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            rs = ps.executeQuery();</span><br><span class="line">            <span class="keyword">if</span>(rs.next())&#123;</span><br><span class="line">                <span class="keyword">return</span> (T) rs.getObject(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JDBCUtils.closeResource(<span class="literal">null</span>, ps, rs);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 考虑事务的通用增删改操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">update</span><span class="params">(Connection conn, String sql, Object ... args)</span>&#123;</span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ps = conn.prepareStatement(sql);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">                ps.setObject(i + <span class="number">1</span>, args[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ps.executeUpdate();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JDBCUtils.closeResource(<span class="literal">null</span>, ps);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通用增删改操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">updateBasic</span><span class="params">(String sql, Object ... args)</span>&#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            conn = JDBCUtils.getConnection();</span><br><span class="line">            ps = conn.prepareStatement(sql);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">                ps.setObject(i + <span class="number">1</span>, args[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ps.executeUpdate();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JDBCUtils.closeResource(conn, ps);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 考虑事务的针对不同表的通用查询操作，返回表中的多条记录</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;T&gt; <span class="title function_">getInstanceList</span><span class="params">(Connection conn, String sql, Object...args)</span> &#123;</span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ps = conn.prepareStatement(sql);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">                ps.setObject(i + <span class="number">1</span>, args[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            rs = ps.executeQuery();</span><br><span class="line">            <span class="comment">// 获取结果集中的元数据</span></span><br><span class="line">            <span class="type">ResultSetMetaData</span> <span class="variable">rsmd</span> <span class="operator">=</span> rs.getMetaData();</span><br><span class="line">            <span class="type">int</span> <span class="variable">colCount</span> <span class="operator">=</span> rsmd.getColumnCount();</span><br><span class="line">            <span class="comment">// 创建集合对象</span></span><br><span class="line">            List&lt;T&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span>(rs.next()) &#123;</span><br><span class="line">                <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; colCount; i++) &#123;</span><br><span class="line">                    <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> rs.getObject(i + <span class="number">1</span>);</span><br><span class="line">                    <span class="comment">// 获取列名</span></span><br><span class="line">                    <span class="comment">// String colName = rsmd.getColumnName(i + 1);</span></span><br><span class="line">                    <span class="type">String</span> <span class="variable">colName</span> <span class="operator">=</span> rsmd.getColumnLabel(i + <span class="number">1</span>);</span><br><span class="line">                    <span class="comment">// 给 t 对象指定的某个属性赋值</span></span><br><span class="line">                    <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getDeclaredField(colName);</span><br><span class="line">                    field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                    field.set(t, value);</span><br><span class="line">                &#125;</span><br><span class="line">                list.add(t);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JDBCUtils.closeResource(<span class="literal">null</span>, ps, rs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 针对不同表的通用查询操作，返回表中的多条记录</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">getInstanceListBasic</span><span class="params">(Class&lt;T&gt; clazz, String sql, Object...args)</span> &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            conn = JDBCUtils.getConnection();</span><br><span class="line">            ps = conn.prepareStatement(sql);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">                ps.setObject(i + <span class="number">1</span>, args[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            rs = ps.executeQuery();</span><br><span class="line">            <span class="comment">// 获取结果集中的元数据</span></span><br><span class="line">            <span class="type">ResultSetMetaData</span> <span class="variable">rsmd</span> <span class="operator">=</span> rs.getMetaData();</span><br><span class="line">            <span class="type">int</span> <span class="variable">colCount</span> <span class="operator">=</span> rsmd.getColumnCount();</span><br><span class="line">            <span class="comment">// 创建集合对象</span></span><br><span class="line">            List&lt;T&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span>(rs.next()) &#123;</span><br><span class="line">                <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; colCount; i++) &#123;</span><br><span class="line">                    <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> rs.getObject(i + <span class="number">1</span>);</span><br><span class="line">                    <span class="comment">// 获取列名</span></span><br><span class="line">                    <span class="comment">// String colName = rsmd.getColumnName(i + 1);</span></span><br><span class="line">                    <span class="type">String</span> <span class="variable">colName</span> <span class="operator">=</span> rsmd.getColumnLabel(i + <span class="number">1</span>);</span><br><span class="line">                    <span class="comment">// 给 t 对象指定的某个属性赋值</span></span><br><span class="line">                    <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getDeclaredField(colName);</span><br><span class="line">                    field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                    field.set(t, value);</span><br><span class="line">                &#125;</span><br><span class="line">                list.add(t);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JDBCUtils.closeResource(conn, ps, rs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 考虑事务的针对不同表的通用查询操作，返回表中的一条记录</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getInstance</span><span class="params">(Connection conn, String sql, Object...args)</span> &#123;</span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ps = conn.prepareStatement(sql);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">                ps.setObject(i + <span class="number">1</span>, args[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            rs = ps.executeQuery();</span><br><span class="line">            <span class="comment">// 获取结果集中的元数据</span></span><br><span class="line">            <span class="type">ResultSetMetaData</span> <span class="variable">rsmd</span> <span class="operator">=</span> rs.getMetaData();</span><br><span class="line">            <span class="type">int</span> <span class="variable">colCount</span> <span class="operator">=</span> rsmd.getColumnCount();</span><br><span class="line">            <span class="keyword">if</span>(rs.next()) &#123;</span><br><span class="line">                <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; colCount; i++) &#123;</span><br><span class="line">                    <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> rs.getObject(i + <span class="number">1</span>);</span><br><span class="line">                    <span class="type">String</span> <span class="variable">colName</span> <span class="operator">=</span> rsmd.getColumnLabel(i + <span class="number">1</span>);</span><br><span class="line">                    <span class="comment">// 给 t 对象指定的某个属性赋值</span></span><br><span class="line">                    <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getDeclaredField(colName);</span><br><span class="line">                    field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                    field.set(t, value);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JDBCUtils.closeResource(<span class="literal">null</span>, ps, rs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 针对不同表的通用查询操作，返回表中的一条记录</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getInstanceBasic</span><span class="params">(Class&lt;T&gt; clazz, String sql, Object...args)</span> &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            conn = JDBCUtils.getConnection();</span><br><span class="line">            ps = conn.prepareStatement(sql);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">                ps.setObject(i + <span class="number">1</span>, args[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            rs = ps.executeQuery();</span><br><span class="line">            <span class="comment">// 获取结果集中的元数据</span></span><br><span class="line">            <span class="type">ResultSetMetaData</span> <span class="variable">rsmd</span> <span class="operator">=</span> rs.getMetaData();</span><br><span class="line">            <span class="type">int</span> <span class="variable">colCount</span> <span class="operator">=</span> rsmd.getColumnCount();</span><br><span class="line">            <span class="keyword">if</span>(rs.next()) &#123;</span><br><span class="line">                <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; colCount; i++) &#123;</span><br><span class="line">                    <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> rs.getObject(i + <span class="number">1</span>);</span><br><span class="line">                    <span class="type">String</span> <span class="variable">colName</span> <span class="operator">=</span> rsmd.getColumnLabel(i + <span class="number">1</span>);</span><br><span class="line">                    <span class="comment">// 给 t 对象指定的某个属性赋值</span></span><br><span class="line">                    <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getDeclaredField(colName);</span><br><span class="line">                    field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                    field.set(t, value);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JDBCUtils.closeResource(conn, ps, rs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h3 id="CustomerDAO"><a href="#CustomerDAO" class="headerlink" title="CustomerDAO"></a>CustomerDAO</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukiyama.jdbc.dao2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.yukiyama.jdbc.bean.Customer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CustomerDAO</span> &#123;</span><br><span class="line">    <span class="comment">// 根据指定的cust插入一行</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(Connection conn, Customer cust)</span>;</span><br><span class="line">    <span class="comment">// 根据ID删除一行</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deleteById</span><span class="params">(Connection conn, <span class="type">int</span> id)</span>;</span><br><span class="line">    <span class="comment">// 根据ID修改一行</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">updateById</span><span class="params">(Connection conn, Customer cust)</span>;</span><br><span class="line">    <span class="comment">// 根据id查询一行记录</span></span><br><span class="line">    Customer <span class="title function_">getCustomerById</span><span class="params">(Connection conn, <span class="type">int</span> id)</span>;</span><br><span class="line">    <span class="comment">// 查询表中的所有记录</span></span><br><span class="line">    List&lt;Customer&gt; <span class="title function_">getAll</span><span class="params">(Connection conn)</span>;</span><br><span class="line">    <span class="comment">// 返回 count(*)</span></span><br><span class="line">    Long <span class="title function_">getCount</span><span class="params">(Connection conn)</span>;</span><br><span class="line">    <span class="comment">// 返回最大生日</span></span><br><span class="line">    Date <span class="title function_">getMaxBirth</span><span class="params">(Connection conn)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h3 id="CustomerDAOImpl"><a href="#CustomerDAOImpl" class="headerlink" title="CustomerDAOImpl"></a>CustomerDAOImpl</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukiyama.jdbc.dao2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.yukiyama.jdbc.bean.Customer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomerDaoImpl</span> <span class="keyword">extends</span> <span class="title class_">BaseDAO</span>&lt;Customer&gt; <span class="keyword">implements</span> <span class="title class_">CustomerDAO</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(Connection conn, Customer cust)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into customers (name, email, birth) values(?, ?, ?)&quot;</span>;</span><br><span class="line">        update(conn, sql, cust.getName(), cust.getEmail(), cust.getBirth());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteById</span><span class="params">(Connection conn, <span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;delete from customers where id = ?&quot;</span>;</span><br><span class="line">        update(conn, sql, id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateById</span><span class="params">(Connection conn, Customer cust)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update customers set name = ?, email = ?, birth = ? where id = ?&quot;</span>;</span><br><span class="line">        update(conn, sql, cust.getName(), cust.getEmail(), cust.getBirth(), cust.getId());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Customer <span class="title function_">getCustomerById</span><span class="params">(Connection conn, <span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select id, name, email, birth from customers where id = ?&quot;</span>;</span><br><span class="line">        <span class="type">Customer</span> <span class="variable">cust</span> <span class="operator">=</span> getInstance(conn, sql, id);</span><br><span class="line">        <span class="keyword">return</span> cust;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Customer&gt; <span class="title function_">getAll</span><span class="params">(Connection conn)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select id, name, email, birth from customers&quot;</span>;</span><br><span class="line">        List&lt;Customer&gt; customers = getInstanceList(conn, sql);</span><br><span class="line">        <span class="keyword">return</span> customers;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">getCount</span><span class="params">(Connection conn)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select count(*) from customers&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> getValue(conn, sql);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Date <span class="title function_">getMaxBirth</span><span class="params">(Connection conn)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select max(birth) from customers&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> getValue(conn, sql);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h2 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>在开发基于数据库的 web 程序时，传统模式如下：　　</p><ul><li>在主程序（如servlet、beans）中建立数据库连接</li><li>进行 sql 操作</li><li>断开数据库连接</li></ul><p>这种模式存在的问题如下。</p><table><thead><tr><th>问题</th><th>描述</th></tr></thead><tbody><tr><td>连接资源重用率差</td><td>需要连接时创建新的连接实例，使用后再关闭，频繁的连接与断开占用大量系统资源。</td></tr><tr><td>获取连接速度慢</td><td>需要连接时通过 DriverManager 获取连接实例 (需验证用户名和密码)，耗时较久。</td></tr><tr><td>内存泄漏</td><td>若未能正常关闭连接，可能导致内存泄漏。</td></tr><tr><td>无法控制连接数</td><td>每次需要连接时都会新建一个连接实例。</td></tr></tbody></table><p>类似线程池的思想，为解决上述问题，可采用 <strong>数据库连接池技术</strong>。</p><ul><li><strong>缓冲池</strong>: 与线程池思想类似，为数据库连接建立一个「缓冲池」。预先在缓冲池中放入一定数量的连接实例，需要连接时，从中取出一个，使用完毕之后再放回。</li><li><strong>连接管理</strong>: 连接池负责管理连接，例如分配和释放。它允许重复利用现有连接而不必总是新建。</li></ul><p>数据库连接池较重要的两个参数是 <strong>「最小连接数」</strong> 和 <strong>「最大连接数」</strong> 。连接池初始化时会创建最小连接数个连接，无论这些连接是否被使用，连接池都将一直保证至少拥有该数量的连接实例。最大连接数限制了连接池拥有的最大连接数，当应用程序向连接池请求的连接数超过该值时，请求将被加入到等待队列中。</p><p>通过连接池即可解决前述问题，也即数据库连接池的优点如下。</p><table><thead><tr><th>优点</th><th>描述</th></tr></thead><tbody><tr><td>连接资源重用</td><td>避免了频繁创建，释放连接引起的大量性能开销。</td></tr><tr><td>提高获取连接的速度</td><td>连接池初始化时已经创建了若干连接实例，需要时可立即使用。</td></tr><tr><td>连接资源可分配</td><td>通过连接池的配置，可控制资源的分配，例如限制最大连接数等。</td></tr><tr><td>避免连接资源泄漏</td><td>根据预先的占用超时设定，强制回收被占用连接，避免内存泄漏。</td></tr></tbody></table><br /><h3 id="DataSource"><a href="#DataSource" class="headerlink" title="DataSource"></a>DataSource</h3><p>JDBC 的数据库连接池对应 <code>javax.sql.DataSource</code> 称为 <strong>「数据源」</strong>，包含 <strong>「连接池」和「连接池管理」</strong> 。DataSource 只是一个接口，该接口通常由服务器 (Weblogic, WebSphere, Tomcat) 提供实现，也有一些数据库连接池开源项目实现，例如 DBCP、C3P0 和 Druid。使用连接池时注意如下两点。</p><ul><li><p>数据库连接池 (DataSource) 和数据库连接不同，DataSource 无需创建多个，它是产生数据库连接的工厂，因此整个应用只需要一个 DataSource 即可。</p></li><li><p>使用连接池来获取连接，使用完毕后执行 <code>conn.close();</code> 时，实际上并未关闭该连接，而是将该连接释放回连接池中。</p></li></ul><br /><h4 id="C3P0"><a href="#C3P0" class="headerlink" title="C3P0"></a>C3P0</h4><p><a href="https://www.mchange.com/projects/c3p0/">C3P0</a> 是一个开源组织提供的一个数据库连接池，hibernate 官方推荐使用。</p><p>连接参数硬编码方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> PropertyVetoException, SQLException &#123;</span><br><span class="line">    <span class="type">ComboPooledDataSource</span> <span class="variable">cpds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ComboPooledDataSource</span>(<span class="string">&quot;c3p0_hello&quot;</span>);</span><br><span class="line">    cpds.setDriverClass( <span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span> ); <span class="comment">//loads the jdbc driver</span></span><br><span class="line">    cpds.setJdbcUrl( <span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span> );</span><br><span class="line">    cpds.setUser(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">    cpds.setPassword(<span class="string">&quot;xxxxxxxx&quot;</span>);</span><br><span class="line">    <span class="comment">// 设置初始连接数</span></span><br><span class="line">    cpds.setInitialPoolSize(<span class="number">5</span>);</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> cpds.getConnection();</span><br><span class="line">    System.out.println(conn);</span><br><span class="line">    <span class="comment">// 销毁 cpds 连接池</span></span><br><span class="line">    <span class="comment">// DataSources.destroy(cpds);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从配置文件中读取配置参数</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="type">ComboPooledDataSource</span> <span class="variable">cpds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ComboPooledDataSource</span>(<span class="string">&quot;c3p0Hello&quot;</span>);</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> cpds.getConnection();</span><br><span class="line">    System.out.println(conn);</span><br><span class="line">    <span class="comment">// 销毁 cpds 连接池</span></span><br><span class="line">    <span class="comment">// DataSources.destroy(cpds);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>src下的配置文件为：c3p0-config.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">c3p0-config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">named-config</span> <span class="attr">name</span>=<span class="string">&quot;c3p0Hello&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span>&gt;</span>com.mysql.cj.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span>&gt;</span>jdbc:mysql://localhost:3306/test<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>xxxxxxx<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 连接数不够时，一次性向连接池申请的连接数 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;acquireIncrement&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 初始连接数 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;initialPoolSize&quot;</span>&gt;</span>10<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 最小连接数 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;minPoolSize&quot;</span>&gt;</span>10<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 最大连接数 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxPoolSize&quot;</span>&gt;</span>100<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 最大 statement 数 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxStatements&quot;</span>&gt;</span>50<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 每个连接的最大连接数 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxStatementsPerConnection&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">named-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">c3p0-config</span>&gt;</span></span><br></pre></td></tr></table></figure><br /><h4 id="DBCP"><a href="#DBCP" class="headerlink" title="DBCP"></a>DBCP</h4><p><a href="https://commons.apache.org/proper/commons-dbcp/">DBCP</a> 是 Apache 软件基金组织下的开源连接池实现，该连接池依赖该组织下的另一个开源系统：Common-pool。如需使用该连接池实现，应在系统中增加如下两个 jar 文件：</p><ul><li>Commons-dbcp.jar：连接池的实现</li><li>Commons-pool.jar：连接池实现的依赖库</li></ul><p><strong>Tomcat 的连接池正是采用该连接池来实现的。</strong> 该数据库连接池既可以与应用服务器整合使用，也可由应用程序独立使用。</p><table><thead><tr><th>属性</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td>initialSize</td><td>0</td><td>连接池启动时创建的初始化连接数量</td></tr><tr><td>maxActive</td><td>8</td><td>连接池中可同时连接的最大的连接数</td></tr><tr><td>maxIdle</td><td>8</td><td>连接池中最大的空闲的连接数，超过的空闲连接将被释放，如果设置为负数表示不限制</td></tr><tr><td>minIdle</td><td>0</td><td>连接池中最小的空闲的连接数，低于这个数量会创建新的连接。该参数越接近maxIdle，性能越好，因为连接的创建和销毁，都是需要消耗资源的；但是不能太大。</td></tr><tr><td>maxWait</td><td>无限制</td><td>最大等待时间，当没有可用连接时，连接池等待连接释放的最大时间，超过该时间限制会抛出异常，如果设置-1表示无限等待</td></tr><tr><td>poolPreparedStatements</td><td>false</td><td>开启池的Statement是否prepared</td></tr><tr><td>maxOpenPreparedStatements</td><td>无限制</td><td>开启池的prepared 后的同时最大连接数</td></tr><tr><td>minEvictableIdleTimeMillis</td><td></td><td>连接池中连接，在时间段内一直空闲， 被逐出连接池的时间</td></tr><tr><td>removeAbandonedTimeout</td><td>300</td><td>超过时间限制，回收没有用(废弃)的连接</td></tr><tr><td>removeAbandoned</td><td>false</td><td>超过removeAbandonedTimeout时间后，是否进 行没用连接（废弃）的回收</td></tr></tbody></table><p>连接参数硬编码方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">BasicDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BasicDataSource</span>();</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    ds.setDriverClassName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">    ds.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>);</span><br><span class="line">    ds.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">    ds.setPassword(<span class="string">&quot;xxxxxxxx&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ds.setInitialSize(<span class="number">10</span>);</span><br><span class="line">    ds.setMaxActive(<span class="number">10</span>);</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> ds.getConnection();</span><br><span class="line">    System.out.println(conn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> DataSource ds1;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">pros</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;src/dbcp.properties&quot;</span>));</span><br><span class="line">        pros.load(is);</span><br><span class="line">        ds1 = BasicDataSourceFactory.createDataSource(pros);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> IOException, SQLException &#123;</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> ds1.getConnection();</span><br><span class="line">    System.out.println(conn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>src下的配置文件为：dbcp.properties</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">driverClassName</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/test</span></span><br><span class="line"><span class="attr">username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">xxxxxxx</span></span><br></pre></td></tr></table></figure><br /><h4 id="Druid"><a href="#Druid" class="headerlink" title="Druid"></a>Druid</h4><p><a href="https://github.com/alibaba/druid">Druid</a> 是阿里巴巴开源的数据库连接池实现，它结合了 C3P0、DBCP、Proxool 等的优点，同时加入了日志监控，可以很好的监控连接池和 SQL 的执行情况，可以说是针对监控而生的数据库连接池。</p><p>配置文件方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> DataSource ds;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">pros</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="comment">// InputStream is = new FileInputStream(new File(&quot;src/druid.properties&quot;));</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader().getResourceAsStream(<span class="string">&quot;druid.properties&quot;</span>);</span><br><span class="line">        pros.load(is);</span><br><span class="line">        ds = DruidDataSourceFactory.createDataSource(pros);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException, SQLException &#123;</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> ds.getConnection();</span><br><span class="line">    System.out.println(conn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>src下的配置文件为：druid.propertis</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">driverClassName</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/test</span></span><br><span class="line"><span class="attr">username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">xxxxxxx</span></span><br><span class="line"><span class="attr">initialSize</span>=<span class="string">5</span></span><br><span class="line"><span class="attr">maxActive</span>=<span class="string">10</span></span><br></pre></td></tr></table></figure><p><a href="https://github.com/alibaba/druid/wiki/DruidDataSource%E9%85%8D%E7%BD%AE%E5%B1%9E%E6%80%A7%E5%88%97%E8%A1%A8">详细配置参数</a></p><br /><h2 id="Apache-DBUtils"><a href="#Apache-DBUtils" class="headerlink" title="Apache-DBUtils"></a>Apache-DBUtils</h2><p><a href="https://commons.apache.org/proper/commons-dbutils/">commons-dbutils</a> 是 Apache 组织提供的一个开源 JDBC工具类库，它封装了 JDBC 的操作，极大简化了操作数据库的编码工作。主要有如下三个类 (均在 <code>org.apache.commons.dbutils</code> 下)。</p><table><thead><tr><th>dbutils主要类</th><th>描述</th></tr></thead><tbody><tr><td><code>QueryRunner</code></td><td>封装DML操作</td></tr><tr><td><code>ResultSetHandler</code></td><td>支持结果集的转换</td></tr><tr><td><code>DbUtils</code></td><td>工具类</td></tr></tbody></table><br /><h3 id="DbUtils"><a href="#DbUtils" class="headerlink" title="DbUtils"></a>DbUtils</h3><p>DbUtils ：提供如关闭连接、装载 JDBC 驱动程序等常规工作的工具类，所有方法均是静态的。主要方法如下。</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><code>close</code></td><td>检查所提供的参数是不是 NULL (Connection, Statement, ResultSet)，不是则关闭。</td></tr><tr><td><code>closeQuietly</code></td><td>完成 <code>close</code> 的功能，并且在关闭连接时不抛出 SQL 异常。</td></tr><tr><td><code>commitAndClose</code></td><td>提交连接的事务，然后关闭连接。</td></tr><tr><td><code>commitAndCloseQuietly</code></td><td>完成 <code>commitAndClose</code> 的功能，并且在关闭连接时不抛出 SQL 异常</td></tr><tr><td><code>rollback</code></td><td></td></tr><tr><td><code>rollbackAndClose</code></td><td></td></tr><tr><td><code>rollbackAndCloseQuietly</code></td><td></td></tr><tr><td><code>loadDriver</code></td><td>装载并注册 JDB C驱动程序，如果成功就返回 true 。</td></tr></tbody></table><br /><h3 id="QueryRunner"><a href="#QueryRunner" class="headerlink" title="QueryRunner"></a>QueryRunner</h3><p>该类封装了 DML 操作，极大简化了操作数据库的编码工作。</p><table><thead><tr><th>主要方法</th><th></th></tr></thead><tbody><tr><td><code>QueryRunner()</code></td><td>默认构造器</td></tr><tr><td><code>QueryRunner(DataSource ds)</code></td><td>传入 DataSource 的构造器</td></tr><tr><td><code>update</code></td><td>执行更新操作（插入、修改、删除)</td></tr><tr><td><code>insert</code></td><td>执行插入操作</td></tr><tr><td><code>batch</code></td><td>批处理</td></tr><tr><td><code>insertBatch</code></td><td>插入操作批处理</td></tr><tr><td><code>query</code></td><td>执行一个查询操作，在这个查询中，对象数组中的每个元素值被用来作为查询语句的置换参数。该方法会自行处理 PreparedStatement 和 ResultSet 的创建和关闭。</td></tr></tbody></table><br /><h3 id="ResultSetHandler"><a href="#ResultSetHandler" class="headerlink" title="ResultSetHandler"></a>ResultSetHandler</h3><p>该接口用于处理 <code>java.sql.ResultSet</code>，将数据按要求转换为另一种形式。ResultSetHandler 接口提供了一个单独的方法：<code>Object handle (java.sql.ResultSet.rs)</code>。主要实现类。</p><table><thead><tr><th>主要实现类</th><th>描述</th></tr></thead><tbody><tr><td>ArrayHandler</td><td>把结果集中的第一行数据转成对象数组。</td></tr><tr><td>ArrayListHandler</td><td>把结果集中的每一行数据都转成一个数组，再存放到List中。</td></tr><tr><td>BeanHandler</td><td>将结果集中的第一行数据封装到一个对应的JavaBean实例中。</td></tr><tr><td>BeanListHandler</td><td>将结果集中的每一行数据都封装到一个对应的JavaBean实例中，存放到List里。</td></tr><tr><td>ColumnListHandler</td><td>将结果集中某一列的数据存放到List中。</td></tr><tr><td>KeyedHandler(name)</td><td>将结果集中的每一行数据都封装到一个Map里，再把这些map再存到一个map里，其 key 为指定的 key 。</td></tr><tr><td>MapHandler</td><td>将结果集中的第一行数据封装到一个Map里，key 是列名，value 就是对应的值。</td></tr><tr><td>MapListHandler</td><td>将结果集中的每一行数据都封装到一个 Map 里，然后再存放到 List 。</td></tr><tr><td>ScalarHandler</td><td>查询单个值对象。</td></tr></tbody></table><br /><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukiyama.jdbc.dbutils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.yukiyama.jdbc.bean.Customer;</span><br><span class="line"><span class="keyword">import</span> com.yukiyama.jdbc.utils.JDBCUtils2;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.dbutils.DbUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.dbutils.QueryRunner;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.dbutils.ResultSetHandler;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.dbutils.handlers.*;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.Date;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QueryRunnerTest</span> &#123;</span><br><span class="line">    <span class="comment">// 插入一条数据</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testInsert</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">QueryRunner</span> <span class="variable">runner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryRunner</span>();</span><br><span class="line">            conn = JDBCUtils2.getConnectionByDruid();</span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into customers (name, email, birth) values (?, ?, ?)&quot;</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">insertCount</span> <span class="operator">=</span> runner.update(conn, sql, <span class="string">&quot;duoduo&quot;</span>, <span class="string">&quot;duo@gmail.com&quot;</span>, <span class="string">&quot;1998-09-09&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;添加了&quot;</span> + insertCount + <span class="string">&quot;条记录。&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JDBCUtils2.closeResource(conn, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查询一条记录 BeanHandler&lt;&gt;</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testQuery1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">QueryRunner</span> <span class="variable">runner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryRunner</span>();</span><br><span class="line">            conn = JDBCUtils2.getConnectionByDruid();</span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select id, name, email, birth from customers where id = ?&quot;</span>;</span><br><span class="line">            BeanHandler&lt;Customer&gt; handler = <span class="keyword">new</span> <span class="title class_">BeanHandler</span>&lt;&gt;(Customer.class);</span><br><span class="line">            <span class="type">Customer</span> <span class="variable">cust</span> <span class="operator">=</span> runner.query(conn, sql, handler, <span class="number">18</span>);</span><br><span class="line">            System.out.println(cust);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JDBCUtils2.closeResource(conn, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查询多条记录 BeanListHandler&lt;&gt;</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testQuery2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">QueryRunner</span> <span class="variable">runner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryRunner</span>();</span><br><span class="line">            conn = JDBCUtils2.getConnectionByDruid();</span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select id, name, email, birth from customers&quot;</span>;</span><br><span class="line">            BeanListHandler&lt;Customer&gt; handler = <span class="keyword">new</span> <span class="title class_">BeanListHandler</span>&lt;&gt;(Customer.class);</span><br><span class="line">            List&lt;Customer&gt; list = runner.query(conn, sql, handler);</span><br><span class="line">            list.forEach(System.out::println);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JDBCUtils2.closeResource(conn, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查询一条记录，以map形式封装 MapHandler</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testQuery3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">QueryRunner</span> <span class="variable">runner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryRunner</span>();</span><br><span class="line">            conn = JDBCUtils2.getConnectionByDruid();</span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select id, name, email, birth from customers where id = ?&quot;</span>;</span><br><span class="line">            <span class="type">MapHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MapHandler</span>();</span><br><span class="line">            Map&lt;String, Object&gt; map = runner.query(conn, sql, handler, <span class="number">18</span>);</span><br><span class="line">            System.out.println(map);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JDBCUtils2.closeResource(conn, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查询多条记录，以map形式封装 MapListHandler</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testQuery4</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">QueryRunner</span> <span class="variable">runner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryRunner</span>();</span><br><span class="line">            conn = JDBCUtils2.getConnectionByDruid();</span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select id, name, email, birth from customers&quot;</span>;</span><br><span class="line">            <span class="type">MapListHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MapListHandler</span>();</span><br><span class="line">            List&lt;Map&lt;String, Object&gt;&gt; list = runner.query(conn, sql, handler);</span><br><span class="line">            list.forEach(System.out::println);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JDBCUtils2.closeResource(conn, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查询单个值 ScalarHandler</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testQuery5</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">QueryRunner</span> <span class="variable">runner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryRunner</span>();</span><br><span class="line">            conn = JDBCUtils2.getConnectionByDruid();</span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select count(*) from customers&quot;</span>;</span><br><span class="line">            <span class="type">ScalarHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScalarHandler</span>();</span><br><span class="line">            <span class="type">Long</span> <span class="variable">count</span> <span class="operator">=</span> (Long) runner.query(conn, sql, handler);</span><br><span class="line">            System.out.println(count);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JDBCUtils2.closeResource(conn, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查询单个值</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testQuery6</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">QueryRunner</span> <span class="variable">runner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryRunner</span>();</span><br><span class="line">            conn = JDBCUtils2.getConnectionByDruid();</span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select max(birth) from customers&quot;</span>;</span><br><span class="line">            <span class="type">ScalarHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScalarHandler</span>();</span><br><span class="line">            <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> (Date) runner.query(conn, sql, handler);</span><br><span class="line">            System.out.println(date);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JDBCUtils2.closeResource(conn, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 自定义 ResultSetHandler</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testQuery7</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">QueryRunner</span> <span class="variable">runner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryRunner</span>();</span><br><span class="line">            conn = JDBCUtils2.getConnectionByDruid();</span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select id, name, email, birth from customers where id = ?&quot;</span>;</span><br><span class="line">            ResultSetHandler&lt;Customer&gt; handler = <span class="keyword">new</span> <span class="title class_">ResultSetHandler</span>&lt;Customer&gt;()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> Customer <span class="title function_">handle</span><span class="params">(ResultSet rs)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">                    <span class="keyword">if</span>(rs.next())&#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> rs.getInt(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">                        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">                        <span class="type">String</span> <span class="variable">email</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;email&quot;</span>);</span><br><span class="line">                        <span class="type">Date</span> <span class="variable">birth</span> <span class="operator">=</span> rs.getDate(<span class="string">&quot;birth&quot;</span>);</span><br><span class="line">                        <span class="type">Customer</span> <span class="variable">customer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Customer</span>(id, name, email, birth);</span><br><span class="line">                        <span class="keyword">return</span> customer;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="type">Customer</span> <span class="variable">cust</span> <span class="operator">=</span> runner.query(conn, sql, handler, <span class="number">18</span>);</span><br><span class="line">            System.out.println(cust);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            DbUtils.closeQuietly(conn);</span><br><span class="line">            <span class="comment">// JDBCUtils2.closeResource(conn, null);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文内容总结如下。</p><table><thead><tr><th>要点</th><th>备注</th></tr></thead><tbody><tr><td>描述JDBC</td><td>公共接口 &#x2F; 标准 Java 库类 &#x2F; 面向接口</td></tr><tr><td>JDBC API 体系</td><td>面向应用 (使用 JDBC 连接和操作不同的 DBMS)<br />面向具体数据库管理系统 (各DBMS需适配)</td></tr><tr><td>使用 JDBC 连接数据库的步骤</td><td>1. 加入依赖<br /><code>mysql-connector-java-8.0.11.jar</code><br />2. 使用 <code>Driver</code> 或 <code>DriverManage</code> 来获取连接实例 <code>Connection</code></td></tr><tr><td>使用 JDBC 连接数据库的代码实现</td><td>三要素: Driver接口实现类 &#x2F; url &#x2F; 用户名&amp;密码</td></tr><tr><td>使用反射实例化 Driver</td><td></td></tr><tr><td>使用 DriverManager 代替 Driver</td><td>在 DriverManager 中注册具体的 Driver 实例<br /><code>DriverManager.registerDriver(new Driver());</code></td></tr><tr><td>Driver 实现类中的静态代码块</td><td>静态代码块中完成注册</td></tr><tr><td>将必要信息写到配置文件中</td><td>代码与配置解耦</td></tr><tr><td>操作数据库</td><td>Statement<br />PreparedStatement<br />CallableStatement</td></tr><tr><td>Statement的弊端</td><td>需要拼串<br />SQL注入</td></tr><tr><td>SQL 注入的例子</td><td><code>select user, password from user_table where user = &#39;&#39; and password = &#39;&#39;</code><br /><code>select user, password from user_table where user = &#39;1&#39; or &#39; and password = &#39;=1 or &#39;1&#39; = &#39;1&#39;</code></td></tr><tr><td>避免 SQL 注入的方法</td><td>使用 PreparedStatement<br />预编译后，通过占位符确定了 sql 语句逻辑关系，避免拼串导致逻辑关系被修改</td></tr><tr><td>PreparedStatement 的优点</td><td>1. 预编译，防止 SQL 注入<br />2. 可以通过占位符传入流，实现对大文件的操作<br />3. 可以实现更高效的批量操作 (原因是预编译)</td></tr><tr><td>使用 PreparedStatement 操作数据库</td><td>1. 获取数据库连接<br />2. 写出预编译 sql 语句，返回 PreparedStatement 实例<br />3. 填充占位符<br />4. 执行<br />5. 关闭资源</td></tr><tr><td>ORM</td><td>Object Relational Model 对象关系模型<br />Object Relational Mapping 对象关系映射<br />- 一个数据表对应一个 java 类<br />- 表中的一条记录对应 java 类的一个对象实例<br />- 标中的一个字段对应 java 类的一个属性</td></tr><tr><td>通用增删改方法</td><td>基于 PreparedStatement</td></tr><tr><td>通用查询方法</td><td></td></tr><tr><td>结果集</td><td><code>ResultSet rs = ps.executeQuery()</code></td></tr><tr><td>结果集元数据</td><td><code>ResultSetMetaData rsmd = rs.getMetaData();</code></td></tr><tr><td>获取列数</td><td><code>int colCount = rsmd.getColumnCount();</code></td></tr><tr><td>将结果中的一行输出为对象实例</td><td>利用反射<br /><code>Object colValue = rs.getObject(i + 1);</code> <br /><code>String colName = rsmd.getColumnLabel(i + 1);</code> <br /><code>Field field = Customer.class.getDeclaredField(colName);</code><br /><code>field.setAccessible(true);</code> <br /><code>field.set(customer, colValue);</code></td></tr><tr><td>获取列别名而不是列名</td><td><code>getColumnLabel</code> 若无别名则返回列名</td></tr><tr><td>对不同表的通用查询方法</td><td>泛型</td></tr><tr><td>两种思想</td><td>1. 面向接口<br />2. ORM</td></tr><tr><td>两种技术</td><td>1. 结果集元数据<br />2. 反射</td></tr></tbody></table><br />]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> JDBC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven学习实战</title>
      <link href="/2022/08/31/Maven%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98_yukiyama/"/>
      <url>/2022/08/31/Maven%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98_yukiyama/</url>
      
        <content type="html"><![CDATA[<h1 id="Maven学习实战-yukiyama"><a href="#Maven学习实战-yukiyama" class="headerlink" title="Maven学习实战_yukiyama"></a>Maven学习实战_yukiyama</h1><blockquote><p>本文总结自 <a href="https://www.bilibili.com/video/BV12q4y147e4/?spm_id_from=333.999.0.0">尚硅谷2022版Maven教程（maven入门+高深，全网无出其右！）</a> 。</p><p>操作环境为 macOS Monterey 12.6 &#x2F; apache-maven-3.8.5 &#x2F; IntelliJ IDEA 2022.2.1 (Ultimate Edition) 。</p></blockquote><br /><h2 id="Maven简述"><a href="#Maven简述" class="headerlink" title="Maven简述"></a>Maven简述</h2><p><a href="https://maven.apache.org/">Maven</a> 是 Apache 基金会维护的针对 <strong>Java 项目构建和依赖管理的工具</strong>，用于定义项目结构、管理项目依赖并提供一套标准的项目构建流程。</p><ul><li><strong>Maven 作为依赖管理工具</strong>。通过引入「依赖」可自动从该依赖的官方网站上下载规范的相关 Jar 包，并管理规模巨大的 jar 包及它们之间的依赖关系。</li><li><strong>Maven 作为构建管理工具</strong>。脱离 IDE 环境时可利用 Maven 进行构建。</li></ul><br /><h3 id="坐标"><a href="#坐标" class="headerlink" title="坐标"></a>坐标</h3><p>Maven 项目使用 <code>pom.xml</code> 文件来管理依赖。该文件中的 <code>&lt;dependencies&gt;</code> 标签中，每一个 <code>&lt;dependency&gt;</code> 都通过三个向量来完成依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.maven.plugins/maven-clean-plugin --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-clean-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这三个向量唯一确定一个 jar 包。</p><table><thead><tr><th>向量</th><th>描述</th></tr></thead><tbody><tr><td>groupId</td><td>公司或组织的项目 ID，例如 <code>org.apache.maven.plugins</code></td></tr><tr><td>artifactId</td><td>项目或项目中的模块，例如<code>maven-clean-plugin</code></td></tr><tr><td>version</td><td>版本号，例如 <code>2.5</code>, <code>1.0-SNAPSHOT</code>, <code>2.0-RELEASE</code> 等。<br /><code>SNAPSHOT</code> 为快照版本，即还在开发迭代中的不稳定版本。<br /><code>RELEASE</code> 为正式版本。</td></tr></tbody></table><p>根据该依赖，如下文件会自动下载到本地仓库 (本演示为 <code>repo</code> ) 中的如下目录中。可以看到，路径实际上是由 <code>groupId</code>, <code>artifactId</code> 和 <code>version</code> 组成的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/Users/yukiyama/maven/repo/org/apache/maven/plugins/maven-clean-plugin/2.5</span><br><span class="line"></span><br><span class="line">_remote.repositories</span><br><span class="line">maven-clean-plugin-2.5.jar</span><br><span class="line">maven-clean-plugin-2.5.jar.sha1</span><br><span class="line">maven-clean-plugin-2.5.pom</span><br><span class="line">maven-clean-plugin-2.5.pom.sha1</span><br></pre></td></tr></table></figure><br /><h3 id="POM"><a href="#POM" class="headerlink" title="POM"></a>POM</h3><p>POM (Project Object Model) ，即 <strong>「项目对象模型」</strong> 。可与之类比的是 XML 文档中的 DOM 的概念 (Document Object Model) ，文档对象模型。POM 将项目抽象为模型体现在项目的 <code>pom.xml</code> 文件中。常用的 pom 标签会在后文中陆续介绍。</p><br /><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p>Maven 项目的目录结构是约定好的，约定目录的目的是尽可能 <strong>自动化完成项目构建</strong> 。例如 Maven 执行编译操作，要先去 Java 源程序目录读取 Java 源代码，然后执行编译，之后将编译结果存放在 target 目录中等等。不同的 Maven 项目的约定的目录结构不同，在后续分别创建「Maven Java 项目」和 「Maven Web 项目」时将分别展示二者的目录结构。</p><p>当前开发领域的技术发展趋势：<strong>约定大于配置，配置大于编码</strong>。</p><br /><h2 id="安装及配置"><a href="#安装及配置" class="headerlink" title="安装及配置"></a>安装及配置</h2><h3 id="安装Maven"><a href="#安装Maven" class="headerlink" title="安装Maven"></a>安装Maven</h3><h4 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h4><ol><li><p>在 <a href="https://maven.apache.org/download.cgi">Maven 官网</a>下载所需版本的 Maven 压缩包。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apache-maven-3.8.6-bin.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>将压缩包解压后置于一个无特殊字符 (如中文字符) 的路径下。</p></li><li><p>在终端中通过 <code>vim ~/.bash_profile</code> 命令编辑配置文件 <code>.bash_profile</code> ，向其中 PATH 中添加 Maven 的路径信息，如下 (Java 已事先安装好并配置到环境变量中了)。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk-16.0.1.jdk/Contents/Home</span><br><span class="line">export M2_HOME=/Users/yukiyama/apache-maven-3.8.5/</span><br><span class="line"></span><br><span class="line">export PATH=$&#123;PATH&#125;:$&#123;JAVA_HOME&#125;/bin:$&#123;M2_HOME&#125;/bin</span><br></pre></td></tr></table></figure></li><li><p>保存并退出后，在终端中执行 <code>source .bash_profile</code> 使新配置生效。</p></li><li><p>在终端中执行 <code>echo $M2_HOME</code> ，应返回 Maven 的路径信息。另外，还可执行 <code>mvn --version</code> ，若安装成功，则返回已安装的 Maven 的版本信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama ~ % echo $M2_HOME</span><br><span class="line">/Users/yukiyama/apache-maven-3.8.5/</span><br><span class="line">yukiyama@yukiyama ~ % mvn --version</span><br><span class="line">Apache Maven 3.8.5 (3599d3414f046de2324203b78ddcf9b5e4388aa0)</span><br><span class="line">Maven home: /Users/yukiyama/apache-maven-3.8.5</span><br><span class="line">Java version: 16.0.1, vendor: Oracle Corporation, runtime: /Library/Java/JavaVirtualMachines/jdk-16.0.1.jdk/Contents/Home</span><br><span class="line">Default locale: zh_JP_#Hans, platform encoding: UTF-8</span><br><span class="line">OS name: &quot;mac os x&quot;, version: &quot;11.5&quot;, arch: &quot;x86_64&quot;, family: &quot;mac&quot;</span><br><span class="line">yukiyama@yukiyama ~ %</span><br></pre></td></tr></table></figure></li></ol><br /><h3 id="配置Maven"><a href="#配置Maven" class="headerlink" title="配置Maven"></a>配置Maven</h3><p>maven 的配置文件在 maven 安装目录下  (apache-maven-x.x.x) 的 <code>conf</code> 文件夹中，文件名为 <code>settings.xml</code> 。常用配置如下。</p><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td><code>&lt;localRepository&gt;</code></td><td>本地仓库路径</td></tr><tr><td><code>&lt;mirrors&gt;</code></td><td>镜像仓库</td></tr></tbody></table><p><strong>指定本地仓库路径</strong></p><p> <code>settings.xml</code> 中搜索 <code>&lt;localRepository&gt;</code> 标签，设置本地仓库路径。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>/Users/yukiyama/maven/repo<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>添加镜像仓库</strong></p><p>搜索 <code>&lt;mirrors&gt;</code> 标签，注释掉现有的 <code>&lt;mirror&gt;</code> 标签内的内容，然后在 <code>&lt;mirrors&gt;</code> 标签内新增阿里云提供的镜像仓库。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus aliyun<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>指定 JDK 版本</strong></p><p>搜索 <code>&lt;profiles&gt;</code> 标签，添加如下内容可以指定 JDK 版本。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用 JDK1.8 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>jdk-1.8<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">jdk</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.compilerVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br></pre></td></tr></table></figure><br /><h2 id="创建及管理项目"><a href="#创建及管理项目" class="headerlink" title="创建及管理项目"></a>创建及管理项目</h2><h3 id="命令行方式"><a href="#命令行方式" class="headerlink" title="命令行方式"></a>命令行方式</h3><h4 id="创建Java项目"><a href="#创建Java项目" class="headerlink" title="创建Java项目"></a>创建Java项目</h4><p>在终端中进入需要创建项目的目录下，执行 <code>mvn archetype:generate</code> 命令 <strong>创建 Maven Java 项目</strong> 。</p><ol><li>初次使用时会下载依赖的 Jar 包，且从下载地址中看到是从我们配置的 aliyun 镜像中下载的。</li><li>下载完成后提示 <code>Choose archetype</code> ，需要输入 1 到 8 <strong>选择 Maven 项目模版</strong>。若直接回车则选择默认的第 7 个模版 <code>maven-archetype-quickstart</code> 。</li><li>接着分别设置 <code>groupId</code>, <code>artifactId</code>, <code>version</code>, <code>package</code> 。</li><li>确认后输入 Y 或直接回车完成。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama ~ % cd /Users/yukiyama/maven/workspace/test</span><br><span class="line">yukiyama@yukiyama test % mvn archetype:generate</span><br><span class="line">[INFO] Scanning for projects...</span><br><span class="line">Downloading from nexus-aliyun: http://maven.aliyun.com/nexus/content/groups/public/org/apache/maven/plugins/maven-clean-plugin/2.5/maven-clean-plugin-2.5.pom</span><br><span class="line">...(省略)...</span><br><span class="line">[INFO] Generating project in Interactive mode</span><br><span class="line">[WARNING] No archetype found in remote catalog. Defaulting to internal catalog</span><br><span class="line">[INFO] No archetype defined. Using maven-archetype-quickstart (org.apache.maven.archetypes:maven-archetype-quickstart:1.0)</span><br><span class="line">Choose archetype:</span><br><span class="line">1: internal -&gt; org.apache.maven.archetypes:maven-archetype-archetype (An archetype which contains a sample archetype.)</span><br><span class="line">2: internal -&gt; org.apache.maven.archetypes:maven-archetype-j2ee-simple (An archetype which contains a simplifed sample J2EE application.)</span><br><span class="line">3: internal -&gt; org.apache.maven.archetypes:maven-archetype-plugin (An archetype which contains a sample Maven plugin.)</span><br><span class="line">4: internal -&gt; org.apache.maven.archetypes:maven-archetype-plugin-site (An archetype which contains a sample Maven plugin site.</span><br><span class="line">      This archetype can be layered upon an existing Maven plugin project.)</span><br><span class="line">5: internal -&gt; org.apache.maven.archetypes:maven-archetype-portlet (An archetype which contains a sample JSR-268 Portlet.)</span><br><span class="line">6: internal -&gt; org.apache.maven.archetypes:maven-archetype-profiles ()</span><br><span class="line">7: internal -&gt; org.apache.maven.archetypes:maven-archetype-quickstart (An archetype which contains a sample Maven project.)</span><br><span class="line">8: internal -&gt; org.apache.maven.archetypes:maven-archetype-site (An archetype which contains a sample Maven site which demonstrates</span><br><span class="line">      some of the supported document types like APT, XDoc, and FML and demonstrates how</span><br><span class="line">      to i18n your site. This archetype can be layered upon an existing Maven project.)</span><br><span class="line">9: internal -&gt; org.apache.maven.archetypes:maven-archetype-site-simple (An archetype which contains a sample Maven site.)</span><br><span class="line">10: internal -&gt; org.apache.maven.archetypes:maven-archetype-webapp (An archetype which contains a sample Maven Webapp project.)</span><br><span class="line">Choose a number or apply filter (format: [groupId:]artifactId, case sensitive contains): 7:</span><br><span class="line">Define value for property &#x27;groupId&#x27;: com.yukiyama.maven</span><br><span class="line">Define value for property &#x27;artifactId&#x27;: pro01-maven-java</span><br><span class="line">Define value for property &#x27;version&#x27; 1.0-SNAPSHOT: :</span><br><span class="line">Define value for property &#x27;package&#x27; com.yukiyama.maven: :</span><br><span class="line">Confirm properties configuration:</span><br><span class="line">groupId: com.yukiyama.maven</span><br><span class="line">artifactId: pro01-maven-java</span><br><span class="line">version: 1.0-SNAPSHOT</span><br><span class="line">package: com.yukiyama.maven</span><br><span class="line"> Y: :</span><br><span class="line"> [INFO] ----------------------------------------------------------------------------</span><br><span class="line">[INFO] Using following parameters for creating project from Old (1.x) Archetype: maven-archetype-quickstart:1.1</span><br><span class="line">[INFO] ----------------------------------------------------------------------------</span><br><span class="line">[INFO] Parameter: basedir, Value: /Users/yukiyama/maven/workspace/test</span><br><span class="line">[INFO] Parameter: package, Value: com.yukiyama.maven</span><br><span class="line">[INFO] Parameter: groupId, Value: com.yukiyama.maven</span><br><span class="line">[INFO] Parameter: artifactId, Value: pro01-maven-java</span><br><span class="line">[INFO] Parameter: packageName, Value: com.yukiyama.maven</span><br><span class="line">[INFO] Parameter: version, Value: 1.0-SNAPSHOT</span><br><span class="line">[INFO] project created from Old (1.x) Archetype in dir: /Users/yukiyama/maven/workspace/test/pro01-maven-java</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESS</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time:  06:29 min</span><br><span class="line">[INFO] Finished at: 2022-09-22T02:20:01+08:00</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">yukiyama@yukiyama test %</span><br></pre></td></tr></table></figure><p>创建完成后在项目目录下可以看到该项目模版的目录结构。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama test % tree pro01-maven-java</span><br><span class="line">pro01-maven-java</span><br><span class="line">├── pom.xml</span><br><span class="line">└── src</span><br><span class="line">    ├── main</span><br><span class="line">    │   └── java</span><br><span class="line">    │       └── com</span><br><span class="line">    │           └── yukiyama</span><br><span class="line">    │               └── maven</span><br><span class="line">    │                   └── App.java</span><br><span class="line">    └── test</span><br><span class="line">        └── java</span><br><span class="line">            └── com</span><br><span class="line">                └── yukiyama</span><br><span class="line">                    └── maven</span><br><span class="line">                        └── AppTest.java</span><br></pre></td></tr></table></figure><p>目录用途如下。</p><table><thead><tr><th>目录</th><th>描述</th></tr></thead><tbody><tr><td>src</td><td>源码目录</td></tr><tr><td>main</td><td>主体程序目录</td></tr><tr><td>java</td><td>Java源码 (<code>.java</code> 文件)</td></tr><tr><td>com</td><td>package 目录</td></tr><tr><td>test</td><td>测试程序目录</td></tr></tbody></table><p>在我们指定的本地仓库中 (<code>repo</code> 文件夹) ，可以看到很多因为本次项目创建而引入的 Jar 包及相关文件。例如对于第一个下载的文件，其下载后的路径如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 下载的第一个文件</span><br><span class="line">Downloading from nexus-aliyun: http://maven.aliyun.com/nexus/content/groups/public/org/apache/maven/plugins/maven-clean-plugin/2.5/maven-clean-plugin-2.5.pom</span><br><span class="line"></span><br><span class="line">// 下载后的路径</span><br><span class="line">repo/org/apache/maven/plugins/maven-clean-plugin/2.5/maven-clean-plugin-2.5.pom</span><br></pre></td></tr></table></figure><p>从这里可以看出，路径实际上是由 <code>groupId</code>, <code>artifactId</code> 和 <code>version</code> 组成的。</p><br /><p>pom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.yukiyama.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pro01-maven-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>pro01-maven-java<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>自动生成的 pom.xml 中依赖的 junit 版本 3.8.1 较低，可按需要改为较新版本，如 4.12 版本。</p><br /><h5 id="项目构建"><a href="#项目构建" class="headerlink" title="项目构建"></a>项目构建</h5><p>需要在 <code>pom.xml</code> 文件所在目录下执行构建命令，否则出现如下错误 (… but there is no POM in this directory …)。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama test % mvn compile</span><br><span class="line">[INFO] Scanning for projects...</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD FAILURE</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time:  0.107 s</span><br><span class="line">[INFO] Finished at: 2022-09-22T20:14:54+08:00</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[ERROR] The goal you specified requires a project to execute but there is no POM in this directory (/Users/yukiyama/maven/workspace/test). Please verify you invoked Maven from the correct directory. -&gt; [Help 1]</span><br><span class="line">[ERROR]</span><br><span class="line">[ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch.</span><br><span class="line">[ERROR] Re-run Maven using the -X switch to enable full debug logging.</span><br><span class="line">[ERROR]</span><br><span class="line">[ERROR] For more information about the errors and possible solutions, please read the following articles:</span><br><span class="line">[ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/MissingProjectException</span><br><span class="line">yukiyama@yukiyama test %</span><br></pre></td></tr></table></figure><br /><h6 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h6><p>在 Maven 项目的 <code>pom.xml</code> 所在目录下执行 <code>mvn complie</code> 完成编译。首次执行此命令会下载相关 Jar 包。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama pro01-maven-java % mvn compile</span><br><span class="line">[INFO] Scanning for projects...</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] ----------------&lt; com.yukiyama.maven:pro01-maven-java &gt;-----------------</span><br><span class="line">[INFO] Building pro01-maven-java 1.0-SNAPSHOT</span><br><span class="line">[INFO] --------------------------------[ jar ]---------------------------------</span><br><span class="line">Downloading from nexus-aliyun: http://maven.aliyun.com/nexus/content/groups/public/org/apache/maven/plugins/maven-resources-plugin/2.6/maven-resources-plugin-2.6.pom</span><br><span class="line">...(略)...</span><br><span class="line">[INFO] Changes detected - recompiling the module!</span><br><span class="line">[INFO] Compiling 1 source file to /Users/yukiyama/maven/workspace/test/pro01-maven-java/target/classes</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESS</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time:  01:17 min</span><br><span class="line">[INFO] Finished at: 2022-09-22T16:20:01+08:00</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">yukiyama@yukiyama pro01-maven-java %</span><br></pre></td></tr></table></figure><p>编译完成后可以看到在项目目录下多了 target 文件夹，编译后的 <code>.class</code> 即存放 <code>target/classes</code> 文件夹下。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">pro01-maven-java</span><br><span class="line">├── pom.xml</span><br><span class="line">├── src</span><br><span class="line">│   ├── main</span><br><span class="line">│   │   └── java</span><br><span class="line">│   │       └── com</span><br><span class="line">│   │           └── yukiyama</span><br><span class="line">│   │               └── maven</span><br><span class="line">│   │                   └── Calculator.java</span><br><span class="line">│   └── test</span><br><span class="line">│       └── java</span><br><span class="line">│           └── com</span><br><span class="line">│               └── yukiyama</span><br><span class="line">│                   └── maven</span><br><span class="line">│                       └── CalculatorTest.java</span><br><span class="line">└── target</span><br><span class="line">    ├── classes</span><br><span class="line">    │   └── com</span><br><span class="line">    │       └── yukiyama</span><br><span class="line">    │           └── maven</span><br><span class="line">    │               └── Calculator.class</span><br><span class="line">    ├── generated-sources</span><br><span class="line">    │   └── annotations</span><br><span class="line">    └── maven-status</span><br><span class="line">        └── maven-compiler-plugin</span><br><span class="line">            └── compile</span><br><span class="line">                └── default-compile</span><br><span class="line">                    ├── createdFiles.lst</span><br><span class="line">                    └── inputFiles.lst</span><br></pre></td></tr></table></figure><br /><h6 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h6><p>执行 <code>mvn test</code> 可以完成测试。同样地，首次执行时会下载相关 Jar 包 (如下执行已经不是首次执行，所以没有下载 Jar 包的记录)。</p><p>可以看到，在执行 <code>test</code> 命令之前，实际上 Maven 还自动依次执行了 <code>resources</code>, <code>compile</code>, <code>testResources</code>, <code>testCompile</code> 。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama pro01-maven-java % mvn test</span><br><span class="line">[INFO] Scanning for projects...</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] ----------------&lt; com.yukiyama.maven:pro01-maven-java &gt;-----------------</span><br><span class="line">[INFO] Building pro01-maven-java 1.0-SNAPSHOT</span><br><span class="line">[INFO] --------------------------------[ jar ]---------------------------------</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ pro01-maven-java ---</span><br><span class="line">[INFO] Using &#x27;UTF-8&#x27; encoding to copy filtered resources.</span><br><span class="line">[INFO] skip non existing resourceDirectory /Users/yukiyama/maven/workspace/test/pro01-maven-java/src/main/resources</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] --- maven-compiler-plugin:3.1:compile (default-compile) @ pro01-maven-java ---</span><br><span class="line">[INFO] Nothing to compile - all classes are up to date</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] --- maven-resources-plugin:2.6:testResources (default-testResources) @ pro01-maven-java ---</span><br><span class="line">[INFO] Using &#x27;UTF-8&#x27; encoding to copy filtered resources.</span><br><span class="line">[INFO] skip non existing resourceDirectory /Users/yukiyama/maven/workspace/test/pro01-maven-java/src/test/resources</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] --- maven-compiler-plugin:3.1:testCompile (default-testCompile) @ pro01-maven-java ---</span><br><span class="line">[INFO] Changes detected - recompiling the module!</span><br><span class="line">[INFO] Compiling 1 source file to /Users/yukiyama/maven/workspace/test/pro01-maven-java/target/test-classes</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] --- maven-surefire-plugin:2.12.4:test (default-test) @ pro01-maven-java ---</span><br><span class="line">[INFO] Surefire report directory: /Users/yukiyama/maven/workspace/test/pro01-maven-java/target/surefire-reports</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------</span><br><span class="line"> T E S T S</span><br><span class="line">-------------------------------------------------------</span><br><span class="line">Running com.yukiyama.maven.CalculatorTest</span><br><span class="line">完成测试。</span><br><span class="line">Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.103 sec</span><br><span class="line"></span><br><span class="line">Results :</span><br><span class="line"></span><br><span class="line">Tests run: 1, Failures: 0, Errors: 0, Skipped: 0</span><br><span class="line"></span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESS</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time:  2.365 s</span><br><span class="line">[INFO] Finished at: 2022-09-24T14:20:57+08:00</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">yukiyama@yukiyama pro01-maven-java %</span><br></pre></td></tr></table></figure><p>测试完成后可以看到 target 文件夹中多了 <code>test-classes</code> 目录，存放测试源文件编译后的  <code>.class</code> 文件。此外还生成了测试报告，存放于 <code>surefire-reports</code> 文件夹中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">pro01-maven-java</span><br><span class="line">├── pom.xml</span><br><span class="line">├── src</span><br><span class="line">│   ├── main</span><br><span class="line">│   │   └── java</span><br><span class="line">│   │       └── com</span><br><span class="line">│   │           └── yukiyama</span><br><span class="line">│   │               └── maven</span><br><span class="line">│   │                   └── Calculator.java</span><br><span class="line">│   └── test</span><br><span class="line">│       └── java</span><br><span class="line">│           └── com</span><br><span class="line">│               └── yukiyama</span><br><span class="line">│                   └── maven</span><br><span class="line">│                       └── CalculatorTest.java</span><br><span class="line">└── target</span><br><span class="line">    ├── classes</span><br><span class="line">    │   └── com</span><br><span class="line">    │       └── yukiyama</span><br><span class="line">    │           └── maven</span><br><span class="line">    │               └── Calculator.class</span><br><span class="line">    ├── generated-sources</span><br><span class="line">    │   └── annotations</span><br><span class="line">    ├── generated-test-sources</span><br><span class="line">    │   └── test-annotations</span><br><span class="line">    ├── maven-status</span><br><span class="line">    │   └── maven-compiler-plugin</span><br><span class="line">    │       ├── compile</span><br><span class="line">    │       │   └── default-compile</span><br><span class="line">    │       │       ├── createdFiles.lst</span><br><span class="line">    │       │       └── inputFiles.lst</span><br><span class="line">    │       └── testCompile</span><br><span class="line">    │           └── default-testCompile</span><br><span class="line">    │               ├── createdFiles.lst</span><br><span class="line">    │               └── inputFiles.lst</span><br><span class="line">    ├── surefire-reports</span><br><span class="line">    │   ├── TEST-com.yukiyama.maven.CalculatorTest.xml</span><br><span class="line">    │   └── com.yukiyama.maven.CalculatorTest.txt</span><br><span class="line">    └── test-classes</span><br><span class="line">        └── com</span><br><span class="line">            └── yukiyama</span><br><span class="line">                └── maven</span><br><span class="line">                    └── CalculatorTest.class</span><br></pre></td></tr></table></figure><br /><h6 id="清理"><a href="#清理" class="headerlink" title="清理"></a>清理</h6><p>执行 <code>mvn clean</code> 清理当前目录的编译结果。同样地，首次执行时会下载相关 Jar 包。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama pro01-maven-java % mvn clean</span><br><span class="line">[INFO] Scanning for projects...</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] ----------------&lt; com.yukiyama.maven:pro01-maven-java &gt;-----------------</span><br><span class="line">[INFO] Building pro01-maven-java 1.0-SNAPSHOT</span><br><span class="line">[INFO] --------------------------------[ jar ]---------------------------------</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ pro01-maven-java ---</span><br><span class="line">Downloading from nexus-aliyun: http://maven.aliyun.com/nexus/content/groups/public/org/codehaus/plexus/plexus-utils/3.0/plexus-utils-3.0.pom</span><br><span class="line">...(略)...</span><br><span class="line">[INFO] Deleting /Users/yukiyama/maven/workspace/test/pro01-maven-java/target</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESS</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time:  4.845 s</span><br><span class="line">[INFO] Finished at: 2022-09-22T16:36:34+08:00</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">yukiyama@yukiyama pro01-maven-java %</span><br></pre></td></tr></table></figure><p>清理后可看到 target 文件夹已删除。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pro01-maven-java</span><br><span class="line">├── pom.xml</span><br><span class="line">└── src</span><br><span class="line">    ├── main</span><br><span class="line">    │   └── java</span><br><span class="line">    │       └── com</span><br><span class="line">    │           └── yukiyama</span><br><span class="line">    │               └── maven</span><br><span class="line">    │                   └── Calculator.java</span><br><span class="line">    └── test</span><br><span class="line">        └── java</span><br><span class="line">            └── com</span><br><span class="line">                └── yukiyama</span><br><span class="line">                    └── maven</span><br><span class="line">                        └── CalculatorTest.java</span><br></pre></td></tr></table></figure><br /><h6 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h6><p>执行 <code>mvn package</code> 打包项目为 Jar 包。同样地，首次执行时会下载相关 Jar 包。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama pro01-maven-java % mvn package</span><br><span class="line">[INFO] Scanning for projects...</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] ----------------&lt; com.yukiyama.maven:pro01-maven-java &gt;-----------------</span><br><span class="line">[INFO] Building pro01-maven-java 1.0-SNAPSHOT</span><br><span class="line">[INFO] --------------------------------[ jar ]---------------------------------</span><br><span class="line">Downloading from nexus-aliyun: http://maven.aliyun.com/nexus/content/groups/public/org/apache/maven/plugins/maven-jar-plugin/2.4/maven-jar-plugin-2.4.pom</span><br><span class="line">...(略)...</span><br><span class="line">[INFO] Building jar: /Users/yukiyama/maven/workspace/test/pro01-maven-java/target/pro01-maven-java-1.0-SNAPSHOT.jar</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESS</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time:  10.557 s</span><br><span class="line">[INFO] Finished at: 2022-09-22T16:40:38+08:00</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">yukiyama@yukiyama pro01-maven-java %</span><br></pre></td></tr></table></figure><p>打包完成后在 target 目录下可以看到生成了如下 Jar 包，文件名是由 <code>artifactId</code> 和 <code>version</code> 组成的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pro01-maven-java-1.0-SNAPSHOT.jar</span><br></pre></td></tr></table></figure><p>解压缩后可看到 Jar 包的如下构成，其中并不包含测试程序的字节码文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pro01-maven-java-1.0-SNAPSHOT</span><br><span class="line">├── META-INF</span><br><span class="line">│   ├── MANIFEST.MF</span><br><span class="line">│   └── maven</span><br><span class="line">│       └── com.yukiyama.maven</span><br><span class="line">│           └── pro01-maven-java</span><br><span class="line">│               ├── pom.properties</span><br><span class="line">│               └── pom.xml</span><br><span class="line">└── com</span><br><span class="line">    └── yukiyama</span><br><span class="line">        └── maven</span><br><span class="line">            └── Calculator.class</span><br></pre></td></tr></table></figure><p>其中 <code>pom.xml</code> 文件与原项目中的相同，<code>pom.properties</code> 文件如下。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Generated by Maven</span></span><br><span class="line"><span class="comment">#Thu Sep 22 16:40:38 CST 2022</span></span><br><span class="line"><span class="attr">groupId</span>=<span class="string">com.yukiyama.maven</span></span><br><span class="line"><span class="attr">artifactId</span>=<span class="string">pro01-maven-java</span></span><br><span class="line"><span class="attr">version</span>=<span class="string">1.0-SNAPSHOT</span></span><br></pre></td></tr></table></figure><br /><h6 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h6><p>执行 <code>mvn install</code> 安装 Jar 包到本地仓库中。从下面的执行日志可看到，在执行安装前，该命令会先完成编译，测试编译，以及测试动作。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama pro01-maven-java % mvn install</span><br><span class="line">[INFO] Scanning for projects...</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] ----------------&lt; com.yukiyama.maven:pro01-maven-java &gt;-----------------</span><br><span class="line">[INFO] Building pro01-maven-java 1.0-SNAPSHOT</span><br><span class="line">[INFO] --------------------------------[ jar ]---------------------------------</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ pro01-maven-java ---</span><br><span class="line">[INFO] Using &#x27;UTF-8&#x27; encoding to copy filtered resources.</span><br><span class="line">[INFO] skip non existing resourceDirectory /Users/yukiyama/maven/workspace/test/pro01-maven-java/src/main/resources</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] --- maven-compiler-plugin:3.1:compile (default-compile) @ pro01-maven-java ---</span><br><span class="line">[INFO] Nothing to compile - all classes are up to date</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] --- maven-resources-plugin:2.6:testResources (default-testResources) @ pro01-maven-java ---</span><br><span class="line">[INFO] Using &#x27;UTF-8&#x27; encoding to copy filtered resources.</span><br><span class="line">[INFO] skip non existing resourceDirectory /Users/yukiyama/maven/workspace/test/pro01-maven-java/src/test/resources</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] --- maven-compiler-plugin:3.1:testCompile (default-testCompile) @ pro01-maven-java ---</span><br><span class="line">[INFO] Nothing to compile - all classes are up to date</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] --- maven-surefire-plugin:2.12.4:test (default-test) @ pro01-maven-java ---</span><br><span class="line">[INFO] Surefire report directory: /Users/yukiyama/maven/workspace/test/pro01-maven-java/target/surefire-reports</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------</span><br><span class="line"> T E S T S</span><br><span class="line">-------------------------------------------------------</span><br><span class="line">Running com.yukiyama.maven.CalculatorTest</span><br><span class="line">完成测试。</span><br><span class="line">Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.09 sec</span><br><span class="line"></span><br><span class="line">Results :</span><br><span class="line"></span><br><span class="line">Tests run: 1, Failures: 0, Errors: 0, Skipped: 0</span><br><span class="line"></span><br><span class="line">[INFO]</span><br><span class="line">[INFO] --- maven-jar-plugin:2.4:jar (default-jar) @ pro01-maven-java ---</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] --- maven-install-plugin:2.4:install (default-install) @ pro01-maven-java ---</span><br><span class="line">Downloading from nexus-aliyun: http://maven.aliyun.com/nexus/content/groups/public/org/codehaus/plexus/plexus-utils/3.0.5/plexus-utils-3.0.5.pom</span><br><span class="line">...(略)...</span><br><span class="line">[INFO] Installing /Users/yukiyama/maven/workspace/test/pro01-maven-java/target/pro01-maven-java-1.0-SNAPSHOT.jar to /Users/yukiyama/maven/repo/com/yukiyama/maven/pro01-maven-java/1.0-SNAPSHOT/pro01-maven-java-1.0-SNAPSHOT.jar</span><br><span class="line">[INFO] Installing /Users/yukiyama/maven/workspace/test/pro01-maven-java/pom.xml to /Users/yukiyama/maven/repo/com/yukiyama/maven/pro01-maven-java/1.0-SNAPSHOT/pro01-maven-java-1.0-SNAPSHOT.pom</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESS</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time:  7.432 s</span><br><span class="line">[INFO] Finished at: 2022-09-22T16:55:49+08:00</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">yukiyama@yukiyama pro01-maven-java %</span><br></pre></td></tr></table></figure><p>我们已经知道，无论执行的是 test, package, install 或是其他命令，maven 默认都会「覆盖式」地按既定执行顺序从最开始的阶段到命令所指定的阶段。若希望跳过某个阶段，可加入 <code>-D</code> 参数，举例如下 （<code>-D</code> 和 <code>maven</code> 之间无空格）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean install -Dmaven.test.skip=true</span><br></pre></td></tr></table></figure><p>该命令表示执行 <code>mvn clean install</code> 时跳过 <code>test</code> 阶段。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean compile -Dmaven.clean.skip=true -Dmaven.validate.skip=true</span><br></pre></td></tr></table></figure><p>该命令表示执行 <code>mvn clean compile</code> 时跳过 <code>clean</code> 和 <code>validate</code> 阶段。</p><p>安装到本地仓库中的路径是根据该项目的坐标生成的。在本地仓库 <code>repo</code> 目录下，可以看到如下文件结构。安装到本地仓库后的 Jar 包文件名不变，但 <code>pom.xml</code> 变为 <code>pro01-maven-java-1.0-SNAPSHOT.pom</code> ，它们内容相同。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">com</span><br><span class="line">└── yukiyama</span><br><span class="line">    └── maven</span><br><span class="line">        └── pro01-maven-java</span><br><span class="line">            ├── 1.0-SNAPSHOT</span><br><span class="line">            │   ├── _remote.repositories</span><br><span class="line">            │   ├── maven-metadata-local.xml</span><br><span class="line">            │   ├── pro01-maven-java-1.0-SNAPSHOT.jar</span><br><span class="line">            │   └── pro01-maven-java-1.0-SNAPSHOT.pom</span><br><span class="line">            └── maven-metadata-local.xml</span><br></pre></td></tr></table></figure><p>此外，还可以使用 <code>mvn clean install</code> 完成安装，实际效果等同于先执行 <code>mvn clean</code> 再执行 <code>mvn install</code> 。</p><br /><h4 id="创建Web项目"><a href="#创建Web项目" class="headerlink" title="创建Web项目"></a>创建Web项目</h4><p>在终端中进入工作目录下，执行如下命令创建 Maven Web 项目 (参考 Maven 官网 <a href="https://maven.apache.org/archetypes/maven-archetype-webapp/">Maven Webapp Archetype</a>)。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn archetype:generate -DarchetypeGroupId=org.apache.maven.archetypes -DarchetypeArtifactId=maven-archetype-webapp -DarchetypeVersion=1.4</span><br></pre></td></tr></table></figure><ol><li>初次使用时会下载依赖的 Jar 包，且从下载地址中看到是从我们配置的 aliyun 镜像中下载的。</li><li>下载完成后根据提示设置 <code>groupId</code>, <code>artifactId</code>, <code>version</code>, <code>package</code> 或直接回车使用默认值。</li><li>确认后输入 Y 或直接回车完成。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama test % mvn archetype:generate -DarchetypeGroupId=org.apache.maven.archetypes -DarchetypeArtifactId=maven-archetype-webapp -DarchetypeVersion=1.4</span><br><span class="line">[INFO] Scanning for projects...</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] ------------------&lt; org.apache.maven:standalone-pom &gt;-------------------</span><br><span class="line">[INFO] Building Maven Stub Project (No POM) 1</span><br><span class="line">[INFO] --------------------------------[ pom ]---------------------------------</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] &gt;&gt;&gt; maven-archetype-plugin:3.2.1:generate (default-cli) &gt; generate-sources @ standalone-pom &gt;&gt;&gt;</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] &lt;&lt;&lt; maven-archetype-plugin:3.2.1:generate (default-cli) &lt; generate-sources @ standalone-pom &lt;&lt;&lt;</span><br><span class="line">[INFO]</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] --- maven-archetype-plugin:3.2.1:generate (default-cli) @ standalone-pom ---</span><br><span class="line">[INFO] Generating project in Interactive mode</span><br><span class="line">[WARNING] No archetype found in remote catalog. Defaulting to internal catalog</span><br><span class="line">[INFO] Archetype repository not defined. Using the one from [org.apache.maven.archetypes:maven-archetype-webapp:1.0] found in catalog internal</span><br><span class="line">Downloading from nexus-aliyun: http://maven.aliyun.com/nexus/content/groups/public/org/apache/maven/archetypes/maven-archetype-webapp/1.4/maven-archetype-webapp-1.4.pom</span><br><span class="line">...(略)...</span><br><span class="line">Define value for property &#x27;groupId&#x27;: com.yukiyama.maven</span><br><span class="line">Define value for property &#x27;artifactId&#x27;: pro02-maven-web</span><br><span class="line">Define value for property &#x27;version&#x27; 1.0-SNAPSHOT: :</span><br><span class="line">Define value for property &#x27;package&#x27; com.yukiyama.maven: :</span><br><span class="line">Confirm properties configuration:</span><br><span class="line">groupId: com.yukiyama.maven</span><br><span class="line">artifactId: pro02-maven-web</span><br><span class="line">version: 1.0-SNAPSHOT</span><br><span class="line">package: com.yukiyama.maven</span><br><span class="line"> Y: :</span><br><span class="line">[INFO] ----------------------------------------------------------------------------</span><br><span class="line">[INFO] Using following parameters for creating project from Archetype: maven-archetype-webapp:1.4</span><br><span class="line">[INFO] ----------------------------------------------------------------------------</span><br><span class="line">[INFO] Parameter: groupId, Value: com.yukiyama.maven</span><br><span class="line">[INFO] Parameter: artifactId, Value: pro02-maven-web</span><br><span class="line">[INFO] Parameter: version, Value: 1.0-SNAPSHOT</span><br><span class="line">[INFO] Parameter: package, Value: com.yukiyama.maven</span><br><span class="line">[INFO] Parameter: packageInPathFormat, Value: com/yukiyama/maven</span><br><span class="line">[INFO] Parameter: package, Value: com.yukiyama.maven</span><br><span class="line">[INFO] Parameter: groupId, Value: com.yukiyama.maven</span><br><span class="line">[INFO] Parameter: artifactId, Value: pro02-maven-web</span><br><span class="line">[INFO] Parameter: version, Value: 1.0-SNAPSHOT</span><br><span class="line">[INFO] Project created from Archetype in dir: /Users/yukiyama/maven/workspace/test/pro02-maven-web</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESS</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time:  39.864 s</span><br><span class="line">[INFO] Finished at: 2022-09-22T17:21:41+08:00</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">yukiyama@yukiyama test %</span><br></pre></td></tr></table></figure><p>创建完成后在项目目录下可以看到该项目模版的目录结构。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pro02-maven-web</span><br><span class="line">├── pom.xml</span><br><span class="line">└── src</span><br><span class="line">    └── main</span><br><span class="line">        └── webapp</span><br><span class="line">            ├── WEB-INF</span><br><span class="line">            │   └── web.xml</span><br><span class="line">            └── index.jsp</span><br></pre></td></tr></table></figure><p>目录用途如下。需要注意的时，不同于 archetype-quickstart ，archetype-webapp 不会自动生成 test 目录，若需要，需手动创建。</p><table><thead><tr><th>目录</th><th>描述</th></tr></thead><tbody><tr><td>src</td><td>源码目录</td></tr><tr><td>main</td><td>主体程序目录</td></tr><tr><td>webapp</td><td>web 应用目录</td></tr></tbody></table><br /><p>pom.xml</p><p>可以看到打包方式 ( <code>&lt;package&gt;</code> 标签) 与之前的 Java 项目不同，为 <code>war</code> 方式。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.yukiyama.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pro02-maven-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>pro02-maven-web Maven Webapp<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- FIXME change it to the project&#x27;s website --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://www.example.com<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>pro02-maven-web<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginManagement</span>&gt;</span><span class="comment">&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-clean-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-resources-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.22.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-war-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-install-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-deploy-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>web.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">web-app</span> <span class="keyword">PUBLIC</span></span></span><br><span class="line"><span class="meta"> <span class="string">&quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot;</span></span></span><br><span class="line"><span class="meta"> <span class="string">&quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot;</span> &gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>Archetype Created Web Application<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><br /><h5 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h5><h6 id="新建Java文件"><a href="#新建Java文件" class="headerlink" title="新建Java文件"></a>新建Java文件</h6><p>由于前述创建项目的命令未帮助我们创建 Java 源文件，需要手动创建，如下，我们在 <code>src/main</code> 下创建 <code>java/com/yukiyama/maven</code> 路径，然后创建如下 <code>HelloServlet.java</code> 文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukiyama.maven;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line">            <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        response.getWriter().write(<span class="string">&quot;hello maven web&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h6 id="注册Servlet"><a href="#注册Servlet" class="headerlink" title="注册Servlet"></a>注册Servlet</h6><p>将如下 xml 标签内容添加到 <code>web.xml</code> 中的 <code>&lt;web-app&gt;</code> 下。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>helloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.atguigu.maven.HelloServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>helloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/helloServlet<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><br /><h6 id="编写超链接"><a href="#编写超链接" class="headerlink" title="编写超链接"></a>编写超链接</h6><p>在 index.jsp 中写入超链接 <code>&lt;a href=&quot;helloServlet&quot;&gt;Access Servlet&lt;/a&gt;</code> 。</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h2&gt;Hello World!&lt;/h2&gt;</span><br><span class="line">&lt;!-- 添加超链接 --&gt;</span><br><span class="line">&lt;a href=<span class="string">&quot;helloServlet&quot;</span>&gt;Access Servlet&lt;/a&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><br /><h5 id="项目构建-1"><a href="#项目构建-1" class="headerlink" title="项目构建"></a>项目构建</h5><p>与构建 Maven Java 项目一样，需要在 <code>pom.xml</code> 文件所在命令下执行构建命令。</p><br /><h6 id="编译-1"><a href="#编译-1" class="headerlink" title="编译"></a>编译</h6><p>在 Maven 项目的 <code>pom.xml</code> 所在目录下执行 <code>mvn complie</code> 完成编译，首次执行此命令会下载相关 Jar 包。执行后可能出现如下错误。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama pro02-maven-web % mvn compile</span><br><span class="line">[INFO] Scanning for projects...</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] -----------------&lt; com.yukiyama.maven:pro02-maven-web &gt;-----------------</span><br><span class="line">[INFO] Building pro02-maven-web Maven Webapp 1.0-SNAPSHOT</span><br><span class="line">[INFO] --------------------------------[ war ]---------------------------------</span><br><span class="line">Downloading from nexus-aliyun: http://maven.aliyun.com/nexus/content/groups/public/org/apache/maven/plugins/maven-resources-plugin/3.0.2/maven-resources-plugin-3.0.2.pom</span><br><span class="line">...(略：Jar 包下载)...</span><br><span class="line">[INFO] Changes detected - recompiling the module!</span><br><span class="line">[INFO] Compiling 1 source file to /Users/yukiyama/maven/workspace/test/pro02-maven-web/target/classes</span><br><span class="line">[INFO] -------------------------------------------------------------</span><br><span class="line">[ERROR] COMPILATION ERROR :</span><br><span class="line">[INFO] -------------------------------------------------------------</span><br><span class="line">[ERROR] /Users/yukiyama/maven/workspace/test/pro02-maven-web/src/main/java/com/yukiyama/maven/HelloServlet.java:[3,26] package javax.servlet.http does not exist</span><br><span class="line">...(略：多条错误信息)...</span><br><span class="line">[INFO] 8 errors</span><br><span class="line">[INFO] -------------------------------------------------------------</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD FAILURE</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time:  01:27 min</span><br><span class="line">[INFO] Finished at: 2022-09-22T20:02:13+08:00</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[ERROR] Failed to execute goal org.apache.maven.plugins:maven-compiler-plugin:3.8.0:compile (default-compile) on project pro02-maven-web: Compilation failure: Compilation failure:</span><br><span class="line">...(略：多条错误信息)...</span><br><span class="line">yukiyama@yukiyama pro02-maven-web %</span><br></pre></td></tr></table></figure><p>失败是由于缺少 <code>servlet-api.jar</code> 依赖导致的。可以在 <code>mvnrepository</code> <a href="https://mvnrepository.com/">网站</a> 查找该依赖的坐标信息，将其添加到 <code>pom.xml</code> 的 <code>&lt;dependencies&gt;</code> 标签下。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>再重新执行 <code>mvn compile</code> 命令，可以看到，下载了 <code>servlet-api</code>  Jar 包及其他相关文件，之后成功完成。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama pro02-maven-web % mvn compile</span><br><span class="line">[INFO] Scanning for projects...</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] -----------------&lt; com.yukiyama.maven:pro02-maven-web &gt;-----------------</span><br><span class="line">[INFO] Building pro02-maven-web Maven Webapp 1.0-SNAPSHOT</span><br><span class="line">[INFO] --------------------------------[ war ]---------------------------------</span><br><span class="line">Downloading from nexus-aliyun: http://maven.aliyun.com/nexus/content/groups/public/javax/servlet/javax.servlet-api/3.1.0/javax.servlet-api-3.1.0.pom</span><br><span class="line">Downloaded from nexus-aliyun: http://maven.aliyun.com/nexus/content/groups/public/javax/servlet/javax.servlet-api/3.1.0/javax.servlet-api-3.1.0.pom (14 kB at 3.8 kB/s)</span><br><span class="line">Downloading from nexus-aliyun: http://maven.aliyun.com/nexus/content/groups/public/net/java/jvnet-parent/3/jvnet-parent-3.pom</span><br><span class="line">Downloaded from nexus-aliyun: http://maven.aliyun.com/nexus/content/groups/public/net/java/jvnet-parent/3/jvnet-parent-3.pom (4.8 kB at 5.5 kB/s)</span><br><span class="line">Downloading from nexus-aliyun: http://maven.aliyun.com/nexus/content/groups/public/javax/servlet/javax.servlet-api/3.1.0/javax.servlet-api-3.1.0.jar</span><br><span class="line">Downloaded from nexus-aliyun: http://maven.aliyun.com/nexus/content/groups/public/javax/servlet/javax.servlet-api/3.1.0/javax.servlet-api-3.1.0.jar (96 kB at 39 kB/s)</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] --- maven-resources-plugin:3.0.2:resources (default-resources) @ pro02-maven-web ---</span><br><span class="line">[INFO] Using &#x27;UTF-8&#x27; encoding to copy filtered resources.</span><br><span class="line">[INFO] skip non existing resourceDirectory /Users/yukiyama/maven/workspace/test/pro02-maven-web/src/main/resources</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] --- maven-compiler-plugin:3.8.0:compile (default-compile) @ pro02-maven-web ---</span><br><span class="line">[INFO] Changes detected - recompiling the module!</span><br><span class="line">[INFO] Compiling 1 source file to /Users/yukiyama/maven/workspace/test/pro02-maven-web/target/classes</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESS</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time:  10.455 s</span><br><span class="line">[INFO] Finished at: 2022-09-22T20:19:53+08:00</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">yukiyama@yukiyama pro02-maven-web %</span><br></pre></td></tr></table></figure><p>编译完成后可以看到在项目目录下多了 target 文件夹，编译后的 <code>.class</code> 即存放在 <code>target/classes</code> 文件夹下。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">pro02-maven-web</span><br><span class="line">├── pom.xml</span><br><span class="line">├── src</span><br><span class="line">│   └── main</span><br><span class="line">│       ├── java</span><br><span class="line">│       │   └── com</span><br><span class="line">│       │       └── yukiyama</span><br><span class="line">│       │           └── maven</span><br><span class="line">│       │               └── HelloServlet.java</span><br><span class="line">│       └── webapp</span><br><span class="line">│           ├── WEB-INF</span><br><span class="line">│           │   └── web.xml</span><br><span class="line">│           └── index.jsp</span><br><span class="line">└── target</span><br><span class="line">    ├── classes</span><br><span class="line">    │   └── com</span><br><span class="line">    │       └── yukiyama</span><br><span class="line">    │           └── maven</span><br><span class="line">    │               └── HelloServlet.class</span><br><span class="line">    ├── generated-sources</span><br><span class="line">    │   └── annotations</span><br><span class="line">    └── maven-status</span><br><span class="line">        └── maven-compiler-plugin</span><br><span class="line">            └── compile</span><br><span class="line">                └── default-compile</span><br><span class="line">                    ├── createdFiles.lst</span><br><span class="line">                    └── inputFiles.lst</span><br></pre></td></tr></table></figure><br /><h6 id="清理-1"><a href="#清理-1" class="headerlink" title="清理"></a>清理</h6><p>执行 <code>mvn clean</code> 清理当前目录的编译结果。同样地，首次执行时会下载相关 Jar 包。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama pro02-maven-web % mvn clean</span><br><span class="line">[INFO] Scanning for projects...</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] -----------------&lt; com.yukiyama.maven:pro02-maven-web &gt;-----------------</span><br><span class="line">[INFO] Building pro02-maven-web Maven Webapp 1.0-SNAPSHOT</span><br><span class="line">[INFO] --------------------------------[ war ]---------------------------------</span><br><span class="line">Downloading from nexus-aliyun: http://maven.aliyun.com/nexus/content/groups/public/org/apache/maven/plugins/maven-clean-plugin/3.1.0/maven-clean-plugin-3.1.0.pom</span><br><span class="line">...(略)...</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] --- maven-clean-plugin:3.1.0:clean (default-clean) @ pro02-maven-web ---</span><br><span class="line">[INFO] Deleting /Users/yukiyama/maven/workspace/test/pro02-maven-web/target</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESS</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time:  7.774 s</span><br><span class="line">[INFO] Finished at: 2022-09-22T20:26:09+08:00</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">yukiyama@yukiyama pro02-maven-web %</span><br></pre></td></tr></table></figure><p>清理后可看到 target 文件夹已删除。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pro02-maven-web</span><br><span class="line">├── pom.xml</span><br><span class="line">└── src</span><br><span class="line">    └── main</span><br><span class="line">        ├── java</span><br><span class="line">        │   └── com</span><br><span class="line">        │       └── yukiyama</span><br><span class="line">        │           └── maven</span><br><span class="line">        │               └── HelloServlet.java</span><br><span class="line">        └── webapp</span><br><span class="line">            ├── WEB-INF</span><br><span class="line">            │   └── web.xml</span><br><span class="line">            └── index.jsp</span><br></pre></td></tr></table></figure><br /><h6 id="打包-1"><a href="#打包-1" class="headerlink" title="打包"></a>打包</h6><p>执行 <code>mvn package</code> 或者 <code>mvn clean package</code> 打包项目为 war 包。同样地，首次执行时会下载相关 Jar 包。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama pro02-maven-web % mvn clean package</span><br><span class="line">[INFO] Scanning for projects...</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] -----------------&lt; com.yukiyama.maven:pro02-maven-web &gt;-----------------</span><br><span class="line">[INFO] Building pro02-maven-web Maven Webapp 1.0-SNAPSHOT</span><br><span class="line">[INFO] --------------------------------[ war ]---------------------------------</span><br><span class="line">Downloading from nexus-aliyun: http://maven.aliyun.com/nexus/content/groups/public/org/apache/maven/plugins/maven-surefire-plugin/2.22.1/maven-surefire-plugin-2.22.1.pom</span><br><span class="line">...(略)...</span><br><span class="line">[INFO] Packaging webapp</span><br><span class="line">[INFO] Assembling webapp [pro02-maven-web] in [/Users/yukiyama/maven/workspace/test/pro02-maven-web/target/pro02-maven-web]</span><br><span class="line">[INFO] Processing war project</span><br><span class="line">[INFO] Copying webapp resources [/Users/yukiyama/maven/workspace/test/pro02-maven-web/src/main/webapp]</span><br><span class="line">[INFO] Webapp assembled in [107 msecs]</span><br><span class="line">[INFO] Building war: /Users/yukiyama/maven/workspace/test/pro02-maven-web/target/pro02-maven-web.war</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESS</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time:  02:04 min</span><br><span class="line">[INFO] Finished at: 2022-09-22T20:33:18+08:00</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">yukiyama@yukiyama pro02-maven-web %</span><br></pre></td></tr></table></figure><p>打包完成后在 target 目录下可以看到生成了如下 war 包 <code>pro02-maven-web.war</code> 及其解压后的文件夹。war 包文件名即 <code>artifactId</code> 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">pro02-maven-web</span><br><span class="line">├── pom.xml</span><br><span class="line">├── src</span><br><span class="line">│   └── main</span><br><span class="line">│       ├── java</span><br><span class="line">│       │   └── com</span><br><span class="line">│       │       └── yukiyama</span><br><span class="line">│       │           └── maven</span><br><span class="line">│       │               └── HelloServlet.java</span><br><span class="line">│       └── webapp</span><br><span class="line">│           ├── WEB-INF</span><br><span class="line">│           │   └── web.xml</span><br><span class="line">│           └── index.jsp</span><br><span class="line">└── target</span><br><span class="line">    ├── classes</span><br><span class="line">    │   └── com</span><br><span class="line">    │       └── yukiyama</span><br><span class="line">    │           └── maven</span><br><span class="line">    │               └── HelloServlet.class</span><br><span class="line">    ├── generated-sources</span><br><span class="line">    │   └── annotations</span><br><span class="line">    ├── maven-archiver</span><br><span class="line">    │   └── pom.properties</span><br><span class="line">    ├── maven-status</span><br><span class="line">    │   └── maven-compiler-plugin</span><br><span class="line">    │       └── compile</span><br><span class="line">    │           └── default-compile</span><br><span class="line">    │               ├── createdFiles.lst</span><br><span class="line">    │               └── inputFiles.lst</span><br><span class="line">    ├── pro02-maven-web</span><br><span class="line">    │   ├── META-INF</span><br><span class="line">    │   ├── WEB-INF</span><br><span class="line">    │   │   ├── classes</span><br><span class="line">    │   │   │   └── com</span><br><span class="line">    │   │   │       └── yukiyama</span><br><span class="line">    │   │   │           └── maven</span><br><span class="line">    │   │   │               └── HelloServlet.class</span><br><span class="line">    │   │   └── web.xml</span><br><span class="line">    │   └── index.jsp</span><br><span class="line">    └── pro02-maven-web.war</span><br></pre></td></tr></table></figure><br /><h6 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h6><p>首先在此 web 工程下添加之前创建的 java 工程。做法是在 <code>pom.xml</code> 中添加如下 <code>&lt;dependency&gt;</code> 内容。</p><p>注意，<code>&lt;scope&gt;</code> 表示该依赖的范围，默认是 <code>compile</code> ，因此可以不写。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 导入 Maven Java 工程依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.yukiyama.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pro01-maven-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接着执行 <code>mvn test</code> 完成测试。同样地，首次执行时会下载相关 Jar 包。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama pro02-maven-web % mvn test</span><br><span class="line">[INFO] Scanning for projects...</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] -----------------&lt; com.yukiyama.maven:pro02-maven-web &gt;-----------------</span><br><span class="line">[INFO] Building pro02-maven-web Maven Webapp 1.0-SNAPSHOT</span><br><span class="line">[INFO] --------------------------------[ war ]---------------------------------</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] --- maven-resources-plugin:3.0.2:resources (default-resources) @ pro02-maven-web ---</span><br><span class="line">[INFO] Using &#x27;UTF-8&#x27; encoding to copy filtered resources.</span><br><span class="line">[INFO] skip non existing resourceDirectory /Users/yukiyama/maven/workspace/test/pro02-maven-web/src/main/resources</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] --- maven-compiler-plugin:3.8.0:compile (default-compile) @ pro02-maven-web ---</span><br><span class="line">[INFO] Nothing to compile - all classes are up to date</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] --- maven-resources-plugin:3.0.2:testResources (default-testResources) @ pro02-maven-web ---</span><br><span class="line">[INFO] Using &#x27;UTF-8&#x27; encoding to copy filtered resources.</span><br><span class="line">[INFO] skip non existing resourceDirectory /Users/yukiyama/maven/workspace/test/pro02-maven-web/src/test/resources</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] --- maven-compiler-plugin:3.8.0:testCompile (default-testCompile) @ pro02-maven-web ---</span><br><span class="line">[INFO] Changes detected - recompiling the module!</span><br><span class="line">[INFO] Compiling 1 source file to /Users/yukiyama/maven/workspace/test/pro02-maven-web/target/test-classes</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] --- maven-surefire-plugin:2.22.1:test (default-test) @ pro02-maven-web ---</span><br><span class="line">Downloading from nexus-aliyun: http://maven.aliyun.com/nexus/content/groups/public/org/apache/maven/surefire/surefire-junit4/2.22.1/surefire-junit4-2.22.1.pom</span><br><span class="line">Downloaded from nexus-aliyun: http://maven.aliyun.com/nexus/content/groups/public/org/apache/maven/surefire/surefire-junit4/2.22.1/surefire-junit4-2.22.1.pom (3.1 kB at 1.9 kB/s)</span><br><span class="line">Downloading from nexus-aliyun: http://maven.aliyun.com/nexus/content/groups/public/org/apache/maven/surefire/surefire-providers/2.22.1/surefire-providers-2.22.1.pom</span><br><span class="line">Downloaded from nexus-aliyun: http://maven.aliyun.com/nexus/content/groups/public/org/apache/maven/surefire/surefire-providers/2.22.1/surefire-providers-2.22.1.pom (2.5 kB at 3.6 kB/s)</span><br><span class="line">Downloading from nexus-aliyun: http://maven.aliyun.com/nexus/content/groups/public/org/apache/maven/surefire/surefire-junit4/2.22.1/surefire-junit4-2.22.1.jar</span><br><span class="line">Downloaded from nexus-aliyun: http://maven.aliyun.com/nexus/content/groups/public/org/apache/maven/surefire/surefire-junit4/2.22.1/surefire-junit4-2.22.1.jar (85 kB at 123 kB/s)</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] -------------------------------------------------------</span><br><span class="line">[INFO]  T E S T S</span><br><span class="line">[INFO] -------------------------------------------------------</span><br><span class="line">[INFO] Running com.yukiyama.maven.CalculatorTest</span><br><span class="line">完成测试。</span><br><span class="line">[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.076 s - in com.yukiyama.maven.CalculatorTest</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] Results:</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESS</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time:  6.989 s</span><br><span class="line">[INFO] Finished at: 2022-09-24T14:44:38+08:00</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">yukiyama@yukiyama pro02-maven-web %</span><br></pre></td></tr></table></figure><p>测试完成后可以看到 target 文件夹中多了 <code>test-classes</code> 目录，存放测试源文件编译后的  <code>.class</code> 文件。此外还生成了测试报告，存放于 <code>surefire-reports</code> 文件夹中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">pro02-maven-web</span><br><span class="line">├── pom.xml</span><br><span class="line">├── src</span><br><span class="line">│   ├── main</span><br><span class="line">│   │   ├── java</span><br><span class="line">│   │   │   └── com</span><br><span class="line">│   │   │       └── yukiyama</span><br><span class="line">│   │   │           └── maven</span><br><span class="line">│   │   │               └── HelloServlet.java</span><br><span class="line">│   │   └── webapp</span><br><span class="line">│   │       ├── WEB-INF</span><br><span class="line">│   │       │   └── web.xml</span><br><span class="line">│   │       └── index.jsp</span><br><span class="line">│   └── test</span><br><span class="line">│       └── java</span><br><span class="line">│           └── com</span><br><span class="line">│               └── yukiyama</span><br><span class="line">│                   └── maven</span><br><span class="line">│                       └── CalculatorTest.java</span><br><span class="line">└── target</span><br><span class="line">    ├── classes</span><br><span class="line">    │   └── com</span><br><span class="line">    │       └── yukiyama</span><br><span class="line">    │           └── maven</span><br><span class="line">    │               └── HelloServlet.class</span><br><span class="line">    ├── generated-sources</span><br><span class="line">    │   └── annotations</span><br><span class="line">    ├── generated-test-sources</span><br><span class="line">    │   └── test-annotations</span><br><span class="line">    ├── maven-archiver</span><br><span class="line">    │   └── pom.properties</span><br><span class="line">    ├── maven-status</span><br><span class="line">    │   └── maven-compiler-plugin</span><br><span class="line">    │       ├── compile</span><br><span class="line">    │       │   └── default-compile</span><br><span class="line">    │       │       ├── createdFiles.lst</span><br><span class="line">    │       │       └── inputFiles.lst</span><br><span class="line">    │       └── testCompile</span><br><span class="line">    │           └── default-testCompile</span><br><span class="line">    │               ├── createdFiles.lst</span><br><span class="line">    │               └── inputFiles.lst</span><br><span class="line">    ├── pro02-maven-web</span><br><span class="line">    │   ├── META-INF</span><br><span class="line">    │   ├── WEB-INF</span><br><span class="line">    │   │   ├── classes</span><br><span class="line">    │   │   │   └── com</span><br><span class="line">    │   │   │       └── yukiyama</span><br><span class="line">    │   │   │           └── maven</span><br><span class="line">    │   │   │               └── HelloServlet.class</span><br><span class="line">    │   │   └── web.xml</span><br><span class="line">    │   └── index.jsp</span><br><span class="line">    ├── pro02-maven-web.war</span><br><span class="line">    ├── surefire-reports</span><br><span class="line">    │   ├── TEST-com.yukiyama.maven.CalculatorTest.xml</span><br><span class="line">    │   └── com.yukiyama.maven.CalculatorTest.txt</span><br><span class="line">    └── test-classes</span><br><span class="line">        └── com</span><br><span class="line">            └── yukiyama</span><br><span class="line">                └── maven</span><br><span class="line">                    └── CalculatorTest.class</span><br></pre></td></tr></table></figure><br /><h6 id="再次打包"><a href="#再次打包" class="headerlink" title="再次打包"></a>再次打包</h6><p>再次执行 <code>mvn package</code> 或者 <code>mvn clean package</code> 再次打包项目，可以看到，除了生成 war 包外，所依赖的 Java 项目被打包在 <code>/target/pro02-maven-web/WEB-INF/lib</code> 下。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">pro02-maven-web</span><br><span class="line">├── pom.xml</span><br><span class="line">├── src</span><br><span class="line">│   ├── main</span><br><span class="line">│   │   ├── java</span><br><span class="line">│   │   │   └── com</span><br><span class="line">│   │   │       └── yukiyama</span><br><span class="line">│   │   │           └── maven</span><br><span class="line">│   │   │               └── HelloServlet.java</span><br><span class="line">│   │   └── webapp</span><br><span class="line">│   │       ├── WEB-INF</span><br><span class="line">│   │       │   └── web.xml</span><br><span class="line">│   │       └── index.jsp</span><br><span class="line">│   └── test</span><br><span class="line">│       └── java</span><br><span class="line">│           └── com</span><br><span class="line">│               └── yukiyama</span><br><span class="line">│                   └── maven</span><br><span class="line">│                       └── CalculatorTest.java</span><br><span class="line">└── target</span><br><span class="line">    ├── classes</span><br><span class="line">    │   └── com</span><br><span class="line">    │       └── yukiyama</span><br><span class="line">    │           └── maven</span><br><span class="line">    │               └── HelloServlet.class</span><br><span class="line">    ├── generated-sources</span><br><span class="line">    │   └── annotations</span><br><span class="line">    ├── generated-test-sources</span><br><span class="line">    │   └── test-annotations</span><br><span class="line">    ├── maven-archiver</span><br><span class="line">    │   └── pom.properties</span><br><span class="line">    ├── maven-status</span><br><span class="line">    │   └── maven-compiler-plugin</span><br><span class="line">    │       ├── compile</span><br><span class="line">    │       │   └── default-compile</span><br><span class="line">    │       │       ├── createdFiles.lst</span><br><span class="line">    │       │       └── inputFiles.lst</span><br><span class="line">    │       └── testCompile</span><br><span class="line">    │           └── default-testCompile</span><br><span class="line">    │               ├── createdFiles.lst</span><br><span class="line">    │               └── inputFiles.lst</span><br><span class="line">    ├── pro02-maven-web</span><br><span class="line">    │   ├── META-INF</span><br><span class="line">    │   ├── WEB-INF</span><br><span class="line">    │   │   ├── classes</span><br><span class="line">    │   │   │   └── com</span><br><span class="line">    │   │   │       └── yukiyama</span><br><span class="line">    │   │   │           └── maven</span><br><span class="line">    │   │   │               └── HelloServlet.class</span><br><span class="line">    │   │   ├── lib</span><br><span class="line">    │   │   │   └── pro01-maven-java-1.0-SNAPSHOT.jar</span><br><span class="line">    │   │   └── web.xml</span><br><span class="line">    │   └── index.jsp</span><br><span class="line">    ├── pro02-maven-web.war</span><br><span class="line">    ├── surefire-reports</span><br><span class="line">    │   ├── TEST-com.yukiyama.maven.CalculatorTest.xml</span><br><span class="line">    │   └── com.yukiyama.maven.CalculatorTest.txt</span><br><span class="line">    └── test-classes</span><br><span class="line">        └── com</span><br><span class="line">            └── yukiyama</span><br><span class="line">                └── maven</span><br><span class="line">                    └── CalculatorTest.class</span><br></pre></td></tr></table></figure><br /><h4 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h4><h5 id="查看依赖"><a href="#查看依赖" class="headerlink" title="查看依赖"></a>查看依赖</h5><p>执行 <code>mvn dependency:list</code> 可查看当前项目的依赖包列表。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama pro02-maven-web % mvn dependency:list</span><br><span class="line">[INFO] Scanning for projects...</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] -----------------&lt; com.yukiyama.maven:pro02-maven-web &gt;-----------------</span><br><span class="line">[INFO] Building pro02-maven-web Maven Webapp 1.0-SNAPSHOT</span><br><span class="line">[INFO] --------------------------------[ war ]---------------------------------</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] --- maven-dependency-plugin:2.8:list (default-cli) @ pro02-maven-web ---</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] The following files have been resolved:</span><br><span class="line">[INFO]    org.hamcrest:hamcrest-core:jar:1.3:test</span><br><span class="line">[INFO]    javax.servlet:javax.servlet-api:jar:3.1.0:provided</span><br><span class="line">[INFO]    com.yukiyama.maven:pro01-maven-java:jar:1.0-SNAPSHOT:compile</span><br><span class="line">[INFO]    junit:junit:jar:4.12:test</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESS</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time:  2.166 s</span><br><span class="line">[INFO] Finished at: 2022-09-24T14:55:51+08:00</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">yukiyama@yukiyama pro02-maven-web %</span><br></pre></td></tr></table></figure><p>也可以执行 <code>mvn dependency:tree</code> 以树形结构查看。树形结构可看出依赖包的传递过程。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama pro02-maven-web % mvn dependency:tree</span><br><span class="line">[INFO] Scanning for projects...</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] -----------------&lt; com.yukiyama.maven:pro02-maven-web &gt;-----------------</span><br><span class="line">[INFO] Building pro02-maven-web Maven Webapp 1.0-SNAPSHOT</span><br><span class="line">[INFO] --------------------------------[ war ]---------------------------------</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] --- maven-dependency-plugin:2.8:tree (default-cli) @ pro02-maven-web ---</span><br><span class="line">[INFO] com.yukiyama.maven:pro02-maven-web:war:1.0-SNAPSHOT</span><br><span class="line">[INFO] +- junit:junit:jar:4.12:test</span><br><span class="line">[INFO] |  \- org.hamcrest:hamcrest-core:jar:1.3:test</span><br><span class="line">[INFO] +- javax.servlet:javax.servlet-api:jar:3.1.0:provided</span><br><span class="line">[INFO] \- com.yukiyama.maven:pro01-maven-java:jar:1.0-SNAPSHOT:compile</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESS</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time:  3.126 s</span><br><span class="line">[INFO] Finished at: 2022-09-24T14:57:02+08:00</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">yukiyama@yukiyama pro02-maven-web %</span><br></pre></td></tr></table></figure><br /><h5 id="依赖范围"><a href="#依赖范围" class="headerlink" title="依赖范围"></a>依赖范围</h5><p><code>&lt;dependency&gt;</code> 标签下的 <code>&lt;scope&gt;</code> 标签表示该依赖的范围，即该依赖 (Jar) 包可以作用于哪些目录下 (的 Java 文件中)，通俗地说就是哪些地方的 Java 文件能够引用该依赖 Jar 包中的类。常用的 scope 有 compile, test, provided。</p><table><thead><tr><th>scope</th><th>main目录</th><th>test目录</th><th>开发过程</th><th>部署到服务器</th></tr></thead><tbody><tr><td>compile</td><td>有效</td><td>有效</td><td>有效</td><td>有效</td></tr><tr><td>test</td><td>无效</td><td>有效</td><td>有效</td><td>无效</td></tr><tr><td>provided</td><td>有效</td><td>有效</td><td>有效</td><td>无效</td></tr></tbody></table><ul><li><p>compile：在项目实际运行时真正要用到的 jar 包都是以 compile 范围进行依赖的，例如 SSM 框架所需 jar 包。<strong>compile 是默认的</strong>，可以不必在 dependency 中显式写出。</p></li><li><p>test：测试过程中使用的 jar 包，例如 junit。</p></li><li><p>provided：通常为开发过程中所需的「服务器上的 jar包」，例如 servlet-api、jsp-api。开发测试时需要，但由于服务器已提供，部署到服务器时不需要。这是为了避免和服务器已存在的同类 jar 包冲突， 同时减轻服务器的负担，因此 provided 的 jar 包部署，不会放入 war 包中。</p></li></ul><p><strong>测试在 main 下依赖 test 范围的 jar 包</strong></p><p>在 main 中的 java 文件导入 junit，即加入 <code>import org.junit.Test;</code> ，然后执行 <code>mvn compile</code> ，报如下错误 (… package org.junit does not exist …)。说明 test 依赖范围的 Jar 包 (类) 不会作用于 main 目录下的 Java 文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama pro01-maven-java % mvn clean compile</span><br><span class="line">[INFO] Scanning for projects...</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] ----------------&lt; com.yukiyama.maven:pro01-maven-java &gt;-----------------</span><br><span class="line">[INFO] Building pro01-maven-java 1.0-SNAPSHOT</span><br><span class="line">[INFO] --------------------------------[ jar ]---------------------------------</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ pro01-maven-java ---</span><br><span class="line">[INFO] Deleting /Users/yukiyama/maven/workspace/test/pro01-maven-java/target</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ pro01-maven-java ---</span><br><span class="line">[INFO] Using &#x27;UTF-8&#x27; encoding to copy filtered resources.</span><br><span class="line">[INFO] skip non existing resourceDirectory /Users/yukiyama/maven/workspace/test/pro01-maven-java/src/main/resources</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] --- maven-compiler-plugin:3.1:compile (default-compile) @ pro01-maven-java ---</span><br><span class="line">[INFO] Changes detected - recompiling the module!</span><br><span class="line">[INFO] Compiling 1 source file to /Users/yukiyama/maven/workspace/test/pro01-maven-java/target/classes</span><br><span class="line">[INFO] -------------------------------------------------------------</span><br><span class="line">[ERROR] COMPILATION ERROR :</span><br><span class="line">[INFO] -------------------------------------------------------------</span><br><span class="line">[ERROR] /Users/yukiyama/maven/workspace/test/pro01-maven-java/src/main/java/com/yukiyama/maven/Calculator.java:[3,17] package org.junit does not exist</span><br><span class="line">[INFO] 1 error</span><br><span class="line">[INFO] -------------------------------------------------------------</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD FAILURE</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time:  2.683 s</span><br><span class="line">[INFO] Finished at: 2022-09-24T17:04:44+08:00</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[ERROR] Failed to execute goal org.apache.maven.plugins:maven-compiler-plugin:3.1:compile (default-compile) on project pro01-maven-java: Compilation failure</span><br><span class="line">[ERROR] /Users/yukiyama/maven/workspace/test/pro01-maven-java/src/main/java/com/yukiyama/maven/Calculator.java:[3,17] package org.junit does not exist</span><br><span class="line">[ERROR]</span><br><span class="line">[ERROR] -&gt; [Help 1]</span><br><span class="line">[ERROR]</span><br><span class="line">[ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch.</span><br><span class="line">[ERROR] Re-run Maven using the -X switch to enable full debug logging.</span><br><span class="line">[ERROR]</span><br><span class="line">[ERROR] For more information about the errors and possible solutions, please read the following articles:</span><br><span class="line">[ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/MojoFailureException</span><br><span class="line">yukiyama@yukiyama pro01-maven-java %</span><br></pre></td></tr></table></figure><p><strong>测试 test 和 provided 范围不参与服务器部署</strong></p><p>在前述 web 工程「再次打包」后，我们已经看到，在 <code>/target/pro02-maven-web/WEB-INF/lib</code> 下打包了 compile 范围的 <code>pro01-maven-java-1.0-SNAPSHOT.jar</code> ，但并未打包 test 范围的 <code>junit</code> 以及 provided 范围的 <code>javax.servlet-api</code> 。</p><br /><h5 id="依赖传递"><a href="#依赖传递" class="headerlink" title="依赖传递"></a>依赖传递</h5><p>A 依赖 B，B 依赖 C 时，A 是否自动依赖 C 取决于 B 依赖 C 时在 B 的 pom.xml 中定义的对 C 的依赖范围。该范围为 compile 时可以传递，为 test 或 privoided 时不能传递。不能传递而 A 又需要依赖 C 时，就必须在 A 的 pom.xml 中明确添加上 C 的 dependency 。</p><p><strong>测试依赖传递</strong></p><p>在 <code>pro01-maven-java</code> 工程的 pom.xml 中添加如下依赖 (默认 compile)。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接着执行 <code>mvn dependency:tree</code> ，可以看到 junit 所依赖的 hamcrest 和 spring-core 所依赖的 commons-logging 被传递到了当前工程。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama pro01-maven-java % mvn dependency:tree</span><br><span class="line">[INFO] Scanning for projects...</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] ----------------&lt; com.yukiyama.maven:pro01-maven-java &gt;-----------------</span><br><span class="line">[INFO] Building pro01-maven-java 1.0-SNAPSHOT</span><br><span class="line">[INFO] --------------------------------[ jar ]---------------------------------</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] --- maven-dependency-plugin:2.8:tree (default-cli) @ pro01-maven-java ---</span><br><span class="line">[INFO] com.yukiyama.maven:pro01-maven-java:jar:1.0-SNAPSHOT</span><br><span class="line">[INFO] +- junit:junit:jar:4.12:test</span><br><span class="line">[INFO] |  \- org.hamcrest:hamcrest-core:jar:1.3:test</span><br><span class="line">[INFO] \- org.springframework:spring-core:jar:4.0.0.RELEASE:compile</span><br><span class="line">[INFO]    \- commons-logging:commons-logging:jar:1.1.1:compile</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESS</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time:  1.855 s</span><br><span class="line">[INFO] Finished at: 2022-09-24T17:32:14+08:00</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">yukiyama@yukiyama pro01-maven-java %</span><br></pre></td></tr></table></figure><p>接着以 <code>pro02-maven-web</code> 为 A， <code>pro01-maven-java</code> 为 B 测试依赖传递。要先重新在 <code>pro01-maven-java</code> 下执行 <code>mvn clean install</code> 更新其在本地仓库中的包。然后再在  <code>pro02-maven-web</code> 中执行 <code>mvn dependency:tree</code> 查看依赖传递信息。可以看到在 <code>pro01-maven-java</code> (B) 下，传递了 compile 范围的 spring-core ，而未传递 B 中 test 范围的 junit 以及 provided 范围的 javax.servlet-api 。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama pro02-maven-web % mvn dependency:tree</span><br><span class="line">[INFO] Scanning for projects...</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] -----------------&lt; com.yukiyama.maven:pro02-maven-web &gt;-----------------</span><br><span class="line">[INFO] Building pro02-maven-web Maven Webapp 1.0-SNAPSHOT</span><br><span class="line">[INFO] --------------------------------[ war ]---------------------------------</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] --- maven-dependency-plugin:2.8:tree (default-cli) @ pro02-maven-web ---</span><br><span class="line">[INFO] com.yukiyama.maven:pro02-maven-web:war:1.0-SNAPSHOT</span><br><span class="line">[INFO] +- junit:junit:jar:4.12:test</span><br><span class="line">[INFO] |  \- org.hamcrest:hamcrest-core:jar:1.3:test</span><br><span class="line">[INFO] +- javax.servlet:javax.servlet-api:jar:3.1.0:provided</span><br><span class="line">[INFO] \- com.yukiyama.maven:pro01-maven-java:jar:1.0-SNAPSHOT:compile</span><br><span class="line">[INFO]    \- org.springframework:spring-core:jar:4.0.0.RELEASE:compile</span><br><span class="line">[INFO]       \- commons-logging:commons-logging:jar:1.1.1:compile</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESS</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time:  1.601 s</span><br><span class="line">[INFO] Finished at: 2022-09-24T18:13:42+08:00</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">yukiyama@yukiyama pro02-maven-web %</span><br></pre></td></tr></table></figure><br /><h5 id="依赖排除"><a href="#依赖排除" class="headerlink" title="依赖排除"></a>依赖排除</h5><p>有 A -&gt; B -&gt; Z 和 A -&gt; C -&gt; Z 依赖关系时，因为前者已经通过依赖传递依赖了 Z，为了避免 jar 包冲突，后者可以排除依赖，即可以在 A 的 pom.xml 中的 C 的 <code>&lt;dependency&gt;</code> 标签中使用 <code>&lt;exclusions&gt;</code> ,<code> &lt;exclusion&gt;</code> 标签， 阻止 C 将 Z 传递到 A。</p><p>在 <code>pro02-maven-web</code> 的 pom.xml 文件对 <code>pro01-maven-java</code> 的依赖修改如下。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.yukiyama.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pro01-maven-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 添加依赖排除 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 不需要写version --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到 <code>commons-logging</code> 已被排除。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama pro02-maven-web % mvn dependency:tree</span><br><span class="line">[INFO] Scanning for projects...</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] -----------------&lt; com.yukiyama.maven:pro02-maven-web &gt;-----------------</span><br><span class="line">[INFO] Building pro02-maven-web Maven Webapp 1.0-SNAPSHOT</span><br><span class="line">[INFO] --------------------------------[ war ]---------------------------------</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] --- maven-dependency-plugin:2.8:tree (default-cli) @ pro02-maven-web ---</span><br><span class="line">[INFO] com.yukiyama.maven:pro02-maven-web:war:1.0-SNAPSHOT</span><br><span class="line">[INFO] +- junit:junit:jar:4.12:test</span><br><span class="line">[INFO] |  \- org.hamcrest:hamcrest-core:jar:1.3:test</span><br><span class="line">[INFO] +- javax.servlet:javax.servlet-api:jar:3.1.0:provided</span><br><span class="line">[INFO] \- com.yukiyama.maven:pro01-maven-java:jar:1.0-SNAPSHOT:compile</span><br><span class="line">[INFO]    \- org.springframework:spring-core:jar:4.0.0.RELEASE:compile</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESS</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time:  1.656 s</span><br><span class="line">[INFO] Finished at: 2022-09-24T18:27:39+08:00</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">yukiyama@yukiyama pro02-maven-web %</span><br></pre></td></tr></table></figure><br /><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>描述工程之间的继承关系，即 B 工程继承 A 工程，配置表现为 A 工程的 pom.xml 中的 <code>&lt;packaging&gt;</code> 标签为 <code>pom</code> ，表示 A 工程是一个用于管理工程的工程，即父工程。而 B 工程的 pom.xml 文件中具有 <code>&lt;parent&gt;</code> 标签描述 A 工程，表示 B 工程为 A 工程的子工程。</p><p>工程的继承关系建立后，可在父工程中统一管理项目中的依赖信息 (主要指依赖的版本) 。一个复杂的工程的「工程层级」很多，良好的依赖的组合方案通过继承可以在创建新项目时复用，节约时间的同时保证项目依赖关系的准确性 (经过了实践的组合方案)。</p><p> 首先创建一个名为 <code>pro03-maven-parent</code> 的 Maven java 工程，然后修改 pom.xml 中的打包方式为 pom。<code>&lt;dependencies&gt;</code> 标签可以删除。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.yukiyama.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pro03-maven-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接着在 <code>pro03-maven-parent</code> 目录下新建三个子工程。完成后父工程的 pom.xml 中新增了记录子工程信息的 <code>&lt;modules&gt;</code> 标签。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">module</span>&gt;</span>pro04-maven-module<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">module</span>&gt;</span>pro05-maven-module<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">module</span>&gt;</span>pro06-maven-module<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br></pre></td></tr></table></figure><p>而子工程的 pom.xml 中新增了 <code>&lt;parent&gt;</code> 标签记录其父工程。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.yukiyama.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pro03-maven-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><p>另外，若子工程坐标中的 groupId 和 version 与其父工程相同，可省略。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- &lt;groupId&gt;com.yukiyama.maven&lt;/groupId&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pro04-maven-module<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; --&gt;</span></span><br></pre></td></tr></table></figure><p>现在，在父工程 pom.xml 中使用 <code>&lt;dependencyManager&gt;</code> 标签统一管理其子工程的依赖版本，如下。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用dependencyManagement标签配置对依赖的管理 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 被管理的依赖并没有真正被引入到工程，需要在子工程中添加需要的依赖，只是无需写版本号 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-expression<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时子工程不会自动依赖这些在父工程中依赖的包，而是按需在其自身的 pom.xml 中添加，但 <strong>不再需要维护版本信息，而是由父工程统一管理</strong> 。如在子工程 <code>pro04-maven-module</code> 的 pom.xml 中添加如下被版本管理的依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在该 pom.xml 所在路径下执行 <code>mvn dependency:tree</code> 查看依赖信息。可以看到 <code>pro04-maven-module</code> 依赖了 spring-core  和 spring-beans，且版本号为父工程 pom 中指定的 4.0.0 。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama pro04-maven-module % mvn dependency:tree</span><br><span class="line">[INFO] Scanning for projects...</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] ---------------&lt; com.yukiyama.maven:pro04-maven-module &gt;----------------</span><br><span class="line">[INFO] Building pro04-maven-module 1.0-SNAPSHOT</span><br><span class="line">[INFO] --------------------------------[ jar ]---------------------------------</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] --- maven-dependency-plugin:2.8:tree (default-cli) @ pro04-maven-module ---</span><br><span class="line">[INFO] com.yukiyama.maven:pro04-maven-module:jar:1.0-SNAPSHOT</span><br><span class="line">[INFO] +- org.springframework:spring-core:jar:4.0.0.RELEASE:compile</span><br><span class="line">[INFO] |  \- commons-logging:commons-logging:jar:1.1.1:compile</span><br><span class="line">[INFO] +- org.springframework:spring-beans:jar:4.0.0.RELEASE:compile</span><br><span class="line">[INFO] \- junit:junit:jar:3.8.1:test</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESS</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time:  1.274 s</span><br><span class="line">[INFO] Finished at: 2022-09-24T20:39:06+08:00</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">yukiyama@yukiyama pro04-maven-module %</span><br></pre></td></tr></table></figure><p>当我们需要统一修改子工程中的依赖版本时，只需要在父工程中完成修改。例如在父工程的 pom.xml 中将前述 spring-core 和 spring-beans 的版本修改为 4.1.0 并保存后。再次查看 <code>pro04-maven-module</code> 的依赖信息，可以看到依赖的版本信息随之更新了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama pro04-maven-module % mvn dependency:tree</span><br><span class="line">[INFO] Scanning for projects...</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] ---------------&lt; com.yukiyama.maven:pro04-maven-module &gt;----------------</span><br><span class="line">[INFO] Building pro04-maven-module 1.0-SNAPSHOT</span><br><span class="line">[INFO] --------------------------------[ jar ]---------------------------------</span><br><span class="line">Downloading from nexus-aliyun: http://maven.aliyun.com/nexus/content/groups/public/org/springframework/spring-core/4.1.0.RELEASE/spring-core-4.1.0.RELEASE.pom</span><br><span class="line">...(略)...</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] --- maven-dependency-plugin:2.8:tree (default-cli) @ pro04-maven-module ---</span><br><span class="line">[INFO] com.yukiyama.maven:pro04-maven-module:jar:1.0-SNAPSHOT</span><br><span class="line">[INFO] +- org.springframework:spring-core:jar:4.1.0.RELEASE:compile</span><br><span class="line">[INFO] |  \- commons-logging:commons-logging:jar:1.1.3:compile</span><br><span class="line">[INFO] +- org.springframework:spring-beans:jar:4.1.0.RELEASE:compile</span><br><span class="line">[INFO] \- junit:junit:jar:3.8.1:test</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESS</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time:  28.726 s</span><br><span class="line">[INFO] Finished at: 2022-09-24T20:43:20+08:00</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">yukiyama@yukiyama pro04-maven-module %</span><br></pre></td></tr></table></figure><br /><h4 id="自定义标签"><a href="#自定义标签" class="headerlink" title="自定义标签"></a>自定义标签</h4><p>在 pom.xml 文件中，可在 <code>&lt;properties&gt;</code> 标签下设置 <strong>自定义标签</strong> 并引用。如下，将版本信息定义为 <code>&lt;yukiyama.spring.version&gt;</code> 标签，然后在需要用到的地方引用即可。统一引用之后，需要修改时只需要在自定义处修改，则引用该自定义标签的内容也都随之更新。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 自定标签，方便引用，并实现一处修改，处处修改 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">yukiyama.spring.version</span>&gt;</span>4.2.0.RELEASE<span class="tag">&lt;/<span class="name">yukiyama.spring.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 使用dependencyManagement标签配置对依赖的管理 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 被管理的依赖并没有真正被引入到工程，需要在子工程中添加需要的依赖，但无需写版本号 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;yukiyama.spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;yukiyama.spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;yukiyama.spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-expression<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;yukiyama.spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;yukiyama.spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><p>再次查看子工程的依赖信息，可以看到版本号更新为了自定义标签中指定的 4.2.0 。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama pro04-maven-module % mvn dependency:tree</span><br><span class="line">[INFO] Scanning for projects...</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] ---------------&lt; com.yukiyama.maven:pro04-maven-module &gt;----------------</span><br><span class="line">[INFO] Building pro04-maven-module 1.0-SNAPSHOT</span><br><span class="line">[INFO] --------------------------------[ jar ]---------------------------------</span><br><span class="line">Downloading from nexus-aliyun: http://maven.aliyun.com/nexus/content/groups/public/org/springframework/spring-core/4.2.0.RELEASE/spring-core-4.2.0.RELEASE.pom</span><br><span class="line">...(略)...</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] --- maven-dependency-plugin:2.8:tree (default-cli) @ pro04-maven-module ---</span><br><span class="line">[INFO] com.yukiyama.maven:pro04-maven-module:jar:1.0-SNAPSHOT</span><br><span class="line">[INFO] +- org.springframework:spring-core:jar:4.2.0.RELEASE:compile</span><br><span class="line">[INFO] |  \- commons-logging:commons-logging:jar:1.2:compile</span><br><span class="line">[INFO] +- org.springframework:spring-beans:jar:4.2.0.RELEASE:compile</span><br><span class="line">[INFO] \- junit:junit:jar:3.8.1:test</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESS</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time:  40.608 s</span><br><span class="line">[INFO] Finished at: 2022-09-24T20:54:00+08:00</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">yukiyama@yukiyama pro04-maven-module %</span><br></pre></td></tr></table></figure><br /><h4 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h4><p>聚合即在父工程或者说「总工程」下将各个子工程或者说「模块工程」汇聚起来。使得在总工程下可统一执行整体项目的构建。聚合配置的方式在「继承」中展示过，即在总工程的 pom.xml 下以 <code>&lt;modules&gt;</code> 标签汇聚子项目。下面展示如何通过汇聚，由总工程完成包括子工程在内的整体项目构建。</p><p>在 <code>pro04-maven-module</code> 的 pom.xml 中添加对 <code>pro05-maven-module</code> 的依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.yukiyama.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pro05-maven-module<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 <code>pro05-maven-module</code> 的 pom.xml 中添加对 <code>pro06-maven-module</code> 的依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.yukiyama.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pro06-maven-module<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在「总工程」 pom.xml 所在路径下执行 <code>mvn clean install</code> 命令，可以看到  install 的顺序是 pro03 &gt; pro06 &gt; pro05 &gt; pro04 。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">yukiyama@yukiyama pro03-maven-parent % mvn clean install</span><br><span class="line">[INFO] Scanning for projects...</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Reactor Build Order:</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] pro03-maven-parent                                                 [pom]</span><br><span class="line">[INFO] pro06-maven-module                                                 [jar]</span><br><span class="line">[INFO] pro05-maven-module                                                 [jar]</span><br><span class="line">[INFO] pro04-maven-module                                                 [jar]</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] ---------------&lt; com.yukiyama.maven:pro03-maven-parent &gt;----------------</span><br><span class="line">[INFO] Building pro03-maven-parent 1.0-SNAPSHOT                           [1/4]</span><br><span class="line">[INFO] --------------------------------[ pom ]---------------------------------</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ pro03-maven-parent ---</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] --- maven-install-plugin:2.4:install (default-install) @ pro03-maven-parent ---</span><br><span class="line">[INFO] Installing /Users/yukiyama/maven/workspace/test/pro03-maven-parent/pom.xml to /Users/yukiyama/maven/repo/com/yukiyama/maven/pro03-maven-parent/1.0-SNAPSHOT/pro03-maven-parent-1.0-SNAPSHOT.pom</span><br><span class="line">...(略，依次安装 pro06, pro05 和 pro04)...</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Reactor Summary for pro03-maven-parent 1.0-SNAPSHOT:</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] pro03-maven-parent ................................. SUCCESS [  0.443 s]</span><br><span class="line">[INFO] pro06-maven-module ................................. SUCCESS [  7.294 s]</span><br><span class="line">[INFO] pro05-maven-module ................................. SUCCESS [  0.628 s]</span><br><span class="line">[INFO] pro04-maven-module ................................. SUCCESS [  0.783 s]</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESS</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time:  9.334 s</span><br><span class="line">[INFO] Finished at: 2022-09-24T21:16:59+08:00</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">yukiyama@yukiyama pro03-maven-parent%</span><br></pre></td></tr></table></figure><p>安装后 <code>pro03-maven-parent</code> 下的目录结构如下。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line">pro03-maven-parent</span><br><span class="line">├── pom.xml</span><br><span class="line">├── pro04-maven-module</span><br><span class="line">│   ├── pom.xml</span><br><span class="line">│   ├── src</span><br><span class="line">│   │   ├── main</span><br><span class="line">│   │   │   └── java</span><br><span class="line">│   │   │       └── com</span><br><span class="line">│   │   │           └── yukiyama</span><br><span class="line">│   │   │               └── maven</span><br><span class="line">│   │   │                   └── App.java</span><br><span class="line">│   │   └── test</span><br><span class="line">│   │       └── java</span><br><span class="line">│   │           └── com</span><br><span class="line">│   │               └── yukiyama</span><br><span class="line">│   │                   └── maven</span><br><span class="line">│   │                       └── AppTest.java</span><br><span class="line">│   └── target</span><br><span class="line">│       ├── classes</span><br><span class="line">│       │   └── com</span><br><span class="line">│       │       └── yukiyama</span><br><span class="line">│       │           └── maven</span><br><span class="line">│       │               └── App.class</span><br><span class="line">│       ├── generated-sources</span><br><span class="line">│       │   └── annotations</span><br><span class="line">│       ├── generated-test-sources</span><br><span class="line">│       │   └── test-annotations</span><br><span class="line">│       ├── maven-archiver</span><br><span class="line">│       │   └── pom.properties</span><br><span class="line">│       ├── maven-status</span><br><span class="line">│       │   └── maven-compiler-plugin</span><br><span class="line">│       │       ├── compile</span><br><span class="line">│       │       │   └── default-compile</span><br><span class="line">│       │       │       ├── createdFiles.lst</span><br><span class="line">│       │       │       └── inputFiles.lst</span><br><span class="line">│       │       └── testCompile</span><br><span class="line">│       │           └── default-testCompile</span><br><span class="line">│       │               ├── createdFiles.lst</span><br><span class="line">│       │               └── inputFiles.lst</span><br><span class="line">│       ├── pro04-maven-module-1.0-SNAPSHOT.jar</span><br><span class="line">│       ├── surefire-reports</span><br><span class="line">│       │   ├── TEST-com.yukiyama.maven.AppTest.xml</span><br><span class="line">│       │   └── com.yukiyama.maven.AppTest.txt</span><br><span class="line">│       └── test-classes</span><br><span class="line">│           └── com</span><br><span class="line">│               └── yukiyama</span><br><span class="line">│                   └── maven</span><br><span class="line">│                       └── AppTest.class</span><br><span class="line">├── pro05-maven-module</span><br><span class="line">│   ├── pom.xml</span><br><span class="line">│   ├── src</span><br><span class="line">│   │   ├── main</span><br><span class="line">│   │   │   └── java</span><br><span class="line">│   │   │       └── com</span><br><span class="line">│   │   │           └── yukiyama</span><br><span class="line">│   │   │               └── maven</span><br><span class="line">│   │   │                   └── App.java</span><br><span class="line">│   │   └── test</span><br><span class="line">│   │       └── java</span><br><span class="line">│   │           └── com</span><br><span class="line">│   │               └── yukiyama</span><br><span class="line">│   │                   └── maven</span><br><span class="line">│   │                       └── AppTest.java</span><br><span class="line">│   └── target</span><br><span class="line">│       ├── classes</span><br><span class="line">│       │   └── com</span><br><span class="line">│       │       └── yukiyama</span><br><span class="line">│       │           └── maven</span><br><span class="line">│       │               └── App.class</span><br><span class="line">│       ├── generated-sources</span><br><span class="line">│       │   └── annotations</span><br><span class="line">│       ├── generated-test-sources</span><br><span class="line">│       │   └── test-annotations</span><br><span class="line">│       ├── maven-archiver</span><br><span class="line">│       │   └── pom.properties</span><br><span class="line">│       ├── maven-status</span><br><span class="line">│       │   └── maven-compiler-plugin</span><br><span class="line">│       │       ├── compile</span><br><span class="line">│       │       │   └── default-compile</span><br><span class="line">│       │       │       ├── createdFiles.lst</span><br><span class="line">│       │       │       └── inputFiles.lst</span><br><span class="line">│       │       └── testCompile</span><br><span class="line">│       │           └── default-testCompile</span><br><span class="line">│       │               ├── createdFiles.lst</span><br><span class="line">│       │               └── inputFiles.lst</span><br><span class="line">│       ├── pro05-maven-module-1.0-SNAPSHOT.jar</span><br><span class="line">│       ├── surefire-reports</span><br><span class="line">│       │   ├── TEST-com.yukiyama.maven.AppTest.xml</span><br><span class="line">│       │   └── com.yukiyama.maven.AppTest.txt</span><br><span class="line">│       └── test-classes</span><br><span class="line">│           └── com</span><br><span class="line">│               └── yukiyama</span><br><span class="line">│                   └── maven</span><br><span class="line">│                       └── AppTest.class</span><br><span class="line">├── pro06-maven-module</span><br><span class="line">│   ├── pom.xml</span><br><span class="line">│   ├── src</span><br><span class="line">│   │   ├── main</span><br><span class="line">│   │   │   └── java</span><br><span class="line">│   │   │       └── com</span><br><span class="line">│   │   │           └── yukiyama</span><br><span class="line">│   │   │               └── maven</span><br><span class="line">│   │   │                   └── App.java</span><br><span class="line">│   │   └── test</span><br><span class="line">│   │       └── java</span><br><span class="line">│   │           └── com</span><br><span class="line">│   │               └── yukiyama</span><br><span class="line">│   │                   └── maven</span><br><span class="line">│   │                       └── AppTest.java</span><br><span class="line">│   └── target</span><br><span class="line">│       ├── classes</span><br><span class="line">│       │   └── com</span><br><span class="line">│       │       └── yukiyama</span><br><span class="line">│       │           └── maven</span><br><span class="line">│       │               └── App.class</span><br><span class="line">│       ├── generated-sources</span><br><span class="line">│       │   └── annotations</span><br><span class="line">│       ├── generated-test-sources</span><br><span class="line">│       │   └── test-annotations</span><br><span class="line">│       ├── maven-archiver</span><br><span class="line">│       │   └── pom.properties</span><br><span class="line">│       ├── maven-status</span><br><span class="line">│       │   └── maven-compiler-plugin</span><br><span class="line">│       │       ├── compile</span><br><span class="line">│       │       │   └── default-compile</span><br><span class="line">│       │       │       ├── createdFiles.lst</span><br><span class="line">│       │       │       └── inputFiles.lst</span><br><span class="line">│       │       └── testCompile</span><br><span class="line">│       │           └── default-testCompile</span><br><span class="line">│       │               ├── createdFiles.lst</span><br><span class="line">│       │               └── inputFiles.lst</span><br><span class="line">│       ├── pro06-maven-module-1.0-SNAPSHOT.jar</span><br><span class="line">│       ├── surefire-reports</span><br><span class="line">│       │   ├── TEST-com.yukiyama.maven.AppTest.xml</span><br><span class="line">│       │   └── com.yukiyama.maven.AppTest.txt</span><br><span class="line">│       └── test-classes</span><br><span class="line">│           └── com</span><br><span class="line">│               └── yukiyama</span><br><span class="line">│                   └── maven</span><br><span class="line">│                       └── AppTest.class</span><br><span class="line">└── src</span><br><span class="line">    ├── main</span><br><span class="line">    │   └── java</span><br><span class="line">    │       └── com</span><br><span class="line">    │           └── yukiyama</span><br><span class="line">    │               └── maven</span><br><span class="line">    │                   └── App.java</span><br><span class="line">    └── test</span><br><span class="line">        └── java</span><br><span class="line">            └── com</span><br><span class="line">                └── yukiyama</span><br><span class="line">                    └── maven</span><br><span class="line">                        └── AppTest.java</span><br><span class="line"></span><br><span class="line">110 directories, 42 files</span><br></pre></td></tr></table></figure><p>工程间依赖时，要注意避免循环依赖，例如 pro03 &gt; pro04 &gt; pro05 &gt; pro06 &gt; pro04 。</p><br /><h3 id="IDE方式-idea"><a href="#IDE方式-idea" class="headerlink" title="IDE方式(idea)"></a>IDE方式(idea)</h3><blockquote><p>使用 IntelliJ IDEA 2022.2.1 (Ultimate Edition) 演示。</p></blockquote><br /><h4 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h4><p>idea 本身已自带 maven ，但若想使用自己下载的 maven 版本，可以通过 File &gt; New Projects Setup &gt; Preferences for New Projects 菜单自定义 maven 相关信息，如下。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/maven_in_action/idea-global-maven-setting.png" alt="idea-global-maven-setting"></p><br /><h4 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h4><h5 id="创建父项目"><a href="#创建父项目" class="headerlink" title="创建父项目"></a>创建父项目</h5><p>接着 File &gt; Project ，选择 Maven Archetype，根据需要选择相应的 archetype ，设置坐标后完成创建。如下创建一个 Java 工程 (quickstart) ，工程名为 <code>maven_in_action</code> 。该工程将作为后续演示中三个 module 的父工程。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/maven_in_action/new-maven-project.png" alt="image-20221001120248093"></p><p>创建后在 idea 中项目结构如下，与之前用命令行创建的 Java 项目类似。如不需要自动创建的 <code>App.java</code> 和 <code>AppTest.java</code> 文件，可删除。点击右侧的 maven 页签，可看到该页签集成了 maven 功能，十分方便操作。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/maven_in_action/maven_project_created.png" alt="maven_project_created"></p><p>此时 <code>maven_in_action</code> 的打包方式为 <code>jar</code> ，可以手动修改为 <code>pom</code> 使其成为一个父工程，也可以直接在该工程下创建新的 module ，则 <code>maven_in_action</code> 会被 idea 自动修改为父工程。</p><br /><h5 id="创建子Java工程"><a href="#创建子Java工程" class="headerlink" title="创建子Java工程"></a>创建子Java工程</h5><p>通过 File &gt; New &gt; Module 菜单可创建子工程，如下，Archetype 选择 <code>quickstart</code>， 创建名为 <code>pro01-module-java</code> 的 java 子工程。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/maven_in_action/new-module.png" alt="new-module"></p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/maven_in_action/module-created.png" alt="module-created"></p><p>创建后，父工程 <code>maven_in_action</code> 的 <code>pom.xml</code> 文件被 idea 自动修改，多出 <code>&lt;modules&gt;</code> 标签，且 <code>&lt;packaging&gt;</code> 方式变为 <code>pom</code> 。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">module</span>&gt;</span>pro01-module-java<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure><p>相比一般工程，子工程的 <code>pom.xml</code> 中具有 <code>&lt;parent&gt;</code> 标签，记录父工程的坐标信息。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven_in_action<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.yukiyama.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><p>为方便后续演示，接着再创建一个子 Java 工程 <code>pro02-module-java</code> ，过程略。 </p><br /><h5 id="创建子web工程"><a href="#创建子web工程" class="headerlink" title="创建子web工程"></a>创建子web工程</h5><p>通过 File &gt; New &gt; Module 菜单可创建子工程，如下，Archetype 选择 <code>webapp</code>， 创建名为 <code>pro03-module-web</code> 的 web 子工程。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/maven_in_action/new-module-web.png" alt="module-created"></p><p>如下，可以看到父工程的 <code>pom.xml</code> 的 <code>&lt;modules&gt;</code> 标签下记录了三个子工程的 artifactId (聚合)，<code>pro03-module-web</code> 子工程打包方式为 <code>war</code> ，且其 <code>&lt;parent&gt;</code> 标签记录了父工程的坐标信息。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/maven_in_action/module-web-created.png"></p><p>如下是自动创建的 <code>web.xml</code> 文件。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">web-app</span> <span class="keyword">PUBLIC</span></span></span><br><span class="line"><span class="meta"> <span class="string">&quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot;</span></span></span><br><span class="line"><span class="meta"> <span class="string">&quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot;</span> &gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>Archetype Created Web Application<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如下是自动创建的 <code>index.jsp</code> 文件。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如不需要自动创建的 <code>web.xml</code> 及 <code>index.jsp</code> 文件，可删除。删除 <code>web.xml</code> 后，可通过 File &gt; Project Structures &gt; Project Settings &gt; Modules，找到 web modules ，在右侧 Deployment Descriptors 中添加 <code>web.xml</code> ，填入正确路径 (<code>WEB-INF</code> 下)，选择所需版本。然后再添加 Web Resources Directories (即 <code>webapp</code>) 。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/maven_in_action/add-webxml.png"></p><p>新建 <code>web.xml</code> 的路径要确保为工程目录下的 src&#x2F;main&#x2F;webapp&#x2F;WEB-INF&#x2F;web.xml 。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/maven_in_action/deployment-descriptor-location.png"></p><p>Web Resource Directories 的路径要确保为工程目录下的 src&#x2F;main&#x2F;webapp 。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/maven_in_action/web-resources-directories.png"></p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/maven_in_action/finished-setting.png"></p><p>通过该方式新建的 <code>web.xml</code> 文件如下。可以看到使用该方式创建 <code>web.xml</code> 的优点时可以指定具体的版本，如下是 4.0 版本。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><br /><h4 id="项目构建-2"><a href="#项目构建-2" class="headerlink" title="项目构建"></a>项目构建</h4><p>在 idea 中，点击右侧 maven 页签打开maven操作界面，可以通过具体工程下的 Lifecycle 或者 Plugins ，对该工程执行具体的 maven 命令。</p><p>如下，双击 <code>pro01-module-java</code> 的 Lifecycle 下的 test ，相当于对该工程执行 <code>mvn test</code> 命令。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/maven_in_action/idea-maven-test.png"></p><p>也可以在 Maven 视窗中点击命令行工具图标 (Execute maven goal) ，在弹出的 Run Anything 界面右上角选择要执行的项目对象，中输入组合命令 (例如 <code>mvn clean test</code> 等) 后回车即可执行。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/maven_in_action/execute-maven-goal.png"></p><p>还可以选中 <code>pom.xml</code> ，右键 Open in &gt; Terminal 的方式，在 idea 中以命令行形式执行 maven 命令，该方式与在终端工具中输入具体命令的方式一样，只不过是在 idea 中而不是 terminal 中执行命令。</p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/maven_in_action/open-in-terminal.png"></p><p><img src="https://raw.githubusercontent.com/iyukiyama/pics/master/maven_in_action/open-in-terminal-mvn-clean.png"></p><br />]]></content>
      
      
      <categories>
          
          <category> Maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL学习实战</title>
      <link href="/2022/08/31/MySQL%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98_yukiyama/"/>
      <url>/2022/08/31/MySQL%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98_yukiyama/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h1><h2 id="客户端工具"><a href="#客户端工具" class="headerlink" title="客户端工具"></a>客户端工具</h2><h3 id="DBeaver"><a href="#DBeaver" class="headerlink" title="DBeaver"></a>DBeaver</h3><br /><h2 id="MySQL必知必会"><a href="#MySQL必知必会" class="headerlink" title="MySQL必知必会"></a>MySQL必知必会</h2><blockquote><p><a href="https://awesome-programming-books.github.io/mysql/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A.pdf">MySQL必知必会 Ben Forta</a>, <a href="https://forta.com/books/0672327120/">配套数据库数据</a></p></blockquote><table><thead><tr><th>章节</th><th>内容</th><th>备注</th></tr></thead><tbody><tr><td><strong>1. 了解SQL</strong></td><td></td><td></td></tr><tr><td></td><td>主键 (primary key) 的定义</td><td>能够唯一标识每一行的列或列的组合。不可为 NULL 值。</td></tr><tr><td></td><td>主键可以由多个列构成</td><td></td></tr><tr><td></td><td>SQL &#x2F; DBMS的关系</td><td>Structrued Query Language<br />Database Management System</td></tr><tr><td><strong>2. MySQL简介</strong></td><td></td><td></td></tr><tr><td></td><td>MySQL是一种DBMS</td><td></td></tr><tr><td></td><td>MySQL的重要版本4.1 &#x2F; 5引入的功能</td><td>V4. InnoDB引擎、增加事务处理、<br />并、改进全文搜索<br />V4.1 函数库、子查询、集成帮助<br />V5. 存储过程、触发器、游标、视图</td></tr><tr><td></td><td>mysql –help</td><td></td></tr><tr><td></td><td>help<br />help select</td><td>获取帮助</td></tr><tr><td><strong>3. 使用MySQL</strong></td><td></td><td></td></tr><tr><td></td><td>MySQL服务端口3306</td><td></td></tr><tr><td>使用数据库</td><td>use crash;</td><td></td></tr><tr><td>查看数据库</td><td>show databases;</td><td></td></tr><tr><td>查看当前数据库的包含的表</td><td>show tables;</td><td></td></tr><tr><td>查看表的字段</td><td>show columns from customers;<br />describe customers;<br />desc customers;</td><td>field: 列名 (字段名)<br />type: 字段类型<br />null: 是否允许 NULL 值<br />key: 标识主键 (PRI)<br />default: 默认值<br />extra: 其他信息如 auto_increment</td></tr><tr><td>自动增量</td><td>auto_increment</td><td>每添加一行，自动分配下一个可用编号</td></tr><tr><td>显示服务器状态信息</td><td>show status;</td><td></td></tr><tr><td>显示状态信息</td><td>status;</td><td>显示当前数据库，当前用户，<br />服务端版本，协议版本，连接信息，<br />服务端客户端字符集等信息</td></tr><tr><td>显示创建数据库的语句</td><td>show create database crash;</td><td></td></tr><tr><td>显示创建列表的语句</td><td>show create table customers;</td><td></td></tr><tr><td>显示授予用户的安全权限</td><td>show grants;</td><td></td></tr><tr><td>显示服务器错误或警告消息</td><td>show errors;<br />show warnings;</td><td></td></tr><tr><td></td><td>help show;</td><td></td></tr><tr><td>显示用户</td><td>select user from mysql.user;</td><td></td></tr><tr><td>显示当前用户</td><td>select user();</td><td></td></tr><tr><td>查询全局设置</td><td>show variables like ‘%auto%’;</td><td>列出变量名含有 ‘auto’ 的变量的当前值。例如 autocommit 。</td></tr><tr><td><strong>4. 检索数据</strong></td><td></td><td></td></tr><tr><td>select</td><td>select prod_name<br />from products;</td><td>检索一列</td></tr><tr><td></td><td>select prod_id, prod_name, prod_price<br/>from products;</td><td>检索多列</td></tr><tr><td></td><td>select *<br/>from products;</td><td>检索所有列</td></tr><tr><td>distinct</td><td>select distinct vend_id<br/>from products;</td><td>检索不同行</td></tr><tr><td>limit</td><td>select prod_name<br/>from products<br/>limit 5;</td><td>限制返回不多于五行</td></tr><tr><td>limit M offset N</td><td>select prod_name<br/>from products<br/>limit 4 offset 3;</td><td>从行3开始取4行（行号从0开始）</td></tr><tr><td>limit N, M</td><td>select prod_name<br/>from products<br/>limit 3, 4;</td><td>从行3开始取4行（行号从0开始）</td></tr><tr><td>完全限定名</td><td>select products.prod_name<br/>from products;</td><td>完全限定表名</td></tr><tr><td></td><td>select products.prod_name<br/>from crash.products;</td><td>完全限定表名&#x2F;数据库名</td></tr><tr><td><strong>5. 排序检索数据</strong></td><td></td><td></td></tr><tr><td></td><td>子句的概念</td><td>之前的 from 即为 select 子句</td></tr><tr><td>order by</td><td>select prod_name<br/>from products<br/>order by prod_name;</td><td>默认排序</td></tr><tr><td></td><td>select prod_id, prod_price, prod_name<br/>from products<br/>order by prod_price, prod_name;</td><td>多列排序，前一列相同的按后一列排序</td></tr><tr><td>asc &#x2F; desc</td><td>select prod_id, prod_price, prod_name<br/>from products<br/>order by prod_price desc, prod_name desc;</td><td>默认为asc<br />一个关键字只作用一列</td></tr><tr><td>order by + limit</td><td>select prod_price<br/>from products<br/>order by prod_price desc<br/>limit 1;</td><td>找最值</td></tr><tr><td><strong>6. 过滤数据</strong></td><td></td><td></td></tr><tr><td>where</td><td>select prod_name, prod_price<br/>from products<br/>where prod_price &#x3D; 2.50;</td><td>where子句操作符<br />&#x3D;,&lt;&gt;,!&#x3D;,&lt;,&lt;&#x3D;,&gt;,&gt;&#x3D;,between…and…</td></tr><tr><td>between…and…</td><td>select prod_name, prod_price<br/>from products<br/>where prod_price between 5 and 10;</td><td>包含指定的值<br />除数值外还可检索日期等</td></tr><tr><td>is null</td><td>select cust_id<br/>from customers<br/>where cust_email is null;</td><td>空值检查</td></tr><tr><td><strong>7. 数据过滤</strong></td><td></td><td>where子句可以组合</td></tr><tr><td>and</td><td>select prod_id, prod_price, prod_name<br/>from products<br/>where vend_id &#x3D; 1003 and prod_price &lt;&#x3D; 10;</td><td></td></tr><tr><td>or</td><td>select prod_name, prod_price<br/>from products<br/>where vend_id &#x3D; 1002 or vend_id &#x3D; 1003;</td><td></td></tr><tr><td></td><td>select prod_name, prod_price<br/>from products<br/>where (vend_id &#x3D; 1002 or vend_id &#x3D; 1003) and prod_price &lt;&#x3D; 10;</td><td>使用多个逻辑符时注意优先级</td></tr><tr><td>in</td><td>select prod_name, prod_price<br/>from products<br/>where vend_id in (1002, 1003)<br/>order by prod_name;</td><td>in结合括号，更清晰<br />in可以包含其他select语句</td></tr><tr><td>not</td><td>select prod_name, prod_price<br/>from products<br/>where vend_id not in (1002, 1003)<br/>order by prod_name;</td><td>not可以对in, between和exists取反</td></tr><tr><td><strong>8. 通配符过滤</strong></td><td></td><td></td></tr><tr><td>通配符</td><td>用来匹配值的一部分的特殊字符。</td><td></td></tr><tr><td>搜索模式</td><td>由字面值、通配符或两者组合构成的搜索条件。</td><td></td></tr><tr><td>like</td><td>select prod_name, prod_price<br/>from products<br/>where prod_name like “jet%”;</td><td>% 表示任何字符出现任意次<br />默认不区分大小写<br />%不能匹配 null 字段</td></tr><tr><td>通配符”%”</td><td>select prod_id, prod_name<br/>from products<br/>where prod_name like “%anvil%”;</td><td>可在搜索模式中的任意位置</td></tr><tr><td></td><td>select prod_id, prod_name<br/>from products<br/>where prod_name like “s%e”;</td><td>以s开头以e结尾的prod_name</td></tr><tr><td>通配符”_”</td><td>select prod_id, prod_name<br/>from products<br/>where prod_name like “_ ton anvil”;</td><td>匹配一个字符，不多也不少</td></tr><tr><td></td><td>通配符使用原则:<br />其他操作符可达到目的时使用其他操作符<br />尽量不在搜索模式开头使用通配符</td><td></td></tr><tr><td><strong>9. 正则表达式</strong></td><td></td><td></td></tr><tr><td>regexp</td><td>select prod_name<br/>from products<br/>where prod_name regexp “1000”<br/>order by prod_name;</td><td>基本字符匹配</td></tr><tr><td>正则字符”.”</td><td>select prod_name<br/>from products<br/>where prod_name regexp “.000”<br/>order by prod_name;</td><td>“.”匹配任意一个字符</td></tr><tr><td></td><td><strong>like 和 regexp 的重要区别</strong>：<br />like 匹配整个字段，而 regexp 匹配字段的部分</td><td>like “100”<br />regexp “100”<br />对于1000，like不匹配而regexp匹配</td></tr><tr><td>binary</td><td></td><td>regexp 不区分大小写<br />使用 binary 可以区分大小写</td></tr><tr><td>正则字符”|”</td><td>select prod_name<br/>from products<br/>where prod_name regexp ‘1000|2000’<br />order by prod_name;</td><td>匹配两个串之一</td></tr><tr><td>正则字符”[]”</td><td>select prod_name<br/>from products<br/>where prod_name regexp ‘[123] ton’<br/>order by prod_name;</td><td>匹配指定字符之一</td></tr><tr><td>正则字符”()”</td><td>select prod_name<br/>from products<br/>where prod_name regexp ‘(1|2|3) ton’<br />order by prod_name;</td><td>(1|2|3)作用等同于[123]</td></tr><tr><td>正则字符”[^]”</td><td>select prod_name<br/>from products<br/>where prod_name regexp ‘[^123] ton’<br/>order by prod_name;</td><td>匹配除指定字符之外的字符</td></tr><tr><td>正则字符”[0-9]”</td><td>select prod_name<br/>from products<br/>where prod_name regexp ‘[0-9] ton’;</td><td>[0-9]匹配数字0到9<br />[1-5]匹配数字1到5</td></tr><tr><td>转义”<code>\\</code>“</td><td>select prod_name<br/>from products<br/>where prod_name regexp ‘\\.’;</td><td>两个反斜杠表示转义<br />其他转义: <code>\\f</code>, <code>\\n</code>, <code>\\r</code>, <code>\\t</code>, <code>\\v</code> <br /><code>\\\</code> 匹配反斜杠本身</td></tr><tr><td>预定义字符集</td><td>select prod_name<br/>from products<br/>where prod_name regexp ‘[:alnum:]’;</td><td>[:alnum:] 同 [a-zA-Z0-9]<br />[:alpha:] 同 [a-zA-Z]<br />[:digit:] 同 [0-9]<br />[:lower:] 同 [a-z]<br />[:upper:] 同 [A-Z]</td></tr><tr><td>重复元字符</td><td>* 0个或多个<br />+ 1个或多个，同{1,}<br />? 0个或1个，同{0,1}<br />{n} 指定匹配n个<br />{n,} 指定匹配不少于n个<br />{n,m} 指定匹配数据不少于n个不多于m个(m&lt;&#x3D;255)</td><td></td></tr><tr><td></td><td>select prod_name<br/>from products<br/>where prod_name regexp ‘\\([0-9] sticks?\\)’;</td><td></td></tr><tr><td>定位符</td><td>^ 文本的开始<br />$ 文本的结尾<br />[[:&lt;:]] 词的开始<br />[[:&gt;:]] 词的结尾</td><td>^ 在 <code>[^]</code> 中用于指定该集合元素之外的元素，否则用来指串的开始处。</td></tr><tr><td></td><td>select prod_name<br/>from products<br/>where prod_name regexp ‘^[0-9\\.]’;</td><td>以小数点或数字开始</td></tr><tr><td>测试</td><td>select ‘hello’ regexp ‘[a-z]’;</td><td>匹配返回1，不匹配返回0<br />不读取表即可直接测试正则表达式</td></tr><tr><td><strong>10. 创建计算字段</strong></td><td></td><td></td></tr><tr><td></td><td>对检索结果的转换、计算、格式化等</td><td></td></tr><tr><td>concat()</td><td>select concat(vend_name, ‘ (‘, vend_country, ‘)’)<br/>from vendors<br/>order by vend_name;</td><td>concat指定一个或多个串，以逗号隔开</td></tr><tr><td>rtrim()<br />ltrim()<br />trim()</td><td>select concat(vend_name, ‘ (‘, rtrim(vend_country), ‘)’)<br/>from vendors<br/>order by vend_name;</td><td>去掉字段右边&#x2F;左边&#x2F;两边的空格</td></tr><tr><td>as</td><td>select concat(vend_name, ‘ (‘, trim(vend_country), ‘)’) as vend_title<br/>from vendors<br/>order by vend_name;</td><td>也可以省略as</td></tr><tr><td>算术计算</td><td>select prod_id, quantity, item_price, quantity * item_price as extended_price<br/>from orderitems<br/>where order_num &#x3D; 20005;</td><td>MySQL 算术操作符: <code>+, -, *, /</code></td></tr><tr><td>测试计算</td><td>select 3 * 2;</td><td>select 1;<br />select now();</td></tr><tr><td><strong>11. 函数</strong></td><td></td><td></td></tr><tr><td>upper()</td><td>select vend_name, upper(vend_name)<br/>from vendors<br/>order by vend_name;</td><td>常用文本处理函数:<br />left() &#x2F; right()<br />length()<br />lower() &#x2F; upper()<br />ltrim() &#x2F; rtrim() &#x2F; trim()<br />locate() &#x2F; substring()<br />soundex()</td></tr><tr><td>soundex()</td><td>select cust_name, cust_contact<br/>from customers<br/>where soundex(cust_contact) &#x3D; soundex(‘Y. Lie’);</td><td></td></tr><tr><td>日期和时间</td><td>select cust_id, order_num<br/>from orders<br/>where order_date &#x3D; ‘2005-09-01’;</td><td>涉及日期时间应使用相关函数</td></tr><tr><td>date()</td><td>select cust_id, order_num<br/>from orders<br/>where date(order_date) &#x3D; ‘2005-09-01’;</td><td>日期和时间相关函数<br />adddate&#x2F;addtime<br />curdate&#x2F;curtime<br />now&#x2F;date&#x2F;year&#x2F;month&#x2F;day<br />time&#x2F;hour&#x2F;minute&#x2F;second<br />datediff&#x2F;date_add&#x2F;date_format<br />dayofweek</td></tr><tr><td></td><td>select cust_id, order_num, order_date<br/>from orders<br/>where date(order_date) between ‘2005-09-01’ and ‘2005-09-30’;</td><td></td></tr><tr><td></td><td>select cust_id, order_num<br/>from orders<br/>where year(order_date) &#x3D; 2005 and month(order_date) &#x3D; 9;</td><td></td></tr><tr><td>数值处理</td><td>作用于数值数据的代数、三角函数或几何运算等</td><td>abs&#x2F;sqrt&#x2F;exp&#x2F;mod<br />pi&#x2F;sin&#x2F;cos&#x2F;tan&#x2F;rand</td></tr><tr><td><strong>12. 汇总数据</strong></td><td></td><td></td></tr><tr><td>聚集函数</td><td>作用于一列，返回一个计算值</td><td>MySQL 提供五种聚集函数: avg&#x2F;count&#x2F;max&#x2F;min&#x2F;sum</td></tr><tr><td>avg()</td><td>select avg(prod_price) as avg_price<br/>from products;</td><td>avg()只作用于一列，<br />获取多列时使用多个avg()<br />avg()忽略null</td></tr><tr><td></td><td>select avg(prod_price) as avg_price<br/>from products<br/>where vend_id &#x3D; 1003;</td><td>结合where子句</td></tr><tr><td>count()</td><td>select count(*)<br/>from customers;</td><td>count(*)包括null</td></tr><tr><td></td><td>select count(cust_email) as valid_cust<br/>from customers;</td><td>count(&lt;指定列名&gt;)不包括null</td></tr><tr><td>max()</td><td>select max(prod_price) as max_price<br/>from products;</td><td></td></tr><tr><td>min()</td><td>select min(prod_price) as min_price<br/>from products;</td><td></td></tr><tr><td>sum()</td><td>select sum(quantity) as total<br/>from orderitems;</td><td></td></tr><tr><td></td><td>select sum(quantity) as 20005_total<br/>from orderitems<br/>where order_num &#x3D; 20005;</td><td>结合where子句</td></tr><tr><td></td><td>select sum(item_price * quantity) as 20005_total_price<br/>from orderitems<br/>where order_num &#x3D; 20005;</td><td>结合计算</td></tr><tr><td></td><td>select avg(distinct prod_price) as avg_price<br/>from products<br/>where vend_id &#x3D; 1003;</td><td>结合其他关键字</td></tr><tr><td>组合聚集函数</td><td>select<br/>  count(*) as num_items,<br/>  min(prod_price) as min_price,<br/>  max(prod_price) as max_price,<br/>  avg(prod_price) as avg_price<br/>from products;</td><td></td></tr><tr><td><strong>13. 分组数据</strong></td><td></td><td></td></tr><tr><td>group by</td><td>select vend_id, count(*) as num_prods<br/>from products<br/>group by vend_id;</td><td>按逻辑组返回<br />null 会被分为一组<br />group by 在 where 后 order by 前</td></tr><tr><td>聚合函数 + group by</td><td><a href="https://blog.csdn.net/Superman___007/article/details/91952070">参考1</a><br />group by 与聚合函数使用时，后者作用在每一个分组之上。<br />group by 的分组字段可以有多个，例如 group by vend_id, prod_id;</td><td>group by x 将表按 x 分为 n 个组（每个组至少有一行），然后对每个组的多个值求「聚合函数f(y)」的值，y是「聚合」列的列名。<br />可想象 group by 的过程有个「临时表」，该表有 n 行，每一行的格子里放入了 x 在原表中对应的多个值。之后聚合函数施加于这个格子中所有值之上。</td></tr><tr><td></td><td>select 列，同时也适用聚集函数时，必须使用group by，如下语句将报错<br />select vend_id, count(*)<br/>from products;<br />ERROR 1140 (42000): In aggregated query without GROUP BY, expression #1 of SELECT list contains nonaggregated column ‘crash.products.vend_id’; this is incompatible with sql_mode&#x3D;only_full_group_by</td><td></td></tr><tr><td>with rollup</td><td>select vend_id,count(*) as num_prods<br/>from products<br/>group by vend_id with rollup;</td><td>得到每个分组以及汇总值<br /><strong>包括 null</strong></td></tr><tr><td>having</td><td>select cust_id, count(*)<br/>from orders<br/>group by cust_id<br/>having count(*) &gt;&#x3D; 2;</td><td>过滤分组<br />where过滤行，<br />having过滤组<br />having 支持所有 where 操作符</td></tr><tr><td></td><td>select vend_id, count(*) as num_prods<br/>from products<br/>where prod_price &gt;&#x3D; 10<br/>group by vend_id<br/>having count(*) &gt;&#x3D; 2;</td><td>where 与 group by - having 结合</td></tr><tr><td></td><td>select order_num, sum(item_price * quantity) as ordertotal<br/>from orderitems<br/>group by order_num<br/>having ordertotal &gt;&#x3D; 50<br/>order by ordertotal;</td><td>group by 与 order by 结合</td></tr><tr><td>select子句顺序</td><td>select<br />from<br />where<br />group by<br />having<br />order by<br />limit</td><td></td></tr><tr><td><strong>14. 使用子查询</strong></td><td></td><td>由4.1引入</td></tr><tr><td></td><td>select cust_id<br/>from orders<br/>where order_num in<br/>(<br/>  select order_num<br/>  from orderitems<br/>  where prod_id &#x3D; ‘TNT2’<br/>);</td><td>从内向外执行</td></tr><tr><td></td><td>select cust_name, cust_contact<br/>from customers<br/>where cust_id in<br/>(<br/>  select cust_id<br/>  from orders<br/>  where order_num in<br/>  (<br/>    select order_num<br/>    from orderitems<br/>    where prod_id &#x3D; ‘TNT2’<br/>  )<br/>);</td><td>子查询多重嵌套</td></tr><tr><td></td><td>select cust_name, cust_state,<br/>(<br/>  select count(*)<br/>  from orders<br/>  where orders.cust_id &#x3D; customers.cust_id<br/>) as orders<br/>from customers<br/>order by cust_name;</td><td>计算字段子查询<br />涉及到完全限定名</td></tr><tr><td></td><td>逐渐增加子查询来建立查询：<br />先建立和测试内层查询，再用直接数据测试外层查询</td><td></td></tr><tr><td><strong>15. 联结表</strong></td><td></td><td></td></tr><tr><td>foreign key</td><td>外键的概念</td><td>当前表的外键为另一表的主键</td></tr><tr><td>分表</td><td>类似程序中的「解耦」，一张表应当只存放一类信息，例如 vendors 表存放供应商信息，products 存放产品信息。两张表的外键分别是对方的主键。</td><td>分表的好处:<br />各自信息解耦，节省空间，逻辑清晰。<br />若其中一个表有改动，只需修改该表即可而不需改动其他表。<br />分表增强了数据库的可伸缩性。</td></tr><tr><td>from 两张表<br />等值联结</td><td>select vend_name, prod_name, prod_price<br/>from vendors, products<br/>where vendors.vend_id &#x3D; products.vend_id<br/>order by vend_name, prod_name;</td><td>等值联结是内联结 (inner join on) 的另一种写法<br />where 子句使用完全限定列名</td></tr><tr><td></td><td>select vend_name, prod_name, prod_price<br/>from vendors as v, products as p<br/>where v.vend_id &#x3D; p.vend_id<br/>order by vend_name, prod_name;</td><td>简化表名 (as可省略)</td></tr><tr><td>笛卡尔积</td><td>select vend_name, prod_name, prod_price<br/>from vendors, products<br/>order by vend_name, prod_name;</td><td>不加 where 限定条件时得到笛卡尔积</td></tr><tr><td>inner join on</td><td>select v.vend_id, vend_name, prod_name<br/>from<br/>  vendors v<br/>  inner join<br/>  products p<br/>  on v.vend_id &#x3D; p.vend_id<br/>order by vend_name, prod_name;</td><td></td></tr><tr><td>多表联结</td><td>select prod_name, vend_name, prod_price, quantity<br/>from orderitems oi, products p, vendors v<br/>where p.vend_id &#x3D; v.vend_id<br/>  and oi.prod_id &#x3D; p.prod_id<br/>  and order_num &#x3D; 20005;</td><td></td></tr><tr><td></td><td>select cust_name, cust_contact<br/>from customers c, orders o, orderitems oi<br/>where c.cust_id &#x3D; o.cust_id<br/>  and oi.order_num &#x3D; o.order_num<br/>  and oi.prod_id &#x3D; ‘TNT2’;</td><td>优于多重子查询的内联结写法</td></tr><tr><td><strong>16. 高级联结</strong></td><td></td><td></td></tr><tr><td></td><td>select prod_id, prod_name<br/>from products<br/>where vend_id &#x3D;<br/>(<br/>  select vend_id<br/>  from products<br/>  where prod_id &#x3D; ‘DTNTR’<br/>);</td><td></td></tr><tr><td>自联结</td><td>上述查询的自联结做法：<br />select p1.prod_id, p1.prod_name<br/>from products p1, products p2<br/>where p1.vend_id &#x3D; p2.vend_id<br/>  and p2.prod_id &#x3D; ‘DTNTR’;</td><td>表与自身连接</td></tr><tr><td>自然联结</td><td>select c.*, o.order_num, o.order_date,<br/>  oi.prod_id, oi.quantity, oi.item_price<br/>from customers c, orders o, orderitems oi<br/>where c.cust_id &#x3D; o.cust_id<br/>  and oi.order_num &#x3D; o.order_num<br/>  and prod_id &#x3D; ‘FB’;</td><td></td></tr><tr><td>外部联结</td><td>select c.cust_id, o.order_num<br/>from<br/>  customers c<br/>  left outer join<br/>  orders o<br/>  on c.cust_id &#x3D; o.cust_id;</td><td>left outer join<br />right outer join</td></tr><tr><td></td><td>select c.cust_id, o.order_num<br/>from<br/>  customers c<br/>  inner join<br/>  orders o<br/>  on c.cust_id &#x3D; o.cust_id;</td><td>内部联结比较</td></tr><tr><td>联结+聚集函数</td><td>select c.cust_id, c.cust_name, count(o.order_num) as num_order<br/>from<br/>  customers c<br/>  inner join<br/>  orders o<br/>  on c.cust_id &#x3D; o.cust_id<br/>group by c.cust_id;</td><td></td></tr><tr><td></td><td>select c.cust_id, c.cust_name, count(o.order_num) as num_order<br/>from<br/>  customers c<br/>  left outer join<br/>  orders o<br/>  on c.cust_id &#x3D; o.cust_id<br/>group by c.cust_id;</td><td></td></tr><tr><td><strong>17. 组合查询</strong></td><td></td><td></td></tr><tr><td>union</td><td>select vend_id, prod_id, prod_price<br/>from products<br/>where prod_price &lt;&#x3D; 5<br/>union<br/>select vend_id, prod_id, prod_price<br/>from products<br/>where vend_id in (1001, 1002);</td><td>通过union组合多条select语句<br /></td></tr><tr><td>union all</td><td>与 where 通过多个条件过滤相同，也会去除重复的行，利用 union all 可包含重复的行</td><td></td></tr><tr><td>union + order by</td><td>select vend_id, prod_id, prod_price<br/>from products<br/>where prod_price &lt;&#x3D; 5<br/>union<br/>select vend_id, prod_id, prod_price<br/>from products<br/>where vend_id in (1001, 1002)<br/>order by vend_id, prod_price;</td><td>order by 只能用于最后，对整个结果集排序</td></tr><tr><td><strong>18. 全文本搜索</strong></td><td></td><td></td></tr><tr><td>数据库引擎支持</td><td>MyISAM 支持，InnoDB 不支持</td><td>由于数据是索引的，全文本搜索相比 LIKE 或正则表达式方式要快</td></tr><tr><td>启用全文搜索</td><td>CREATE TABLE productnotes <br />(<br/>  note_id int NOT NULL AUTO_INCREMENT,<br/>  prod_id char(10) NOT NULL,<br/>  note_date datetime NOT NULL,<br/>  note_text text,<br/>  PRIMARY KEY (note_id),<br/>  FULLTEXT KEY note_text (note_text)<br/>) ENGINE&#x3D;MyISAM AUTO_INCREMENT&#x3D;115 DEFAULT CHARSET&#x3D;utf8mb4 COLLATE&#x3D;utf8mb4_0900_ai_ci;</td><td>在 CREATE 语句中使用 FULLTEXT KEY() 子句</td></tr><tr><td>match &#x2F; against</td><td>select note_text<br/> from productnotes<br/> where match(note_text) against(‘rabbit’);</td><td>结果以「匹配」的良好程度排序返回</td></tr><tr><td></td><td>select note_text, match(note_text) against(‘rabbit’) as score <br />from productnotes;</td><td>列出匹配程度得分</td></tr><tr><td><strong>19. 插入数据</strong></td><td></td><td></td></tr><tr><td>依据次序插入</td><td>insert into customers<br/>values (null, ‘yukiyama’, ‘liangzhu wenhuacun’, ‘hangzhou’, ‘ZJ’, ‘00000’, ‘China’, null, null);</td><td>需严格按照次序完整给出所有列</td></tr><tr><td>依据列名插入</td><td>insert into customers (cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country, cust_contact, cust_email)<br/>values (‘duoduo’, ‘Koiwa’, ‘Tokyo’, ‘Japan’, ‘22222’, ‘Japan’, null, null);</td><td>对于可以为 NULL 值的列，且默认值为 NULL，则插入 NULL 值时，可省略不写。</td></tr><tr><td>合并表</td><td>insert into customers (cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country, cust_contact, cust_email)<br/>values (‘duoduo’, ‘Koiwa’, ‘Tokyo’, ‘Japan’, ‘22222’, ‘Japan’, null, null)<br />select cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country, cust_contact, cust_email <br />from custnew;</td><td>select 中的列名不必与 insert into 中的相同。select 中声明的列讲依次填充 insert into 中指定的列。</td></tr><tr><td><strong>20. 更新和删除数据</strong></td><td></td><td></td></tr><tr><td>更新一行一个字段</td><td>update customers<br/>set cust_email &#x3D; ‘<a href="mailto:&#x65;&#102;&#117;&#x64;&#x64;&#x40;&#x67;&#x6d;&#97;&#105;&#x6c;&#46;&#99;&#111;&#109;">&#x65;&#102;&#117;&#x64;&#x64;&#x40;&#x67;&#x6d;&#97;&#105;&#x6c;&#46;&#99;&#111;&#109;</a>‘<br/>where cust_id &#x3D; 10005;</td><td></td></tr><tr><td>更新一行多个字段</td><td>update customers<br/>set cust_email &#x3D; ‘<a href="mailto:&#x65;&#102;&#x75;&#100;&#x64;&#64;&#103;&#109;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#109;">&#x65;&#102;&#x75;&#100;&#x64;&#64;&#103;&#109;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#109;</a>‘,<br/>cust_name &#x3D; ‘The Fudds’<br />where cust_id &#x3D; 10005;</td><td></td></tr><tr><td>更新多行一个字段</td><td>update customers<br/>set cust_email &#x3D; null;</td><td>不使用 where 子句过滤时将更新所有行的指定字段为指定值</td></tr><tr><td>删除行</td><td>delete from customers<br />where cust_id &#x3D; 10006;</td><td>以 where 子句过滤要删除的行</td></tr><tr><td>删除所有行</td><td>delete from customers;</td><td>不使用 where 子句过滤时将删除所有行</td></tr><tr><td>更新和删除的原则</td><td>在更新和删除前应先使用 select 列出目标，确保不误更新活误删除</td><td></td></tr><tr><td><strong>21. 创建和操纵表</strong></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td><strong>22. 使用视图</strong></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td><strong>23. 使用存储过程</strong></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td><strong>24. 使用游标</strong></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td><strong>25. 使用触发器</strong></td><td></td><td></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>splay树</title>
      <link href="/2022/08/17/splay%E6%A0%91/"/>
      <url>/2022/08/17/splay%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="splay树-树ADT连载-5-x2F-13"><a href="#splay树-树ADT连载-5-x2F-13" class="headerlink" title="splay树 (树ADT连载 5&#x2F;13)"></a>splay树 (树ADT连载 5&#x2F;13)</h1><blockquote><ul><li><p>可在作者的 <a href="https://github.com/iyukiyama/leetcode-posts">github仓库</a> 中获取本文和其他文章的 markdown 源文件及相关代码。</p></li><li><p>欢迎评论或仓库 PR 指出文章错漏或与我讨论相关问题，我将长期维护所有文章。</p></li><li><p>所有文章均用 Typora 完成写作，可使用 Typora 打开文章 md 文件，以获得最佳阅读体验。</p></li></ul></blockquote><p>🌲🌲🌲 <strong>一起手写一棵完整的 splay 树。</strong></p><p>❗️ <strong>【NEW】</strong> ❗️</p><ul><li>9-15:  <a href="https://leetcode.cn/circle/discuss/SwgIJV/">红黑树从入门到看开</a></li></ul><p>这是小白 yuki 推出的「树ADT」系列文章的第 5 篇 (5&#x2F;13) 。</p><hr><blockquote><p>$keywords$ :</p><p>splay树 &#x2F; 展开 &#x2F; 自顶向下展开 &#x2F; 摊还时间上的平衡</p></blockquote><p>本文介绍一种易于实现的平衡二叉查找树 –– splay树。实际上本文是为了后续讲解多种 <strong>平衡二叉树</strong> 的前置文章，最终目的是讲解 <strong>「红黑树」</strong> (已推出，<a href="https://leetcode.cn/circle/discuss/SwgIJV/">红黑树从入门到看开</a>)。</p><p>本文重点在于展现如何设计一个 splay树 类，分析主要方法的代码实现，并给出该类的完整实现代码。读者学习之后 <strong>可以自己写出一个方法较为完备的splay树类</strong> 。</p><hr><p>yuki的其他文章如下，欢迎阅读指正！</p><blockquote><p>如下所有文章同时也在我的 github <a href="https://github.com/iyukiyama/leetcode-posts">仓库</a> 中维护。</p></blockquote><table><thead><tr><th>文章</th><th>[发布时间] 字数&#x2F;览&#x2F;藏&#x2F;赞 (~2022-10-20)</th></tr></thead><tbody><tr><td><a href="https://leetcode.cn/circle/discuss/eBo9UB/">十大排序从入门到入赘</a>  🔥🔥🔥</td><td>[20220516]  2.5万字&#x2F;64.8k览&#x2F;3.7k藏&#x2F;937赞</td></tr><tr><td><a href="https://leetcode.cn/circle/discuss/ooxfo8/">二分查找从入门到入睡</a> 🔥🔥🔥</td><td>[20220509]  2.3万字&#x2F;38.4k览&#x2F;2.1k藏&#x2F;503赞</td></tr><tr><td><a href="https://leetcode.cn/circle/discuss/qmjuMW/">并查集从入门到出门</a> 🔥🔥</td><td>[20220514]  1.2万字&#x2F;17.9k览&#x2F;1.0k藏&#x2F;321赞</td></tr><tr><td><a href="https://leetcode.cn/circle/discuss/FyPTTM/">图论算法从入门到放下</a> 🔥🔥</td><td>[20220617]  5.6万字&#x2F;19.9k览&#x2F;1.3k藏&#x2F;365赞</td></tr><tr><td>树ADT系列 (预计13篇)</td><td>系列文章，连载中</td></tr><tr><td>3. <a href="https://leetcode.cn/circle/discuss/wPzlSb/">二叉查找树</a></td><td>[20220801]  5千字</td></tr><tr><td>4. <a href="https://leetcode.cn/circle/discuss/zbwD3p/">AVL树</a></td><td>[20220817]  5千字</td></tr><tr><td>5. <a href="https://leetcode.cn/circle/discuss/BCK17f/">splay树</a></td><td>[20220817]  5千字</td></tr><tr><td>6. <a href="https://leetcode.cn/circle/discuss/SwgIJV/">红黑树从入门到看开</a> 🔥🤯🤯🤯</td><td>[20220915]  3万字&#x2F;5.3k览&#x2F;269藏&#x2F;72赞</td></tr><tr><td>10. <a href="https://leetcode.cn/circle/discuss/qGREiN/">树状数组从入门到下车</a> 🔥🤯</td><td>[20220722]  1.4万字&#x2F;5.8k览&#x2F;196藏&#x2F;72赞</td></tr><tr><td>11. <a href="https://leetcode.cn/circle/discuss/H4aMOn/">线段树从入门到急停</a> 🔥🤯</td><td>[20220726]  2.5万字&#x2F;8.7k览&#x2F;481藏&#x2F;138赞</td></tr><tr><td><a href="https://leetcode.cn/circle/discuss/GV0JrV/">图论相关证明系列</a></td><td>系列文章</td></tr><tr><td>1. <a href="https://leetcode.cn/circle/discuss/jJQn7V/">Dijkstra正确性证明</a> 🤯</td><td>[20220531]</td></tr><tr><td>2. <a href="https://leetcode.cn/circle/discuss/VVEc8f/">Prim正确性证明</a> 🤯</td><td>[20220919]</td></tr><tr><td>3. <a href="https://leetcode.cn/circle/discuss/xeEwYl/">Bellman-Ford及SPFA正确性证明</a></td><td>[20220602]</td></tr><tr><td>4. <a href="https://leetcode.cn/circle/discuss/Nbzix4/">Floyd正确性证明</a></td><td>[20220602]</td></tr><tr><td>5. <a href="https://leetcode.cn/circle/discuss/tMIy36/">最大流最小割定理证明</a> 🤯🤯</td><td>[20220719]</td></tr><tr><td>6. <a href="https://leetcode.cn/circle/discuss/tN3sZc/">Edmonds-Karp复杂度证明</a> 🤯🤯</td><td>[20220515]</td></tr><tr><td>7. <a href="https://leetcode.cn/circle/discuss/T9Xa1R/">Dinic复杂度证明</a> 🤯🤯</td><td>[20220531]</td></tr></tbody></table><hr><p>[TOC]</p><hr><h3 id="splay树"><a href="#splay树" class="headerlink" title="splay树"></a>splay树</h3><p>伸展树是解决基本 BST 在非平衡状态下主要操作无法达到 $O(logn)$ 复杂度的另一种解决方案。相比 AVL 树，伸展树并不严格地使 BST 每次操作后保持平衡，因此伸展树的单次操作可能为 $O(n)$ 复杂度，但伸展树保证 $m$ 次操作的最坏时间复杂度为 $mO(logn)$，也就是说其主要操作的 <strong>均摊时间复杂度</strong> 为 $O(logn)$  。伸展树相对 AVL 树的优点是 <strong>无需维护树的高度信息</strong> ，从而能够节省一部分空间，且编程相对简单。伸展树的主要操作均基于 <strong>「展开 (splay)」</strong> ，展开操作的基础是我们已在 AVL 中讲解过的旋转， <strong>「展开」动作将目标结点旋转至根结点处，并在这个过程中调整沿途上的结点</strong> 。本节将介绍一种只需 $O(1)$ 辅助空间的「自顶向下」展开的伸展树。</p><blockquote><p>伸展树由 <a href="https://en.wikipedia.org/wiki/Daniel_Sleator">Daniel Sleator</a> 和 <a href="https://en.wikipedia.org/wiki/Robert_Tarjan">Robert Tarjan</a> 共同发明，发表于1985年的 <a href="https://www.cs.cmu.edu/~sleator/papers/self-adjusting.pdf">论文</a> 中。</p><p>本文内容为Mark Allen Weiss所著 <a href="https://awesome-programming-books.github.io/algorithms/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9AJava%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0.pdf">数据结构与算法分析：Java语言描述</a> 相关章节的整理和总结。代码亦来自该书，略作改动。</p></blockquote><br /><h4 id="展开"><a href="#展开" class="headerlink" title="展开"></a>展开</h4><p>伸展树「展开」的想法基于这样一个事实：当一个结点被访问时 (查询最小&#x2F;最大&#x2F;是否存在&#x2F;插入&#x2F;删除等)，它很可能将在不久之后被再次访问。因此为了提高总体访问效率，在访问一个结点后，考虑将其移动到根结点处， <strong>移动过程即「展开」</strong> 。在 AVL 树一节中我们已经掌握如何通过旋转向一个方向移动目标结点，很容易想到通过有限次的「单旋转」将目标结点展开至根结点处 (使其成为根结点)。</p><p>以下图为例，通过简单旋转将左侧树的结点 1 展开至根处得到右侧树。同时我们希望在展开过程中能够降低树高，而下图单旋转方式显然没有改变树高。</p><p><img src="https://pic.leetcode-cn.com/1660706904-GveWEq-image.png" alt="image.png"></p><p>为了使得展开同时具有降低树高的效果，伸展树采用 <strong>双旋转与单旋转结合</strong> 的方式展开。主要为以下三种情形，每种情形有对称的两种子情形 (不再列出)。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">单旋转: 与 AVL 树中介绍的单旋转相同，分为左单旋状和右单旋转。</span><br><span class="line">之字形双旋转：与 AVL 树中介绍的之字形双旋转相同，实际上就是连续两次不同向的单旋转，分为左右双旋转和右左双旋转。</span><br><span class="line">一字形双旋转：实际上就是连续两次同向的单旋转，分为左左双旋转和右右双旋转。</span><br></pre></td></tr></table></figure><p>如下图左侧是我们在 AVL 树一节中已经熟悉的之字形左右双旋转 (先左旋 $P-X$ ，再右旋 $X-G$ )，右侧是一字形右右双旋转 (先右旋 $G-P$ ，再右旋 $P-X$ )。</p><p><img src="https://pic.leetcode-cn.com/1660706954-RvPxlZ-image.png" alt="image.png"></p><p>伸展树中的「展开」操作要求 <strong>在能够双旋转时采用双旋转，只能单旋转时才执行单旋转</strong> 。现在我们利用此规则展开前面给出的 1 到 6 的链状树，如下，展开过程为两次一字形的双旋转和一次单旋转。尽管由于结点树较少而无法很好地看出树高减小的效果，但总体上，相比简单的单旋转，我们确实能够看到树高减小的效果。</p><p><img src="https://pic.leetcode-cn.com/1660707012-AlXOuk-image.png" alt="image.png"></p><br /><h4 id="自顶向下展开"><a href="#自顶向下展开" class="headerlink" title="自顶向下展开"></a>自顶向下展开</h4><p>展开操作的前提是找到目标结点，因此需要一次遍历来找到目标结点，然后再沿着此路径将目标结点旋转至根结点，这显然需要保存路径信息。在 AVL 树中我们以递归调用的方式，借助隐式保存了路径信息的递归栈实现上述做法。这里我们将介绍一种 <strong>无需栈空间的「自顶向下」展开</strong> ，即无需遍历找到目标后再展开，而是在自顶向下寻找目标的过程中实时地展开。</p><p>在前面的例子中我们没有展示之字形旋转的过程，实际上，本节给出的「自顶向下」的展开实现中， <strong>对之字形的情况按照「单旋转」处理</strong> 。此外，展开的过程中始终维护树 $L$ 、树 $M$ 以及树 $R$ ，使得旋转操作得到简化，其定义如下。</p><blockquote><p> 整棵树中小于中间树 $M$ 的根结点但不在 $M$ 中的结点存储在 $L$ 树中，大于中间树 $M$ 的根结点但不在 $M$ 中的结点存储在 $R$ 树中。初始时 $M$ 即为原树，$L, R$ 为空树。</p></blockquote><p>下图从上到下表示 <strong>单旋转、之字形旋转 (同单旋转) 以及一字形旋转</strong> 。可以看到，与 AVL 的旋转相比，这里的「单旋转」实际上只是修改了一些链接关系 ( AVL 单旋转本质也是修改一些链接关系，但重点在于旋转主体目标结点相对关系的改变，例如下图的单旋转，若为 AVL 中的单旋转，则 $X$ 到 $Y$ 的链接「右旋」后将变为 $Y$ 到 $X$ 的链接)，而「一字形旋转」也只是执行了一次 $Y-X$ 右旋后修改了一些链接关系。因此相比 AVL 树的实现，「自顶向下」伸展树的代码十分易于编写。</p><p><img src="https://pic.leetcode-cn.com/1660707064-QHwUvv-image.png" alt="image.png"></p><p>实际编程中应用了一些技巧，例如利用 $nullNode$ 来简化程序并提高了程序效率。通过设置 $header$ 来保存 $L$ 和 $R$ 首次不为空树时的树根，以便于最后的 <strong>组装</strong> 操作。下图表现了展开操作最后的组装动作，同样只是简单地修改一些链接关系。具体实现以及提到的一些实现技巧在初看时较难理解，因此我在本文「主要方法」以及「类的实现代码」中提供了详细注释，请读者务必仔细阅读。</p><p><img src="https://pic.leetcode-cn.com/1660707113-IQMlgo-image.png" alt="image.png"></p><br /><h4 id="伸展树类架构"><a href="#伸展树类架构" class="headerlink" title="伸展树类架构"></a>伸展树类架构</h4><p>以下是伸展树 SplayTree 架构。</p><table><thead><tr><th>类成员&#x2F;方法</th><th>描述</th></tr></thead><tbody><tr><td><code>private BinaryNode&lt;E&gt; root</code></td><td>字段，splay树的根结点</td></tr><tr><td><code>private BinaryNode&lt;E&gt; newNode</code></td><td>字段，插入结点</td></tr><tr><td><code>private BinaryNode&lt;E&gt; nullNode</code></td><td>字段，为方便编程而设置的 $null$ 结点</td></tr><tr><td><code>public SplayTree()</code></td><td>构造器</td></tr><tr><td><code>public void makeEmpty()</code></td><td>树置空</td></tr><tr><td><code>public boolean isEmpty()</code></td><td>树判空</td></tr><tr><td><code>public void insert(E e)</code></td><td>插入结点方法</td></tr><tr><td><code>public void remove(E e)</code></td><td>删除结点方法</td></tr><tr><td><code>public E findMin()</code></td><td>查找最小结点驱动方法</td></tr><tr><td><code>public E findMax()</code></td><td>查找最大结点驱动方法</td></tr><tr><td><code>public boolean contains(E e)</code></td><td>判断是否包含指定元素方法</td></tr><tr><td><code>public void printTree()</code></td><td>按中序遍历打印树的驱动方法</td></tr><tr><td><code>public int size()</code></td><td>求树的结点个数驱动方法</td></tr><tr><td><code>private BinaryNode&lt;E&gt; splay(E e, BinaryNode&lt;E&gt; t)</code></td><td>展开方法</td></tr><tr><td><code>private BinaryNode&lt;E&gt; findMin(BinaryNode&lt;E&gt; t)</code></td><td>返回树的最小结点</td></tr><tr><td><code>private BinaryNode&lt;E&gt; findMax(BinaryNode&lt;E&gt; t)</code></td><td>返回树的最大结点</td></tr><tr><td><code>private void printTree(BinaryNode&lt;E&gt; t)</code></td><td>中序遍历打印树</td></tr><tr><td><code>private int size(BinaryNode&lt;E&gt; t)</code></td><td>递归地遍历所有结点，返回结点总数</td></tr><tr><td><code>private BinaryNode&lt;E&gt; rotateRight(BinaryNode&lt;E&gt; k2)</code></td><td>右单旋转</td></tr><tr><td><code>private BinaryNode&lt;E&gt; rotateLeft(BinaryNode&lt;E&gt; k1)</code></td><td>左单旋转</td></tr></tbody></table><p>以下是二叉树结点嵌套类 BinaryNode 的架构。</p><table><thead><tr><th>类成员&#x2F;方法</th><th>描述</th></tr></thead><tbody><tr><td><code>public E element</code></td><td>字段，本结点数据</td></tr><tr><td><code>public BinaryNode&lt;E&gt; left</code></td><td>字段，本结点的左子结点</td></tr><tr><td><code>public BinaryNode&lt;E&gt; right</code></td><td>字段，本结点的右子结点</td></tr><tr><td><code>public BinaryNode()</code></td><td>构造器</td></tr><tr><td><code>public BinaryNode(E element)</code></td><td>构造器</td></tr><tr><td><code>public BinaryNode(E element, BinaryNode&lt;E&gt; left, BinaryNode&lt;E&gt; right)</code></td><td>构造器</td></tr></tbody></table><br /><h4 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h4><h5 id="splay"><a href="#splay" class="headerlink" title="splay"></a>splay</h5><p>展开。伸展树中最主要的操作，传入目标结点值 $e$ 和当前根结点 $t$ (中间树 $M$ 的根结点) ， <strong>在寻找目标结点的过程中完成展开</strong> 。首先新建树 $L$ 与树 $R$，初始为空树，方法中并不直接声明这两棵树，而是通过 $header, leftTreeMax, rightTreeMin$ 来动态维护。动态维护主要体现在 $L$ 中的 $leftTreeMax$ 以及 $R$ 中的 $rightTreeMin$ ，一开始令此二者为 $header$ ，该变量仅用于保存 $L$ 和 $R$ 初次不为空树时的根结点，用于最后 $M, L, R$ 的组装。如其名，在方法的整个过程中，此二者始终代表 $L$ 中最大结点以及 $R$ 中最小结点。</p><blockquote><p>首次执行 <code>rightTreeMin.left = t</code> 时，即 <code>header.left = t</code> ，且此后 <code>header.left</code> 引用不变， <code>leftTreeMax.right = t</code> 同理。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> BinaryNode&lt;E&gt; <span class="title function_">splay</span><span class="params">(E e, BinaryNode&lt;E&gt; t)</span> &#123; <span class="comment">// 自顶向下展开目标结点</span></span><br><span class="line">    BinaryNode&lt;E&gt; leftTreeMax, rightTreeMin;</span><br><span class="line">    header.left = header.right = nullNode;</span><br><span class="line">    leftTreeMax = rightTreeMin = header;</span><br><span class="line">    nullNode.element = e;   <span class="comment">// 确保能够匹配，便于编程</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">compareRes</span> <span class="operator">=</span> e.compareTo(t.element);</span><br><span class="line">        <span class="keyword">if</span>(compareRes &lt; <span class="number">0</span>) &#123; <span class="comment">// 目标在t的左子树中</span></span><br><span class="line">            <span class="keyword">if</span>(e.compareTo(t.left.element) &lt; <span class="number">0</span>) t = rotateRight(t); <span class="comment">// 一字型右旋(右单旋)</span></span><br><span class="line">            <span class="keyword">if</span>(t.left == nullNode) <span class="keyword">break</span>; <span class="comment">// t无左儿子，已完成一次单旋(包括之字形)，跳出循环</span></span><br><span class="line">            rightTreeMin.left = t; <span class="comment">// 挂接到R下，同时保存R首次不为空时的根，且此后head.left不变</span></span><br><span class="line">            rightTreeMin = t; <span class="comment">// 更新rightTreeMin</span></span><br><span class="line">            t = t.left; <span class="comment">// 令t.left为中间树M的根结点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(compareRes &gt; <span class="number">0</span>) &#123; <span class="comment">// 目标在t的右子树中</span></span><br><span class="line">            <span class="keyword">if</span>(e.compareTo(t.right.element) &gt; <span class="number">0</span>) t = rotateLeft(t); <span class="comment">// 一字型左旋(左单旋)</span></span><br><span class="line">            <span class="keyword">if</span>(t.right == nullNode) <span class="keyword">break</span>; <span class="comment">// t无右儿子，已完成一次单旋(包括之字形)，跳出循环</span></span><br><span class="line">            leftTreeMax.right = t; <span class="comment">// 挂接到L下，同时保存了L首次不为空时的根，且此后head.right不变</span></span><br><span class="line">            leftTreeMax = t; <span class="comment">// 更新leftTreeMax</span></span><br><span class="line">            t = t.right; <span class="comment">// 令t.right为中间树M的根结点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>; <span class="comment">// 相等即可退出</span></span><br><span class="line">    &#125; <span class="comment">// 后续四句完成组装</span></span><br><span class="line">    leftTreeMax.right = t.left;</span><br><span class="line">    rightTreeMin.left = t.right;</span><br><span class="line">    t.left = header.right; <span class="comment">// header.right为L的根</span></span><br><span class="line">    t.right = header.left; <span class="comment">// header.left为R的根</span></span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h5 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h5><p>插入值为 $e$ 的结点。当前树空时，将待插入的结点作为根结点，否则 <strong>将目标结点旋转至根处</strong> ，再根据该结点值与 $e$ 的大小调整链接关系。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(E e)</span> &#123; <span class="comment">// 插入结点</span></span><br><span class="line">    <span class="keyword">if</span>(newNode == <span class="literal">null</span>) newNode = <span class="keyword">new</span> <span class="title class_">BinaryNode</span>&lt;&gt;(e);</span><br><span class="line">    <span class="keyword">if</span>(root == nullNode) &#123; <span class="comment">// 当前为空树，将newNode作为root插入</span></span><br><span class="line">        newNode.left = newNode.right = nullNode;</span><br><span class="line">        root = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">// 否则将目标结点旋转至根处，比较大小后插入</span></span><br><span class="line">        root = splay(e, root);</span><br><span class="line">        <span class="type">int</span> <span class="variable">compareRes</span> <span class="operator">=</span> e.compareTo(root.element);</span><br><span class="line">        <span class="keyword">if</span>(compareRes &lt; <span class="number">0</span>) &#123; <span class="comment">// e小于root的值，将newNode作为根插入</span></span><br><span class="line">            newNode.left = root.left;</span><br><span class="line">            newNode.right = root;</span><br><span class="line">            root.left = nullNode;</span><br><span class="line">            root = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(compareRes &gt; <span class="number">0</span>) &#123; <span class="comment">// e大于root的值，将newNode作为根插入</span></span><br><span class="line">            newNode.right = root.right;</span><br><span class="line">            newNode.left = root;</span><br><span class="line">            root.right = nullNode;</span><br><span class="line">            root = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span>; <span class="comment">// 相等时不插入</span></span><br><span class="line">    &#125;</span><br><span class="line">    newNode = <span class="literal">null</span>; <span class="comment">// 下一次插入时newNode == null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h5 id="findMin-x2F-findMax"><a href="#findMin-x2F-findMax" class="headerlink" title="findMin&#x2F;findMax"></a>findMin&#x2F;findMax</h5><p>查找具有最小&#x2F;最大数据的结点的操作由驱动方法和具体方法实现。与 AVL 树中对应方法的不同仅在于此处的具体方法在找到目标结点后要对其执行一次 $splay$ 操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">findMin</span><span class="params">()</span> &#123; <span class="comment">// 查找最小结点驱动方法</span></span><br><span class="line">    <span class="keyword">if</span>(isEmpty()) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">    <span class="keyword">return</span> findMin(root).element;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> BinaryNode&lt;E&gt; <span class="title function_">findMin</span><span class="params">(BinaryNode&lt;E&gt; t)</span> &#123; <span class="comment">// 返回树的最小结点</span></span><br><span class="line">    <span class="keyword">while</span>(t.left != nullNode) t = t.left;</span><br><span class="line">    root = splay(t.element, root);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">findMax</span><span class="params">()</span> &#123; <span class="comment">// 查找最大结点驱动方法</span></span><br><span class="line">    <span class="keyword">if</span>(isEmpty()) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">    <span class="keyword">return</span> findMax(root).element;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> BinaryNode&lt;E&gt; <span class="title function_">findMax</span><span class="params">(BinaryNode&lt;E&gt; t)</span> &#123; <span class="comment">// 返回树的最大结点</span></span><br><span class="line">    <span class="keyword">while</span>(t.right != nullNode) t = t.right;</span><br><span class="line">    root = splay(t.element, root);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h5 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h5><p>调用 $contains$ 方法查找是否存在值为 $e$ 的结点，若不存在直接返回，若存在则通过 $contains$ 方法，已将该结点展开为根结点，根据此时 $root$ 有无左儿子来执行具体的删除动作。若无左儿子，可直接删除 $root$ ，即让删除后的根结点为 $root.right$ ，否则通过 <code>splay(e, newRoot)</code> 将此时根的左子树中具有最大值的根结点 (必小于 $e$) 展开至 $newRoot$ ，以其为删除后的根结点，并执行 <code>newRoot.right = root.right</code> 。此删除为 <strong>懒惰删除</strong> ，即只改变链接关系来达到删除的效果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(E e)</span> &#123; <span class="comment">// 删除结点</span></span><br><span class="line">    <span class="keyword">if</span>(!contains(e)) <span class="keyword">return</span>; <span class="comment">// 不存在直接返回，若存在，则该目标结点已被展开至根</span></span><br><span class="line">    BinaryNode&lt;E&gt; newRoot;</span><br><span class="line">    <span class="keyword">if</span>(root.left == nullNode) newRoot = root.right; <span class="comment">// 无左儿子，直接删除(懒惰删除)</span></span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">// 有左儿子</span></span><br><span class="line">        newRoot = root.left;</span><br><span class="line">        newRoot = splay(e, newRoot); <span class="comment">// 将左子树中最大者旋转至根，令其为删除操作后的新根</span></span><br><span class="line">        newRoot.right = root.right; <span class="comment">// 将root.right接到newTree.right上</span></span><br><span class="line">    &#125;</span><br><span class="line">    root = newRoot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h5 id="contains"><a href="#contains" class="headerlink" title="contains"></a>contains</h5><p>若为空树直接返回 $false$ ，否则以值为 $e$ 的结点为目标执行 $splay$ ，最后根据 $splay$ 的目标结点值是否等于 $e$ 来返回 $true$ 或 $false$ 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(E e)</span> &#123; <span class="comment">// 判断树中是否有指定元素的结点</span></span><br><span class="line">    <span class="keyword">if</span>(isEmpty()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    root = splay(e, root);</span><br><span class="line">    <span class="keyword">return</span> root.element.compareTo(e) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h5 id="rotateRight"><a href="#rotateRight" class="headerlink" title="rotateRight"></a>rotateRight</h5><p>右单旋转，见前述说明。</p><br /><h5 id="rotateLeft"><a href="#rotateLeft" class="headerlink" title="rotateLeft"></a>rotateLeft</h5><p>左单旋转，见前述说明。</p><br /><h4 id="类的实现代码"><a href="#类的实现代码" class="headerlink" title="类的实现代码"></a>类的实现代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SplayTree</span>&lt;E <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;? <span class="built_in">super</span> E&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> BinaryNode&lt;E&gt; root, newNode;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BinaryNode&lt;E&gt; nullNode;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SplayTree</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.nullNode = <span class="keyword">new</span> <span class="title class_">BinaryNode</span>&lt;&gt;();</span><br><span class="line">        <span class="built_in">this</span>.root = <span class="built_in">this</span>.nullNode.left = <span class="built_in">this</span>.nullNode.right = <span class="built_in">this</span>.nullNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(E e)</span> &#123; <span class="comment">// 插入结点</span></span><br><span class="line">        <span class="keyword">if</span>(newNode == <span class="literal">null</span>) newNode = <span class="keyword">new</span> <span class="title class_">BinaryNode</span>&lt;&gt;(e);</span><br><span class="line">        <span class="keyword">if</span>(root == nullNode) &#123; <span class="comment">// 当前为空树，将newNode作为root插入</span></span><br><span class="line">            newNode.left = newNode.right = nullNode;</span><br><span class="line">            root = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// 否则将目标结点旋转至根处，比较大小后插入</span></span><br><span class="line">            root = splay(e, root);</span><br><span class="line">            <span class="type">int</span> <span class="variable">compareRes</span> <span class="operator">=</span> e.compareTo(root.element);</span><br><span class="line">            <span class="keyword">if</span>(compareRes &lt; <span class="number">0</span>) &#123; <span class="comment">// e小于root的值，将newNode作为根插入</span></span><br><span class="line">                newNode.left = root.left;</span><br><span class="line">                newNode.right = root;</span><br><span class="line">                root.left = nullNode;</span><br><span class="line">                root = newNode;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(compareRes &gt; <span class="number">0</span>) &#123; <span class="comment">// e大于root的值，将newNode作为根插入</span></span><br><span class="line">                newNode.right = root.right;</span><br><span class="line">                newNode.left = root;</span><br><span class="line">                root.right = nullNode;</span><br><span class="line">                root = newNode;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span>; <span class="comment">// 相等时不插入</span></span><br><span class="line">        &#125;</span><br><span class="line">        newNode = <span class="literal">null</span>; <span class="comment">// 下一次插入时newNode == null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(E e)</span> &#123; <span class="comment">// 删除结点</span></span><br><span class="line">        <span class="keyword">if</span>(!contains(e)) <span class="keyword">return</span>; <span class="comment">// 不存在直接返回，若存在，则该目标结点已被展开至根</span></span><br><span class="line">        BinaryNode&lt;E&gt; newRoot;</span><br><span class="line">        <span class="keyword">if</span>(root.left == nullNode) newRoot = root.right; <span class="comment">// 无左结点，直接删除(懒惰删除)</span></span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// 有左结点</span></span><br><span class="line">            newRoot = root.left;</span><br><span class="line">            newRoot = splay(e, newRoot); <span class="comment">// 将左子树中最大者旋转至根，令其为删除操作后的新根</span></span><br><span class="line">            newRoot.right = root.right; <span class="comment">// 将root.right接到newTree.right上</span></span><br><span class="line">        &#125;</span><br><span class="line">        root = newRoot;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">findMin</span><span class="params">()</span> &#123; <span class="comment">// 查找最小结点驱动方法</span></span><br><span class="line">        <span class="keyword">if</span>(isEmpty()) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">        <span class="keyword">return</span> findMin(root).element;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">findMax</span><span class="params">()</span> &#123; <span class="comment">// 查找最大结点驱动方法</span></span><br><span class="line">        <span class="keyword">if</span>(isEmpty()) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">        <span class="keyword">return</span> findMax(root).element;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(E e)</span> &#123; <span class="comment">// 判断树中是否有指定元素的结点</span></span><br><span class="line">        <span class="keyword">if</span>(isEmpty()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        root = splay(e, root);</span><br><span class="line">        <span class="keyword">return</span> root.element.compareTo(e) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printTree</span><span class="params">()</span>&#123; <span class="comment">// 按中序遍历打印树的驱动方法</span></span><br><span class="line">        <span class="keyword">if</span>(isEmpty()) System.out.println(<span class="string">&quot;Empty tree&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> printTree(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123; <span class="comment">// 求树的结点个数驱动方法</span></span><br><span class="line">        <span class="keyword">return</span> size(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeEmpty</span><span class="params">()</span> &#123; <span class="comment">// 树置空</span></span><br><span class="line">        root = nullNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123; <span class="comment">// 树判空</span></span><br><span class="line">        <span class="keyword">return</span> root == nullNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BinaryNode&lt;E&gt; header = <span class="keyword">new</span> <span class="title class_">BinaryNode</span>&lt;&gt;(<span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">private</span> BinaryNode&lt;E&gt; <span class="title function_">splay</span><span class="params">(E e, BinaryNode&lt;E&gt; t)</span> &#123; <span class="comment">// 自顶向下展开目标结点</span></span><br><span class="line">        BinaryNode&lt;E&gt; leftTreeMax, rightTreeMin;</span><br><span class="line">        header.left = header.right = nullNode;</span><br><span class="line">        leftTreeMax = rightTreeMin = header;</span><br><span class="line">        nullNode.element = e;   <span class="comment">// 确保能够匹配，便于编程</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">compareRes</span> <span class="operator">=</span> e.compareTo(t.element);</span><br><span class="line">            <span class="keyword">if</span>(compareRes &lt; <span class="number">0</span>) &#123; <span class="comment">// 目标在t的左子树中</span></span><br><span class="line">                <span class="keyword">if</span>(e.compareTo(t.left.element) &lt; <span class="number">0</span>) t = rotateRight(t); <span class="comment">// 一字型右旋</span></span><br><span class="line">                <span class="keyword">if</span>(t.left == nullNode) <span class="keyword">break</span>; <span class="comment">// t无左儿子，已完成一次单旋(包括之字形)，跳出循环</span></span><br><span class="line">                rightTreeMin.left = t; <span class="comment">// 挂接到R下，同时保存R首次不为空时的根，且此后head.left不变</span></span><br><span class="line">                rightTreeMin = t; <span class="comment">// 更新rightTreeMin</span></span><br><span class="line">                t = t.left; <span class="comment">// 令t.left为中间树M的根结点</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(compareRes &gt; <span class="number">0</span>) &#123; <span class="comment">// 目标在t的右子树中</span></span><br><span class="line">                <span class="keyword">if</span>(e.compareTo(t.right.element) &gt; <span class="number">0</span>) t = rotateLeft(t); <span class="comment">// 一字型左旋</span></span><br><span class="line">                <span class="keyword">if</span>(t.right == nullNode) <span class="keyword">break</span>; <span class="comment">// t无右儿子，已完成一次单旋(包括之字形)，跳出循环</span></span><br><span class="line">                leftTreeMax.right = t; <span class="comment">// 挂接到L下，同时保存了L首次不为空时的根，且此后head.right不变</span></span><br><span class="line">                leftTreeMax = t; <span class="comment">// 更新leftTreeMax</span></span><br><span class="line">                t = t.right; <span class="comment">// 令t.right为中间树M的根结点</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>; <span class="comment">// 相等即可退出</span></span><br><span class="line">        &#125; <span class="comment">// 后续四句完成组装</span></span><br><span class="line">        leftTreeMax.right = t.left;</span><br><span class="line">        rightTreeMin.left = t.right;</span><br><span class="line">        t.left = header.right; <span class="comment">// header.right为L的根</span></span><br><span class="line">        t.right = header.left; <span class="comment">// header.left为R的根</span></span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> BinaryNode&lt;E&gt; <span class="title function_">rotateRight</span><span class="params">(BinaryNode&lt;E&gt; k2)</span>&#123; <span class="comment">// 右单旋</span></span><br><span class="line">        BinaryNode&lt;E&gt; k1 = k2.left;</span><br><span class="line">        k2.left = k1.right;</span><br><span class="line">        k1.right = k2;</span><br><span class="line">        <span class="keyword">return</span> k1; <span class="comment">// 返回调整后原失衡处结点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> BinaryNode&lt;E&gt; <span class="title function_">rotateLeft</span><span class="params">(BinaryNode&lt;E&gt; k1)</span>&#123; <span class="comment">// 左单旋</span></span><br><span class="line">        BinaryNode&lt;E&gt; k2 = k1.right;</span><br><span class="line">        k1.right = k2.left;</span><br><span class="line">        k2.left = k1;</span><br><span class="line">        <span class="keyword">return</span> k2; <span class="comment">// 返回调整后原失衡处结点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> BinaryNode&lt;E&gt; <span class="title function_">findMin</span><span class="params">(BinaryNode&lt;E&gt; t)</span> &#123; <span class="comment">// 返回树的最小结点</span></span><br><span class="line">        <span class="keyword">while</span>(t.left != nullNode) t = t.left;</span><br><span class="line">        root = splay(t.element, root);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> BinaryNode&lt;E&gt; <span class="title function_">findMax</span><span class="params">(BinaryNode&lt;E&gt; t)</span> &#123; <span class="comment">// 返回树的最大结点</span></span><br><span class="line">        <span class="keyword">while</span>(t.right != nullNode) t = t.right;</span><br><span class="line">        root = splay(t.element, root);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printTree</span><span class="params">(BinaryNode&lt;E&gt; t)</span> &#123; <span class="comment">// 中序遍历打印树</span></span><br><span class="line">        <span class="keyword">if</span>(t != nullNode) &#123;</span><br><span class="line">            printTree(t.left);</span><br><span class="line">            System.out.println(t.element);</span><br><span class="line">            printTree(t.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">(BinaryNode&lt;E&gt; t)</span> &#123; <span class="comment">// 递归地遍历所有结点，返回结点总数</span></span><br><span class="line">        <span class="keyword">if</span>(t != nullNode) &#123;</span><br><span class="line">            <span class="keyword">if</span>(t.left != nullNode &amp;&amp; t.right != nullNode) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span> + size(t.left) + size(t.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> t.left != nullNode ? <span class="number">1</span> + size(t.left) : <span class="number">1</span> + size(t.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 二叉树结点嵌套类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">BinaryNode</span>&lt;E&gt;&#123;</span><br><span class="line">        <span class="keyword">public</span> E element;</span><br><span class="line">        <span class="keyword">public</span> BinaryNode&lt;E&gt; left, right;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unused&quot;)</span></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">BinaryNode</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>(<span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">BinaryNode</span><span class="params">(E element)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>(element, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">BinaryNode</span><span class="params">(E element, BinaryNode&lt;E&gt; left, BinaryNode&lt;E&gt; right)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.element = element;</span><br><span class="line">            <span class="built_in">this</span>.left = left;</span><br><span class="line">            <span class="built_in">this</span>.right = right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h4 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukiyama;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.NoSuchElementException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SplayTreeDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SplayTree&lt;Integer&gt; t = <span class="keyword">new</span> <span class="title class_">SplayTree</span>&lt;&gt;( );</span><br><span class="line">        <span class="type">int</span>[] elements = &#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">16</span>,<span class="number">15</span>,<span class="number">14</span>,<span class="number">13</span>,<span class="number">12</span>,<span class="number">11</span>,<span class="number">10</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> e : elements) t.insert(e);</span><br><span class="line">        t.printTree();</span><br><span class="line">        System.out.printf(<span class="string">&quot;size: %d, min: %d, max: %d\n&quot;</span>, t.size(), t.findMin(), t.findMax()); <span class="comment">// 输出10</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;has 10? %s, has 100? %s\n&quot;</span>, t.contains(<span class="number">10</span>), t.contains(<span class="number">100</span>));</span><br><span class="line">        t.remove(<span class="number">1</span>);</span><br><span class="line">        t.remove(<span class="number">10</span>);</span><br><span class="line">        t.remove(<span class="number">16</span>);</span><br><span class="line">        t.printTree();</span><br><span class="line">        System.out.printf(<span class="string">&quot;size: %d\n&quot;</span>, t.size());<span class="comment">// 输出0</span></span><br><span class="line">        System.out.println(<span class="string">&quot;is empty: &quot;</span> + t.isEmpty()); <span class="comment">// false</span></span><br><span class="line">        t.makeEmpty();</span><br><span class="line">        System.out.println(<span class="string">&quot;is empty: &quot;</span> + t.isEmpty()); <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br />]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> splay树 </tag>
            
            <tag> 平衡二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AVL树</title>
      <link href="/2022/08/17/AVL%E6%A0%91/"/>
      <url>/2022/08/17/AVL%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="AVL树-树ADT连载-4-x2F-13"><a href="#AVL树-树ADT连载-4-x2F-13" class="headerlink" title="AVL树 (树ADT连载 4&#x2F;13)"></a>AVL树 (树ADT连载 4&#x2F;13)</h1><blockquote><ul><li><p>可在作者的 <a href="https://github.com/iyukiyama/leetcode-posts">github仓库</a> 中获取本文和其他文章的 markdown 源文件及相关代码。</p></li><li><p>欢迎评论或仓库 PR 指出文章错漏或与我讨论相关问题，我将长期维护所有文章。</p></li><li><p>所有文章均用 Typora 完成写作，可使用 Typora 打开文章 md 文件，以获得最佳阅读体验。</p></li></ul></blockquote><p>🌲🌲🌲 <strong>一起手写一棵完整的 AVL 树。</strong></p><p>❗️ <strong>【NEW】</strong> ❗️</p><ul><li>9-15:  <a href="https://leetcode.cn/circle/discuss/SwgIJV/">红黑树从入门到看开</a></li></ul><p>这是小白 yuki 推出的「树ADT」系列文章的第 4 篇 (4&#x2F;13) 。</p><hr><blockquote><p>$keywords$ :</p><p>AVL树 &#x2F; 单旋转与双旋转 &#x2F; 绝对平衡</p></blockquote><p>本文介绍一种最早提出的自平衡二叉查找树 –– AVL树。本文重点在于展现如何设计一个AVL树类，分析主要方法的代码实现，并给出该类的完整实现代码。期待读者学习之后 <strong>能够自己写出一个方法较为完备的AVL树类</strong> 。</p><hr><p>yuki的其他文章如下，欢迎阅读指正！</p><blockquote><p>如下所有文章同时也在我的 github <a href="https://github.com/iyukiyama/leetcode-posts">仓库</a> 中维护。</p></blockquote><table><thead><tr><th>文章</th><th>[发布时间] 字数&#x2F;览&#x2F;藏&#x2F;赞 (~2022-10-20)</th></tr></thead><tbody><tr><td><a href="https://leetcode.cn/circle/discuss/eBo9UB/">十大排序从入门到入赘</a>  🔥🔥🔥</td><td>[20220516]  2.5万字&#x2F;64.8k览&#x2F;3.7k藏&#x2F;937赞</td></tr><tr><td><a href="https://leetcode.cn/circle/discuss/ooxfo8/">二分查找从入门到入睡</a> 🔥🔥🔥</td><td>[20220509]  2.3万字&#x2F;38.4k览&#x2F;2.1k藏&#x2F;503赞</td></tr><tr><td><a href="https://leetcode.cn/circle/discuss/qmjuMW/">并查集从入门到出门</a> 🔥🔥</td><td>[20220514]  1.2万字&#x2F;17.9k览&#x2F;1.0k藏&#x2F;321赞</td></tr><tr><td><a href="https://leetcode.cn/circle/discuss/FyPTTM/">图论算法从入门到放下</a> 🔥🔥</td><td>[20220617]  5.6万字&#x2F;19.9k览&#x2F;1.3k藏&#x2F;365赞</td></tr><tr><td>树ADT系列 (预计13篇)</td><td>系列文章，连载中</td></tr><tr><td>3. <a href="https://leetcode.cn/circle/discuss/wPzlSb/">二叉查找树</a></td><td>[20220801]  5千字</td></tr><tr><td>4. <a href="https://leetcode.cn/circle/discuss/zbwD3p/">AVL树</a></td><td>[20220817]  5千字</td></tr><tr><td>5. <a href="https://leetcode.cn/circle/discuss/BCK17f/">splay树</a></td><td>[20220817]  5千字</td></tr><tr><td>6. <a href="https://leetcode.cn/circle/discuss/SwgIJV/">红黑树从入门到看开</a> 🔥🤯🤯🤯</td><td>[20220915]  3万字&#x2F;5.3k览&#x2F;269藏&#x2F;72赞</td></tr><tr><td>10. <a href="https://leetcode.cn/circle/discuss/qGREiN/">树状数组从入门到下车</a> 🔥🤯</td><td>[20220722]  1.4万字&#x2F;5.8k览&#x2F;196藏&#x2F;72赞</td></tr><tr><td>11. <a href="https://leetcode.cn/circle/discuss/H4aMOn/">线段树从入门到急停</a> 🔥🤯</td><td>[20220726]  2.5万字&#x2F;8.7k览&#x2F;481藏&#x2F;138赞</td></tr><tr><td><a href="https://leetcode.cn/circle/discuss/GV0JrV/">图论相关证明系列</a></td><td>系列文章</td></tr><tr><td>1. <a href="https://leetcode.cn/circle/discuss/jJQn7V/">Dijkstra正确性证明</a> 🤯</td><td>[20220531]</td></tr><tr><td>2. <a href="https://leetcode.cn/circle/discuss/VVEc8f/">Prim正确性证明</a> 🤯</td><td>[20220919]</td></tr><tr><td>3. <a href="https://leetcode.cn/circle/discuss/xeEwYl/">Bellman-Ford及SPFA正确性证明</a></td><td>[20220602]</td></tr><tr><td>4. <a href="https://leetcode.cn/circle/discuss/Nbzix4/">Floyd正确性证明</a></td><td>[20220602]</td></tr><tr><td>5. <a href="https://leetcode.cn/circle/discuss/tMIy36/">最大流最小割定理证明</a> 🤯🤯</td><td>[20220719]</td></tr><tr><td>6. <a href="https://leetcode.cn/circle/discuss/tN3sZc/">Edmonds-Karp复杂度证明</a> 🤯🤯</td><td>[20220515]</td></tr><tr><td>7. <a href="https://leetcode.cn/circle/discuss/T9Xa1R/">Dinic复杂度证明</a> 🤯🤯</td><td>[20220531]</td></tr></tbody></table><hr><p>[2022-10-17]</p><ul><li>旋转后结点高度更新代码有误，<code>Math.max()</code> 取得左右子树中较高者的高度后还要加 1。感谢匿名用户提醒！🙏</li></ul><hr><p>[TOC]</p><hr><h3 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h3><p>对于二叉查找树的插入、删除、查找等操作，时间复杂度为 $O(logn)$ 的前提是 <strong>保持树的平衡</strong> ，即保持树的高度为 $logn$ 。在 <a href="https://leetcode.cn/circle/discuss/wPzlSb/">二叉查找树</a> 一文的删除结点的操作中，我们总是 <strong>删除目标结点右子树中的最小结点</strong> ，可以预见多次删除操作后将使树呈现 <strong>左高右低的倾向</strong> 。而一旦树不平衡，插入、删除、查找等操作将无法达到 $O(logn)$ 的复杂度，于是我们自然会想如何在多次删除操作后，树总能够保持平衡。若一棵 BST 在操作后总能保持平衡，我们称其为 <strong>平衡 BST</strong> 。 <strong>AVL 树是最早提出的自平衡二叉查找树</strong> 。</p><p>AVL 树以 <strong>「旋转 (rotation)」</strong> 操作保证 <strong>任意结点的左右子树高度差不超过 1</strong>，使得树的深度总保持为 $O(logn)$ 。下图左侧的树是 AVL 树，右侧的树则不是 AVL 树，在结点 7 处失衡。</p><p><img src="https://pic.leetcode-cn.com/1656841310-TPLbDJ-image.png" alt="image.png"></p><blockquote><p>AVL (Adelson-Velsky and Landis Tree) 树由 G.M. Adelson-Velsky 和E.M. Landis于1962年的 <a href="https://zhjwpku.com/assets/pdf/AED2-10-avl-paper.pdf">论文</a> 中首次介绍。</p><p>文本内容为 Mark Allen Weiss 所著 <a href="https://awesome-programming-books.github.io/algorithms/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9AJava%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0.pdf">数据结构与算法分析：Java语言描述</a> 相关章节的整理和总结。代码亦来自该书，略作改动。</p></blockquote><br /><h4 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h4><p>在上图 AVL 树中插入 6 时， 6 将作为 7 的左子结点被插入，这将破坏结点 8 的平衡 (8的左子树与其右子树高差为 2)。AVL 树通过旋转操作能够恢复失衡结点的平衡，本节详细讲解此操作的细节。</p><p>考虑插入一个结点 $x$ 后，平衡被破坏的结点 $y1, y2,…$ ，这些结点只可能在 $x$ 到根结点路径上，因此 <strong>只需沿着此路径恢复平衡即可</strong> 。更进一步地，不难证明，只需在第一个平衡被破坏的结点 $y$ （ $x$ 到根结点方向）上重新平衡这棵树，即能保证整棵树恢复为 AVL 树。</p><p>插入情况必为如下四情形种之一：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">情形1(左-左): 插入点在 y 的左儿子的左子树</span><br><span class="line">情形2(左-右): 插入点在 y 的左儿子的右子树</span><br><span class="line">情形3(右-左): 插入点在 y 的右儿子的左子树</span><br><span class="line">情形4(右-右): 插入点在 y 的右儿子的右子树</span><br></pre></td></tr></table></figure><p>其中 1 和 4，2 和 3 关于 $y$ 镜像对称，所以实际只有两种情况，但从编程角度来看需要分别处理这四种情形。对于发生在外侧的情况 (左-左，右-右) ，需要通过 <strong>单旋转</strong> 恢复平衡，对于发生在内侧的情况 (左-右，右-左) ，需要通过 <strong>双旋转</strong> 恢复平衡。</p><blockquote><p>许多资料将本节介绍的左单旋、右单旋、左右双旋、右左双旋分别称作 zag, zig, zag-zig, zig-zag 操作。zig 和 zag 原意并无左右之分，为了避免歧义，本文不采用这种称呼，读者只需了解即可。在「伸展树」一节中还会有「一字型」的左左双旋和右右双旋，分别被称为 zag-zag 和 zig-zig ，也仅需了解即可。</p></blockquote><br /><h5 id="单旋转"><a href="#单旋转" class="headerlink" title="单旋转"></a><strong>单旋转</strong></h5><p><strong>右单旋转 (情形1)：</strong> 如下，左侧的树是在 $k2$ 的左儿子 $k_1$ 的左子树中插入结点后导致 $k2$ 失去平衡 ( $k2$ 左子树比右子树深 2 层)。</p><p><img src="https://pic.leetcode-cn.com/1660706050-mewSNE-image.png" alt="image.png"></p><p>上左图中 $X$ , $Y$ , $Z$ 的高度如此表现的依据： $Y$ 不可能与当前的 $X$ 在同一水平上，否则在插入前即失衡。$Y$ 也不可能与 $Z$ 在同一水平上，否则插入后先失衡的是 $k1$（在插入结点通往根路上第一个失衡）。</p><p>单旋转操作方法：</p><p>在失衡结点 $k2$ 和其左子结点 $k1$ 之间旋转。如图，核心操作为 <code>k2.left = k1.right</code>，<code>k1.right = k2</code> ，可以形象地描述为将 $k1$ 提起，$k_2$ 下沉的同时 $Y$ 被抖落到 $k2$ 的左侧。旋转方向为右侧，即顺时针方向，且只有一次旋转操作，因此称为 <strong>右单旋转</strong> 。旋转后以 $k2$ 和 $k1$ 为根结点的树的高度也需要实时调整（ $height$ 是 $AvlNode$ 类的属性）。如下是该左-左单旋转的代码实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> AvlNode&lt;E&gt; <span class="title function_">rotateRight</span><span class="params">(AvlNode&lt;E&gt; k2)</span>&#123; <span class="comment">// 传入失衡结点</span></span><br><span class="line">    AvlNode&lt;E&gt; k1 = k2.left;</span><br><span class="line">    k2.left = k1.right;</span><br><span class="line">    k1.right = k2;</span><br><span class="line">    k2.height = Math.max(height(k2.left), height(k2.right)) + <span class="number">1</span>; <span class="comment">// 调整k2高度</span></span><br><span class="line">    k1.height = Math.max(height(k1.left), height(k1.right)) + <span class="number">1</span>; <span class="comment">// 调整k1高度</span></span><br><span class="line">    <span class="keyword">return</span> k1; <span class="comment">// 返回调整后原失衡处结点 (已变为 k1)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 如图调整，将 $k1$ 作为调整后树的根结点，$X$ 上移 1 层，$Y$ 深度不变，$Z$ 下移 1 层，调整后 $XYZ$ 深度相同，树高度恢复为插入前的高度。</p><br /><p><strong>左单旋转(情形4)：</strong> 如下，左侧的树在 $k1$ 的右儿子 $k_2$ 的右子树中插入结点后导致 $k1$ 失去平衡 ( $k1$ 右子树比左子树深 2 层)。</p><p><img src="https://pic.leetcode-cn.com/1660706134-YyTUbp-image.png" alt="image.png"></p><p>恢复平衡的旋转操作与左-左单旋转类似，核心操作为 <code>k1.right = k2.left</code>，<code>k2.left = k1</code> 。旋转方向为左侧，即逆时针方向，且只有一次旋转操作，因此称为 <strong>左单旋转</strong> 。以下给出右-右单旋转的代码实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> AvlNode&lt;E&gt; <span class="title function_">rotateLeft</span><span class="params">(AvlNode&lt;E&gt; k1)</span>&#123; <span class="comment">// 传入失衡结点</span></span><br><span class="line">    AvlNode&lt;E&gt; k2 = k1.right;</span><br><span class="line">    k1.right = k2.left;</span><br><span class="line">    k2.left = k1;</span><br><span class="line">    <span class="comment">// 调整平衡后更新k1，k2的高度</span></span><br><span class="line">    k1.height = Math.max(height(k1.left), height(k1.right)) + <span class="number">1</span>;</span><br><span class="line">    k2.height = Math.max(height(k2.left), height(k2.right)) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> k2; <span class="comment">// 返回调整后原失衡处结点 (已变为 k2)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h5 id="双旋转"><a href="#双旋转" class="headerlink" title="双旋转"></a><strong>双旋转</strong></h5><p><strong>左右双旋转(情形2)：</strong> 如下图左侧的树，在 $k2$ 的左儿子 $k1$ 的右子树中插入结点后导致 $k2$ 失衡 ( $k2$ 的左子树比右子树高 2)。</p><p>对于情形2和情形3，单旋转无法恢复平衡。如下图，执行一次单旋转后 $k1$ 的右子树比左子树高 2，平衡未恢复。恢复此情形的平衡需采用 <strong>「双旋转」</strong> 操作。</p><p><img src="https://pic.leetcode-cn.com/1660706178-nImvWX-image.png" alt="image.png"></p><p>双旋转操作方法：</p><p>将上述左-右失衡情形 (情形2) 表示为下图。导致失衡的结点插入位置为 $k1$ 的右子树，因此可以表示为 $k2$ 及其左右子树的结构。</p><p>如前述，单旋转将 $k1$ 作为根无效，因此考虑将 $k2$ 作为根，将 $k2$ 的左子树 $B$ 作为 $k1$ 的右子树，$k2$ 的右子树 $C$ 作 为$k3$ 的左子树。然后 $k2$ 的左右儿子分别更新为 $k1$ ， $k3$ 。如下图，平衡恢复。该双旋转实际上可以通过对 $k1$ 执行一次左单旋转，再对 $k3$ 执行一次右单旋转实现。可以看到代码实现十分简洁。</p><p><img src="https://pic.leetcode-cn.com/1660706235-cVYNSC-image.png" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 左右双旋</span></span><br><span class="line"><span class="comment"> * 因k2的左子结点的内侧子树，即k2的左子结点的右子树导致k2失衡。</span></span><br><span class="line"><span class="comment"> * 对k2执行一次右单旋转后仍然在k1处(新根)失衡，因此考虑展开一开始导致失衡的k1右子树，</span></span><br><span class="line"><span class="comment"> * 做如下转换(总是以中序遍历的顺序标注结点，注意k1,k2,k3位置变化)。</span></span><br><span class="line"><span class="comment"> * 因为不知道是B或C中的哪一棵导致失衡(比D深2层)，所以将B，C画成比D深1.5。</span></span><br><span class="line"><span class="comment"> * 依次执行如下两次单旋转后可恢复原失衡处的平衡。</span></span><br><span class="line"><span class="comment"> * 1. 对k1(k3.left)执行左单旋转。</span></span><br><span class="line"><span class="comment"> * 2. 对k3执行右单旋转。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *           k2                        k3</span></span><br><span class="line"><span class="comment"> *         /    \                    /     \</span></span><br><span class="line"><span class="comment"> *        k1     /\　  转换为        k1      /\</span></span><br><span class="line"><span class="comment"> *       /  \   /__\   ====&gt;      /   \    /__\</span></span><br><span class="line"><span class="comment"> *     /\    /\   Z             /\     k2    D</span></span><br><span class="line"><span class="comment"> *    /__\  /  \               /__\   /  \</span></span><br><span class="line"><span class="comment"> *     X   /    \               A   /\    /\</span></span><br><span class="line"><span class="comment"> *        /______\                 /  \  /  \</span></span><br><span class="line"><span class="comment"> *           Y                    /____\/____\　</span></span><br><span class="line"><span class="comment"> *                                  B      C</span></span><br><span class="line"><span class="comment"> *                         k3                                k2</span></span><br><span class="line"><span class="comment"> *                       /     \                         /        \</span></span><br><span class="line"><span class="comment"> *  对k1执行             k2      /\    对k3执行           K1          K3</span></span><br><span class="line"><span class="comment"> *  一次左单旋转         /    \  /__\   一次右单旋转      /    \       /  \</span></span><br><span class="line"><span class="comment"> *    =====&gt;         k1      /\  D    ====&gt;          /\    /\     /\   /\</span></span><br><span class="line"><span class="comment"> *                 /   \    /  \                    /__\  /　\   / 　\ /__\</span></span><br><span class="line"><span class="comment"> *                /\    /\ /____\                    A   /____\ /____\  D</span></span><br><span class="line"><span class="comment"> *               /__\  /  \  C                             B      C</span></span><br><span class="line"><span class="comment"> *　　　　         A   /____\　</span></span><br><span class="line"><span class="comment"> *                      B</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> AvlNode&lt;E&gt; <span class="title function_">rotateLeftRight</span><span class="params">(AvlNode&lt;E&gt; k3)</span>&#123; <span class="comment">// 传入失衡结点</span></span><br><span class="line">    k3.left = rotateLeft(k3.left);</span><br><span class="line">    <span class="keyword">return</span> rotateRight(k3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><p><strong>右-左双旋转(情形3)：</strong> 如下图左侧的树，在 $k_1$ 的右儿子 $k_3$ 的左子树中插入结点后导致 $k_1$ 失衡 ( $k_1$ 的右子树比左子树高 2)。</p><p><img src="https://pic.leetcode-cn.com/1660706286-OEwZUN-image.png" alt="image.png"></p><p>恢复平衡的旋转操作与左右双旋转类似，以下给出右左双旋转的代码实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> AvlNode&lt;E&gt; <span class="title function_">rotateRightLeft</span><span class="params">(AvlNode&lt;E&gt; k1)</span>&#123;</span><br><span class="line">    k1.right = rotateRight(k1.right);</span><br><span class="line">    <span class="keyword">return</span> rotateLeft(k1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h4 id="AVL树类架构"><a href="#AVL树类架构" class="headerlink" title="AVL树类架构"></a>AVL树类架构</h4><p>以下是AVL查找树类 <code>AvlTree</code> 的架构。</p><table><thead><tr><th>类成员&#x2F;方法</th><th>描述</th></tr></thead><tbody><tr><td><code>private AvlNode&lt;E&gt; root</code></td><td>字段，AVL树的根结点</td></tr><tr><td><code>private static final int ALLOWED_IMBALANCE = 1</code></td><td>常量字段，结点的失衡判定值，大于此值则失衡</td></tr><tr><td><code>public AvlTree()</code></td><td>无参构造器，$root$ 初始化为 $null$</td></tr><tr><td><code>public void makeEmpty()</code></td><td>树置空</td></tr><tr><td><code>public boolean isEmpty()</code></td><td>判断树是否为空</td></tr><tr><td><code>public void insert(E e)</code></td><td>插入结点驱动方法</td></tr><tr><td><code>public void remove(E e)</code></td><td>删除结点驱动方法</td></tr><tr><td><code>public E findMin()</code></td><td>查找最小结点驱动方法</td></tr><tr><td><code>public E findMax()</code></td><td>查找最大结点驱动方法</td></tr><tr><td><code>public boolean contains(E e)</code></td><td>判断是否包含指定元素驱动方法</td></tr><tr><td><code>public void printTree()</code></td><td>按中序遍历打印树的驱动方法</td></tr><tr><td><code>public int size()</code></td><td>求树的结点个数驱动方法</td></tr><tr><td><code>public int height()</code></td><td>求树的高度驱动方法</td></tr><tr><td><code>public void checkBalance()</code></td><td>树平衡检查驱动方法</td></tr><tr><td><code>private AvlNode&lt;E&gt; balance(AvlNode&lt;E&gt; t)</code></td><td>调整 $t$ 结点处的平衡，并返回 $t$ 。<br />如果 $t$ 失去平衡，根据其失衡的情况，执行如下四种情形之一的旋转调整。<br />左外情形，对 $t$ 执行右单旋转 $rotateRight$<br />左内情形，对 $t$ 执行左右双旋转 $rotateLeftRight$<br />右外情形，对 $t$ 执行左单旋转 $rotateLeft$<br />右内情形，对 $t$ 执行右左双旋转 $rotateRightLeft$</td></tr><tr><td><code>private AvlNode&lt;E&gt; insert(E e, AvlNode&lt;E&gt; t)</code></td><td>插入结点<br />与 BST 的不同在于返回时调用 $balance(t)$ ，<br />调整插入 $t$ 后 $t$ 处的平衡，返回 $t$ 。</td></tr><tr><td><code>private AvlNode&lt;E&gt; remove(E e, AvlNode&lt;E&gt; t)</code></td><td>删除结点(懒惰删除)<br />与 BST 的不同在于返回时调用 $balance(t)$ ，<br />调整删除 $t$ 后 $t$ 处的平衡，返回 $t$ (新 $t$ )。</td></tr><tr><td><code>private AvlNode&lt;E&gt; findMin(AvlNode&lt;E&gt; t)</code></td><td>返回树的最小结点</td></tr><tr><td><code>private AvlNode&lt;E&gt; findMax(AvlNode&lt;E&gt; t)</code></td><td>返回树的最大结点</td></tr><tr><td><code>private boolean contains(E e, AvlNode&lt;E&gt; t)</code></td><td>判断树中是否有指定元素的结点</td></tr><tr><td><code>private void printTree(AvlNode&lt;E&gt; t)</code></td><td>中序遍历打印树</td></tr><tr><td><code>private int height(AvlNode&lt;E&gt; t)</code></td><td>返回以 $t$ 为根结点的树的高度</td></tr><tr><td><code>private int size(AvlNode&lt;E&gt; t)</code></td><td>递归地遍历所有结点，返回结点总数</td></tr><tr><td><code>private int checkBalance(AvlNode&lt;E&gt; t)</code></td><td>检查树是否平衡，不平衡打印“imbalance”，并返回树高度</td></tr><tr><td><code>private AvlNode&lt;E&gt; rotateRight(AvlNode&lt;E&gt; k2)</code></td><td>右单旋转</td></tr><tr><td><code>private AvlNode&lt;E&gt; rotateLeft(AvlNode&lt;E&gt; k1)</code></td><td>左单旋转</td></tr><tr><td><code>private AvlNode&lt;E&gt; rotateLeftRight(AvlNode&lt;E&gt; k3)</code></td><td>左右双旋转</td></tr><tr><td><code>private AvlNode&lt;E&gt; rotateRightLeft(AvlNode&lt;E&gt; k1)</code></td><td>右左双旋转</td></tr></tbody></table><p>以下为 AVL 树结点嵌套类 $AvlNode$ 的架构。</p><table><thead><tr><th>类成员&#x2F;方法</th><th>描述</th></tr></thead><tbody><tr><td><code>public E element</code></td><td>字段，本结点元素</td></tr><tr><td><code>public AvlNode&lt;E&gt; left</code></td><td>字段，本结点的左子结点</td></tr><tr><td><code>public AvlNode&lt;E&gt; right</code></td><td>字段，本结点的右子结点</td></tr><tr><td><code>public int height</code></td><td>字段，该结点的高度</td></tr><tr><td><code>public AvlNode(E theElement)</code></td><td>构造器</td></tr><tr><td><code>public AvlNode(E element, AvlNode&lt;E&gt; left, AvlNode&lt;E&gt; right)</code></td><td>构造器</td></tr></tbody></table><br /><h4 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h4><h5 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h5><p>插入结点操作由插入驱动方法和具体插入方法完成，与 BST 的插入方法的不同在于，插入后通过 $balance$ 方法，调整 $t$ 处的平衡后通过返回原根。由于递归，$balance$ 方法能够自底向上调整 <strong>插入路径上所有结点的平衡</strong> ，且实际上在调整 <strong>第一个</strong>（自底向上方向上的第一个）失衡结点后使整棵树恢复为 AVL 树。$balance$ 方法后续详述。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(E e)</span> &#123; <span class="comment">// 插入结点驱动方法</span></span><br><span class="line">    root = insert(e, root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> AvlNode&lt;E&gt; <span class="title function_">insert</span><span class="params">(E e, AvlNode&lt;E&gt; t)</span>&#123; <span class="comment">// 插入结点，返回时沿路检查平衡并调整</span></span><br><span class="line">    <span class="keyword">if</span>(t == <span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AvlNode</span>&lt;&gt;(e,<span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">compareRes</span> <span class="operator">=</span> e.compareTo(t.element);</span><br><span class="line">    <span class="keyword">if</span>(compareRes &lt; <span class="number">0</span>) t.left = insert(e, t.left);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(compareRes &gt; <span class="number">0</span>) t.right = insert(e, t.right);</span><br><span class="line">    <span class="comment">// 等于时不插入(以该树只能存放不同的元素为前提)</span></span><br><span class="line">    <span class="keyword">return</span> balance(t); <span class="comment">// 调整t处的平衡并返回t</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h5 id="findMin-x2F-findMax"><a href="#findMin-x2F-findMax" class="headerlink" title="findMin&#x2F;findMax"></a>findMin&#x2F;findMax</h5><p>与 BST 的对应方法一致。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">findMin</span><span class="params">()</span> &#123; <span class="comment">// 查找最小结点驱动方法</span></span><br><span class="line">    <span class="keyword">if</span>(isEmpty()) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">    <span class="keyword">return</span> findMin(root).element;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> AvlNode&lt;E&gt; <span class="title function_">findMin</span><span class="params">(AvlNode&lt;E&gt; t)</span>&#123; <span class="comment">// 返回树的最小结点(递归方式)</span></span><br><span class="line">    <span class="keyword">if</span>(t == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(t.left == <span class="literal">null</span>) <span class="keyword">return</span> t;</span><br><span class="line">    <span class="keyword">return</span> findMin(t.left);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">findMax</span><span class="params">()</span>&#123; <span class="comment">// 查找最大结点驱动方法</span></span><br><span class="line">    <span class="keyword">if</span>(isEmpty()) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">    <span class="keyword">return</span> findMax(root).element;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> AvlNode&lt;E&gt; <span class="title function_">findMax</span><span class="params">(AvlNode&lt;E&gt; t)</span>&#123; <span class="comment">// 返回树的最大结点(循环方式)</span></span><br><span class="line">    <span class="keyword">if</span>(t == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(t.right != <span class="literal">null</span>) t = t.right;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h5 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h5><p>删除结点操作由删除驱动方法和具体删除方法完成，与 BST 的删除方法的不同在于，删除后通过 $balance$ 方法，调整 $t$ 处的平衡后通过返回原根。由于递归，$balance$ 方法能够自底向上调整 <strong>插入路径上所有结点的平衡</strong> ，且实际上在调整 <strong>第一个</strong>（自底向上方向上的第一个）失衡结点后使整棵树恢复为 AVL 树。$balance$ 方法后续详述。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(E e)</span> &#123; <span class="comment">// 删除结点驱动方法</span></span><br><span class="line">    root = remove(e, root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> AvlNode&lt;E&gt; <span class="title function_">remove</span><span class="params">(E e, AvlNode&lt;E&gt; t)</span>&#123; <span class="comment">// 删除结点(懒惰删除)，返回时沿路检查平衡并调整</span></span><br><span class="line">    <span class="keyword">if</span>(t == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">compareRes</span> <span class="operator">=</span> e.compareTo(t.element);</span><br><span class="line">    <span class="keyword">if</span>(compareRes &lt; <span class="number">0</span>) t.left = remove(e, t.left); <span class="comment">// 递归地在左侧寻找</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(compareRes &gt; <span class="number">0</span>) t.right = remove(e, t.right); <span class="comment">// 递归地在右侧寻找</span></span><br><span class="line">    <span class="comment">// e等于t.element，分两种情形</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(t.left != <span class="literal">null</span> &amp;&amp; t.right != <span class="literal">null</span>) &#123; <span class="comment">// 情形1：该t的左右子结点均不为null</span></span><br><span class="line">        t.element = findMin(t.right).element; <span class="comment">// 在右子树中找min</span></span><br><span class="line">        t.right = remove(t.element, t.right); <span class="comment">// 此时min已是t.element，必为情形2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> t = (t.left != <span class="literal">null</span>) ? t.left : t.right; <span class="comment">// 情形2: 1以外的情形</span></span><br><span class="line">    <span class="keyword">return</span> balance(t); <span class="comment">// 调整t处的平衡并返回t</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h5 id="contains"><a href="#contains" class="headerlink" title="contains"></a>contains</h5><p>与 BST 的对应方法一致。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(E e)</span> &#123; <span class="comment">// 判断是否包含指定元素驱动方法</span></span><br><span class="line">    <span class="keyword">return</span> contains(e, root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(E e, AvlNode&lt;E&gt; t)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(t == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">compareRes</span> <span class="operator">=</span> e.compareTo(t.element);</span><br><span class="line">    <span class="keyword">if</span>(compareRes &lt; <span class="number">0</span>) <span class="keyword">return</span> contains(e, t.left);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(compareRes &gt; <span class="number">0</span>) <span class="keyword">return</span> contains(e, t.right);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h5 id="balance"><a href="#balance" class="headerlink" title="balance"></a>balance</h5><p>在每一次插入或删除结点后，路径上结点 $t$ 的平衡。判断 $t$ 的左右子树高差是否超过设定的值（<code>ALLOWED_IMBALANCE = 1</code>），若超过则分别判断属于左-左、左-右、右-右、右-左中的哪一种情形，调用相应的旋转方法调整即可。该方法返回 $t$ 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> AvlNode&lt;E&gt; <span class="title function_">balance</span><span class="params">(AvlNode&lt;E&gt; t)</span>&#123; <span class="comment">// 调整 t 结点处的平衡，并返回 t</span></span><br><span class="line">    <span class="keyword">if</span>(t == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(height(t.left) - height(t.right) &gt; ALLOWED_IMBALANCE) &#123; <span class="comment">// 失衡，且左高于右</span></span><br><span class="line">        <span class="keyword">if</span>(height(t.left.left) &gt;= height(t.left.right))&#123; <span class="comment">// 右单旋情形</span></span><br><span class="line">            t = rotateRight(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> t = rotateLeftRight(t); <span class="comment">// 左右双旋情形</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(height(t.right) - height(t.left) &gt; ALLOWED_IMBALANCE)&#123; <span class="comment">// 失衡，且右高于左</span></span><br><span class="line">        <span class="keyword">if</span>(height(t.right.right) &gt;= height(t.right.left)) &#123; <span class="comment">// 左单旋情形</span></span><br><span class="line">            t = rotateLeft(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> t = rotateRightLeft(t); <span class="comment">// 右左双旋情形</span></span><br><span class="line">    &#125;</span><br><span class="line">    t.height = Math.max(height(t.left), height(t.right)) + <span class="number">1</span>; <span class="comment">// 更新 t 的高度</span></span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h5 id="rotateRight"><a href="#rotateRight" class="headerlink" title="rotateRight"></a>rotateRight</h5><p>右单旋转，见前述说明。</p><br /><h5 id="rotateLeft"><a href="#rotateLeft" class="headerlink" title="rotateLeft"></a>rotateLeft</h5><p>左单旋转，见前述说明。</p><br /><h5 id="rotateLeftRight"><a href="#rotateLeftRight" class="headerlink" title="rotateLeftRight"></a>rotateLeftRight</h5><p>左右双旋转，见前述说明。</p><br /><h5 id="rotateRightLeft"><a href="#rotateRightLeft" class="headerlink" title="rotateRightLeft"></a>rotateRightLeft</h5><p>右左双旋转，见前述说明。</p><br /><h5 id="checkBalance"><a href="#checkBalance" class="headerlink" title="checkBalance"></a>checkBalance</h5><p>检查整棵树是否平衡的方法。由平衡检查驱动方法和具体平衡检查方法完成。具体方法中以递归方式检查，若平衡则返回树高，不平衡则打印 $imbalance$ 并返回树高。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkBalance</span><span class="params">()</span> &#123; <span class="comment">// 树平衡检查驱动方法</span></span><br><span class="line">    checkBalance(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">checkBalance</span><span class="params">(AvlNode&lt;E&gt; t)</span> &#123; <span class="comment">// 检查树是否平衡，不平衡打印“imbalance”，并返回树高度</span></span><br><span class="line">    <span class="keyword">if</span>(t == <span class="literal">null</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">lh</span> <span class="operator">=</span> checkBalance(t.left);</span><br><span class="line">    <span class="type">int</span> <span class="variable">rh</span> <span class="operator">=</span> checkBalance(t.right);</span><br><span class="line">    <span class="keyword">if</span>(Math.abs(height(t.left) - height(t.right)) &gt; <span class="number">1</span></span><br><span class="line">            || height(t.left) != lh || height(t.right) != rh) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;imbalance&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> height(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h4 id="类的实现代码"><a href="#类的实现代码" class="headerlink" title="类的实现代码"></a>类的实现代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AvlTree</span>&lt;E <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;? <span class="built_in">super</span> E&gt;&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> AvlNode&lt;E&gt; root;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ALLOWED_IMBALANCE</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AvlTree</span><span class="params">()</span> &#123;&#125; <span class="comment">// 无参构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeEmpty</span><span class="params">()</span> &#123; <span class="comment">// 树置空</span></span><br><span class="line">        root = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123; <span class="comment">// 树判空</span></span><br><span class="line">        <span class="keyword">return</span> root == <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(E e)</span> &#123; <span class="comment">// 插入结点驱动方法</span></span><br><span class="line">        root = insert(e, root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(E e)</span> &#123; <span class="comment">// 删除结点驱动方法</span></span><br><span class="line">        root = remove(e, root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">findMin</span><span class="params">()</span> &#123; <span class="comment">// 查找最小结点驱动方法</span></span><br><span class="line">        <span class="keyword">if</span>(isEmpty()) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">        <span class="keyword">return</span> findMin(root).element;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">findMax</span><span class="params">()</span>&#123; <span class="comment">// 查找最大结点驱动方法</span></span><br><span class="line">        <span class="keyword">if</span>(isEmpty()) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">        <span class="keyword">return</span> findMax(root).element;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(E e)</span> &#123; <span class="comment">// 判断是否包含指定元素驱动方法</span></span><br><span class="line">        <span class="keyword">return</span> contains(e, root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printTree</span><span class="params">()</span>&#123; <span class="comment">// 按中序遍历打印树的驱动方法</span></span><br><span class="line">        <span class="keyword">if</span>(isEmpty()) System.out.println(<span class="string">&quot;Empty tree&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> printTree(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123; <span class="comment">// 求树的结点个数驱动方法</span></span><br><span class="line">        <span class="keyword">return</span> size(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">height</span><span class="params">()</span> &#123; <span class="comment">// 求树的高度驱动方法</span></span><br><span class="line">        <span class="keyword">return</span> height(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkBalance</span><span class="params">()</span> &#123; <span class="comment">// 树平衡检查驱动方法</span></span><br><span class="line">        checkBalance(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> AvlNode&lt;E&gt; <span class="title function_">balance</span><span class="params">(AvlNode&lt;E&gt; t)</span>&#123; <span class="comment">// 调整 t 结点处的平衡，并返回 t</span></span><br><span class="line">        <span class="keyword">if</span>(t == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(height(t.left) - height(t.right) &gt; ALLOWED_IMBALANCE) &#123; <span class="comment">// 失衡，且左高于右</span></span><br><span class="line">            <span class="keyword">if</span>(height(t.left.left) &gt;= height(t.left.right))&#123; <span class="comment">// 右单旋情形</span></span><br><span class="line">                t = rotateRight(t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> t = rotateLeftRight(t); <span class="comment">// 左右双旋情形</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(height(t.right) - height(t.left) &gt; ALLOWED_IMBALANCE)&#123; <span class="comment">// 失衡，且右高于左</span></span><br><span class="line">            <span class="keyword">if</span>(height(t.right.right) &gt;= height(t.right.left)) &#123; <span class="comment">// 左单旋情形</span></span><br><span class="line">                t = rotateLeft(t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> t = rotateRightLeft(t); <span class="comment">// 右左双旋情形</span></span><br><span class="line">        &#125;</span><br><span class="line">        t.height = Math.max(height(t.left), height(t.right)) + <span class="number">1</span>; <span class="comment">// 更新 t 的高度</span></span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> AvlNode&lt;E&gt; <span class="title function_">insert</span><span class="params">(E e, AvlNode&lt;E&gt; t)</span>&#123; <span class="comment">// 插入结点，返回时沿路检查平衡并调整</span></span><br><span class="line">        <span class="keyword">if</span>(t == <span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AvlNode</span>&lt;&gt;(e,<span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">compareRes</span> <span class="operator">=</span> e.compareTo(t.element);</span><br><span class="line">        <span class="keyword">if</span>(compareRes &lt; <span class="number">0</span>) t.left = insert(e, t.left);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(compareRes &gt; <span class="number">0</span>) t.right = insert(e, t.right);</span><br><span class="line">        <span class="comment">// 等于时不插入(以该树只能存放不同的元素为前提)</span></span><br><span class="line">        <span class="keyword">return</span> balance(t); <span class="comment">// 调整t处的平衡并返回t</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> AvlNode&lt;E&gt; <span class="title function_">remove</span><span class="params">(E e, AvlNode&lt;E&gt; t)</span>&#123; <span class="comment">// 删除结点(懒惰删除)，返回时沿路检查平衡并调整</span></span><br><span class="line">        <span class="keyword">if</span>(t == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">compareRes</span> <span class="operator">=</span> e.compareTo(t.element);</span><br><span class="line">        <span class="keyword">if</span>(compareRes &lt; <span class="number">0</span>) t.left = remove(e, t.left); <span class="comment">// 递归地在左侧寻找</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(compareRes &gt; <span class="number">0</span>) t.right = remove(e, t.right); <span class="comment">// 递归地在右侧寻找</span></span><br><span class="line">        <span class="comment">// e等于t.element，分两种情形</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(t.left != <span class="literal">null</span> &amp;&amp; t.right != <span class="literal">null</span>) &#123; <span class="comment">// 情形1：该t的左右子结点均不为null</span></span><br><span class="line">            t.element = findMin(t.right).element; <span class="comment">// 在右子树中找min</span></span><br><span class="line">            t.right = remove(t.element, t.right); <span class="comment">// 此时min已是t.element，必为情形2</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> t = (t.left != <span class="literal">null</span>) ? t.left : t.right; <span class="comment">// 情形2: 1以外的情形</span></span><br><span class="line">        <span class="keyword">return</span> balance(t); <span class="comment">// 调整t处的平衡并返回t</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> AvlNode&lt;E&gt; <span class="title function_">findMin</span><span class="params">(AvlNode&lt;E&gt; t)</span>&#123; <span class="comment">// 返回树的最小结点(递归方式)</span></span><br><span class="line">        <span class="keyword">if</span>(t == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(t.left == <span class="literal">null</span>) <span class="keyword">return</span> t;</span><br><span class="line">        <span class="keyword">return</span> findMin(t.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> AvlNode&lt;E&gt; <span class="title function_">findMax</span><span class="params">(AvlNode&lt;E&gt; t)</span>&#123; <span class="comment">// 返回树的最大结点(循环方式)</span></span><br><span class="line">        <span class="keyword">if</span>(t == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(t.right != <span class="literal">null</span>) t = t.right;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(E e, AvlNode&lt;E&gt; t)</span> &#123; <span class="comment">// 判断树中是否有指定元素的结点</span></span><br><span class="line">        <span class="keyword">if</span>(t == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">compareRes</span> <span class="operator">=</span> e.compareTo(t.element);</span><br><span class="line">        <span class="keyword">if</span>(compareRes &lt; <span class="number">0</span>) <span class="keyword">return</span> contains(e, t.left);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(compareRes &gt; <span class="number">0</span>) <span class="keyword">return</span> contains(e, t.right);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printTree</span><span class="params">(AvlNode&lt;E&gt; t)</span> &#123; <span class="comment">// 中序遍历打印树</span></span><br><span class="line">        <span class="keyword">if</span>(t != <span class="literal">null</span>) &#123;</span><br><span class="line">            printTree(t.left);</span><br><span class="line">            System.out.println(t.element);</span><br><span class="line">            printTree(t.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">height</span><span class="params">(AvlNode&lt;E&gt; t)</span> &#123; <span class="comment">// 返回以t为根结点的树的高度</span></span><br><span class="line">        <span class="keyword">return</span> t == <span class="literal">null</span> ? -<span class="number">1</span> : t.height;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">(AvlNode&lt;E&gt; t)</span> &#123; <span class="comment">// 递归地遍历所有结点，返回结点总数</span></span><br><span class="line">        <span class="keyword">if</span>(t != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(t.left != <span class="literal">null</span> &amp;&amp; t.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span> + size(t.left) + size(t.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> t.left != <span class="literal">null</span> ? <span class="number">1</span> + size(t.left) : <span class="number">1</span> + size(t.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">checkBalance</span><span class="params">(AvlNode&lt;E&gt; t)</span> &#123; <span class="comment">// 检查树是否平衡，不平衡打印“imbalance”，并返回树高度</span></span><br><span class="line">        <span class="keyword">if</span>(t == <span class="literal">null</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lh</span> <span class="operator">=</span> checkBalance(t.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rh</span> <span class="operator">=</span> checkBalance(t.right);</span><br><span class="line">        <span class="keyword">if</span>(Math.abs(height(t.left) - height(t.right)) &gt; <span class="number">1</span></span><br><span class="line">                || height(t.left) != lh || height(t.right) != rh) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;imbalance&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> height(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> AvlNode&lt;E&gt; <span class="title function_">rotateRight</span><span class="params">(AvlNode&lt;E&gt; k2)</span>&#123; <span class="comment">// 右单旋</span></span><br><span class="line">        AvlNode&lt;E&gt; k1 = k2.left;</span><br><span class="line">        k2.left = k1.right;</span><br><span class="line">        k1.right = k2;</span><br><span class="line">        k2.height = Math.max(height(k2.left), height(k2.right)) + <span class="number">1</span>; <span class="comment">// 调整k2高度</span></span><br><span class="line">        k1.height = Math.max(height(k1.left), height(k1.right)) + <span class="number">1</span>; <span class="comment">// 调整k1高度</span></span><br><span class="line">        <span class="keyword">return</span> k1; <span class="comment">// 返回调整后原失衡处结点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> AvlNode&lt;E&gt; <span class="title function_">rotateLeft</span><span class="params">(AvlNode&lt;E&gt; k1)</span>&#123; <span class="comment">// 左单旋</span></span><br><span class="line">        AvlNode&lt;E&gt; k2 = k1.right;</span><br><span class="line">        k1.right = k2.left;</span><br><span class="line">        k2.left = k1;</span><br><span class="line">        k1.height = Math.max(height(k1.left), height(k1.right)) + <span class="number">1</span>; <span class="comment">// 调整k1高度</span></span><br><span class="line">        k2.height = Math.max(height(k2.left), height(k2.right)) + <span class="number">1</span>; <span class="comment">// 调整k2高度</span></span><br><span class="line">        <span class="keyword">return</span> k2; <span class="comment">// 返回调整后原失衡处结点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> AvlNode&lt;E&gt; <span class="title function_">rotateLeftRight</span><span class="params">(AvlNode&lt;E&gt; k3)</span>&#123; <span class="comment">// 左右双旋</span></span><br><span class="line">        k3.left = rotateLeft(k3.left);</span><br><span class="line">        <span class="keyword">return</span> rotateRight(k3);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> AvlNode&lt;E&gt; <span class="title function_">rotateRightLeft</span><span class="params">(AvlNode&lt;E&gt; k1)</span>&#123; <span class="comment">// 右左双旋</span></span><br><span class="line">        k1.right = rotateRight(k1.right);</span><br><span class="line">        <span class="keyword">return</span> rotateLeft(k1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * AVL树结点嵌套类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AvlNode</span>&lt;E&gt;&#123;</span><br><span class="line">        <span class="keyword">public</span> E element;</span><br><span class="line">        <span class="keyword">public</span> AvlNode&lt;E&gt; left, right;</span><br><span class="line">        <span class="comment">// 比BinaryNode多维护一个height字段，每次insert或remove一个结点时通过balance方法更新</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> height;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unused&quot;)</span></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">AvlNode</span><span class="params">(E theElement)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>(theElement, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">AvlNode</span><span class="params">(E element, AvlNode&lt;E&gt; left, AvlNode&lt;E&gt; right)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.element = element;</span><br><span class="line">            <span class="built_in">this</span>.left = left;</span><br><span class="line">            <span class="built_in">this</span>.right = right;</span><br><span class="line">            <span class="built_in">this</span>.height = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h4 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukiyama;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.NoSuchElementException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AvlTreeDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        AvlTree&lt;Integer&gt; t = <span class="keyword">new</span> <span class="title class_">AvlTree</span>&lt;&gt;( );</span><br><span class="line">        <span class="type">int</span>[] elements = &#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">16</span>,<span class="number">15</span>,<span class="number">14</span>,<span class="number">13</span>,<span class="number">12</span>,<span class="number">11</span>,<span class="number">10</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> e : elements) t.insert(e);</span><br><span class="line">        t.printTree();</span><br><span class="line">        System.out.printf(<span class="string">&quot;size: %d, height: %d, min: %d, max: %d\n&quot;</span>, t.size(), t.height(), t.findMin(), t.findMax()); <span class="comment">// 输出10</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;has 10? %s, has 100? %s\n&quot;</span>, t.contains(<span class="number">10</span>), t.contains(<span class="number">100</span>));</span><br><span class="line">        t.checkBalance();</span><br><span class="line">        t.remove(<span class="number">1</span>); t.checkBalance();</span><br><span class="line">        t.remove(<span class="number">10</span>); t.checkBalance();</span><br><span class="line">        t.remove(<span class="number">16</span>); t.checkBalance();</span><br><span class="line">        t.printTree(); <span class="comment">// 8 10 13 20 29 74 98</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;size: %d, height: %d\n&quot;</span>, t.size(), t.height());<span class="comment">// 输出0</span></span><br><span class="line">        System.out.println(<span class="string">&quot;is empty: &quot;</span> + t.isEmpty()); <span class="comment">// false</span></span><br><span class="line">        t.makeEmpty();</span><br><span class="line">        System.out.println(<span class="string">&quot;is empty: &quot;</span> + t.isEmpty()); <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br />]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 平衡二叉树 </tag>
            
            <tag> AVL树 </tag>
            
            <tag> 旋转操作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉查找树</title>
      <link href="/2022/08/01/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/"/>
      <url>/2022/08/01/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉查找树-树ADT连载-3-x2F-13"><a href="#二叉查找树-树ADT连载-3-x2F-13" class="headerlink" title="二叉查找树 (树ADT连载 3&#x2F;13)"></a>二叉查找树 (树ADT连载 3&#x2F;13)</h1><blockquote><ul><li><p>可在作者的 <a href="https://github.com/iyukiyama/leetcode-posts">github仓库</a> 中获取本文和其他文章的 markdown 源文件及相关代码。</p></li><li><p>欢迎评论或仓库 PR 指出文章错漏或与我讨论相关问题，我将长期维护所有文章。</p></li><li><p>所有文章均用 Typora 完成写作，可使用 Typora 打开文章 md 文件，以获得最佳阅读体验。</p></li></ul></blockquote><p>🌲🌲🌲 <strong>一起手写一棵完整的二叉查找树。</strong></p><p>❗️ <strong>【NEW】</strong> ❗️</p><ul><li>9-15:  <a href="https://leetcode.cn/circle/discuss/SwgIJV/">红黑树从入门到看开</a></li></ul><p>这是小白 yuki 推出的「树ADT」系列文章的第 3 篇 (3&#x2F;13) 。</p><hr><p>实际上本文是为了后续讲解多种 <strong>平衡二叉树</strong> 的前置文章，最终目的是讲解 <strong>「红黑树」</strong> (已推出，<a href="https://leetcode.cn/circle/discuss/SwgIJV/">红黑树从入门到看开</a>)。</p><p>本文重点在于展现如何设计一个 BST 类，分析主要方法的代码实现，并给出该类的完整实现代码。读者学习之后 <strong>可以自己写出一个方法较为完备的基本 BST 类</strong> 。</p><hr><p>yuki的其他文章如下，欢迎阅读指正！</p><blockquote><p>如下所有文章同时也在我的 github <a href="https://github.com/iyukiyama/leetcode-posts">仓库</a> 中维护。</p></blockquote><table><thead><tr><th>文章</th><th>[发布时间] 字数&#x2F;览&#x2F;藏&#x2F;赞 (~2022-10-20)</th></tr></thead><tbody><tr><td><a href="https://leetcode.cn/circle/discuss/eBo9UB/">十大排序从入门到入赘</a>  🔥🔥🔥</td><td>[20220516]  2.5万字&#x2F;64.8k览&#x2F;3.7k藏&#x2F;937赞</td></tr><tr><td><a href="https://leetcode.cn/circle/discuss/ooxfo8/">二分查找从入门到入睡</a> 🔥🔥🔥</td><td>[20220509]  2.3万字&#x2F;38.4k览&#x2F;2.1k藏&#x2F;503赞</td></tr><tr><td><a href="https://leetcode.cn/circle/discuss/qmjuMW/">并查集从入门到出门</a> 🔥🔥</td><td>[20220514]  1.2万字&#x2F;17.9k览&#x2F;1.0k藏&#x2F;321赞</td></tr><tr><td><a href="https://leetcode.cn/circle/discuss/FyPTTM/">图论算法从入门到放下</a> 🔥🔥</td><td>[20220617]  5.6万字&#x2F;19.9k览&#x2F;1.3k藏&#x2F;365赞</td></tr><tr><td>树ADT系列 (预计13篇)</td><td>系列文章，连载中</td></tr><tr><td>3. <a href="https://leetcode.cn/circle/discuss/wPzlSb/">二叉查找树</a></td><td>[20220801]  5千字</td></tr><tr><td>4. <a href="https://leetcode.cn/circle/discuss/zbwD3p/">AVL树</a></td><td>[20220817]  5千字</td></tr><tr><td>5. <a href="https://leetcode.cn/circle/discuss/BCK17f/">splay树</a></td><td>[20220817]  5千字</td></tr><tr><td>6. <a href="https://leetcode.cn/circle/discuss/SwgIJV/">红黑树从入门到看开</a> 🔥🤯🤯🤯</td><td>[20220915]  3万字&#x2F;5.3k览&#x2F;269藏&#x2F;72赞</td></tr><tr><td>10. <a href="https://leetcode.cn/circle/discuss/qGREiN/">树状数组从入门到下车</a> 🔥🤯</td><td>[20220722]  1.4万字&#x2F;5.8k览&#x2F;196藏&#x2F;72赞</td></tr><tr><td>11. <a href="https://leetcode.cn/circle/discuss/H4aMOn/">线段树从入门到急停</a> 🔥🤯</td><td>[20220726]  2.5万字&#x2F;8.7k览&#x2F;481藏&#x2F;138赞</td></tr><tr><td><a href="https://leetcode.cn/circle/discuss/GV0JrV/">图论相关证明系列</a></td><td>系列文章</td></tr><tr><td>1. <a href="https://leetcode.cn/circle/discuss/jJQn7V/">Dijkstra正确性证明</a> 🤯</td><td>[20220531]</td></tr><tr><td>2. <a href="https://leetcode.cn/circle/discuss/VVEc8f/">Prim正确性证明</a> 🤯</td><td>[20220919]</td></tr><tr><td>3. <a href="https://leetcode.cn/circle/discuss/xeEwYl/">Bellman-Ford及SPFA正确性证明</a></td><td>[20220602]</td></tr><tr><td>4. <a href="https://leetcode.cn/circle/discuss/Nbzix4/">Floyd正确性证明</a></td><td>[20220602]</td></tr><tr><td>5. <a href="https://leetcode.cn/circle/discuss/tMIy36/">最大流最小割定理证明</a> 🤯🤯</td><td>[20220719]</td></tr><tr><td>6. <a href="https://leetcode.cn/circle/discuss/tN3sZc/">Edmonds-Karp复杂度证明</a> 🤯🤯</td><td>[20220515]</td></tr><tr><td>7. <a href="https://leetcode.cn/circle/discuss/T9Xa1R/">Dinic复杂度证明</a> 🤯🤯</td><td>[20220531]</td></tr></tbody></table><hr><p>[TOC]</p><hr><h2 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h2><p><a href="https://en.wikipedia.org/wiki/Binary_search_tree">二叉查找树 &#x2F; 二叉搜索树 &#x2F; 二叉排序树 (Binary Search Tree &#x2F; Binary Sort Tree, BST) </a>: 对于一棵二叉树，每个结点存有一个可用于比较的数据项，规定结点 $x$ 的左子树中所有结点的数据项小于 $x$ 的数据项，而 $x$ 的右子树中所有结点的数据项大于 $x$ 的数据项，这样的二叉树即为二叉查找树。对于有 $n$ 个元素的二叉树，假设树高平衡，则根据前面的性质可知其高度为 $logn$ ，我们将能够通过其结点数据项有序的特点，以类似二分查找的树上的 <strong>二分操作</strong> 实现 $O(logn)$ 平均时间复杂度的插入，查找和删除等操作。BST 内容非常丰富，下面我们先介绍非自平衡的 <strong>基本 BST</strong> ，由于基本BST树高不保证平衡，树上操作的复杂度无法保证为 $O(logn)$ ，因此引入 <strong>平衡 BST</strong> 。我们将会详细几种不同的平衡 BST 实现。</p><p>根据定义可知下图中只有左侧的树是 BST ，右侧的树中结点 7 与 6 不满足 BST 的结点顺序性质，若结点 7 是结点 8 的左子结点，则为 BST。</p><p><img src="https://pic.leetcode-cn.com/1656840556-GvQFIZ-image.png" alt="image.png"></p><p>※ 应用二叉查找树实现的数据结构一般为 $set$ 或 $map$，若为 $set$ (例如 Java 中的 $TreeSet$)，则不会存储相同数据项，若为 $map$ (例如 Java 中的 $TreeMap$)，则不会存储相同 $key$ 值。若要求保存相同值，可以采用链表或将相同值看作小于或大于来处理，本文以及后续讲解的所有二叉查找树均不保存相同值。 </p><blockquote><p>根据 Wiki 词条，此数据结构在 1960 年代由多人独立提出。</p><p>The binary search tree algorithm was discovered independently by several researchers, including P.F. Windley, <a href="https://en.wikipedia.org/wiki/Andrew_Donald_Booth">Andrew Donald Booth</a>, <a href="https://en.wikipedia.org/wiki/Andrew_Colin">Andrew Colin</a>, <a href="https://en.wikipedia.org/wiki/Thomas_N._Hibbard">Thomas N. Hibbard</a>. </p></blockquote><br /><h3 id="基本BST"><a href="#基本BST" class="headerlink" title="基本BST"></a>基本BST</h3><p>基本 BST 即只保持 BST 结点数据项大小关系性质，而不维护树高平衡的 <strong>非平衡 BST</strong> 。所谓「平衡」，指树的形态类似等腰三角形，从根结点到任意叶子结点的路径长度都是稳定的 $O(logn)$ ，更严格的定义是 <strong>「任意结点的左右子树高差不超过 1」</strong> ，如此即能保证对结点的增删改查的时间复杂度均为 $O(logn)$ 。</p><p>基本BST的定义十分简单，我们直接给出它的类的实现架构，并介绍其中的主要方法，然后再分析主要操作的时空复杂度。</p><blockquote><p>本节内容为 Mark Allen Weiss 所著 <a href="https://awesome-programming-books.github.io/algorithms/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9AJava%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0.pdf">数据结构与算法分析：Java语言描述</a> 相关章节的整理和总结。代码亦来自该书，略作改动。</p></blockquote><br /><h4 id="基本BST类架构"><a href="#基本BST类架构" class="headerlink" title="基本BST类架构"></a>基本BST类架构</h4><p>以下是基本 BST 类 ($MyTreeSet$) 架构。</p><table><thead><tr><th>类成员&#x2F;方法</th><th>描述</th></tr></thead><tbody><tr><td><code>private Node&lt;E&gt; root</code></td><td>唯一字段，根结点</td></tr><tr><td><code>public MyTreeSet()</code></td><td>无参构造器</td></tr><tr><td><code>public void clear()</code></td><td>树置空</td></tr><tr><td><code>public boolean isEmpty()</code></td><td>树判空</td></tr><tr><td><code>public void add(E e)</code></td><td>插入结点驱动方法</td></tr><tr><td><code>public void remove(E e)</code></td><td>删除结点驱动方法</td></tr><tr><td><code>public E first()</code></td><td>查找最小结点驱动方法</td></tr><tr><td><code>public E last()</code></td><td>查找最大结点驱动方法</td></tr><tr><td><code>public E floor(E e)</code></td><td>查找小于等于 $e$ 的最大元素驱动方法</td></tr><tr><td><code>public E ceiling(E e)</code></td><td>查找大于等于 $e$ 的最小元素驱动方法</td></tr><tr><td><code>public E lower(E e)</code></td><td>查找严格小于 $e$ 的最大元素驱动方法</td></tr><tr><td><code>public E higher(E e)</code></td><td>查找严格大于 $e$ 的最小元素驱动方法</td></tr><tr><td><code>public boolean contains(E e)</code></td><td>结点存在判定驱动方法</td></tr><tr><td><code>public void printTree()</code></td><td>中序遍历打印树的驱动方法</td></tr><tr><td><code>public int size()</code></td><td>求树大小驱动方法</td></tr><tr><td><code>public int height()</code></td><td>求树高驱动方法</td></tr><tr><td><code>private Node&lt;E&gt; add(E e, Node&lt;E&gt; t)</code></td><td>插入结点</td></tr><tr><td><code>private Node&lt;E&gt; remove(E e, Node&lt;E&gt; t)</code></td><td>删除结点(懒惰删除)</td></tr><tr><td><code>private Node&lt;E&gt; first(Node&lt;E&gt; t)</code></td><td>返回树的最小结点</td></tr><tr><td><code>private Node&lt;E&gt; last(Node&lt;E&gt; t)</code></td><td>返回树的最大结点</td></tr><tr><td><code>private Node floor(Node&lt;E&gt; x, E e)</code></td><td>查找小于等于 $e$ 的最大元素</td></tr><tr><td><code>private Node&lt;E&gt; ceiling(Node&lt;E&gt; x, E e)</code></td><td>查找大于等于 $e$ 的最小元素</td></tr><tr><td><code>private Node lower(Node&lt;E&gt; x, E e)</code></td><td>查找严格小于 $e$ 的最大元素</td></tr><tr><td><code>private Node&lt;E&gt; higher(Node&lt;E&gt; x, E e)</code></td><td>查找严格大于 $e$ 的最小元素</td></tr><tr><td><code>private boolean contains(E e, Node&lt;E&gt; t)</code></td><td>判断树中是否有指定元素的结点</td></tr><tr><td><code>private void printTree(Node&lt;E&gt; t)</code></td><td>中序遍历打印树</td></tr><tr><td><code>private int height(Node&lt;E&gt; t)</code></td><td>求以 $t$ 为根结点的树高</td></tr><tr><td><code>private int size(Node&lt;E&gt; t)</code></td><td>求以 $t$ 为根结点的树大小</td></tr></tbody></table><br /><p>以下是二叉树结点嵌套类 $Node$ 的架构。</p><table><thead><tr><th>类成员&#x2F;方法</th><th>描述</th></tr></thead><tbody><tr><td><code>public E element</code></td><td>结点数据</td></tr><tr><td><code>public Node&lt;E&gt; left</code></td><td>左子结点</td></tr><tr><td><code>public Node&lt;E&gt; right</code></td><td>右子结点</td></tr><tr><td><code>public Node(E element)</code></td><td>构造器</td></tr><tr><td><code>public Node(E element, Node&lt;E&gt; left, Node&lt;E&gt; right)</code></td><td>构造器</td></tr></tbody></table><br /><h4 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h4><p>在类架构表格中，我们看到 BST 实现的 $set$ 类 ($MyTreeSet$) 主要应该包含哪些方法，接下来我们讲解这其中的主要方法。其他实现简单的方法在「类的实现代码」中呈现。</p><br /><h5 id="add"><a href="#add" class="headerlink" title="add"></a>add</h5><p>插入结点操作由插入驱动方和具体插入方法完成，将值为 $e$ 的结点插入到当前二叉树中并使得插入后仍保持查找树性质。递归地比较 $e$ 和当前结点值的大小，最后 $e$ 总能 <strong>作为一个叶子结点</strong> 被插入到满足查找树性质的位置。</p><p>对于具体插入方法，当原树为 $null$ 时返回 <code>Node&lt;&gt;(e,null, null)</code> 给 $root$ ，即数据为 $e$ 的结点作为根结点插入。当原树不为 $null$ 时， <strong>插入后返回原根</strong> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123; <span class="comment">// 插入结点驱动方法</span></span><br><span class="line">    root = add(e, root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> Node&lt;E&gt; <span class="title function_">add</span><span class="params">(E e, Node&lt;E&gt; t)</span>&#123; <span class="comment">// 插入结点</span></span><br><span class="line">    <span class="keyword">if</span>(t == <span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(e,<span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> e.compareTo(t.element);</span><br><span class="line">    <span class="keyword">if</span>(cmp &lt; <span class="number">0</span>) t.left = add(e, t.left); <span class="comment">// 递进直到t.left == null</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(cmp &gt; <span class="number">0</span>) t.right = add(e, t.right); <span class="comment">// 递进直到t.right == null</span></span><br><span class="line">    <span class="keyword">return</span> t; <span class="comment">// 等于时不插入(以该树只能存放不同的元素为前提)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h5 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h5><p>删除结点操作由删除驱动方法和具体删除方法完成，将数据项为 $e$ 的结点删除并使得删除后仍保持查找树性质。</p><p>首先，在驱动方法中执行 $contains(e)$ ，若不存在直接返回，否则删除目标存在，调用具体删除方法，递归地寻找 $element$ 为 $e$ 的结点 $t$ ，对其执行 <strong>懒惰删除</strong> 。删除相比其他操作要复杂一些，以下为找到时结点 $t$ 的两种情形。</p><ul><li>情形1: $t$ 有左右两个子结点。</li><li>情形2: $t$ 有一个或没有子结点。</li></ul><p>情形1时，找到 $t$ 的右子树中最小结点 $min$ ，令 <code>t.element = min.element</code> ，即相当于用 $min$ 替换掉要删除的 $t$ ，然后对右子树执行删除 $min$ 的操作（由于是最小值，故此删除必属于情形 2）。</p><p>情形2时，根据是否有左子结点，执行此语句 <code>t = (t.left != null) ? t.left : t.right</code> 。有左子结点时 <code>t = t.left</code>，即用这个左子结点取代 $t$。没有左子结点时 <code>t = t.right</code>，表示以右子结点取代 $t$（包含右子结点也为空的情形，则此时 <code>t = null</code>）。</p><p>对于具体删除方法，当原树为 $null$ 时返回 $t$ (即 $root$ ) 给 $root$ 。当原树不为 $null$ 时，在删除后递归地返回到当前根给 $root$（例如当树只有根结点，且删除的就是该根时，<code>root = null</code> ）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(E e)</span> &#123; <span class="comment">// 删除结点驱动方法</span></span><br><span class="line">    <span class="keyword">if</span> (e == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;argument to remove() is null&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!contains(e)) <span class="keyword">return</span>; <span class="comment">// 检测删除目标是否存在</span></span><br><span class="line">    root = remove(e, root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> Node&lt;E&gt; <span class="title function_">remove</span><span class="params">(E e, Node&lt;E&gt; t)</span>&#123; <span class="comment">// 懒惰删除结点</span></span><br><span class="line">    <span class="keyword">if</span>(t == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> e.compareTo(t.element);</span><br><span class="line">    <span class="keyword">if</span>(cmp &lt; <span class="number">0</span>) t.left = remove(e, t.left); <span class="comment">// 递归地在左侧寻找</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(cmp &gt; <span class="number">0</span>) t.right = remove(e, t.right); <span class="comment">// 递归地在右侧寻找</span></span><br><span class="line">    <span class="comment">// e等于t.element，分两种情形</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(t.left != <span class="literal">null</span> &amp;&amp; t.right != <span class="literal">null</span>) &#123; <span class="comment">// 情形1：该t的左右子节点均不为null</span></span><br><span class="line">        t.element = first(t.right).element; <span class="comment">// 在右子树中找min</span></span><br><span class="line">        t.right = remove(t.element, t.right); <span class="comment">// 此时min已是t.element，必为情形2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> t = (t.left != <span class="literal">null</span>) ? t.left : t.right; <span class="comment">// 情形2: 1以外的情形</span></span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h5 id="first-x2F-last"><a href="#first-x2F-last" class="headerlink" title="first&#x2F;last"></a>first&#x2F;last</h5><p>查找具有最小&#x2F;最大数据的结点的操作由驱动方法和具体方法实现。根据 BST 性质一直向左&#x2F;向右寻找即可找到最小&#x2F;最大值。以下以递归方式实现 $first$，以迭代方式实现 $last$ 。这两个方法的实现容易理解，不赘述。如下展示 $first$ 的实现，$last$ 的实现请看「类的实现代码」。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">first</span><span class="params">()</span> &#123; <span class="comment">// 查找最小结点驱动方法</span></span><br><span class="line">    <span class="keyword">if</span>(isEmpty()) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">    <span class="keyword">return</span> first(root).element;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> Node&lt;E&gt; <span class="title function_">first</span><span class="params">(Node&lt;E&gt; t)</span>&#123; <span class="comment">// 返回树的最小节点(尾递归方式)</span></span><br><span class="line">    <span class="keyword">if</span>(t.left == <span class="literal">null</span>) <span class="keyword">return</span> t;</span><br><span class="line">    <span class="keyword">return</span> first(t.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h5 id="floor-x2F-ceiling"><a href="#floor-x2F-ceiling" class="headerlink" title="floor&#x2F;ceiling"></a>floor&#x2F;ceiling</h5><p>$floor$ 方法用于查找小于等于指定元素中的最大者，$ceiling$ 方法用于查找大于等于指定元素中的最小者，均由驱动方法和具体方法实现。其实现方式也是根据 BST 性质向左&#x2F;向右寻找目标。</p><p>以 $floor$ 为例，说明如下。</p><ol><li><code>if (cmp == 0) return x;</code> 若当前元素 $x$ 与目标元素相等，则 $x$ 即为所求直接返回。</li><li><code>if (cmp &lt; 0) return floor(x.left, e);</code> 若 $e$ 小于当前元素 $x$，说明目标元素在 $x$ 的左子树中，传入 $x.left$ 递归调用 $floor$ 。</li><li><code>Node&lt;E&gt; t = floor(x.right, e);</code> 否则此时 $e$ 大于 $x$ ，在 $x$ 的右子树中找最大者，即为所求。</li></ol><p>如下展示 $floor$ 的实现，$ceiling$ 的实现请看「类的实现代码」。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">floor</span><span class="params">(E e)</span> &#123; <span class="comment">// 查找小于等于 e 的最大元素驱动方法</span></span><br><span class="line">    <span class="keyword">if</span> (e == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;argument to floor() is null&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (isEmpty()) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>(<span class="string">&quot;calls floor() with empty symbol table&quot;</span>);</span><br><span class="line">    Node&lt;E&gt; x = floor(root, e);</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>(<span class="string">&quot;argument to floor() is too small&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> x.element;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">floor</span><span class="params">(Node&lt;E&gt; x, E e)</span> &#123; <span class="comment">// 小于等于 e 中最大者</span></span><br><span class="line">    <span class="keyword">if</span> (x == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> e.compareTo(x.element);</span><br><span class="line">    <span class="keyword">if</span> (cmp == <span class="number">0</span>) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) <span class="keyword">return</span> floor(x.left, e);</span><br><span class="line">    Node&lt;E&gt; t = floor(x.right, e);</span><br><span class="line">    <span class="keyword">if</span> (t != <span class="literal">null</span>) <span class="keyword">return</span> t;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似地，$lower$ 方法用于查找严格小于指定元素中的最大者，$higher$ 方法用于查找严格大于指定元素的最小者。二者的实现方式与 $floor&#x2F;ceiling$ 非常类似，只需要将等于的情形与需要递归的情形合写即可，具体请看「类的实现代码」。 </p><br /><h5 id="contains"><a href="#contains" class="headerlink" title="contains"></a>contains</h5><p>寻找树中是否包含数据项为 $e$ 的结点的操作由相应的驱动方法和具体方法实现。根据二叉查找树的性质以递归方式一直向左&#x2F;向右寻找。找到返回 $true$ ，否则返回 $false$ 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(E e)</span> &#123; <span class="comment">// 判断是否包含值为e的元素的结点的驱动方法</span></span><br><span class="line">    <span class="keyword">return</span> contains(e, root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(E e, Node&lt;E&gt; t)</span> &#123; <span class="comment">// 判断树中是否有指定元素的节点</span></span><br><span class="line">    <span class="keyword">if</span>(t == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> e.compareTo(t.element);</span><br><span class="line">    <span class="keyword">if</span>(cmp &lt; <span class="number">0</span>) <span class="keyword">return</span> contains(e, t.left);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(cmp &gt; <span class="number">0</span>) <span class="keyword">return</span> contains(e, t.right);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h4 id="时空复杂度"><a href="#时空复杂度" class="headerlink" title="时空复杂度"></a>时空复杂度</h4><p>二叉查找树的平均深度为 $O(logn)$ ，因此上述介绍的主要方法 <strong>平均时间复杂度</strong> 均为 $O(logn)$ 。当树为链状时，退化为链表形式，达到最坏时间复杂度 $O(n)$ 。若方法以递归实现，则空间复杂度取决于递归深度 $O(logn)$ ，若以迭代方式实现则空间复杂度为 $O(1)$ 。</p><table><thead><tr><th>方法</th><th>平均时间</th><th>最坏时间</th></tr></thead><tbody><tr><td>add&#x2F;remove&#x2F;first&#x2F;last&#x2F;floor&#x2F;ceiling&#x2F;lower&#x2F;higher&#x2F;contains</td><td>$O(logn)$</td><td>$O(n)$</td></tr></tbody></table><blockquote><p>BST 平均深度为 $O(logn)$ 的证明见此<a href="http://luc.devroye.org/devroye_reed_1995_variance_height_random_binary_search_tree.pdf">论文</a>。</p></blockquote><br /><h4 id="类的实现代码"><a href="#类的实现代码" class="headerlink" title="类的实现代码"></a>类的实现代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉查找树类 MyTreeSet</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyTreeSet</span>&lt;E <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;? <span class="built_in">super</span> E&gt;&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; root; <span class="comment">// 唯一字段，根节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyTreeSet</span><span class="params">()</span> &#123;&#125; <span class="comment">// 无参构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123; <span class="comment">// 树置空</span></span><br><span class="line">        root = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123; <span class="comment">// 判树空</span></span><br><span class="line">        <span class="keyword">return</span> root == <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123; <span class="comment">// 插入结点驱动方法</span></span><br><span class="line">        root = add(e, root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(E e)</span> &#123; <span class="comment">// 删除结点驱动方法</span></span><br><span class="line">        <span class="keyword">if</span> (e == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;argument to remove() is null&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!contains(e)) <span class="keyword">return</span>; <span class="comment">// 检测删除目标是否存在</span></span><br><span class="line">        root = remove(e, root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">first</span><span class="params">()</span> &#123; <span class="comment">// 查找最小结点驱动方法</span></span><br><span class="line">        <span class="keyword">if</span>(isEmpty()) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">        <span class="keyword">return</span> first(root).element;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">last</span><span class="params">()</span>&#123; <span class="comment">// 查找最大结点驱动方法</span></span><br><span class="line">        <span class="keyword">if</span>(isEmpty()) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">        <span class="keyword">return</span> last(root).element;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">floor</span><span class="params">(E e)</span> &#123; <span class="comment">// 查找小于等于 e 的最大元素驱动方法</span></span><br><span class="line">        <span class="keyword">if</span> (e == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;argument to floor() is null&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>(<span class="string">&quot;calls floor() with empty symbol table&quot;</span>);</span><br><span class="line">        Node&lt;E&gt; x = floor(root, e);</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>(<span class="string">&quot;argument to floor() is too small&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> x.element;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">ceiling</span><span class="params">(E e)</span> &#123; <span class="comment">// 查找大于等于 e 的最小元素驱动方法</span></span><br><span class="line">        <span class="keyword">if</span> (e == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;argument to ceiling() is null&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>(<span class="string">&quot;calls ceiling() with empty symbol table&quot;</span>);</span><br><span class="line">        Node&lt;E&gt; x = ceiling(root, e);</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>(<span class="string">&quot;argument to ceiling() is too large&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> x.element;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">lower</span><span class="params">(E e)</span> &#123; <span class="comment">// 查找严格小于 e 的最大元素驱动方法</span></span><br><span class="line">        <span class="keyword">if</span> (e == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;argument to lower() is null&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>(<span class="string">&quot;calls lower() with empty symbol table&quot;</span>);</span><br><span class="line">        Node&lt;E&gt; x = lower(root, e);</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>(<span class="string">&quot;argument to lower() is too small&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> x.element;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">higher</span><span class="params">(E e)</span> &#123; <span class="comment">// 查找严格大于 e 的最小元素驱动方法</span></span><br><span class="line">        <span class="keyword">if</span> (e == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;argument to higher() is null&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>(<span class="string">&quot;calls higher() with empty symbol table&quot;</span>);</span><br><span class="line">        Node&lt;E&gt; x = higher(root, e);</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>(<span class="string">&quot;argument to higher() is too large&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> x.element;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(E e)</span> &#123; <span class="comment">// 判断是否包含值为e的元素的结点的驱动方法</span></span><br><span class="line">        <span class="keyword">return</span> contains(e, root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printTree</span><span class="params">()</span> &#123; <span class="comment">// 中序遍历打印</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) System.out.println(<span class="string">&quot;Empty tree&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> printTree(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123; <span class="comment">// 求树的个数驱动方法</span></span><br><span class="line">        <span class="keyword">return</span> size(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">height</span><span class="params">()</span> &#123; <span class="comment">// 求树的高度驱动方法</span></span><br><span class="line">        <span class="keyword">return</span> height(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; <span class="title function_">add</span><span class="params">(E e, Node&lt;E&gt; t)</span>&#123; <span class="comment">// 插入结点</span></span><br><span class="line">        <span class="keyword">if</span>(t == <span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(e,<span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> e.compareTo(t.element);</span><br><span class="line">        <span class="keyword">if</span>(cmp &lt; <span class="number">0</span>) t.left = add(e, t.left); <span class="comment">// 递进直到t.left == null</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cmp &gt; <span class="number">0</span>) t.right = add(e, t.right); <span class="comment">// 递进直到t.right == null</span></span><br><span class="line">        <span class="keyword">return</span> t; <span class="comment">// 等于时不插入(以该树只能存放不同的元素为前提)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; <span class="title function_">remove</span><span class="params">(E e, Node&lt;E&gt; t)</span>&#123; <span class="comment">// 懒惰删除结点</span></span><br><span class="line">        <span class="keyword">if</span>(t == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> e.compareTo(t.element);</span><br><span class="line">        <span class="keyword">if</span>(cmp &lt; <span class="number">0</span>) t.left = remove(e, t.left); <span class="comment">// 递归地在左侧寻找</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cmp &gt; <span class="number">0</span>) t.right = remove(e, t.right); <span class="comment">// 递归地在右侧寻找</span></span><br><span class="line">        <span class="comment">// e等于t.element，分两种情形</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(t.left != <span class="literal">null</span> &amp;&amp; t.right != <span class="literal">null</span>) &#123; <span class="comment">// 情形1：该t的左右子节点均不为null</span></span><br><span class="line">            t.element = first(t.right).element; <span class="comment">// 在右子树中找min</span></span><br><span class="line">            t.right = remove(t.element, t.right); <span class="comment">// 此时min已是t.element，必为情形2</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> t = (t.left != <span class="literal">null</span>) ? t.left : t.right; <span class="comment">// 情形2: 1以外的情形</span></span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; <span class="title function_">first</span><span class="params">(Node&lt;E&gt; t)</span>&#123; <span class="comment">// 返回树的最小节点(尾递归方式)</span></span><br><span class="line">        <span class="keyword">if</span>(t.left == <span class="literal">null</span>) <span class="keyword">return</span> t;</span><br><span class="line">        <span class="keyword">return</span> first(t.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; <span class="title function_">last</span><span class="params">(Node&lt;E&gt; t)</span>&#123; <span class="comment">// 返回树的最大节点(循环方式)</span></span><br><span class="line">        <span class="keyword">while</span>(t.right != <span class="literal">null</span>) t = t.right;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">floor</span><span class="params">(Node&lt;E&gt; x, E e)</span> &#123; <span class="comment">// 小于等于 e 中最大者</span></span><br><span class="line">        <span class="keyword">if</span> (x == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> e.compareTo(x.element);</span><br><span class="line">        <span class="keyword">if</span> (cmp == <span class="number">0</span>) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) <span class="keyword">return</span> floor(x.left, e);</span><br><span class="line">        Node&lt;E&gt; t = floor(x.right, e);</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="literal">null</span>) <span class="keyword">return</span> t;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; <span class="title function_">ceiling</span><span class="params">(Node&lt;E&gt; x, E e)</span> &#123; <span class="comment">// 大于等于 e 中的最小者</span></span><br><span class="line">        <span class="keyword">if</span> (x == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> e.compareTo(x.element);</span><br><span class="line">        <span class="keyword">if</span> (cmp == <span class="number">0</span>) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)  <span class="keyword">return</span> ceiling(x.right, e);</span><br><span class="line">        Node&lt;E&gt; t = ceiling(x.left, e);</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="literal">null</span>) <span class="keyword">return</span> t;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">lower</span><span class="params">(Node&lt;E&gt; x, E e)</span> &#123; <span class="comment">// 小于 e 中最大者</span></span><br><span class="line">        <span class="keyword">if</span> (x == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> e.compareTo(x.element);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt;= <span class="number">0</span>) <span class="keyword">return</span> lower(x.left, e);</span><br><span class="line">        Node&lt;E&gt; t = lower(x.right, e);</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="literal">null</span>) <span class="keyword">return</span> t;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; <span class="title function_">higher</span><span class="params">(Node&lt;E&gt; x, E e)</span> &#123; <span class="comment">// 大于 e 中的最小者</span></span><br><span class="line">        <span class="keyword">if</span> (x == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> e.compareTo(x.element);</span><br><span class="line">        <span class="keyword">if</span> (cmp &gt;= <span class="number">0</span>)  <span class="keyword">return</span> higher(x.right, e);</span><br><span class="line">        Node&lt;E&gt; t = higher(x.left, e);</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="literal">null</span>) <span class="keyword">return</span> t;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(E e, Node&lt;E&gt; t)</span> &#123; <span class="comment">// 判断树中是否有指定元素的节点</span></span><br><span class="line">        <span class="keyword">if</span>(t == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> e.compareTo(t.element);</span><br><span class="line">        <span class="keyword">if</span>(cmp &lt; <span class="number">0</span>) <span class="keyword">return</span> contains(e, t.left);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cmp &gt; <span class="number">0</span>) <span class="keyword">return</span> contains(e, t.right);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printTree</span><span class="params">(Node&lt;E&gt; t)</span> &#123; <span class="comment">// 中序遍历打印树</span></span><br><span class="line">        <span class="keyword">if</span>(t != <span class="literal">null</span>) &#123;</span><br><span class="line">            printTree(t.left);</span><br><span class="line">            System.out.println(t.element);</span><br><span class="line">            printTree(t.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">height</span><span class="params">(Node&lt;E&gt; t)</span> &#123; <span class="comment">// 返回以t为根节点的树的高度</span></span><br><span class="line">        <span class="keyword">if</span>(t == <span class="literal">null</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span> + Math.max(height(t.left), height(t.right));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">(Node&lt;E&gt; t)</span> &#123; <span class="comment">// 递归地遍历树的所有节点，返回节点总数</span></span><br><span class="line">        <span class="keyword">if</span>(t != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(t.left != <span class="literal">null</span> &amp;&amp; t.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span> + size(t.left) + size(t.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> t.left != <span class="literal">null</span> ? <span class="number">1</span> + size(t.left) : <span class="number">1</span> + size(t.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 二叉树节点嵌套类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt;&#123;</span><br><span class="line">        <span class="keyword">public</span> E element;</span><br><span class="line">        <span class="keyword">public</span> Node&lt;E&gt; left, right;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(E element, Node&lt;E&gt; left, Node&lt;E&gt; right)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.element = element;</span><br><span class="line">            <span class="built_in">this</span>.left = left;</span><br><span class="line">            <span class="built_in">this</span>.right = right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h4 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukiyama;</span><br><span class="line"><span class="keyword">import</span> java.util.NoSuchElementException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTreeSetDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        MyTreeSet&lt;Integer&gt; t = <span class="keyword">new</span> <span class="title class_">MyTreeSet</span>&lt;&gt;( );</span><br><span class="line">        <span class="comment">// 10 98 61 13 8 20 48 29 47 74</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         *            10</span></span><br><span class="line"><span class="comment">         *        8       98</span></span><br><span class="line"><span class="comment">         *             61</span></span><br><span class="line"><span class="comment">         *          13    74</span></span><br><span class="line"><span class="comment">         *            20</span></span><br><span class="line"><span class="comment">         *              48</span></span><br><span class="line"><span class="comment">         *            29</span></span><br><span class="line"><span class="comment">         *              47</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">int</span>[] elements = &#123;<span class="number">10</span>,<span class="number">98</span>,<span class="number">61</span>,<span class="number">13</span>,<span class="number">8</span>,<span class="number">20</span>,<span class="number">48</span>,<span class="number">29</span>,<span class="number">47</span>,<span class="number">74</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> e : elements) t.add(e);</span><br><span class="line">        t.add(<span class="number">10</span>);</span><br><span class="line">        t.printTree(); <span class="comment">// 输出8 10 13 20 29 47 48 61 74 98</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;size: %d, height: %d, min: %d, max: %d\n&quot;</span>, t.size(), t.height(), t.first(), t.last());</span><br><span class="line">        System.out.printf(<span class="string">&quot;has 47? %s, has 100? %s\n&quot;</span>, t.contains(<span class="number">47</span>), t.contains(<span class="number">100</span>));</span><br><span class="line">        System.out.printf(<span class="string">&quot;floor(9): %s, floor(10): %s, ceiling(73): %s, ceiling(98): %s\n&quot;</span>, t.floor(<span class="number">9</span>), t.floor(<span class="number">10</span>), t.ceiling(<span class="number">73</span>), t.ceiling(<span class="number">98</span>));</span><br><span class="line">        System.out.printf(<span class="string">&quot;lower(9): %s, lower(10): %s, higher(73): %s, higher(61): %s\n&quot;</span>, t.lower(<span class="number">9</span>), t.lower(<span class="number">10</span>), t.higher(<span class="number">73</span>), t.higher(<span class="number">61</span>));</span><br><span class="line">        t.remove(<span class="number">47</span>); t.remove(<span class="number">48</span>); t.remove(<span class="number">61</span>);</span><br><span class="line">        t.printTree();</span><br><span class="line">        System.out.println(<span class="string">&quot;is empty: &quot;</span> + t.isEmpty()); <span class="comment">// 输出false</span></span><br><span class="line">        t.clear();</span><br><span class="line">        System.out.println(<span class="string">&quot;is empty: &quot;</span> + t.isEmpty()); <span class="comment">// 输出true</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;size: %d, height: %d\n&quot;</span>, t.size(), t.height());<span class="comment">// 输出0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br />]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
            <tag> 二叉查找树 </tag>
            
            <tag> 算法与数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树状数组从入门到下车</title>
      <link href="/2022/07/26/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E4%B8%8B%E8%BD%A6/"/>
      <url>/2022/07/26/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E4%B8%8B%E8%BD%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="树状数组从入门到下车"><a href="#树状数组从入门到下车" class="headerlink" title="树状数组从入门到下车"></a>树状数组从入门到下车</h1><p><strong>感谢官方推荐</strong> 🎉😄。</p><blockquote><ul><li><p>可在作者的 <a href="https://github.com/iyukiyama/leetcode-posts">github仓库</a> 中获取本文和其他文章的 markdown 源文件及相关代码。</p></li><li><p>欢迎评论或仓库 PR 指出文章错漏或与我讨论相关问题，我将长期维护所有文章。</p></li><li><p>所有文章均用 Typora 完成写作，可使用 Typora 打开文章 md 文件，以获得最佳阅读体验。</p></li></ul></blockquote><p>⚠️⚠️⚠️ <strong>全文一万四千字，外科手术式讲解三种树状数组。抽象的，我们让它具体，难解的，我们条分缕析。</strong></p><p>❗️ <strong>【NEW】</strong> ❗️</p><ul><li>9-15:  <a href="https://leetcode.cn/circle/discuss/SwgIJV/">红黑树从入门到看开</a></li></ul><p>这是小白 yuki 推出的「树ADT」系列文章的第 10 篇 (10&#x2F;13) 。</p><hr><blockquote><p>$keywords$ :</p><p>树状数组 (BIT) &#x2F; 区间划分 &#x2F; 前缀和 &#x2F; $lowbit$ &#x2F; 单点修改 (Point Update, PU) &#x2F; 单点查询 (Point Query, PQ) &#x2F; 区间修改 (Range Update, RU) &#x2F; 区间查询 (Range Query, RQ) &#x2F; 单改区查 (PURQ BIT) &#x2F; 区改单查 (RUPQ BIT) &#x2F; 区改区查 (RURQ BIT) &#x2F; 差分数组 &#x2F; 离散化 (松离散 &amp; 紧离散) &#x2F; 指定区间在给定取值范围内的元素数</p></blockquote><p><strong>树状数组</strong> 是一种能够高效求解「区间问题」的数据结构。「区间问题」指的是对于大小为 $n$ 的输入数组 $nums$ ，通过其上执行「区间求和」、「区间修改」等操作 (通过不同类型的树状数组) 来处理的问题，解决区间问题的过程中通常还伴随着针对单个元素的「单点查询」、「单点修改」这两种单点操作。若直接根据下标操作 $nums$ ，则单点操作时间复杂度为 $O(1)$ ，而区间操作为 $O(n)$ ；若采用「前缀和」，则区间操作为 $O(1)$ ，而单点操作为 $O(n)$ 。</p><p>本文将介绍的树状数组，利用 $nums$ 的 <strong>下标二进制表示及其位运算</strong> ，十分巧妙地将输入区间划分为 $n$ 个子区间，使得这些区间构成一棵或多棵多叉树，这些树通过一个数组表达，即所谓「树状数组」。借助树状数组的逻辑树形结构，能够 <strong>同时实现 $O(logn)$ 时间复杂度的单点操作与区间操作</strong> 。</p><p>上述文字是对树状数组的高度概括，初学时必然难解其意，但只要读者学完本文，一定会对上述描述有深刻的理解。本文主要内容及编排顺序如下。</p><ol><li><strong>基本树状数组 (单点修改区间查询树状数组)</strong> : 以 $O(logn)$ 时间复杂度解决长度为 $n$ 的序列的 <strong>单点修改</strong> 及 <strong>区间查询</strong> 问题。</li><li><strong>区间划分：</strong> 从区间查询问题出发，思考如何利用类似倍增思想的做法来划分子区间，从而提高区间查询的效率。</li><li><strong>lowbit:</strong>  由「划分连续子区间」的需求出发，尝试从元素下标二进制表示入手，找到通过 $lowbit$ 求子区间 (左右界) 的方式，所有子区间构成一棵或多棵逻辑上的多叉的 <strong>「二元索引树」</strong> 。</li><li><strong>时间复杂度分析：</strong> 单点修改及区间查询的时间复杂度都与 $(n)_2$ 的位数相关，简单分析后可知它们都是时间为 $O(logn)$ 的操作。</li><li><strong>区间修改单点查询树状数组：</strong> 在「单点修改区间查询树状数组」的基础上，引入 <strong>差分数组</strong> 实现区间修改单点查询树状数组。</li><li><strong>区间修改区间查询树状数组：</strong> 在「区间修改单点查询树状数组」的基础上，根据 <strong>算式推导</strong> ，引入 <strong>辅助树状数组</strong> 实现区间修改区间查询树状数组。</li><li><strong>离散化</strong> : 当区间问题只关心元素之间的大小关系而不关心元素值时，将输入序列离散化，能够提高求解效率或帮助解决一些特定问题。离散化实现包括 <strong>松离散</strong> 和 <strong>紧离散</strong> 。</li><li><strong>指定区间内指定取值范围的元素数</strong>:「求指定区间 $[l,r]$ 内大小在指定取值范围 $[lower, upper]$ 内的元素数」是一类特定的可用树状数组巧妙解决的问题。</li></ol><p>本文原题 「树状数组 (树ADT连载 10&#x2F;13)」，十分干瘪，不太符合作者的气质，遂改为现标题。<strong>「下车」表示作者的一种希望</strong>，此刻我们开始发车学习树状数组，看完本文，希望读者朋友们能轻松掌握，安全下车。</p><hr><p>yuki的其他文章如下，欢迎阅读指正！</p><blockquote><p>如下所有文章同时也在我的 github <a href="https://github.com/iyukiyama/leetcode-posts">仓库</a> 中维护。</p></blockquote><table><thead><tr><th>文章</th><th>[发布时间] 字数&#x2F;览&#x2F;藏&#x2F;赞 (~2022-10-20)</th></tr></thead><tbody><tr><td><a href="https://leetcode.cn/circle/discuss/eBo9UB/">十大排序从入门到入赘</a>  🔥🔥🔥</td><td>[20220516]  2.5万字&#x2F;64.8k览&#x2F;3.7k藏&#x2F;937赞</td></tr><tr><td><a href="https://leetcode.cn/circle/discuss/ooxfo8/">二分查找从入门到入睡</a> 🔥🔥🔥</td><td>[20220509]  2.3万字&#x2F;38.4k览&#x2F;2.1k藏&#x2F;503赞</td></tr><tr><td><a href="https://leetcode.cn/circle/discuss/qmjuMW/">并查集从入门到出门</a> 🔥🔥</td><td>[20220514]  1.2万字&#x2F;17.9k览&#x2F;1.0k藏&#x2F;321赞</td></tr><tr><td><a href="https://leetcode.cn/circle/discuss/FyPTTM/">图论算法从入门到放下</a> 🔥🔥</td><td>[20220617]  5.6万字&#x2F;19.9k览&#x2F;1.3k藏&#x2F;365赞</td></tr><tr><td>树ADT系列 (预计13篇)</td><td>系列文章，连载中</td></tr><tr><td>3. <a href="https://leetcode.cn/circle/discuss/wPzlSb/">二叉查找树</a></td><td>[20220801]  5千字</td></tr><tr><td>4. <a href="https://leetcode.cn/circle/discuss/zbwD3p/">AVL树</a></td><td>[20220817]  5千字</td></tr><tr><td>5. <a href="https://leetcode.cn/circle/discuss/BCK17f/">splay树</a></td><td>[20220817]  5千字</td></tr><tr><td>6. <a href="https://leetcode.cn/circle/discuss/SwgIJV/">红黑树从入门到看开</a> 🔥🤯🤯🤯</td><td>[20220915]  3万字&#x2F;5.3k览&#x2F;269藏&#x2F;72赞</td></tr><tr><td>10. <a href="https://leetcode.cn/circle/discuss/qGREiN/">树状数组从入门到下车</a> 🔥🤯</td><td>[20220722]  1.4万字&#x2F;5.8k览&#x2F;196藏&#x2F;72赞</td></tr><tr><td>11. <a href="https://leetcode.cn/circle/discuss/H4aMOn/">线段树从入门到急停</a> 🔥🤯</td><td>[20220726]  2.5万字&#x2F;8.7k览&#x2F;481藏&#x2F;138赞</td></tr><tr><td><a href="https://leetcode.cn/circle/discuss/GV0JrV/">图论相关证明系列</a></td><td>系列文章</td></tr><tr><td>1. <a href="https://leetcode.cn/circle/discuss/jJQn7V/">Dijkstra正确性证明</a> 🤯</td><td>[20220531]</td></tr><tr><td>2. <a href="https://leetcode.cn/circle/discuss/VVEc8f/">Prim正确性证明</a> 🤯</td><td>[20220919]</td></tr><tr><td>3. <a href="https://leetcode.cn/circle/discuss/xeEwYl/">Bellman-Ford及SPFA正确性证明</a></td><td>[20220602]</td></tr><tr><td>4. <a href="https://leetcode.cn/circle/discuss/Nbzix4/">Floyd正确性证明</a></td><td>[20220602]</td></tr><tr><td>5. <a href="https://leetcode.cn/circle/discuss/tMIy36/">最大流最小割定理证明</a> 🤯🤯</td><td>[20220719]</td></tr><tr><td>6. <a href="https://leetcode.cn/circle/discuss/tN3sZc/">Edmonds-Karp复杂度证明</a> 🤯🤯</td><td>[20220515]</td></tr><tr><td>7. <a href="https://leetcode.cn/circle/discuss/T9Xa1R/">Dinic复杂度证明</a> 🤯🤯</td><td>[20220531]</td></tr></tbody></table><hr><p>[2022-10-16]</p><ul><li>再次重写「指定区间内指定取值范围的元素数」一节 (重写三回了。。。😅)。</li></ul><p>[2022-10-15]</p><ul><li>将原先 $tree$ 的有效下标为 $[1,n]$ 改为更容易理解的 $[0,n-1]$ ，相应地，修改了三种 BIT 类的实现代码以适应这一调整。一并修改了大部分配图。</li><li>几乎重写了「指定区间内指定取值范围的元素数」一节。</li></ul><p>[2022-10-14]</p><ul><li><p>修正了两幅配图。</p></li><li><p>大幅修改了三种 BIT 类的实现代码，修改后更易于理解。</p></li></ul><hr><p>[TOC]</p><hr><h2 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h2><p><a href="https://en.wikipedia.org/wiki/Fenwick_tree">树状数组</a> (二元索引树 &#x2F; 二元下标树 &#x2F; Binary Indexed Tree, BIT &#x2F; Fenwick Tree): 树状数组虽名为数组，但从其英文名 (Binary Indexed Tree) 可看出它本质上是一种被表达为树的数据结构。对于大小为 $n$ 的序列 $nums$ ，最基本的树状数组以 $O(logn)$ 时间复杂度同时支持如下两种操作。</p><ul><li>更新 $nums$ 中单个元素的值，即 <strong>单点修改</strong> 。</li><li>求 $nums$ 任意区间的元素值之和，即 <strong>区间查询</strong> 。</li></ul><p>对于这两种操作，最简单的做法是直接根据下标操作 $nums$ ，单点修改的时间复杂度为 $O(1)$ ，区间查询为 $O(n)$ 。此外，我们也可以利用「前缀和」来完成。首先计算出 $nums$ 的前缀和数组  $preSum$ ，那么求 $[l , r]$ 区间和，即是求 $preSum[r] - preSum[l-1]$ ，时间复杂度为 $O(1)$ 。但单点修改 $nums[i]$ 时，需要更新 $preSum[i]$ 及之后的前缀和数组元素 (否则之后求区间和会出错)，这使得单点修改时间复杂度为 $O(n)$ 。</p><p>无论是使用普通数组还是利用前缀和数组，对于上述两种操作，均有一种的时间复杂度为 $O(n)$ 。而树状数组通过维护一个与 $nums$ 等大的，在逻辑上为树状结构 (一棵或多棵多叉树) 的数组 $tree[]$ ，使得两种操作的时间复杂度均为 $O(logn)$ 。</p><table><thead><tr><th>序列操作</th><th>数组</th><th>前缀和</th><th>树状数组</th></tr></thead><tbody><tr><td>单点修改</td><td>$O(1)$</td><td>$O(n)$</td><td>$O(logn)$</td></tr><tr><td>区间查询</td><td>$O(n)$</td><td>$O(1)$</td><td>$O(logn)$</td></tr></tbody></table><p><strong>树状数组是一种极具巧思，代码实现极轻巧却不失高效的数据结构</strong> 。我们马上会看到树状数组如何借助 <strong>二进制形式的 $nums$ 的下标值</strong> ，将 $nums$ 划分为多个子区间，这些子区间构成逻辑树形结构，利用树的特点使得两种基本操作都复杂度都是 $O(logn)$ 。</p><p>为方便后续行文，我们提前介绍如下操作，并约定称呼及简称。</p><table><thead><tr><th>操作</th><th>定义</th></tr></thead><tbody><tr><td>单点修改 (Point Update, PU)</td><td>修改 $nums$ 的单个元素</td></tr><tr><td>单点查询 (Point Query, PQ)</td><td>查询 $nums$ 的单个元素</td></tr><tr><td>区间修改 (Range Update, RU)</td><td>修改 $nums$ 的某个区间<br />※ 区间元素都加上同一个数</td></tr><tr><td>区间查询 (Range Query, RQ)</td><td>求 $nums$ 的某个区间的区间和</td></tr></tbody></table><blockquote><p>根据 wiki，树状数组最早由 Boris Ryabko (前苏联) 于1989年 <a href="http://boris.ryabko.net/dan1989.pdf">提出</a> ，并在1992 年发表了一个 <a href="http://boris.ryabko.net/ryabko1992.pdf">改进版本</a> 。 Peter Fenwick  在其1994年的 <a href="https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.14.8917">文章</a> 中描述了该数据结构，随后此数据结构便以 Fenwick tree 之名广为人知。</p><p>This structure was proposed by Boris Ryabko in 1989[<a href="https://en.wikipedia.org/wiki/Fenwick_tree#cite_note-1">1]</a> with a further modification published in 1992.[<a href="https://en.wikipedia.org/wiki/Fenwick_tree#cite_note-2">2]</a> It has subsequently become known under the name Fenwick tree after <a href="https://en.wikipedia.org/w/index.php?title=Peter_Fenwick_(computer_scientist)&action=edit&redlink=1">Peter Fenwick</a>, who described this structure in his 1994 article.[<a href="https://en.wikipedia.org/wiki/Fenwick_tree#cite_note-3">3]</a></p><p>作者的「树状数组」知识，最初学自 OI wiki <a href="https://oi-wiki.org/ds/fenwick/">树状数组</a>。</p></blockquote><br /><h3 id="PURQ-BIT-单改区查"><a href="#PURQ-BIT-单改区查" class="headerlink" title="PURQ BIT (单改区查)"></a>PURQ BIT (单改区查)</h3><p>最基本的树状数组支持「单点修改 (PU)」和「区间查询 (RQ)」，即 PURQ BIT。</p><br /><h4 id="区间划分"><a href="#区间划分" class="headerlink" title="区间划分"></a>区间划分</h4><p>我们已经知道，使用普通数组或利用前缀和数组实现 PU &#x2F; RQ 操作时，各自均有一种操作需要遍历 <strong>一段连续的区间</strong> 。在 $nums$ 上的「连续」操作的时间复杂度为 $O(n)$ 。为了提高操作效率，我们必须 <strong>减少操作的次数</strong> 。首先考虑求长度为 $k$ 的区间的区间和操作，我们会想，如果不是连续地相加 $k$ 次，而是通过某种预先处理的手段，将大小为 $k$ 的区间 <strong>划分为多个子区间</strong> ，子区间个数显著地少于 $k$ ，每一个子区间的区间和都被高效地实时维护，那么求区间和时，就只需要执行远少于 $k$ 次的加运算 (子区间的区间和相加) 。</p><p>例如下图，当我们求 $nums$ 区间 $[3, 8]$ 的区间和时，如果我们能通过某种方式，找到子区间 $[3,4]$ 、 子区间 $[5,7]$ 、子区间 $[8,8]$ ，且这些子区间的区间和总是能够被实时维护，那么只需将这三个子区间的和相加即可，原先需要将 6 个数相加，现在只需要将 3 个数相加，这样就减少了操作的次数。  </p><p><img src="https://pic.leetcode-cn.com/1665804555-nkqKvk-image.png" alt="image.png"></p><p><strong>那么树状数组是这一想法的实现吗？答案是：不完全是。</strong> 树状数组确实将 $nums$ 划分成了多个区间，但并不是对任意区间 $[l,r]$ 划分连续子区间，而是通过 <strong>「前缀区间和」作差</strong> 的方式来得到指定区间的「区间和」，前缀区间才是通过若干个连续子区间组成的。</p><p>我们提前指出，树状数组这一数据结构，对输入数组 $nums$ 划分为多个子区间，使得对任意的 $[0,k]$ 前缀区间，都可以 <strong>由划分结果中的若干个连续的子区间构成</strong> ，这些子区间的区间和相加即可得到「前缀区间和」。对于任意区间 $[l,r]$ ，将右界前缀区间 $[0, r]$ 的区间和减去左界前一位的前缀区间 $[0,l-1]$ 的区间和，即为 $[l,r]$ 区间和。</p><p>区间划分的思考也许会让你想到利用「倍增思想」的快速幂算法 <a href="https://leetcode-cn.com/problems/powx-n/">leetcode #50-pow(x, n)</a> ，该算法不是通过「连续」地将 $x$ 相乘 $n$ 次，而总是借助已经算出的结果来快速得到新的更大范围的中间结果，这个中间结果又能用于之后求更大范围的结果的计算中。实际上除了倍增思想，动态规划、记忆化搜索都体现了这种 <strong>「利用已求出的结果完成下一步计算」</strong> 的思想。总之我们需要一种类似倍增方法的能够跳跃式划分区间 (下标) 的方法。</p><p>现在，我们重新将 <strong>树状数组解决区间和问题</strong> 的 <strong>灵感来源</strong> 描述如下: </p><ul><li>$nums$ 上任意 $[l, r]$ 的区间和，将通过 $[0,r]$ 和 $[0, l-1]$ 的「前缀区间和」作差得到。</li><li>前缀区间由若干个相邻的子区间构成，这些子区间的区间和相加得到前缀区间的区间和。</li><li>也许能够通过某种类似倍增方式划分 $nums$ 的下标 (从倍增法得到的灵感)。</li></ul><p>很抽象，尤其是最后一句，现在无法得知如何处理下标来划分输入区间，不过没关系，我们马上对大小为 8 (下标范围为 $[0,7]$)的 $nums$ 实践上述描述。 首先明确为了实现「更快地求区间和」的需求：</p><ol><li>将指定长度的 $nums$ 划分为若干区间。对 $nums$ 下标的划分动作应当是一种 <strong>可循环的操作</strong> 。</li><li>$nums$ 上的任意区间 $[l, r]$ 的区间和可由 $[0,r]$ 区间和与 $[0,l-1]$ 区间和作差得到，这是「前缀和」思想。这要求 $[0, l-1], [0,r]$  均由 $nums$ 划分结果中的 <strong>若干相邻区间</strong> 所构成。从这里可以看出， 对 $nums$ 的划分，不只是对 $[0,n-1]$ 的划分，而是对 $<a href="k%E2%88%88%5B0,n-1%5D">0,k</a>$ 的划分。划分结果必须满足能由若干连续区间构成任意的 $<a href="k%E2%88%88%5B0,n-1%5D">0,k</a>$ 区间 (这句话是理解树状数组的关键，请读者在阅读后文时反复体会)。</li><li>子区间的区间和被 <strong>实时维护</strong> 。需要用一个 $tree[]$ 数组保存所有子区间和 (我们马上会知道为什么命名为 $tree$)。</li><li>求给定区间的区间和，即求两次前缀区间和再作差。求前缀区间和需要通过 <strong>某种规则</strong> 一边寻找其子区间 $i$ (连续的) ，一边将 $tree[i]$ (子区间 $i$ 的区间和) 累计到结果中。</li><li>更新 $nums[i]$ 时，通过 <strong>某种规则</strong> 更新包含该值的所有子区间的区间和。</li></ol><p>「灵感来源」描述中提到了「类似倍增方式」，我们不难想到可以从下标的二进制表示着手。以划分区间 $[0,14]$ 为例，先写出 14 的二进制表示 $14&#x3D;(1110)_2$ 。我们要求划分动作是可循环的操作，且对于任意长度的 $nums$，都能通过同样的方式完成划分。划分区间就是要确定区间的左右界。很直接地，区间 $[0,14]$ 的 <strong>最右子区间的右界</strong> 为 14 ， <strong>最左子区间的左界</strong> 是 0 。我们将最右子区间作为当前区间，从当前子区间右界下标 14 开始考虑。</p><p>一个容易想到的方法如下：</p><blockquote><p>【区间划分方法】：从最右子区间右界 $k$ 开始，将 $k$ 的最低位 1 换成 0 ，新的 $k$ 作为当前区间的左界下标，减 1 即为其 <strong>左邻子区间的右界下标</strong> 。重复该操作直到当前区间右界下标为 0 (二进制数所有位都没有 1) 。</p></blockquote><p>于是区间 $[0,14]$ 被划分为这三个区间 $[(0000)_2,(1000)_2)$ , $[(1000)_2,(1100)_2)$ , $[(1100)_2,(1110)_2]$ ，即 $[0,7]$ , $[8,11]$ , $[12,14]$。我们一方面保证了划分动作是循环的，同时也保证了划分后的子区间是连续的。但还存在一个小问题，当划分到最后一个子区间 $[(0000)_2,(1000)_2)$ 时，左界为 0 ，应当要退出划分区间的循环，但此时需要处理最后一个区间 ($[0,7]$)，不能直接退出，于是我们利用下一次左界「也是」0 来作为退出划分区间循环的判断条件。但要记录连续两次左界，这似乎有点麻烦，实际上我们只需做一个小调整，即可更优雅地结束划分。</p><p>仍以 $[0,14]$ 为例，我们不直接使用 14 而是使用 $14+1&#x3D;15$ 的二进制表示 $15&#x3D;(1111)_2$ 作为划分起始点 $i$ (这里的 $i$ 不是下标，而是右界下标 $k$ 加 1)。划分方法与之前相同。按照该方式，区间 $[0,14]$ 从右到左被依次被划分为。</p><ul><li>$[(1110)_2,(1111)_2)$ (即 $[14,14]$)</li><li>$[(1100)_2,(1110)_2)$ (即 $[12,13]$)</li><li>$[(1000)_2,(1100)_2)$ (即 $[8,11]$)</li><li>$[(0000)_2,(1000)_2)$ (即 $[0,7]$)</li></ul><p>利用该方法，我们一方面保证了划分动作是循环的，同时也保证了划分后的子区间是连续的，还保证了循环能够退出，即一定会完成划分。实际上经过验证后，我们发现，这样的区间划分方式完全符合前述 5 点要求，对照说明如下。</p><ol><li>规则是固定的，因此操作是可循环的，通过这种方式，我们一定能够将 $nums$ 的任意 $[0, k]$ 区间划分为一些子区间。 也容易看出，$[0,k]$ 无论怎么划分， <strong>一定有且只有一个以 $k$ 为右界的子区间</strong> 。$k$ 的取值有 $n$ 种 ($0 \sim n-1$)，因此 <strong>长度为 $n$ 的 $nums$ 划分出 $n$ 个子区间</strong> ，这些子区间的右界是 ${0,1,2,…,n-1}$  ，左界通过 $(k+1)-lowbit(k+1)$ 求出，即 ${1-lowbit(1),2-lowbit(2),3-lowbit(3),…,n-lowbit(n)}$ ($lowbit(i)$ 就是最低位 1 所代表的数字，后续介绍其实现)。</li><li>根据 1，对于任意的 $[l,r]$ ，一定有对应的由一个或多个连续区间构成的「前缀区间」 $[0,l-1]$ 和 $[0,r]$ ，将二者的区间和作差即可得到 $[l,r]$ 的区间和。</li><li>单点修改会导致所有包含被修改的元素值的区间的区间和发生变动，需要对这些区间的区间和做同样的更新操作。现在我们还不知道要怎么找 「<strong>包含给定元素的所有区间」</strong> ，留到后续说明。</li><li>「将当前子区间右界下标最低位的 1 换成 0」的划分方式即为该规则 (即 $lowbit()$ 方法)。</li><li>同 3，后续说明。</li></ol><p>至此，我们终于可以描述「树状数组」 $tree[]$ 。</p><ul><li>划分得到 $n$ 个子区间，每一个子区间的右界元素都唯一地存在于该区间中，因此当我们要表示区间的区间和时，可用该区间右界作为 $tree[]$ 的下标，例如 $tree[5]$ 指的是右界为 5 的区间的区间和 (只有该区间包含了 $nums[5]$) 。</li><li>由上述，$tree$ 的大小与 $nums$ 相同，为 $n$ 。</li><li>以 $k$ 为右界的区间的左界为 $(k+1)-lowbit(k+1)$ 。$lowbit$ 方法即划分区间的位运算实现。</li></ul><p>还是很抽象？再坚持一下，介绍 $lowbit$ 方法后上图，外科手术式解析。</p><br /><h5 id="lowbit"><a href="#lowbit" class="headerlink" title="lowbit"></a>lowbit</h5><p>前面我们说过「将当前子区间右界 $k$ 加 1后的 $k+1$ 的二进制表示中最低位的 1 换成 0 后作为该子区间左界」。在代码中我们通过巧妙的位运算来实现这一更新。 下图以两个例子 (110101, 101000) 展示这一运算过程，也即下式 ( $k+1$ 用 $i$ 来表示)。<br>$$<br>i&#x3D;i&amp;(\sim i+1)<br>$$<br><img src="https://pic.leetcode-cn.com/1657804443-daTLhp-image.png" alt="image.png"></p><p>正数 $i$ ( $i&#x3D;k+1$ 大于等于1，必为正) 的相反数 $-i$ 必是负数，<a href="https://en.wikipedia.org/wiki/Signed_number_representations">我们知道</a>，负数在计算机中以补码 (<a href="https://en.wikipedia.org/wiki/Two%27s_complement">two’s complement</a>) 表示， <strong>负数 $-i$ 的补码为对应正数 $i$ 的除符号位外按位取反后再加 1</strong> ，即 $-i&#x3D;\sim i+1$ ，恰好与上述式子与运算 $&amp;$ 的右边相同，于是我们给出如下 $lowbit(i)$方法，如其方法名所表达的那样， <strong>该方法返回下标 $i$ 的二进制表示中的最低位的 1 所代表的数</strong> 。后续我们可以用该方法方便地对当前子区间右界 $i$ 求其左界，即其左邻子区间右界 $i-lowbit(i)$ 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">lowbit</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i &amp; -i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下图展示了大小为 16 的 $nums$ (图中的 $a$ 数组) 的子区间划分 ($t[]$ 为 $tree[]$ )，16个矩形代表划分出的16个子区间。如图，$tree[0]$ 表示右界为 $nums[0]$ 的区间和 (该区间只有一个元素)，$tree[1]$ 表示右界为 $nums[1]$ 的区间的区间和 (该区间只有 $nums[0]$ 和 $nums[1]$ 两个元素)，依次类推。蓝线表示 <strong>区间包含关系</strong> 。单点修改操作需要更新所有包含修改点的区间的区间和，寻找包含修改点的区间的过程就是 <strong>沿着蓝线向上</strong> 的过程。</p><p>到这里，相信读者们应该对「树状数组」和 「<em>Binary Indexed Tree</em>」有了更深的理解。</p><p><img src="https://pic.leetcode-cn.com/1665813576-iiunPC-image.png" alt="image.png"></p><p>将该图稍作调整可以更清晰地看出「树」的结构。</p><p><img src="https://pic.leetcode-cn.com/1665818555-aoDRNy-image.png" alt="image.png"></p><p>需要强调的是，$tree$ 所代表的逻辑树并非二叉树，英文名称中的 binary 指的是下标 <strong>「二进制」表示中「二」</strong> ，表达的是下标二进制数位取 0 或取 1 得到的下标值与 $tree$  逻辑结点的索引关系。对于大小不是 2 的整数次幂的 $nums$ ，其子区间构成多棵而不是一棵多叉树。例如大小 $nums$ 大小为 15 时 ($[0,14]$)，子区间构成四棵多叉树，分别以结点 $tree[7]$, $tree[11]$, $tree[13]$ , $tree[14]$ 为根结点。</p><p><img src="https://pic.leetcode-cn.com/1665813789-iUSAMZ-image.png" alt="image.png"></p><p>接下来我们分析如何实现「单点修改」和「区间查询」，分析过后你会知道之前需求 3 和 5 是如何被满足的。</p><br /><h4 id="单点修改"><a href="#单点修改" class="headerlink" title="单点修改"></a>单点修改</h4><p>更新 $nums[k]$ ，需要相应地更新包含它的所有区间的区间和 $tree[]$ 。通过前面的树状图，我们不难看到，<strong>第一个要更新的区间和一定是 $tree[k]$</strong> 。沿着蓝线上升，考虑蓝线连接的父子结点的下标二进制表示，我们发现 $i &#x3D; i + lowbit(i)$  ($i&#x3D;k+1$) 总是 (包含修改点的) 下一个更大的 (父结点) 区间的右界加 1 ，每上升一层，就会找到包含修改点的更大范围的区间。$i$ 的最大值是区间右界下标 $n-1$ 加 1，即 $nums$ 的大小 $n$ 。</p><p>增量式单点修改方法为 <code>public void add(int k, int x)</code> 表示为包含 $nums[k]$ 的所有区间和加上增量 $x$ 。该方法将从 $tree[k]$ 开始，沿着蓝色链条依次为包含 $nums[k]$ 的所有区间加上增量 $x$ 。可见 $add$ 方法的主体是一个循环，蓝色链条上的区间和结点下标 $i$ 的更新我们已经知道。</p><p>若单点修改为覆盖式修改，则执行 <code>public void update(int k, int x)</code> ，表示更新 <code>nums[k] = x</code>  ，通过调用 <code>public void add(int k, int x)</code> 方法实现。于是不难写出如下 $update$ 和 $add$ 方法。寥寥数行，配合 $lowbit$ 向上更新，十分奇妙。</p><p>再次强调，$i$ 的取值总是当前区间右界下标加 1，因此更新区间和时下标为 $i-1$ (对应该区间右界下标)，即 $tree[i-1]$ 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单点修改: 令 nums[k] = x</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span> <span class="params">(<span class="type">int</span> k, <span class="type">int</span> x)</span>&#123;</span><br><span class="line">    add(k, x - nums[k]); </span><br><span class="line">    nums[k] = x; <span class="comment">// 更新 nums[k] 为 x</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 单点修改: 令 nums[k] += x</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> x)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k + <span class="number">1</span>; i &lt;= n; i += lowbit(i))&#123; </span><br><span class="line">        tree[i - <span class="number">1</span>] += x; <span class="comment">// 包含第 k 项的区间都加上 x</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下图展示了 $add(4,2)$ 的过程。</p><p><img src="https://pic.leetcode-cn.com/1665819480-iJBaBA-image.png" alt="image.png"></p><br /><h4 id="区间查询"><a href="#区间查询" class="headerlink" title="区间查询"></a>区间查询</h4><p>给定 $nums$ 上的区间 $[l,r]$ ，求区间和。利用前缀和的思想，我们定义方法 <code>private int preSum(int k)</code> ，表示求 $nums[0]$ 到 $nums[k]$ 的和 (前 $k+1$ 项和) ，那么求 $[l,r]$ 的区间和即为 $preSum(r) - preSum(l - 1)$ 。以求 $preSum(r)$ 为例，在「区间划分」中我们已经知道通过 <code>i = i - lowbit(i)</code> 的方式从 $i&#x3D;r+1$ 开始依次求出组成 $[0,r]$ 区间的子区间的右界下标 ($i-1$)，也即区间和逻辑结点 $tree$ 的下标，依次将得到的 $tree[i-1]$ 累计即可得到要求的前缀区间和。可见 <code>preSum(k)</code> 方法的主体是一循环，循环条件是 $i &gt; 0$ ，循环终止时 ( $i&#x3D;&#x3D;0$ ) 求出 $nums[0]$ 到 $nums[k]$ 的和，不难写出如下 $sum$ 和 $preSum$ 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 区间查询 (区间求和): 求 nums[l] 到 nums[r] 之和</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> preSum(r) - preSum(l - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 求前缀和: 求 nums[0] 到 nums[k] 的区间和 (前 k+1 项和)</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">preSum</span><span class="params">(<span class="type">int</span> k)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k + <span class="number">1</span>; i &gt; <span class="number">0</span>; i -= lowbit(i))&#123;</span><br><span class="line">        ans += tree[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下图展示了 $preSum(14)$ 的过程。</p><p><img src="https://pic.leetcode-cn.com/1665819908-OJmBsN-image.png" alt="image.png"></p><br /><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>从「区间划分」入手，我们得出了基本树状数组所要解决的单点修改和区间查询操作，这两种操作都要建立在最初 $tree[]$ 有值的情况下，现在我们回过头分析 $tree[]$ 的初始化。 一开始 $tree[]$ 所有元素值均为 0，前面我们说过，单点修改 $nums[i]$ 时，首个需要更新的结点的区间和为 $tree[i]$ ，调用 $add(i, nums[i])$ 方法，更新 $tree[i]$ 之后，$add$ 中的 $for$ 循环会沿着蓝色链条向上更新所有包含该修改点的更大的区间结点的区间和。因此， $tree[]$ 的初始化可以按 <strong>任意顺序</strong> 调用 $n$ 次 $add$ 初始化 $n$ 个区间的区间和，每次调用 $add$ 更新某个区间和时，总能保证受影响的更大区间的区间和得到更新。一般我们按 $0 \sim n-1$ 的顺序初始化 $tree$ (即按 $0 \sim n-1$ 的顺序调用 $add(i, nums[i])$ )，在树状数组类的实现中，初始化部分如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单点修改区间查询</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PURQBIT</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] nums, tree; <span class="comment">// nums 为输入数组，tree 为对应 nums 的区间和树状数组</span></span><br><span class="line">    <span class="type">int</span> n; <span class="comment">// nums大小</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PURQBIT</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.nums = nums;</span><br><span class="line">        <span class="built_in">this</span>.n = nums.length;</span><br><span class="line">        <span class="built_in">this</span>.tree = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            add(i, nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h4 id="时空复杂度"><a href="#时空复杂度" class="headerlink" title="时空复杂度"></a>时空复杂度</h4><p><strong>时间复杂度:</strong> </p><ol><li><p><strong>单点修改时间复杂度</strong> : $O(logn)$ 。</p><p>取决于更新结点到根结点的路径上的结点数，更新 $nums<a href="k=0">0</a>$ 时路径上结点数最多，其数量为 $i&#x3D;k+1$ 从 $(000…001)_2$ 通过 $i +&#x3D; lowbit(i)$ 逐位更新到 $(n)_2$ 的更新次数。该数量不会大于 $(n)_2$ 的位数，也即 $logn$ ，因此单点修改的时间复杂度为 $O(logn)$。</p></li><li><p><strong>区间查询时间复杂度</strong> : $O(logn)$ 。</p><p>区间为 $[l, r]$， $[0,l-1]$ 与 $[0,r]$ 的连续子区间个数分别为 $p, q$ 个，则区间查询复杂度取决于 $max(p,q)$ 。根据子区间界的计算方法，子区间个数与 $i$ 的二进制数中 1 的数量有关 ( $i$ 为区间右界 $k$ 加 1，$i&#x3D;k+1$ )，假设 $i$ 的二进制数有 $t$ 位，则 $i&#x3D;2^t-1$ 时 1 的位数最多，共 $t$ 个，  $t&#x3D;log(i+1)$。根据 $sum$ 方法，要求 $[0,l-1]$ 以及 $[0,r]$ 的前缀区间和，时间复杂度为 $O(2*t)$ 。故区间查询的时间复杂度为 $O(logn)$。</p></li><li><p><strong>初始化时间复杂度</strong> ： 调用 $n$ 次 $add$ ，时间复杂度为 $O(nlogn)$ 。</p></li></ol><p><strong>空间复杂度:</strong> $O(n)$ ，即 $tree$ 数组大小 $n$ 。 </p><br /><h4 id="类的实现代码"><a href="#类的实现代码" class="headerlink" title="类的实现代码"></a>类的实现代码</h4><p>以下是「基本树状数组」 (PURQ BIT) 的实现代码，所有方法均已分析。「实战应用」中给出的 <a href="https://leetcode.cn/problems/range-sum-query-mutable/">307. 区域和检索 - 数组可修改</a> 是基本树状数组 (PURQ BIT) 模版题，利用我们给出的代码可轻松解决，详细可参考 <a href="https://leetcode.cn/problems/range-sum-query-mutable/solution/yukiyama-by-yukiyama-euo5/">题解</a> 。</p><p>在这里对 $tree$ 的下标范围做一个特别说明。最早给出的实现代码中，采用的是 $tree$ 大小为 $n+1$ 的实现，即 $tree[i]$ 为以 $nums[i-1]$ 为右界的子区间的区间和。但后来感觉还是让 $tree$ 与 $nums$ 完全对齐会更方便理解，即 $tree[i]$ 为以 $nums[i]$ 为右界的子区间的区间和，毕竟下标总是加一减一多少会带来一些思考负担。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单点修改区间查询</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PURQBIT</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] nums, tree; <span class="comment">// nums 为输入数组，tree 为对应 nums 的区间和树状数组</span></span><br><span class="line">    <span class="type">int</span> n; <span class="comment">// nums大小</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PURQBIT</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.nums = nums;</span><br><span class="line">        <span class="built_in">this</span>.n = nums.length;</span><br><span class="line">        <span class="built_in">this</span>.tree = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            add(i, nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单点修改: 令 nums[k] = x</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span> <span class="params">(<span class="type">int</span> k, <span class="type">int</span> x)</span>&#123;</span><br><span class="line">        add(k, x - nums[k]);</span><br><span class="line">        nums[k] = x; <span class="comment">// 更新 nums[k] 为 x</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单点修改: 令 nums[k] += x</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> x)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k + <span class="number">1</span>; i &lt;= n; i += lowbit(i))&#123;</span><br><span class="line">            tree[i - <span class="number">1</span>] += x; <span class="comment">// 包含第 k 项的区间都加上 x</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区间查询 (区间求和): 求 nums[l] 到 nums[r] 之和</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> preSum(r) - preSum(l - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 求前缀和: 求 nums[0] 到 nums[k] 的区间和 (前 k+1 项和)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">preSum</span><span class="params">(<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k + <span class="number">1</span>; i &gt; <span class="number">0</span>; i -= lowbit(i))&#123;</span><br><span class="line">            ans += tree[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">lowbit</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i &amp; -i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h3 id="RUPQ-BIT-区改单查"><a href="#RUPQ-BIT-区改单查" class="headerlink" title="RUPQ BIT (区改单查)"></a>RUPQ BIT (区改单查)</h3><p>基本树状数组 (PURQ BIT) 很好地支持了「单点修改」及「区间查询」操作。我们进一步思考更多的区间操作，例如 <strong>「区间修改」</strong> 操作，即将指定区间的每一个元素都加上同一个值，也叫「增量式区间修改」，如果仍用基本树状数组，我们只能对区间内的每一个元素都执行一次单点修改来实现，这显然不是我们想要的。接下来我们介绍的 RUPQ BIT 引入差分数组 $diff[]$ ，使得 <strong>「区间修改」</strong> 和 <strong>「单点查询」</strong> 操作的时间复杂度均为 $O(logn)$ 。</p><br /><h4 id="差分数组"><a href="#差分数组" class="headerlink" title="差分数组"></a>差分数组</h4><p>「RUPQ BIT」实现的关键是 <strong>「差分数组」</strong> 。对大小为 $n$ 的输入数组 $nums$ ，对应的差分数组 $diff$ 为：<br>$$<br>\begin{aligned}<br>diff[0] &amp;&#x3D;nums[0] \<br>diff[i] &amp;&#x3D; nums[i] - nums[i - 1] (i&gt;0)<br>\end{aligned}<br>$$<br>下面我们指出关于差分数组的重要性质。 </p><ol><li><strong>区间修改</strong> : $[l, r]$ 区间每个元素加 $x$ 。根据 $diff$ 的定义，除了 $diff[l] +&#x3D; x$ 、$diff[r+1] -&#x3D; x$ 外，其他 $diff$ 元素值不变。因为若两个作差的元素都增加了 $x$ ，则差值不变。 </li><li><strong>单点查询</strong> : 由于我们不修改 $nums$  的元素 (否则时间复杂度为 $O(n)$ )，因此区间修改后，我们将无法再通过 $nums$ 来查询单个元素值。但通过下式，我们有 $nums[k] &#x3D; \sum_{i&#x3D;0}^{k} diff[i]$，也就是 $diff[0]$ 到 $diff[k]$ 的和 (前缀和) 为 $nums[k]$ 。</li></ol><p>$$<br>\begin{aligned}<br>nums[k] &amp;&#x3D;(nums[k]-nums[k-1])+(nums[k-1]-nums[k-2])+…+ \<br>&amp;\quad (nums[1]-nums[0])+nums[0] \<br>&amp;&#x3D; diff[k]+diff[k - 1]+…+diff[1]+diff[0]<br>\end{aligned}<br>$$</p><p>对于「单点查询」，例如 $nums &#x3D; {4,2,-2,7,8}$，则 $diff &#x3D;{4,-2,-4,9,1}$ 。我们对先对 $[1,3]$ 区间加 3，然后再求 $nums[2]$ 。 </p><table><thead><tr><th>操作</th><th>nums</th><th>diff</th></tr></thead><tbody><tr><td>初始</td><td>${4,2,-2,7,8}$</td><td>${4,-2,-4,9,1}$</td></tr><tr><td>$[1,3]$ 区间加 3</td><td>${4,5,1,10,8}$ <br />※ 实际不修改 $nums$</td><td>${4,1,-4,9,-2}$</td></tr></tbody></table><p>对照上表与前述分析，可以看到 $diff[]$ 中除了 $diff[1]+&#x3D;3$ 及 $diff[4]-&#x3D;3$ ，其他不变。且 $nums[2]&#x3D;diff[0]+diff[1]+diff[2]&#x3D;1$ ，通过求 $diff$ 前缀和完成了单点查询。因此，借助「差分数组」，对 $nums$ 的区间修改实际可以通过对 $diff$ 执行两次 <strong>单点修改</strong> 来表达，时间复杂度为 $O(1)$ ，而对 $nums$ 的单点查询实际上是对 $diff$ 的 <strong>区间查询 (求前缀区间和)</strong> ， 时间复杂度为 $O(n)$ 。</p><p>如果把 $diff[]$ 数组看作 PURQ BIT 中的 $nums[]$ ，那么对原输入序列 $nums[]$ 的 <strong>区间修改</strong> ，可通过单点修改 $diff[l]$ 和 $diff[r+1]$ 来表达，对应了 PURQ BIT 中的 $add$ 操作。对原输入序列 $nums[]$ 的 <strong>单点查询</strong> 则对应基本 BIT 中的求前缀和的 $preSum$ 操作。下面我们分析 RUPQ BIT，并给出实现。</p><br /><h4 id="从PURQ到RUPQ"><a href="#从PURQ到RUPQ" class="headerlink" title="从PURQ到RUPQ"></a>从PURQ到RUPQ</h4><p>经过前述分析，快速理解 RUPQ BIT 的关键只需明确一点: RUPQ BIT 中的 $tree[]$ 对应的是 $diff[]$ 的所有子区间的区间和。如下是 PURQ BIT 和 RUPQ BIT 的简单对比。</p><table><thead><tr><th></th><th>PURQ BIT</th><th>RUPQ BIT</th></tr></thead><tbody><tr><td>输入数组</td><td>$nums[]$</td><td>$nums[]$</td></tr><tr><td>前缀和求解对象</td><td>$nums[]$</td><td>$diff[]$</td></tr><tr><td>逻辑二元索引树</td><td>$nums[]$ 的所有子区间的区间和构成 $tree[]$</td><td>$diff[]$ 的所有子区间的区间和构成 $tree[]$</td></tr></tbody></table><p>通过「差分数组」的学习，我们知道 RUPQ BIT 的「区间修改」，实际上只需要执行 $add(l, x)$ 以及  $add(r+1,-x)$ 。我们已经知道，$add$ 方法中的 $for$ 循环会沿着结点的父链不断更新更大区间的区间和。这一点保证了「单点查询」时， 执行 $preSum(k)$ 能够取得正确的 $diff[0] \sim diff[k]$ 的和，也就是 $nums[k]$  。除了初始时需要从 $nums$ 求出 $diff$ ，RUPQ BIT 的 $add$ 和 $query$ 方法与 PURQ BIT 是完全相同的。</p><br /><h4 id="时空复杂度-1"><a href="#时空复杂度-1" class="headerlink" title="时空复杂度"></a>时空复杂度</h4><p>分析方法及结果均同 PURQ BIT。</p><br /><h4 id="类的代码实现"><a href="#类的代码实现" class="headerlink" title="类的代码实现"></a>类的代码实现</h4><p>以下是 RUPQ BIT 的实现代码。「实战应用」中给出的 <a href="https://leetcode.cn/problems/range-sum-query-mutable/">307. 区域和检索 - 数组可修改</a> 虽是基本树状数组 (PURQ BIT) 模版题，但我们也可以用 RUPQ BIT 解决。用左右界相同的区间修改来实现单点修改，对区间大小为 $k$ 的区间求和，执行 $k$ 次单点查询并累加来实现区间求和。当然，后者的时间复杂度为 $O(nlogn)$ ，比维护 $nums$ 并在其上直接累加 $k$ 个元素来实现区间求和还要糟糕，不过我们只是为了验证此处给出的 RUPQ BIT 的正确性，虽然超时，但不报错，说明我们给出的实现是正确的。详细可参考 <a href="https://leetcode.cn/problems/range-sum-query-mutable/solution/yukiyama-by-yukiyama-euo5/">题解</a> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 区间修改单点查询</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RUPQBIT</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] diff, tree; <span class="comment">// diff 为差分数组，tree 为对应 diff 的树状数组</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RUPQBIT</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123; <span class="comment">// nums 为输入数组</span></span><br><span class="line">        <span class="built_in">this</span>.n = nums.length; <span class="comment">// 有效元素个数</span></span><br><span class="line">        <span class="built_in">this</span>.diff = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="built_in">this</span>.tree = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        diff[<span class="number">0</span>] = nums[<span class="number">0</span>]; <span class="comment">// 求diff[]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++)&#123; <span class="comment">// 求 diff[]</span></span><br><span class="line">            diff[i] = nums[i] - nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123; <span class="comment">// 初始化 tree[]</span></span><br><span class="line">            add(i, diff[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区间修改: nums[l] 到 nums[r] 所有元素加上 x</span></span><br><span class="line">    <span class="comment">// --&gt; 实际单点修改 diff[l] 和 diff[r + 1]</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span>&#123;</span><br><span class="line">        add(l, x);</span><br><span class="line">        add(r + <span class="number">1</span>, -x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单点查询: nums[k]</span></span><br><span class="line">    <span class="comment">// --&gt; 实际求 diff 的前缀区间和 ([0, k])</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> preSum(k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单点修改: 令 diff[k] += x</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> x)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k + <span class="number">1</span>; i &lt;= n; i += lowbit(i))&#123;</span><br><span class="line">            tree[i - <span class="number">1</span>] += x; <span class="comment">// 包含第 k 项的区间都加上 x</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 求前缀和: 求 diff[0] 到 diff[k] 的区间和 (前 k+1 项和)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">preSum</span><span class="params">(<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k + <span class="number">1</span>; i &gt; <span class="number">0</span>; i -= lowbit(i))&#123;</span><br><span class="line">            ans += tree[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">lowbit</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i &amp; -i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们已经有了 PURQ BIT ，因此 RUPQ BIT 可以十分简单地调用前者的方法即可，所以 RUPQ BIT 类也可以这么写。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 区间修改单点查询</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RUPQBIT2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> PURQBIT purqBit;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RUPQBIT2</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123; <span class="comment">// nums 为输入数组</span></span><br><span class="line">        <span class="type">int</span>[] diff = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        diff[<span class="number">0</span>] = nums[<span class="number">0</span>]; <span class="comment">// 求diff[]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++)&#123; <span class="comment">// 求 diff[]</span></span><br><span class="line">            diff[i] = nums[i] - nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.purqBit = <span class="keyword">new</span> <span class="title class_">PURQBIT</span>(diff);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区间修改: nums[l] 到 nums[r] 所有元素加上 x</span></span><br><span class="line">    <span class="comment">// --&gt; 实际单点修改 diff[l] 和 diff[r + 1]</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span>&#123;</span><br><span class="line">        purqBit.add(l, x);</span><br><span class="line">        purqBit.add(r + <span class="number">1</span>, -x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单点查询: nums[k]</span></span><br><span class="line">    <span class="comment">// --&gt; 实际求 diff 的前缀区间和 ([0, k])</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> purqBit.sum(<span class="number">0</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h3 id="RURQ-BIT-区改区查"><a href="#RURQ-BIT-区改区查" class="headerlink" title="RURQ BIT (区改区查)"></a>RURQ BIT (区改区查)</h3><p>本小节介绍第三种树状数组，RURQ BIT ，即 <strong>「区间修改区间查询」树状数组</strong> 。RURQ BIT 以 $O(logn)$ 时间复杂度支持 <strong>「区间修改」</strong> 及 <strong>「区间查询」</strong> 。</p><br /><h4 id="从RUPQ到RURQ"><a href="#从RUPQ到RURQ" class="headerlink" title="从RUPQ到RURQ"></a>从RUPQ到RURQ</h4><p>该版本的 BIT 在 RUPQ BIT 差分数组的基础上， 通过如下算式推导发现只需 <strong>再引入一棵逻辑树</strong> 即可同时以 $O(logn)$ 时间复杂度实现 <strong>「区间修改」</strong> 及 <strong>「区间查询」</strong> 。<br>$$<br>\begin{aligned}<br>sum(l,r) &amp;&#x3D; preSum(r)-preSum(l-1) \<br>&amp;&#x3D; (nums[0]+nums[1]+,…,+nums[r])-(nums[0]+nums[1]+…+nums[l-1]) \<br>\end{aligned}<br>$$</p><p>$$<br>\begin{aligned}<br>preSum(k)&amp;&#x3D;nums[0]+nums[1]+,…,+nums[k] \<br>&amp;&#x3D;diff[0]+(diff[0]+diff[1])+,…,+(diff[0]+diff[1]+,…,+diff[k])\<br>&amp;&#x3D;(k+1)<em>diff[0]+k</em>diff[1]+,…,+diff[k] \<br>&amp;&#x3D;(k+1)<em>(diff[0]+diff[1]+,…,+diff[k])\<br>&amp;\quad -(0</em>diff[0]+1<em>diff[1]+,…,+k</em>diff[k])<br>\end{aligned}<br>$$</p><p>从 $preSum(k)$ 的推导的最后一行可以看到，减号左边是 $k+1$ 倍的 $preSum(k)$ (RUPQ BIT)，而右边可以引入新的逻辑树数组 $helperTree$ 来维护数组 $helperArr&#x3D;{i*diff[i]}, i∈[0,n-1]$ 的区间和，每次区间修改时，同时修改 $tree, helperTree$ ，如此，便可通过上面给出的式子实现「区间查询」。具体实现请看「类的实现代码」。</p><br /><h4 id="时空复杂度-2"><a href="#时空复杂度-2" class="headerlink" title="时空复杂度"></a>时空复杂度</h4><p>分析方法及结果类似 PURQ BIT。</p><br /><h4 id="类的实现代码-1"><a href="#类的实现代码-1" class="headerlink" title="类的实现代码"></a>类的实现代码</h4><p>以下是 RURQ BIT 的实现代码。「实战应用」中给出的 <a href="https://leetcode.cn/problems/range-sum-query-mutable/">307. 区域和检索 - 数组可修改</a> 虽是基本树状数组 (PURQ BIT) 模版题，但我们也可以用 RURQ BIT 解决。其中，单点修改用左右界相同的区间修改来实现，通过 RURQ BIT 实现的 PU &#x2F; RQ 操作的时间复杂度也都是 $O(logn)$。详细可参考 <a href="https://leetcode.cn/problems/range-sum-query-mutable/solution/yukiyama-by-yukiyama-euo5/">题解</a> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 区间修改区间查询</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RURQBIT</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] diff, tree, helperTree;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RURQBIT</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.n = nums.length; <span class="comment">// 有效元素个数</span></span><br><span class="line">        <span class="built_in">this</span>.diff = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="built_in">this</span>.tree = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="built_in">this</span>.helperTree = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        diff[<span class="number">0</span>] = nums[<span class="number">0</span>]; <span class="comment">// 求diff[]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++)&#123; <span class="comment">// 求 diff[]</span></span><br><span class="line">            diff[i] = nums[i] - nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123; <span class="comment">// 初始化 tree[] 和 helperTree[]</span></span><br><span class="line">            add(tree, i, diff[i]);</span><br><span class="line">            add(helperTree, i, i * diff[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区间修改: nums[l] 到 nums[r] 所有元素加上 x</span></span><br><span class="line">    <span class="comment">// --&gt; 实际单点修改 diff[l], diff[r + 1] 及对应的 l * diff[l], (r + 1) * diff[r + 1]</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span>&#123;</span><br><span class="line">        add(tree, l, x);</span><br><span class="line">        add(tree, r + <span class="number">1</span>, -x);</span><br><span class="line">        add(helperTree, l, l * x);</span><br><span class="line">        add(helperTree, r + <span class="number">1</span>, (r + <span class="number">1</span>) * (-x));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区间查询 (区间求和): 求 nums[l] 到 nums[r] 之和</span></span><br><span class="line">    <span class="comment">// --&gt; 实际求两次前缀和后作差</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">preSumLeft</span> <span class="operator">=</span> l * preSum(tree, l - <span class="number">1</span>) - preSum(helperTree, l - <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">preSumRight</span> <span class="operator">=</span> (r + <span class="number">1</span>) * preSum(tree, r) - preSum(helperTree, r);</span><br><span class="line">        <span class="keyword">return</span> preSumRight - preSumLeft;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 求前缀和: 求 thisTree 对应的序列的 [0, k] 前缀区间之和</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">preSum</span><span class="params">(<span class="type">int</span>[] thisTree, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k + <span class="number">1</span>; i &gt; <span class="number">0</span>; i -= lowbit(i))&#123;</span><br><span class="line">            ans += thisTree[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单点修改: 为 thisTree 对应的序列下标为 k 的元素加上 x</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span>[] thisTree, <span class="type">int</span> k, <span class="type">int</span> x)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k + <span class="number">1</span>; i &lt;= n; i += lowbit(i))&#123;</span><br><span class="line">            thisTree[i - <span class="number">1</span>] += x; <span class="comment">// 包含下标为 k 的项的区间都加上 x</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">lowbit</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i &amp; -i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h3 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h3><p>对于区间问题，当我们只关心输入数组 $nums$ 元素的大小关系而不关心元素的具体值时，为了压缩空间，我们先将 $nums$ 离散化。常见的离散化方式有两种，它们都基于排序，但其中一种借助了 $set$ 去重，使得离散化后的有效数字更少，取值范围更小，我把这种方式称为 <strong>「紧离散」</strong> ；另一种则没有去重，因此离散化后的有效数字更多 (存在相同的数字)，取值范围也更大，我称之为 <strong>「松离散」</strong> 。以下是两种离散化方式的实现。</p><p><strong>松离散</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 松离散方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">discrete</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123; </span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span>[] tmp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    System.arraycopy(nums, <span class="number">0</span>, tmp, <span class="number">0</span>, n);</span><br><span class="line">    Arrays.sort(tmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        nums[i] = Arrays.binarySearch(tmp, nums[i]) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>紧离散</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 紧离散方法</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;Integer, Integer&gt; <span class="title function_">discrete</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123; </span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> num : nums) set.add(num);</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(set);</span><br><span class="line">    Collections.sort(list);</span><br><span class="line">    <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> num : list) map.put(num, ++idx);</span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如对于 $nums&#x3D;{2,4,4,6}$ ，松离散得到 $nums&#x3D;{1,2,2,4}$，离散化后的 $nums$ 大小与原来相同；紧离散得到 $map&#x3D;{(2,1),(4,2),(6,3)}$ ， $key$ 为 $nums$ 中的元素，对应的 $value$ 为其离散化值，$value$  一定是从 1 开始的没有重复的连续正整数。两种方式离散化后虽然有效数字不同，取值范围也不同，但求解结果都是正确的 (读者可以思考一下为什么)。松离散无需哈希计算，通常速度更快，但有的题目可能更适合返回 $map$ 的紧离散 (例如 <a href="https://leetcode.cn/problems/count-of-range-sum/">327. 区间和的个数</a> 和 <a href="https://leetcode.cn/problems/reverse-pairs/">493. 翻转对</a> )。</p><br /><h3 id="指定区间内指定取值范围的元素数"><a href="#指定区间内指定取值范围的元素数" class="headerlink" title="指定区间内指定取值范围的元素数"></a>指定区间内指定取值范围的元素数</h3><p>下面我们重点介绍巧用树状数组解决的一类常见问题 ── <strong>求指定区间 $[l,r]$ 内大小在指定取值范围 $[lower, upper]$ 内的元素数</strong> 。</p><p>有点拗口？没关系，我们先从著名的 <strong>「逆序对」</strong> 问题开始。 <a href="https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">剑指 Offer 51. 数组中的逆序对</a> 一题，求输入数组 $nums$ 的逆序对， <strong>是树状数组的经典应用，更是一个「妙用」</strong> 。我们指出，它属于本节标题「指定区间指定取值范围的元素数」的范畴。</p><p>但在讨论树状数组解法之前，我们先给出最朴素两层循环做法 (该做法有许多不同的写法，这里选取一种与我们树状数组解法最为对应的写法)。</p><ul><li><p>外层循环遍历 $nums$ ，对于当前元素 $nums[i]$ ，内层循环 <strong>顺序遍历</strong>  $nums<a href="j%3Ei">j</a>$ ，如果 $nums[i]&gt;nums[j]$ ，则 $(nums[i],num[j])$ 是一个逆序对，令  $countGreater[j]++$ ， $countGreater[j]$ 表示 $nums[j]$ 与其左侧的数形成的逆序对的个数。</p></li><li><p>当程序结束时，每一个 $countGreater[i]$ 就是 $nums[i]$ 的逆序数 (逆序对形式为 $(x,nums[i]),x&gt;nums[i]$ ，$x$ 是 $nums[i]$ 左侧的元素)，累计所有的 $countGreater[i]$ 就是所要求的 $nums$ 的逆序对总数。由于 $countGreater[i]$ 是在结束针对d $nums[i-1]$ 的内层循环时确定的，因此在开始 $nums[i]$ 内层循环前累计。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">reversePairs</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] countGreater = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            ans += countGreater[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt; nums[j]) countGreater[j]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再回到树状数组的做法，如下。其中的 $discrete$ 是「离散化」一节给出的「松离散」方法，BIT 类是我们在前面给出的 PURQ BIT 类 (该题详细 <a href="https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/solution/by-yukiyama-elnl/">题解</a> )。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">reversePairs</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        discrete(nums); <span class="comment">// 松离散</span></span><br><span class="line">        <span class="type">BIT</span> <span class="variable">bit</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BIT</span>(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            ans += bit.preSum((nums[i] - <span class="number">1</span>) - <span class="number">1</span>);</span><br><span class="line">            bit.add(nums[i] - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在主方法 $reversePairs$ 中，首先将 $nums$ 离散化 (后续的 $nums$ 均指离散化后的 $nums$ ) ，接着 <strong>逆序遍历</strong> $nums$ 元素，对每一个 $nums[i]$ ，依次执行 $preSum$ 和 $add$ 方法。我们知道 $preSum(k)$ 是求输入序列前 $k+1$ 项的和，$add(k,x)$ 是从首个包含下标为 $k$ 的元素的区间开始，为所有包含该元素的区间的区间和加上 $x$ 。那么代码中的 $add(nums[i]-1,1)$ 是什么意思呢？对比朴素做法，可知 $add(nums[i]-1,1)$ 相当于朴素做法的内层循环，用于计算「当前元素逆序数」，分析如下。</p><p>该方法使得 $tree$ 从 $tree[nums[i]-1]$ 开始，沿着父链上升，包含下标为 $nums[i]-1$ 的更大区间 $x$ 的 $tree[x]$ 加 1 。$tree$ 的下标范围 $[0,n-1]$ 与 (松离散化后的)  $nums$ 元素值的大小范围 $[1,n]$  <strong>一一对应</strong>  ，可以把 $add$ 方法 (以及 $preSum$ 方法) 中的 $nums[i]-1$ 等同于原数组中的 $nums[i]$ 方便理解。 $tree[i]$ 的意义也不再是区间和。</p><p>举例说明。假设松离散化后有 $nums &#x3D; {2,6,8,7,4,5,1,3}$ ，逆序遍历 $nums[i]$ 并执行 $add(nums[i]-1,1)$ 。对第一个遍历到的 $nums[7]&#x3D;3$ 执行 $add(2, 1)$ (操作 ① )，如下图。</p><p><img src="https://pic.leetcode-cn.com/1665827150-VTykUh-image.png" alt="image.png"></p><p>$add$ 操作使得 $tree[2]$ , $tree[3]$ , $tree[7]$ 增加 1 ，其意义相当于为数组中 <strong>大于等于</strong> $nums[7]$ 的所有数 $nums[j]$ ，都执行 $countGreaterEqual[j]++$ 。注意，树状数组做法中不存在 $countGreaterEqual$ ，这里只是类比朴素方法中的 $CounterGreater$ 数组。那我们如何得到此时的 $countGreaterEqual[j]$ 呢？从代码中我们已经知道，通过执行 $preSum$ 方法求得。</p><p>由于我们从后往前求逆序对，因此我们考察左侧元素 $nums[j]$ 的 $countGreaterEqual[j]$ (不存在该数组，只是类比) 是否被正确更新了。由上图很容易看出，可通过 $preSum(nums[j]-1)$ 查询到。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">preSum(nums[6] - 1) = preSum[0] = 0</span><br><span class="line">preSum(nums[5] - 1) = preSum[4] = 1</span><br><span class="line">preSum(nums[4] - 1) = preSum[3] = 1</span><br><span class="line">preSum(nums[3] - 1) = preSum[6] = 1</span><br><span class="line">preSum(nums[2] - 1) = preSum[7] = 1</span><br><span class="line">preSum(nums[1] - 1) = preSum[5] = 1</span><br><span class="line">preSum(nums[0] - 1) = preSum[1] = 0</span><br></pre></td></tr></table></figure><p>所以本质上 $add(nums[i]-1,1)$ 操作相当于对 $nums$ 中的 <strong>大于等于</strong>  $nums[i]$ 的所有的 $nums[j]$ ，使其对应的 $countGreaterEqual[j]$ 加 1 。而 $counterGreaterEqual[j]$ 是通过 $preSum(nums[j]-1)$ 求得的。遍历 $nums[i]$ 时，以它为逆序对左元素 (即 $(nums[i], x)$ 形式，$x$ 是 $nums[i]$ 右侧的元素) 的逆序对数量在上一轮执行 $add[nums[i-1] - 1, 1]$ 后就完全确定了，因此先执行 $preSum$ 方法累计该逆序对数。</p><p>需要注意的是，当我们执行 $preSum(nums[i]-1)$ 时，求的是 ${(nums[i],x), nums[i]≥x}$  的数量 (对应 $counterGreaterEqual[i]$)，而逆序对要求的是 ${(nums[i],x), nums[i]&gt;x}$ (对应 $counterGreater[i]$) ，即严格大于才算逆序。要如何处理呢？再次看向树状图，以 $preSum(6)$ 为例，其结果为 $tree[6]+tree[5]+tree[3]$ ，其中 $tree[6]$ 就代表了等于时带来的累计量，去掉这个累计量只需要向左侧移动一位即可，即求 $preSum(5)$ 。对应到题解代码中，即为 $preSum((nums[i]-1)-1)$ ，或写成 $preSum(nums[i]-2)$ ，对应了朴素解法中的 $counterGreater[i]$ 。</p><p>现在我们将树状数组解法与朴素解法对比如下。</p><table><thead><tr><th>操作</th><th>朴素解法</th><th>树状数组解法</th></tr></thead><tbody><tr><td>累计当前元素的逆序数</td><td><code>ans += countGreater[i];</code><br />$(x,nums[i]),x&gt;nums[i]$ 形式逆序对</td><td><code>ans += bit.preSum(nums[i] - 2);</code><br />$(nums[i],x),nums[i]&gt;x$ 形式逆序对</td></tr><tr><td>计算当前元素的逆序数</td><td>内层循环<br />$(nums[i],x),nums[i]&gt;x$ 形式逆序对</td><td><code>bit.add(nums[i] - 1, 1);</code><br />$(x,nums[i]),x&gt;nums[i]$ 形式逆序对</td></tr></tbody></table><p>我们惊讶地发现，$add$ 方法本质上完成了朴素做法的内层循环所做的事，并且是以 $O(logn)$ 时间复杂度完成的。而且实际上完成得更多，因为朴素做法更新的是 $nums[i]$ 右侧的小于 $nums[i]$ 的 $nums[j] (j&gt;i)$ 的 $countGreater[j]$ ，而树状数组 $add$ 方法是对所有大于等于 $nums[i]$ 的 $nums[j]$ 更新其 $countGreaterEqual[j]$ (类比，实际通过 $preSum(num[j]-1)$ 求出)，并不限制在 $nums[i]$「左侧」，只不过我们按逆序方向执行 (向左处理)，即便 $nums[i]$ 右侧某个元素大于 $nums[i]$ ，经由 $add$ 方法使该数对应的逆序数增加 1，它也没有机会再被累加了，况且，它在 $nums[i]$ 右侧，与 $nums[i]$ 构成的实际上是正序对。</p><p>总之，我们将一个 $nums$ 离散化后，逆序遍历它，先执行 $preSum(nums[i]-2)$ ，这个操作即为获取 ${(nums[i],x),nums[i]&gt;x}$ 形式的逆序对对数。再执行 $add(nums[i]-1, 1)$ 找到 ${(x,nums[i]),x&gt;nums[i]}$ 形式的逆序对，更新相应的 $tree[]$ 值。</p><p>实际上 $preSum(([nums[i]-1)-1])$ 就是本小节标题「指定区间内指定取值范围的元素数」 的体现。即执行 $preSum((nums[i]-1)-1)$ 时，查询 $[i+1,n-1]$ 区间取值范围为 $[1,nums[i]-1]$ 的数的数量  (即 ${(nums[i],nums[j]),j∈[i+1,n-1]}$ 逆序对的数量)。</p><p>对于前面的例子 $nums &#x3D; {2,6,8,7,4,5,1,3}$ ，我们给出执行 ① ~ ⑧ 后得到的树形图，供读者仔细验证。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">① add(2, 1)</span><br><span class="line">② add(0, 1)</span><br><span class="line">③ add(4, 1)</span><br><span class="line">④ add(3, 1)</span><br><span class="line">⑤ add(6, 1)</span><br><span class="line">⑥ add(7, 1)</span><br><span class="line">⑦ add(5, 1)</span><br><span class="line">⑧ add(1, 1)</span><br></pre></td></tr></table></figure><p><img src="https://pic.leetcode-cn.com/1665830781-SDAcPL-image.png" alt="image.png"></p><p>在理解了「遍历离散化后的 $nums$ ，在遍历过程中执行 $preSum$ 及 $add$ 」的意义后，类似的题目如下:</p><ul><li><a href="https://leetcode.cn/problems/count-of-smaller-numbers-after-self/">315. 计算右侧小于当前元素的个数</a> 题，与「逆序数」问题的区别仅在此题要求解「小于」，逆序数问题中涉及的是「小于等于」，只需要在「小于等于」版本的代码上做简单调整即可，详情见题解。</li><li><a href="https://leetcode.cn/problems/queue-reconstruction-by-height/">406. 根据身高重建队列</a> 也是用树状数组求对于当前元素它之前的「小于等于」它的元素个数的问题，具体实现需结合二分查找，这是树状数组与其他方法相结合的一个好例子。</li><li><a href="https://leetcode.cn/problems/reverse-pairs/">493. 翻转对</a> 。「逆序对」的变形题，$query(x)$ 中 $x$ 的范围超过了离散化后 $nums$ 的取值范围，这一点类似 327 题，可能会被查询的数值要与原 $nums$ 中的数一起离散化。</li><li><a href="https://leetcode.cn/problems/count-of-range-sum/">327. 区间和的个数</a> 。此题是更进阶的题目，不仅求解对象从 $nums$ 变成了 $preSums$ ，$lower, upper$ 的范围也不再是 $[1,n]$  ($n$ 是 $nums$ 的大小) 。这道题细节处理较多，详细内容请看题解。</li></ul><p>不得不说树状数组的这个应用确实十分抽象，希望读者仔细阅读本节内容后能够完全理解。关于这几题的详细题解和更多的树状数组题目，请参考「实战应用」。</p><br /><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>关于「树状数组」，总结本文内容如下。</p><ol><li>基本的树状数组 (PURQ BIT) 以 $O(logn)$ 时间复杂度解决长度为 $n$ 的序列的 <strong>单点修改</strong> 及 <strong>区间查询</strong> 问题。</li><li>我们从区间查询出发，思考如何利用类似倍增思想的做法来划分子区间，从而提高区间查询的效率。</li><li>通过对 $nums$ 下标二进制形式的观察，找到了一种将输入序列划分为 $n$ 个子区间的方式。链接子区间及包含它的更大一点的子区间后，这些子区间构成一棵或多棵逻辑上的多叉的 <strong>「二元索引树」</strong> 。</li><li>单点修改及区间查询的时间复杂度都与 $(n)_2$ 的位数相关，简单分析后可知它们都是时间为 $O(logn)$ 的操作。</li><li>在 PURQ BIT 的基础上，引入 <strong>差分数组</strong> ，实现了 RUPQ BIT。</li><li>在 RUPQ BIT 的基础上，根据 <strong>算式推导</strong> ，引入 <strong>辅助树状数组</strong> ，实现了 RURQ BIT。</li><li>当区间问题只关心元素之间的大小关系而不关心元素值时，可以先将输入序列 <strong>离散化</strong> ，有助于提高求解效率或帮助解决一些特定问题。离散化实现包括 <strong>松离散</strong> 和 <strong>紧离散</strong> 。</li><li>「求指定区间 $[l,r]$ 内大小在指定取值范围 $[lower, upper]$ 内的元素数」是一类特定的可用树状数组巧妙解决的问题。</li></ol><p>总结不同方式的 PU&#x2F;PQ&#x2F;RU&#x2F;RQ 操作的时间复杂度如下。</p><table><thead><tr><th>方式</th><th>单点修改</th><th>单点查询</th><th>区间修改</th><th>区间查询</th></tr></thead><tbody><tr><td>普通数组</td><td>$O(1)$</td><td>$O(1)$</td><td>$O(n)$</td><td>$O(n)$</td></tr><tr><td>普通数组+前缀和数组</td><td>$O(n)$</td><td>$O(1)$</td><td>$O(n)$</td><td>$O(1)$</td></tr><tr><td>差分数组</td><td>$O(1)$</td><td>$O(n)$</td><td>$O(1)$</td><td>$O(n)$</td></tr><tr><td>PURQ BIT</td><td>★ $O(logn)$</td><td></td><td></td><td>★ $O(logn)$</td></tr><tr><td>RUPQ BIT</td><td></td><td>★ $O(logn)$</td><td>★ $O(logn)$</td><td></td></tr><tr><td>RURQ BIT</td><td></td><td></td><td>★ $O(logn)$</td><td>★ $O(logn)$</td></tr></tbody></table><p>值得注意的是，RURQ BIT 对大小为1的区间执行区间修改和区间查询实际上就是单点修改和单点查询，因此 RURQ BIT 以 $O(logn)$ 复杂度同时实现了 单点修改 &#x2F; 单点查询 &#x2F; 区间修改(增量式) &#x2F; 区间查询(区间求和) 操作。</p><br /><h3 id="实战应用"><a href="#实战应用" class="headerlink" title="实战应用"></a>实战应用</h3><table><thead><tr><th>题目</th><th>难度</th><th>题解</th></tr></thead><tbody><tr><td><a href="https://leetcode.cn/problems/range-sum-query-mutable/">307. 区域和检索 - 数组可修改</a><br />※ PURQBIT模版题</td><td>中等</td><td><a href="https://leetcode.cn/problems/range-sum-query-mutable/solution/yukiyama-by-yukiyama-euo5/">题解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">剑指 Offer 51. 数组中的逆序对</a></td><td>困难</td><td><a href="https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/solution/by-yukiyama-elnl/">题解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/count-of-smaller-numbers-after-self/">315. 计算右侧小于当前元素的个数</a></td><td>困难</td><td><a href="https://leetcode.cn/problems/count-of-smaller-numbers-after-self/solution/yukiyama-by-yukiyama-nqas/">题解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/queue-reconstruction-by-height/">406. 根据身高重建队列</a></td><td>中等</td><td><a href="https://leetcode.cn/problems/queue-reconstruction-by-height/solution/yukiyama-shu-zhuang-shu-zu-er-fen-by-yuk-1ovu/">题解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/reverse-pairs/">493. 翻转对</a></td><td>困难</td><td><a href="https://leetcode.cn/problems/reverse-pairs/solution/by-yukiyama-ljyp/">题解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/count-of-range-sum/">327. 区间和的个数</a></td><td>困难</td><td><a href="https://leetcode.cn/problems/count-of-range-sum/solution/by-yukiyama-e9on/">题解</a></td></tr></tbody></table><br /><hr><p>【文章更新日志】</p><p>[2022-10-03]</p><ul><li>修改了目录结构。</li></ul><p>[2022-09-23]</p><ul><li>文章开头新增若干介绍文字。</li></ul><p>[2022-07-25]</p><ul><li><a href="/u/isuxiz/">@isuxiz</a> (isuxiz) 指出一处笔误，感谢 🙏。</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法与数据结构 </tag>
            
            <tag> 树状数组 </tag>
            
            <tag> 区间问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线段树从入门到急停</title>
      <link href="/2022/07/26/%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%80%A5%E5%81%9C/"/>
      <url>/2022/07/26/%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%80%A5%E5%81%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="线段树从入门到急停"><a href="#线段树从入门到急停" class="headerlink" title="线段树从入门到急停"></a>线段树从入门到急停</h1><p><strong>感谢官方推荐</strong> 🎉😄。</p><blockquote><ul><li><p>可在作者的 <a href="https://github.com/iyukiyama/leetcode-posts">github仓库</a> 中获取本文和其他文章的 markdown 源文件及相关代码。</p></li><li><p>欢迎评论或仓库 PR 指出文章错漏或与我讨论相关问题，我将长期维护所有文章。</p></li><li><p>所有文章均用 Typora 完成写作，可使用 Typora 打开文章 md 文件，以获得最佳阅读体验。</p></li></ul></blockquote><p>⚠️ ⚠️ ⚠️ <strong>谨以此两万五千字文章献给在线段树门前徘徊的朋友。</strong></p><p>❗️ <strong>【NEW】最新文章如下</strong> ❗️</p><ul><li>9-15:  <a href="https://leetcode.cn/circle/discuss/SwgIJV/">红黑树从入门到看开</a></li></ul><p>这是小白 yuki 推出的「树ADT」系列文章的第 11 篇 (11&#x2F;13) 。</p><hr><blockquote><p>$keywords$ :</p><p>完全二叉树下标性质 &#x2F; 分治算法 &#x2F; 单点查询 (维护或不维护 $nums$) &#x2F; 单点修改 ($add$ &amp; $update$) &#x2F; (增量式 &amp; 覆盖式) 区间修改 &#x2F; 区间查询 (求和 &amp; 求最值) &#x2F; 堆式 (静态) 线段树 &#x2F; 懒惰标记 &#x2F; 延迟修改 &#x2F; 离散化 (松离散 &amp; 紧离散) &#x2F; 强制在线 &#x2F; 动态开点 &#x2F; 结点数组法动态线段树 &#x2F; 结点指针 (引用) 法动态线段树</p></blockquote><p><strong>线段树</strong> 是著名的用于高效求解 <strong>「区间问题」</strong> 的数据结构。「区间问题」即对于输入数组 $nums$ ，在其上执行 <strong>「区间求和」</strong> 、 <strong>「区间修改」</strong> 等操作，通常还伴随着针对单个元素的 <strong>「单点查询」</strong> 、 <strong>「单点修改」</strong> 这两种单点操作。若直接操作 $nums$ ，则单点操作时间复杂度为 $O(1)$ ，而区间操作为 $O(n)$ ；若采用「前缀和」，则区间操作为 $O(1)$ ，而单点操作为 $O(n)$ 。利用完全二叉树下标特点 (静态堆式线段树) 或动态开点操作 (动态线段树)，将 $nums$ 上对任意元素值或任意区间值 (区间求和、区间最值等) 的求解，构建在一棵二叉树上，通过对该二叉树的分治处理 ($dfs$) ，<strong>同时实现 $O(logn)$ 时间复杂度的单点操作与区间操作</strong> 。</p><p>本文行文过程中，我会将线段树与另一种求解区间问题的数据结构 –– 「树状数组」做对比。虽然「线段树」与「树状数组」在原理上差别不小，但 <strong>「区间划分」</strong> 的思想是一致的。「树状数组」的特点是思维难度大，实现简单，「线段树」正好相反，思维难度低，实现相对复杂，且对于区间问题，线段树比树状数组更具普适性。不过我仍然建议你在阅读本文之前先阅读 <a href="https://leetcode.cn/circle/discuss/qGREiN/">树状数组</a> 一文，即便暂时理解不了树状数组中 $lowbit$ 的作用也没关系，有了「树」与「区间问题」相联系的印象后，再学习本文的「线段树」，然后再返回去学习「树状数组」，效果也许更好（主要是我先写了「树状数组」再写的「线段树」😅）。</p><p>本文将给出 <strong>十种</strong> 线段树的完整类实现代码 (静态 &amp; 动态)，可应对力扣中出现的 <strong>(几乎) 所有能用线段树解决的题目</strong> 。并在「实战应用」中给出近十道力扣上的线段树题目及详细题解 (持续增加中)。</p><p>另外，本文原题 「线段树 (树ADT连载 11&#x2F;13)」，十分干瘪，不太符合作者的气质，遂改为现标题。<strong>「急停」表示作者的一种希望</strong>，我猜想许多朋友跟作者一样，在求索线段树的路上狼奔豕突，相关文章和题解看了不少，却始终不得其法。现在，作者希望朋友们能够通过本文实现完美急停，此后 <strong>从容吟啸且徐行</strong>。</p><hr><p>yuki的其他文章如下，欢迎阅读指正！</p><blockquote><p>如下所有文章同时也在我的 github <a href="https://github.com/iyukiyama/leetcode-posts">仓库</a> 中维护。</p></blockquote><table><thead><tr><th>文章</th><th>[发布时间] 字数&#x2F;览&#x2F;藏&#x2F;赞 (~2022-10-20)</th></tr></thead><tbody><tr><td><a href="https://leetcode.cn/circle/discuss/eBo9UB/">十大排序从入门到入赘</a>  🔥🔥🔥</td><td>[20220516]  2.5万字&#x2F;64.8k览&#x2F;3.7k藏&#x2F;937赞</td></tr><tr><td><a href="https://leetcode.cn/circle/discuss/ooxfo8/">二分查找从入门到入睡</a> 🔥🔥🔥</td><td>[20220509]  2.3万字&#x2F;38.4k览&#x2F;2.1k藏&#x2F;503赞</td></tr><tr><td><a href="https://leetcode.cn/circle/discuss/qmjuMW/">并查集从入门到出门</a> 🔥🔥</td><td>[20220514]  1.2万字&#x2F;17.9k览&#x2F;1.0k藏&#x2F;321赞</td></tr><tr><td><a href="https://leetcode.cn/circle/discuss/FyPTTM/">图论算法从入门到放下</a> 🔥🔥</td><td>[20220617]  5.6万字&#x2F;19.9k览&#x2F;1.3k藏&#x2F;365赞</td></tr><tr><td>树ADT系列 (预计13篇)</td><td>系列文章，连载中</td></tr><tr><td>3. <a href="https://leetcode.cn/circle/discuss/wPzlSb/">二叉查找树</a></td><td>[20220801]  5千字</td></tr><tr><td>4. <a href="https://leetcode.cn/circle/discuss/zbwD3p/">AVL树</a></td><td>[20220817]  5千字</td></tr><tr><td>5. <a href="https://leetcode.cn/circle/discuss/BCK17f/">splay树</a></td><td>[20220817]  5千字</td></tr><tr><td>6. <a href="https://leetcode.cn/circle/discuss/SwgIJV/">红黑树从入门到看开</a> 🔥🤯🤯🤯</td><td>[20220915]  3万字&#x2F;5.3k览&#x2F;269藏&#x2F;72赞</td></tr><tr><td>10. <a href="https://leetcode.cn/circle/discuss/qGREiN/">树状数组从入门到下车</a> 🔥🤯</td><td>[20220722]  1.4万字&#x2F;5.8k览&#x2F;196藏&#x2F;72赞</td></tr><tr><td>11. <a href="https://leetcode.cn/circle/discuss/H4aMOn/">线段树从入门到急停</a> 🔥🤯</td><td>[20220726]  2.5万字&#x2F;8.7k览&#x2F;481藏&#x2F;138赞</td></tr><tr><td><a href="https://leetcode.cn/circle/discuss/GV0JrV/">图论相关证明系列</a></td><td>系列文章</td></tr><tr><td>1. <a href="https://leetcode.cn/circle/discuss/jJQn7V/">Dijkstra正确性证明</a> 🤯</td><td>[20220531]</td></tr><tr><td>2. <a href="https://leetcode.cn/circle/discuss/VVEc8f/">Prim正确性证明</a> 🤯</td><td>[20220919]</td></tr><tr><td>3. <a href="https://leetcode.cn/circle/discuss/xeEwYl/">Bellman-Ford及SPFA正确性证明</a></td><td>[20220602]</td></tr><tr><td>4. <a href="https://leetcode.cn/circle/discuss/Nbzix4/">Floyd正确性证明</a></td><td>[20220602]</td></tr><tr><td>5. <a href="https://leetcode.cn/circle/discuss/tMIy36/">最大流最小割定理证明</a> 🤯🤯</td><td>[20220719]</td></tr><tr><td>6. <a href="https://leetcode.cn/circle/discuss/tN3sZc/">Edmonds-Karp复杂度证明</a> 🤯🤯</td><td>[20220515]</td></tr><tr><td>7. <a href="https://leetcode.cn/circle/discuss/T9Xa1R/">Dinic复杂度证明</a> 🤯🤯</td><td>[20220531]</td></tr></tbody></table><hr><p>[2022-09-23]</p><ul><li>在「实战应用」中增加 <a href="https://leetcode.cn/problems/longest-increasing-subsequence-ii/">2407. 最长递增子序列 II</a> 的 <a href="https://leetcode.cn/problems/longest-increasing-subsequence-ii/solution/-by-yukiyama-khmm/">题解</a> 。</li><li>增加两种以 $O(logn)$ 实现区间最值查询的线段树类实现。</li></ul><p>[2022-09-22]</p><ul><li>增加了「区间最值查询」小节，替换了一张错误图片，另有若干词句修改。</li></ul><hr><p>[TOC]</p><hr><h2 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h2><p>我们已经知道，针对序列上的「区间操作」，相比普通数组和前缀和数组，基本树状数组 (PURQ BIT) 对「单点修改」及「区间查询」这两种操作实现了平衡，即均为 $O(logn)$ 时间复杂度。借助差分数组，从 PURQ BIT 发展而来的 RUPQ BIT (区间修改单点查询) 和 RURQ BIT (区间修改区间查询) 还可以实现 $O(logn)$ 复杂度区间修改操作，但需要针对不同的需要选择不同版本的树状数组。另外，当我们需要 <strong>将区间内元素修改为同一元素时</strong> ，或者求给定区间的 <strong>区间最大&#x2F;最小值</strong> 时，三种树状数组均不能以 $O(logn)$ 时间复杂度完成该操作。</p><p>对于这些需求，线段树都能够以 $O(logn)$ 时间复杂度完成 。</p><p><a href="https://en.wikipedia.org/wiki/Segment_tree">线段树 (Segment Tree)</a>: 线段树是一种用以支持序列区间操作的数据结构，相比基本树状数组，能够支持的操作种类更多，因此对一般的序列区间问题更具 <strong>普适性</strong> 。</p><p>在后续内容中，我们先通过 <strong>「完全二叉树下标性质」</strong> 和 <strong>「分治算法」</strong> 来理解基本线段树的工作原理。在掌握了支持「单点修改」和「区间查询」的基本线段树后，引入  <strong>「懒惰标记」</strong> 和 <strong>「延迟修改」</strong> 的概念，用以实现 「区间修改」。在给出带懒惰标记的线段树实现后，我们马上尝试解决  <a href="https://leetcode.cn/problems/falling-squares/">699. 掉落的方块</a> ，为解决此题需借用在「树状数组」中介绍过的 <strong>「离散化」</strong> 方法，我将给出 <strong>「松离散」</strong> 和 <strong>「紧离散」</strong> 两种离散化实现 (我自己瞎命名的)。接着尝试解决  <a href="https://leetcode.cn/problems/range-module/">715. Range 模块</a> ，并发现该题具有「<a href="https://en.wikipedia.org/wiki/Online_algorithm">强制在线</a>」的特点，由于无法离散化，这要求我们实现能够 <strong>「动态开点」</strong>  (动态地创建结点) 的线段树。根据是否可以提前估计树的大小，我们将分别介绍  <strong>「结点数组法动态开点线段树」</strong> 以及 <strong>「结点指针 (引用) 法动态开点线段树」</strong> ，在给出它们的完整的类代码后，演示如何将其用于解决 699 题以及 715 题。</p><p>在讲解过程中，我会给出十种线段树的完整类代码，基本能够覆盖力扣上的所有线段树题目。</p><blockquote><p>线段树由 Jon Bentley 于1977年发明。</p><p>The segment tree was invented by <a href="https://en.wikipedia.org/wiki/Jon_Bentley_(computer_scientist)">Jon Bentley</a> in 1977; in “Solutions to Klee’s rectangle problems”.[<a href="https://en.wikipedia.org/wiki/Segment_tree#cite_note-Schwarzkopf4-7">7]</a></p><p>作者的「线段树」知识，最初学自 OI wiki <a href="https://oi-wiki.org/ds/seg/">线段树</a> 。</p></blockquote><br /><h3 id="基本线段树"><a href="#基本线段树" class="headerlink" title="基本线段树"></a>基本线段树</h3><p>如果我们只要求线段树像基本树状数组 (PURQ BIT) 那样只需支持「单点修改」和「区间查询」，那么我们将得到最基本的线段树。</p><p>在「树状数组」中我们从如何提高区间查询的效率这一问题入手，提出了将原数组 $nums$ 分成若干子区间的想法，且这些子区间构成一棵逻辑树，通过树的结构实现 $O(logn)$ 的复杂度。但树状数组的实现太具技巧性，我们会想，除了树状数组利用 $lowbit$ 那样巧妙构造树的方法，有没有 <strong>更一般</strong> 的方法能够将 $nums$ 划分为多个子区间，这些子区间作为结点构成一棵树，树上的结点相比树状数组 <strong>更直观</strong> 地组成任意区间 (直接结合而非前缀区间作差)，且仍能通过下标的某些性质来操作结点呢 (目的是通过下标定位到需要的区间和结点) ？</p><p>根据树结点下标性质来操作结点这一要求中，我们嗅到了 <strong>「完全二叉树」</strong> 的味道。在完全二叉树中，结点 $i$ (根结点为结点 1) 的左子结点下标为 $2<em>i$ ，右子结点下标为 $2</em>i+1$ 。顺着这个想法，我们尝试将「线段树」构造为一棵「完全二叉树」。</p><br /><h4 id="线段树的形态"><a href="#线段树的形态" class="headerlink" title="线段树的形态"></a>线段树的形态</h4><p>假设需要在输入数组 $nums$ 上求解区间问题，我们需要将 $nums$ 处理为一棵「线段树」。下面是我们将「线段树」构造为一棵「完全二叉树」的思考过程。</p><ul><li><p>首先，既然是完全二叉树，那么这棵线段树可以与一个数组对应，数组的一个元素对应一个树的一个结点。树的一个结点代表某个区间的区间和，我们用 $tree[]$ 数组表达这棵线段树，其大小暂时未知。</p></li><li><p>更大的区间总是由更小区间构成，因此代表 $nums$ 中单个元素的结点 $tree[x]$  <strong>应当在树的最底层</strong> ，即线段树的每一个叶子结点都与 $nums$ 中的一个值对应 $tree[x] &#x3D; nums[i]$ ，且是从左到右对应的。</p></li><li><p>更大的区间是从叶子结点开始向上构成的，例如代表 $nums[0]$ 的叶子结点是一个左子结点，代表 $nums[1]$ 的叶子结点是一个右子结点，那么他们的父节点即为代表区间 $[0,1]$ 的结点。</p></li><li><p>查询区间 $[l,r]$ 的区间和，总是从上到下查询。从根结点开始，为了知道指定区间包含哪些区间结点，需要将 $l,r$ 与结点的标号联系起来，也就是将 $nums$ 的下标与 <strong>形如完全二叉树的线段树的结点标号</strong> 相联系，这个「完全二叉树结点下标性质」我们很熟悉，将数组 $nums$ 看作完全二叉树时，树的结点代表 $nums$ 中的某个值， 而在线段树中，树的结点代表 $nums$ 中的某段区间和。</p></li></ul><p>在熟知完全二叉树下标性质的基础上，上述分析是简单的。$tree[i]$ 表示标号为 $i$ 的结点所代表的区间的区间和。令根结点标号为 1。根结点 $tree[1]$ 代表整个 $nums$ 所有元素之和。很自然地，根结点的左右子结点应当代表左右两半区间的区间和，即 $tree[2]$ 表示区间 $[0, \frac{n-1}{2}]$ 的区间和，$tree[3]$ 表示区间 $[\frac{n-1}{2}+1, n-1]$ 的区间和，依次向下， <strong>结点标号总是与该结点代表的区间一一对应</strong> 。</p><blockquote><p>代表区间 $[l,r]$ 的结点 $tree[i]$ ，其左子结点 $tree[2<em>i]$ 表示区间 $[l,\frac{l+r}{2}]$ 的区间和；其右子结点 $tree[2</em>i+1]$ 表示区间 $[\frac{l+r}{2}+1,r]$ 的区间和。</p></blockquote><p>于是我们很容易得到线段树的一般表示，下图表示大小为 15 的 $nums&#x3D;{a0,a1,…,a14}$ 对应的线段树。可以看到，对于任意区间 $[l,r], l,r∈[0,n-1]$ ，我们都可以由 $l$ 到 $r$ 的若干个子区间组合得到，这一点是线段树与树状数组的显著区别 (树状数组通过两个前缀区间作差得到)。 </p><p><img src="https://pic.leetcode-cn.com/1658564316-ptpqfb-image.png" alt="image.png"></p><p>了解了线段树的区间划分、结点所代表的具体区间与结点下标的关系后，接下来我们给出基本线段树的「初始化」、「单点修改」以及「区间查询」实现。在这之前先简单分析线段树的大小。</p><br /><h4 id="线段树的大小"><a href="#线段树的大小" class="headerlink" title="线段树的大小"></a>线段树的大小</h4><p>对于长度为 $n$ 的输入数组 $nums$ ，初始化它所对应的线段树前 (即 $tree[]$ 数组)，我们需要知道 $tree[]$ 的大小。$n$ 对应的是线段树叶子结点数，我们设总结点数为 $m$ ，可以 <strong>根据线段树为一棵完全二叉树的特点来寻找 $n$ 与 $m$ 的关系</strong> 。证明见 <a href="https://oi-wiki.org/ds/seg/">oi-wiki 线段树</a> ，作者未完全看懂 $m$ 最大时为 $m&#x3D;4*n-5$ 的证明过程。<strong>如果读者能提供易懂的数学证明，盼赐教</strong>。</p><p>总之，在实际使用时，我们总是不精确地令 $m&#x3D;4*n$ 。</p><br /><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>如果读者熟悉归并排序和快速排序这类 <strong>分治算法</strong> 的「对原问题域递归地划分为左右子问题域」的操作，那么线段树的主要方法都将是简单的。我们直接给出如下线段树类 $SegmentTree$ 的构造器代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SegmentTree</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] nums, tree;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SegmentTree</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.nums = nums;</span><br><span class="line">        <span class="built_in">this</span>.n = nums.length;</span><br><span class="line">        <span class="built_in">this</span>.tree = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span> * n]; <span class="comment">// 线段树结点数不超过 4*n</span></span><br><span class="line">        build(<span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123; <span class="comment">// 构建线段树(tree数组), i: 当前区间结点下标</span></span><br><span class="line">        <span class="keyword">if</span>(s == t) &#123; <span class="comment">// s: start,nums当前区间左界，t: terminal,nums当前结点区间右界</span></span><br><span class="line">            tree[i] = nums[s];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        build(s, c, i * <span class="number">2</span>);</span><br><span class="line">        build(c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        tree[i] = tree[i * <span class="number">2</span>] + tree[i * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造器通过 <code>build(0, n - 1, 1)</code> 完成线段树的构建 (初始化 $tree[]$)。在 $build$ 中，自根结点往下，按照我们在「线段树的形态」中所说的那样，递归地将 $nums$ 分为左右两半，直到叶子结点，每次递归， <strong>区间和结点的下标总是和该区间的左右界一起被传入</strong> 。该写法实际上就是大家十分熟悉的二叉树的「后序遍历」写法。</p><p>递归的基准情形是根据 <code>s == t</code> 判断到达叶子结点后，令 <code>tree[i] = nums[s]</code> ，使得每个叶子结点从左到右对应 $nums$ 的每个元素值。在回溯过程中通过 <code>tree[i] = tree[i * 2] + tree[i * 2 + 1]</code>  自底向上地初始化所有区间结点的区间和。这行语句在线段树的实现中较常用，我们可以将它封装为一个辅助方法 $pushUp$ 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更新 tree[i]</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pushUp</span><span class="params">(<span class="type">int</span> i)</span>&#123; </span><br><span class="line">    tree[i] = tree[i * <span class="number">2</span>] + tree[i * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后面我们将看到，线段树的所有主要方法的执行过程，都是类似这样的 <strong>二叉树后序遍历的递归过程</strong> ，读者一定会感到线段树不同方法的写法如出一辙，简单得令人惊讶。</p><br /><h4 id="单点修改"><a href="#单点修改" class="headerlink" title="单点修改"></a>单点修改</h4><p>单点修改有两种，<strong>增量式修改，即加上某值</strong> (记为 $add$ 方法) $nums[i]+&#x3D;x$  或 <strong>覆盖式修改，即改为某值</strong> (记为 $update$ 方法) $nums[i]&#x3D;x$。如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单点修改(驱动): nums[i] += x</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> x)</span>&#123; </span><br><span class="line">    add(i, x, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 单点修改(驱动): nums[i] = x</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> x)</span>&#123;</span><br><span class="line">    update(i, x, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 单点修改: nums[idx] += x</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> x, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == t) &#123;</span><br><span class="line">        tree[i] += x; <span class="comment">// 增量更新</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(idx &lt;= c) add(idx, x, s, c, i * <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">else</span> add(idx, x, c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">    pushUp(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 单点修改: nums[idx] = x</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> x, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == t) &#123;</span><br><span class="line">        tree[i] = x; <span class="comment">// 覆盖更新</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(idx &lt;= c) update(idx, x, s, c, i * <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">else</span> update(idx, x, c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">    pushUp(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$add$ 和 $update$ 均采用上述写法时，可以不用维护 $nums$ ，由于 $nums$ 不可用，单点查询可实现如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单点查询 (驱动): 查询 nums[i]</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> i)</span>&#123; </span><br><span class="line">    <span class="keyword">return</span> query(i, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 单点查询 (具体): 查询 nums[i]，尾递归</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == t) <span class="keyword">return</span> tree[i];</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(idx &lt;= c) <span class="keyword">return</span> query(idx, s, c, i * <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> query(idx, c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然我们也可以实时地维护 $nums$ ，那么 $add$ 写法不变， $update$ 可借助 $add$ 实现。由于 $nums[i]$ 是实时维护的，单点查询时直接返回 $nums[i]$ 即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单点修改(驱动): nums[i] = x</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> x)</span>&#123; </span><br><span class="line">    add(i, x - nums[i], <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    nums[i] = x; <span class="comment">// 实时维护 nums[i]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> i)</span>&#123; <span class="comment">// 单点查询: 查询 nums[i]</span></span><br><span class="line">    <span class="keyword">return</span> nums[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，由于单点查询和单点修改都可以视作区间长度为 1 的区间查询和区间修改。上述方法也可以由区间查询和区间修改代替。</p><br /><h4 id="区间查询"><a href="#区间查询" class="headerlink" title="区间查询"></a>区间查询</h4><p>区间查询 (求和) 也是简单的。与单点操作不同的是，区间和需要累积，因此 <code>if(l &lt;= c)</code> 与 <code>if(r &gt; c)</code> 是并列关系。递归的基准情形为 <code>if(l &lt;= s &amp;&amp; t &lt;= r)</code> ，表示当前递进到的区间 $[s,t]$ 在所求区间 $[l,r]$ 之内，返回该区间的区间和 $tree[i]$ 用于累计。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 区间查询(驱动): nums[l]~nums[r]之和</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span>&#123; </span><br><span class="line">    <span class="keyword">return</span> sum(l, r, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 区间查询: nums[l]~nums[r]之和</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= s &amp;&amp; t &lt;= r) <span class="keyword">return</span> tree[i]; <span class="comment">// 当前结点区间在所求范围之间</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= c) sum += sum(l, r, s, c, i * <span class="number">2</span>); <span class="comment">// 递归累加目标区间落在c左侧(含c)的区间和</span></span><br><span class="line">    <span class="keyword">if</span>(r &gt; c) sum += sum(l, r, c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>); <span class="comment">// 递归累加目标区间落在c右侧的区间和</span></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以查询区间最值，以区间最小值为例，如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 区间查询 (驱动): 查询[l,r]中的最小值</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span>&#123; </span><br><span class="line">    <span class="keyword">return</span> min(l, r, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 区间查询: 查询[l,r]中的最小值</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == t) <span class="keyword">return</span> tree[i]; <span class="comment">// 叶子结点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>, lmin = Integer.MAX_VALUE, rmin = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= c) lmin = min(l, r, s, c, i * <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; c) rmin = min(l, r, c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> Math.min(lmin, rmin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h5 id="区间最值查询"><a href="#区间最值查询" class="headerlink" title="区间最值查询"></a>区间最值查询</h5><p><strong>需要注意的是</strong>，对于「区间最值查询」，上面给出的 $min$ 方法建立在 $tree[]$ 的定义为「区间和」基础之上。在这个定义下，由于缺乏子区间最值的记录，为了找到最值， $min$ , $max$ 方法最终会递进到区间内的每一个叶子结点，如果查询的是整个问题区间上的最值，那就相当于经历一次完整的树的 $dfs$ 遍历，所以平均时间复杂度是 $O(n)$ 。若要实现 $O(logn)$ 复杂度的「区间最值查询」，做法是令 $tree[]$  <strong>记录区间最值</strong> 而不是区间和。以 $tree[]$ 记录区间最值的典型线段树题目是 <a href="https://leetcode.cn/problems/falling-squares/">699. 掉落的方块</a> 一题，详细做法请参考 <a href="https://leetcode.cn/problems/falling-squares/solution/-by-yukiyama-lxtu/">题解</a> 。其中求区间最大值的代码如下，可以看到，与 $tree[]$ 定义为「区间和」时的「区间求和查询」的 $sum$ 方法十分类似。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tree[] 定义为区间最大值时，可实现 O(logn) 时间复杂度的区间最值查询。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 区间查询 (驱动): 查询[l,r]中的最大值</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span>&#123; </span><br><span class="line">    <span class="keyword">return</span> max(l, r, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 区间查询: 查询[l,r]中的最大值</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(l &lt;= s &amp;&amp; t &lt;= r) <span class="keyword">return</span> tree[i]; <span class="comment">// 当前区间是否包含在所求区间中</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>, lmax = <span class="number">0</span>, rmax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(lazy[i] != <span class="number">0</span>) pushDown(s, c, t, i);</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= c) lmax = max(l, r, s, c, i * <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; c) rmax = max(l, r, c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> Math.max(lmax, rmax);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外要注意由于 $tree[]$ 的意义是区间最值，因此 $pushUp$ 方法也与之前不同，应如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pushup: 更新 tree[i]</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pushUp</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">    tree[i] = Math.max(tree[i * <span class="number">2</span>], tree[i * <span class="number">2</span> + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于后续其他版本的线段树，只需将 $tree[]$ 定义为记录「区间最大值」，相应地完成上述两处修改，即可得到以 $O(logn)$ 时间复杂度完成「区间最大值查询」的线段树。同样地，若想得到以 $O(logn)$ 时间复杂度完成「区间最小值查询」的线段树，就将 $tree[]$ 定义为记录「区间最小值」。但是要注意，因为 $tree[]$ 不再记录「区间和」，则 $sum$ 方法求区间和需要递进到每一个叶子结点，此时 $sum$ 方法的时间复杂度是 $O(n)$ 。</p><p>我们看到，无论 $tree[]$ 的定义是什么，当需要单个叶子结点信息时，基准情形应写为 <code>if(s == t) return tree[i];</code> ，当需要包含于所求区间的当前区间信息时，基准情形为 <code>if(l &lt;= s &amp;&amp; t &lt;= r) return tree[i];</code> 。</p><p>在下面的「类的实现代码」中，只展示「不维护 $nums$ 的以 $O(logn)$ 时间复杂度完成区间最大值查询的基本静态线段树」的完整类代码，其他版本读者可以自己写出。</p><p>若要求线段树以 $O(logn)$ 时间复杂度同时支持「区间和查询」、「区间最大值查询」以及「区间最小值查询」，只需要同时维护三个树结点值数组即可，$treeSum[],treeMax[],treeMin[]$ 分别用来记录区间和、区间最大值以及区间最小值，并简单修改相关代码即可。完整实现是「类的实现代码」中的「区间查询扩展版本」。</p><br /><h4 id="类的实现代码"><a href="#类的实现代码" class="headerlink" title="类的实现代码"></a>类的实现代码</h4><p>将前述方法的实现代码组合起来即可 (实时维护 $nums$ 或不维护 $nums$ 两个版本)，见后。</p><p>不过，我们在一开始说过线段树能很好地支持「区间修改」操作，为什么还没提供相关方法就在这里给出类的代码呢？这是因为，与树状数组 (RUPQ&#x2F;RURQ BIT) 区间修改时只需要在 $add$ 中沿着父链修改 $O(logn)$ 次不同， <strong>线段树修改一段区间自上而下涉及到一个或多个子树空间内所有结点的修改</strong> 。例如若修改整个 $nums$ ，那么就要从根结点 $dfs$ 整棵树，修改涉及 <strong>所有结点</strong> ，时间复杂度为 $O(n)$ 。对于随机区间来说，平均时间复杂度为 $O(n)$ ，且由于所有区间结点的数量大于 $n$ (通常设置为 $4n$)，这样的操作甚至劣于直接遍历 $nums$ 逐个修改。</p><p>为了解决这个问题，我们不是直接 $dfs$ 修改，而是通过一种称为 <strong>「懒惰标记」</strong> 的技巧，使子树中的修改操作 <strong>延迟</strong> 到后续修改和查询操作中，此技巧使得区间修改的时间复杂度仍为 $O(logn)$ 。</p><p>为了更稳固地学习后续内容，建议读者先基于目前为止讲解的内容尝试解决 <a href="https://leetcode.cn/problems/range-sum-query-mutable/">307. 区域和检索 - 数组可修改</a> ，代码可参考「实战应用」一节给出的题解。</p><br /><h5 id="实时维护nums的版本"><a href="#实时维护nums的版本" class="headerlink" title="实时维护nums的版本"></a>实时维护nums的版本</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基本线段树1 (无懒标记，无区间修改方法，实时维护 nums[i])</span></span><br><span class="line"><span class="comment"> * 支持：单点修改 / 单点查询 / 区间查询</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SegmentTreeBasic1</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] nums, tree;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SegmentTreeBasic1</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.nums = nums;</span><br><span class="line">        <span class="built_in">this</span>.n = nums.length;</span><br><span class="line">        <span class="built_in">this</span>.tree = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span> * n];</span><br><span class="line">        build(<span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> x)</span>&#123; <span class="comment">// 单点修改(驱动): nums[i] += x</span></span><br><span class="line">        add(i, x, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> x)</span>&#123; <span class="comment">// 单点修改(驱动): nums[i] = x</span></span><br><span class="line">        add(i, x - nums[i], <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        nums[i] = x; <span class="comment">// 实时维护 nums[i]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> i)</span>&#123; <span class="comment">// 单点查询: 查询 nums[i]</span></span><br><span class="line">        <span class="keyword">return</span> nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span>&#123; <span class="comment">// 区间查询(驱动): nums[l]~nums[r]之和</span></span><br><span class="line">        <span class="keyword">return</span> sum(l, r, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span>&#123; <span class="comment">// 区间查询 (驱动): 查询[l,r]中的最小值</span></span><br><span class="line">        <span class="keyword">return</span> min(l, r, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span>&#123; <span class="comment">// 区间查询 (驱动): 查询[l,r]中的最大值</span></span><br><span class="line">        <span class="keyword">return</span> max(l, r, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单点修改: nums[idx] += x</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> x, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) &#123;</span><br><span class="line">            tree[i] += x; <span class="comment">// 增量更新</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(idx &lt;= c) add(idx, x, s, c, i * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">else</span> add(idx, x, c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        pushUp(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区间查询: nums[l]~nums[r]之和</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= s &amp;&amp; t &lt;= r) <span class="keyword">return</span> tree[i]; <span class="comment">// 当前结点区间在所求范围之间</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= c) sum += sum(l, r, s, c, i * <span class="number">2</span>); <span class="comment">// 递归累加目标区间落在c左侧(含c)的区间和</span></span><br><span class="line">        <span class="keyword">if</span>(r &gt; c) sum += sum(l, r, c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>); <span class="comment">// 递归累加目标区间落在c右侧的区间和</span></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区间查询: 查询[l,r]中的最小值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) <span class="keyword">return</span> tree[i]; <span class="comment">// 叶子结点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>, lmin = Integer.MAX_VALUE, rmin = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= c) lmin = min(l, r, s, c, i * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(r &gt; c) rmin = min(l, r, c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> Math.min(lmin, rmin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区间查询: 查询[l,r]中的最大值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) <span class="keyword">return</span> tree[i];</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>, lmax = Integer.MIN_VALUE, rmax = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= c) lmax = max(l, r, s, c, i * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(r &gt; c) rmax = max(l, r, c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> Math.max(lmax, rmax);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构建线段树(tree数组)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) &#123; <span class="comment">// s: start,nums当前区间起点下标，t: terminal,nums当前结点区间末尾下标</span></span><br><span class="line">            tree[i] = nums[s];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        build(s, c, i * <span class="number">2</span>);</span><br><span class="line">        build(c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        pushUp(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// pushup: 更新 tree[i]</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pushUp</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        tree[i] = tree[i * <span class="number">2</span>] + tree[i * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h5 id="不维护nums的版本"><a href="#不维护nums的版本" class="headerlink" title="不维护nums的版本"></a>不维护nums的版本</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基本线段树2 (无懒标记，无区间修改方法，不维护 nums[i])</span></span><br><span class="line"><span class="comment"> * 支持：单点修改 / 单点查询 / 区间查询</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SegmentTreeBasic2</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] nums, tree;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SegmentTreeBasic2</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.nums = nums;</span><br><span class="line">        <span class="built_in">this</span>.n = nums.length;</span><br><span class="line">        <span class="built_in">this</span>.tree = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span> * n];</span><br><span class="line">        build(<span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> x)</span>&#123; <span class="comment">// 单点修改(驱动): nums[i] += x</span></span><br><span class="line">        add(i, x, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> x)</span>&#123;<span class="comment">// 单点修改(驱动): nums[i] = x</span></span><br><span class="line">        update(i, x, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> i)</span>&#123; <span class="comment">// 单点查询 (驱动): 查询 nums[i]</span></span><br><span class="line">        <span class="keyword">return</span> query(i, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span>&#123; <span class="comment">// 区间查询(驱动): nums[l]~nums[r]之和</span></span><br><span class="line">        <span class="keyword">return</span> sum(l, r, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span>&#123; <span class="comment">// 区间查询 (驱动): 查询[l,r]中的最小值</span></span><br><span class="line">        <span class="keyword">return</span> min(l, r, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span>&#123; <span class="comment">// 区间查询 (驱动): 查询[l,r]中的最大值</span></span><br><span class="line">        <span class="keyword">return</span> max(l, r, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单点查询 (具体): 查询 nums[i]，尾递归</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) <span class="keyword">return</span> tree[i];</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(idx &lt;= c) <span class="keyword">return</span> query(idx, s, c, i * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> query(idx, c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单点修改: nums[idx] += x</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> x, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) &#123;</span><br><span class="line">            tree[i] += x; <span class="comment">// 增量更新</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(idx &lt;= c) add(idx, x, s, c, i * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">else</span> add(idx, x, c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        pushUp(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单点修改: nums[idx] = x</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> x, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) &#123;</span><br><span class="line">            tree[i] = x; <span class="comment">// 覆盖更新</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(idx &lt;= c) update(idx, x, s, c, i * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">else</span> update(idx, x, c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        pushUp(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区间查询: nums[l]~nums[r]之和</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= s &amp;&amp; t &lt;= r) <span class="keyword">return</span> tree[i]; <span class="comment">// 当前结点区间在所求范围之间</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= c) sum += sum(l, r, s, c, i * <span class="number">2</span>); <span class="comment">// 递归累加目标区间落在c左侧(含c)的区间和</span></span><br><span class="line">        <span class="keyword">if</span>(r &gt; c) sum += sum(l, r, c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>); <span class="comment">// 递归累加目标区间落在c右侧的区间和</span></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区间查询: 查询[l,r]中的最小值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) <span class="keyword">return</span> tree[i]; <span class="comment">// 叶子结点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>, lmin = Integer.MAX_VALUE, rmin = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= c) lmin = min(l, r, s, c, i * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(r &gt; c) rmin = min(l, r, c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> Math.min(lmin, rmin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区间查询: 查询[l,r]中的最大值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) <span class="keyword">return</span> tree[i];</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>, lmax = Integer.MIN_VALUE, rmax = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= c) lmax = max(l, r, s, c, i * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(r &gt; c) rmax = max(l, r, c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> Math.max(lmax, rmax);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构建线段树(tree数组)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) &#123; <span class="comment">// s: start,nums当前区间起点下标，t: terminal,nums当前结点区间末尾下标</span></span><br><span class="line">            tree[i] = nums[s];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        build(s, c, i * <span class="number">2</span>);</span><br><span class="line">        build(c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        pushUp(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// pushup: 更新 tree[i]</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pushUp</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        tree[i] = tree[i * <span class="number">2</span>] + tree[i * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h5 id="O-logn-时间求区间最大值版本"><a href="#O-logn-时间求区间最大值版本" class="headerlink" title="O(logn)时间求区间最大值版本"></a>O(logn)时间求区间最大值版本</h5><p>以下是不维护 $nums$ 的以 $O(logn)$ 时间复杂度完成 「区间最大值查询」 的基本静态线段树类实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 区间最大值基本线段树 (无懒标记，无区间修改方法，不维护 nums[i])</span></span><br><span class="line"><span class="comment"> * 支持：单点修改 / 单点查询 / 区间查询最大值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SegmentTreeBasicRangeMax</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] nums, tree;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SegmentTreeBasicRangeMax</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.nums = nums;</span><br><span class="line">        <span class="built_in">this</span>.n = nums.length;</span><br><span class="line">        <span class="built_in">this</span>.tree = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span> * n];</span><br><span class="line">        build(<span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> x)</span>&#123; <span class="comment">// 单点修改(驱动): nums[i] += x</span></span><br><span class="line">        add(i, x, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> x)</span>&#123;<span class="comment">// 单点修改(驱动): nums[i] = x</span></span><br><span class="line">        update(i, x, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> i)</span>&#123; <span class="comment">// 单点查询 (驱动): 查询 nums[i]</span></span><br><span class="line">        <span class="keyword">return</span> query(i, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span>&#123; <span class="comment">// 区间查询(驱动): nums[l]~nums[r]之和</span></span><br><span class="line">        <span class="keyword">return</span> sum(l, r, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span>&#123; <span class="comment">// 区间查询 (驱动): 查询[l,r]中的最大值</span></span><br><span class="line">        <span class="keyword">return</span> max(l, r, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单点查询 (具体): 查询 nums[i]，尾递归</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) <span class="keyword">return</span> tree[i];</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(idx &lt;= c) <span class="keyword">return</span> query(idx, s, c, i * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> query(idx, c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单点修改: nums[idx] += x</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> x, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) &#123;</span><br><span class="line">            tree[i] += x; <span class="comment">// 增量更新</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(idx &lt;= c) add(idx, x, s, c, i * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">else</span> add(idx, x, c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        pushUp(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单点修改: nums[idx] = x</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> x, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) &#123;</span><br><span class="line">            tree[i] = x; <span class="comment">// 覆盖更新</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(idx &lt;= c) update(idx, x, s, c, i * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">else</span> update(idx, x, c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        pushUp(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区间查询: nums[l]~nums[r]之和</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) <span class="keyword">return</span> tree[i]; <span class="comment">// 返回所求范围内的叶子结点的值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= c) sum += sum(l, r, s, c, i * <span class="number">2</span>); <span class="comment">// 递归累加目标区间落在c左侧(含c)的区间和</span></span><br><span class="line">        <span class="keyword">if</span>(r &gt; c) sum += sum(l, r, c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>); <span class="comment">// 递归累加目标区间落在c右侧的区间和</span></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区间查询: 查询[l,r]中的最大值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= s &amp;&amp; t &lt;= r) <span class="keyword">return</span> tree[i];</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>, lmax = Integer.MIN_VALUE, rmax = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= c) lmax = max(l, r, s, c, i * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(r &gt; c) rmax = max(l, r, c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> Math.max(lmax, rmax);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构建线段树(tree数组)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) &#123; <span class="comment">// s: start,nums当前区间起点下标，t: terminal,nums当前结点区间末尾下标</span></span><br><span class="line">            tree[i] = nums[s];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        build(s, c, i * <span class="number">2</span>);</span><br><span class="line">        build(c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        pushUp(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// pushup: 更新 tree[i]</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pushUp</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        tree[i] = Math.max(tree[i * <span class="number">2</span>], tree[i * <span class="number">2</span> + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h5 id="区间查询扩展版本"><a href="#区间查询扩展版本" class="headerlink" title="区间查询扩展版本"></a>区间查询扩展版本</h5><p>以 $O(logn)$ 时间复杂度同时支持「区间和查询」、「区间最大值查询」以及「区间最小值查询」的基本静态线段树类实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基本线段树 (无懒标记，无区间修改方法，不维护 nums[i])</span></span><br><span class="line"><span class="comment"> * 支持：单点修改 / 单点查询 / 区间查询 (同时支持 O(logn) 时间的区间和，区间最大值，区间最小值查询)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SegmentTreeBasic</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] nums, treeSum, treeMin,treeMax;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SegmentTreeBasic</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.nums = nums;</span><br><span class="line">        <span class="built_in">this</span>.n = nums.length;</span><br><span class="line">        <span class="built_in">this</span>.treeSum = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span> * n];</span><br><span class="line">        <span class="built_in">this</span>.treeMin = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span> * n];</span><br><span class="line">        <span class="built_in">this</span>.treeMax = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span> * n];</span><br><span class="line">        build(<span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> x)</span>&#123; <span class="comment">// 单点修改(驱动): nums[i] += x</span></span><br><span class="line">        add(i, x, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> x)</span>&#123;<span class="comment">// 单点修改(驱动): nums[i] = x</span></span><br><span class="line">        update(i, x, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> i)</span>&#123; <span class="comment">// 单点查询 (驱动): 查询 nums[i]</span></span><br><span class="line">        <span class="keyword">return</span> query(i, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span>&#123; <span class="comment">// 区间查询(驱动): nums[l]~nums[r]之和</span></span><br><span class="line">        <span class="keyword">return</span> sum(l, r, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span>&#123; <span class="comment">// 区间查询 (驱动): 查询[l,r]中的最小值</span></span><br><span class="line">        <span class="keyword">return</span> min(l, r, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span>&#123; <span class="comment">// 区间查询 (驱动): 查询[l,r]中的最大值</span></span><br><span class="line">        <span class="keyword">return</span> max(l, r, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单点查询 (具体): 查询 nums[i]，尾递归</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) <span class="keyword">return</span> treeSum[i];</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(idx &lt;= c) <span class="keyword">return</span> query(idx, s, c, i * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> query(idx, c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单点修改: nums[idx] += x</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> x, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) &#123;</span><br><span class="line">            treeSum[i] += x; <span class="comment">// 增量更新</span></span><br><span class="line">            treeMin[i] += x; <span class="comment">// 增量更新</span></span><br><span class="line">            treeMax[i] += x; <span class="comment">// 增量更新</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(idx &lt;= c) add(idx, x, s, c, i * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">else</span> add(idx, x, c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        pushUpSum(i);</span><br><span class="line">        pushUpMin(i);</span><br><span class="line">        pushUpMax(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单点修改: nums[idx] = x</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> x, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) &#123;</span><br><span class="line">            treeSum[i] = x; <span class="comment">// 覆盖更新</span></span><br><span class="line">            treeMin[i] = x; <span class="comment">// 覆盖更新</span></span><br><span class="line">            treeMax[i] = x; <span class="comment">// 覆盖更新</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(idx &lt;= c) update(idx, x, s, c, i * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">else</span> update(idx, x, c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        pushUpSum(i);</span><br><span class="line">        pushUpMin(i);</span><br><span class="line">        pushUpMax(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区间查询: nums[l]~nums[r]之和</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= s &amp;&amp; t &lt;= r) <span class="keyword">return</span> treeSum[i]; </span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= c) sum += sum(l, r, s, c, i * <span class="number">2</span>); <span class="comment">// 递归累加目标区间落在c左侧(含c)的区间和</span></span><br><span class="line">        <span class="keyword">if</span>(r &gt; c) sum += sum(l, r, c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>); <span class="comment">// 递归累加目标区间落在c右侧的区间和</span></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区间查询: 查询[l,r]中的最小值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= s &amp;&amp; t &lt;= r) <span class="keyword">return</span> treeMin[i];</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>, lmin = Integer.MAX_VALUE, rmin = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= c) lmin = min(l, r, s, c, i * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(r &gt; c) rmin = min(l, r, c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> Math.min(lmin, rmin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区间查询: 查询[l,r]中的最大值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= s &amp;&amp; t &lt;= r) <span class="keyword">return</span> treeMax[i];</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>, lmax = Integer.MIN_VALUE, rmax = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= c) lmax = max(l, r, s, c, i * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(r &gt; c) rmax = max(l, r, c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> Math.max(lmax, rmax);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构建线段树(tree数组)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) &#123; <span class="comment">// s: start,nums当前区间起点下标，t: terminal,nums当前结点区间末尾下标</span></span><br><span class="line">            treeSum[i] = nums[s];</span><br><span class="line">            treeMin[i] = nums[s];</span><br><span class="line">            treeMax[i] = nums[s];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        build(s, c, i * <span class="number">2</span>);</span><br><span class="line">        build(c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        pushUpSum(i);</span><br><span class="line">        pushUpMin(i);</span><br><span class="line">        pushUpMax(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// pushUpSum: 更新 treeSum[i]</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pushUpSum</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        treeSum[i] = treeSum[i * <span class="number">2</span>] + treeSum[i * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// pushUpMin: 更新 treeMin[i]</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pushUpMin</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        treeMin[i] = Math.min(treeMin[i * <span class="number">2</span>], treeMin[i * <span class="number">2</span> + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// pushUpMax: 更新 treeMax[i]</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pushUpMax</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        treeMax[i] = Math.max(treeMax[i * <span class="number">2</span>], treeMax[i * <span class="number">2</span> + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h3 id="懒惰标记"><a href="#懒惰标记" class="headerlink" title="懒惰标记"></a>懒惰标记</h3><p>回顾一下前述 $sum$ 方法，给定区间 $[l,r]$ ，当方法递归到一个完全位于 $[l,r]$ 的 $[s,t]$ 区间 (即 <code>l &lt;= s &amp;&amp; t &lt;= r</code> ) 时，我们直接累积该区间的区间和。可见，区间查询时，只要当前区间完全处于查询区间之内，我们就不需要知道此区间以下的区间的信息。因此对于区间查询 (求和) 操作，时间复杂度是 $O(logn)$ ，那么「区间修改」该如何实现呢？思考与区间查询类似的做法，区间修改方法从根结点递进到一个 <strong>包含于修改区间之内的区间</strong> 时，是否可以 <strong>只修改代表该区间的区间和</strong> ，而不必继续深入修改它的子区间的区间和呢？因为若修改区间下的子区间 (子树空间) 都要修改的话，相当于树的遍历，时间复杂度为 $O(n)$ ，而我们想要实现时间复杂度为 $O(logn)$ 的区间修改。下面我们仔细分析这一做法。</p><p>因为递归方法总是同时传入结点下标 $i$ 及该结点代表区间的左右界 $[s,t]$ ，因此可以通过 <code>if(l &lt;= s &amp;&amp; t &lt;= r)</code> 来判断当前结点代表的区间是否完全包含于 $[l,r]$ 的区间内，若包含，由于知道左右界信息，因此可以直接更新 $tree[i]$ 。此后查询包含 $[s,t]$ 的区间 $[l,r]$ ，$dfs$ 递进到代表 $[s,t]$ 区间的结点 $tree[i]$ 时，$tree[i]$ 总是正确的。但如果 $[l,r]$ 值只覆盖了一部分 $[s,t]$ ，就必须从 $tree[i]$ 结点继续向下访问 $[s,t]$ 的子区间，而先前我们并没有将区间修改进行到子区间，因此查询将得不到正确结果。</p><p>解决办法是在前一次修改 $[s,t]$ 的 $tree[i]$ 值时，另外使用一个与 $tree[]$ 等大的 $lazy[]$ 数组标记此时的修改 (修改 $lazy[i]$ )，以便于下次查询到 $tree[i]$ 时 <strong>将这个修改传递给子区间</strong> 。我们将这个动作称为 <strong>「延迟修改」</strong> ，将这个标记形象地称作 <strong>「懒惰标记」</strong> 。不好理解？没关系，我们马上结合示意图与代码来跟踪相关操作。</p><br /><h4 id="区间修改-增量式"><a href="#区间修改-增量式" class="headerlink" title="区间修改 (增量式)"></a>区间修改 (增量式)</h4><p>我们先分析 <strong>为区间内所有元素增加同一值的「增量式区间修改」</strong> 操作。</p><p>如下图，执行 <code>add(6, 11, 2)</code> 为区间 $[6,11]$ 的每个元素都加上 2 。 递归调用到 $tree[6]$ 以及 $tree[11]$ 时 (暂时忽略递进到此处之前的操作)，会分别执行 <code>tree[6] += (11 - 8 + 1) * 2</code> 和 <code>tree[11] += (7 - 6 + 1) * 2</code> 。同时，增量 2 也会被 $lazy[6]$ 和 $lazy[11]$ 记录。由于 <strong>标记可能还记录了前面的修改，而修改是增量式的，因此需累加</strong> ，即 <code>lazy[6] += 2</code> 及 <code>lazy[11] += 2</code>。</p><p><img src="https://pic.leetcode-cn.com/1663821361-KyUNOS-image.png" alt="image.png"></p><p>接着，我们查询 $[6,9]$ 的区间和 ( $sum(6,9)$ )，递进访问到 $tree[6]$ 结点时，要将懒标记记录的修改量 $lazy[6]$ 传递给 $tree[12]$ 和 $tree[13]$ 。同样地，访问到 $tree[11]$ 结点时，要将懒标记记录的修改量 $lazy[11]$ 传递给 $tree[22]$ 和 $tree[23]$ 。 <strong>「推送」</strong> 指的是通过 $pushDown$ 方法完成 <strong>当前区间以及它的两个子结点区间的区间和以及懒标记的更新</strong> 。</p><p><img src="https://pic.leetcode-cn.com/1658588970-kOwQAr-image.png" alt="image.png"></p><p>现在我们很容易理解下面的实现代码。<code>private void add</code> 方法中，当递进到所代表的区间完全包含于 $[l,r]$ 内的 $tree[i]$ 结点时 (代表区间 $[s,t]$ )，我们执行 <code>tree[i] += (t - s + 1) * x</code> 语句更新 $tree[i]$ ，接着执行 <code>if(s != t) lazy[i] += x</code>  后返回。懒标记更新前的判断使得 <strong>叶子结点不会被标记</strong> ，因为 <strong>叶子结点之下不再有需要推送标记的结点</strong> 。当然也可以不用判断，因为无论是查询还是修改，到达叶子结点时一定会进入方法开始的 $if$ 语句后通过 $return$ 返回，叶子结点没有向下推送的机会。</p><p><code>if(lazy[i] != 0) pushDown(s, c, t, i)</code> 表示在递归进入左右子结点前，检查当前 $tree[i]$ 顶点值是否要向下推送标记，<code>lazy[i] != 0</code> 说明当前 $tree[i]$ 有 <strong>尚未推送的修改</strong> ，需要在这个时候推送到下一层，否则递归进入左右子结点时，左右子结点的区间和是旧的。</p><p>$pushDown$ 方法传入 $s,c,t,i$ ，用于更新 $tree[i]$ 的左子结点区间和 $tree[2<em>i]$ 、右子结点区间和 $tree[2</em>i+1]$  以及它们的懒标记。更新结束后 $tree[i]$ 结点的「推送修改量」的任务就完成了，需要将其懒标记设置为 0 ，即 <code>lazy[i] = 0</code> ，否则下次修改或查询再经过 $tree[i]$ 时，会重复推送。</p><p>$add$ 方法的最后一行调用 $pushUp$ 方法，这是递归的 <strong>「后序」</strong> 动作，回溯过程中自底向上更新递进路径上的 $tree[i]$ 。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 区间修改(驱动): [l,r]区间所有元素加上x</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span>&#123; </span><br><span class="line">    add(l, r, x, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 区间修改: 增量式 [l,r] 区间所有元素加上x</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(l &lt;= s &amp;&amp; t &lt;= r)&#123; <span class="comment">// 当前结点代表的区间在所求区间之内</span></span><br><span class="line">        tree[i] += (t - s + <span class="number">1</span>) * x; <span class="comment">// 结点i的区间和加上t-s+1个x</span></span><br><span class="line">        <span class="keyword">if</span>(s != t) lazy[i] += x; <span class="comment">// 结点i不是叶子结点，懒标记值加上x</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(lazy[i] != <span class="number">0</span>) pushDown(s, c, t, i); <span class="comment">// 当前结点懒惰标记不为0，推送标记</span></span><br><span class="line">    <span class="keyword">if</span>(l &lt;= c) add(l, r, x, s, c, i * <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; c) add(l, r, x, c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">    pushUp(i); <span class="comment">// 后序动作，自底向上更新结点区间和 tree[i]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 更新结点i左右子结点的区间和以及懒惰标记值，最后重置结点i的懒惰标记值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pushDown</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> c, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123; </span><br><span class="line">    tree[i * <span class="number">2</span>] += (c - s + <span class="number">1</span>) * lazy[i]; <span class="comment">// 更新其左子结点的区间和</span></span><br><span class="line">    lazy[i * <span class="number">2</span>] += lazy[i]; <span class="comment">// 传递懒标记(增量标记)</span></span><br><span class="line">    tree[i * <span class="number">2</span> + <span class="number">1</span>] += (t - c) * lazy[i];</span><br><span class="line">    lazy[i * <span class="number">2</span> + <span class="number">1</span>] += lazy[i];</span><br><span class="line">    lazy[i] = <span class="number">0</span>; <span class="comment">// 重置当前结点懒惰标记值（增量标记置0）</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 更新 tree[i]</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pushUp</span><span class="params">(<span class="type">int</span> i)</span>&#123; </span><br><span class="line">    tree[i] = tree[i * <span class="number">2</span>] + tree[i * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h4 id="区间修改-覆盖式"><a href="#区间修改-覆盖式" class="headerlink" title="区间修改 (覆盖式)"></a>区间修改 (覆盖式)</h4><p>接着分析 <strong>将区间内所有元素修改为同一值的「覆盖式区间修改」</strong> 操作。与单点覆盖式修改方法可以通过调用单点增量式修改方法来实现不同，由于 <strong>涉及多个值的修改</strong> ，区间覆盖式修改不能通过调用区间增量式方法来实现。且覆盖式修改可能将 $nums$ 的原元素值改为 0，因此不能再以 <code>lazy[i] != 0</code> 来作为推送标记的标志。我们可以创建一个新的 <code>boolean updated[]</code> 数组来记录结点 $i$ 当前的修改状态，若 <code>updated[i] == true</code> 说明结点 $i$ 的 <strong>覆盖式修改未推送</strong> 。需注意的是， $pushDown$ 方法也需要若干调整。如下是区间覆盖式修改的相关代码实现，与增量式区间修改代码的区别仅仅是用 <code>if(updated[i])</code> 代替了 <code>if(lazy[i] != 0)</code> ，以及将「增量赋值」的 <code>+=</code> 改为「覆盖赋值」 <code>=</code> ，以及相应的 $updated[i]$ 的设置和更新。</p><p>如果我们能确定覆盖式区间修改不会将元素值改为 0 的话，那 $updated[]$ 数组不是必须的，仍可用 $lazy[i]$ 是否为 0 作为判断条件，这种情况下增量式与覆盖式的代码将十分相似，几乎只有 <code>+=</code> 和 <code>=</code> 的区别。例如 <a href="https://leetcode.cn/problems/falling-squares/">699. 掉落的方块</a> 一题，需要实现覆盖式区间修改，但题目保证了修改值不会是 0 ，实现代码就不需要另外使用 <code>boolean updated[]</code> ，具体请看「实战应用」中该题 <a href="https://leetcode.cn/problems/falling-squares/solution/-by-yukiyama-lxtu/">题解</a>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 区间修改(驱动): 覆盖式 [l,r] 区间所有元素改为x</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span>&#123; </span><br><span class="line">    update(l, r, x, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 区间修改: 覆盖式 [l,r] 区间所有元素改为x</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(l &lt;= s &amp;&amp; t &lt;= r)&#123; <span class="comment">// 当前结点代表的区间在所求区间之内</span></span><br><span class="line">        tree[i] = (t - s + <span class="number">1</span>) * x; <span class="comment">// 结点i的区间和等于t-s+1个x</span></span><br><span class="line">        <span class="keyword">if</span>(s != t) &#123; <span class="comment">// 结点i不是叶子结点</span></span><br><span class="line">            lazy[i] = x; <span class="comment">// 懒标记值等于x</span></span><br><span class="line">            updated[i] = <span class="literal">true</span>; <span class="comment">// updated[i]置于为为true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(updated[i]) pushDown(s, c, t, i); <span class="comment">// 当前结点updated为true，推送标记</span></span><br><span class="line">    <span class="keyword">if</span>(l &lt;= c) update(l, r, x, s, c, i * <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; c) update(l, r, x, c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">    pushUp(i); <span class="comment">// 后序动作，自底向上更新结点区间和 tree[i]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 更新结点i左右子结点的区间和/懒惰标记值/updated[i]，最后重置懒惰标记值/updated[i]</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pushDown</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> c, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123; </span><br><span class="line">    tree[i * <span class="number">2</span>] = (c - s + <span class="number">1</span>) * lazy[i]; <span class="comment">// 更新其左子结点的区间和</span></span><br><span class="line">    lazy[i * <span class="number">2</span>] = lazy[i]; <span class="comment">// 传递懒标记(覆盖式标记)</span></span><br><span class="line">    updated[i * <span class="number">2</span>] = <span class="literal">true</span>;</span><br><span class="line">    tree[i * <span class="number">2</span> + <span class="number">1</span>] = (t - c) * lazy[i];</span><br><span class="line">    lazy[i * <span class="number">2</span> + <span class="number">1</span>] = lazy[i];</span><br><span class="line">    updated[i * <span class="number">2</span> + <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    lazy[i] = <span class="number">0</span>; <span class="comment">// 重置当前结点懒惰标记值（覆盖式标记置0）</span></span><br><span class="line">    updated[i] = <span class="literal">false</span>; <span class="comment">// 重置当前结点updated[i]为false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h4 id="类的实现代码-1"><a href="#类的实现代码-1" class="headerlink" title="类的实现代码"></a>类的实现代码</h4><h5 id="增量式区间修改版"><a href="#增量式区间修改版" class="headerlink" title="增量式区间修改版"></a>增量式区间修改版</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 静态线段树 (带懒标记，增量式区间修改)</span></span><br><span class="line"><span class="comment"> * 支持：单点修改 / 单点查询 / 区间求和 / 增量式区间修改</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SegmentTreeAdd</span>&#123;</span><br><span class="line">    <span class="type">int</span>[] nums, tree, lazy;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SegmentTreeAdd</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.nums = nums;</span><br><span class="line">        <span class="built_in">this</span>.n = nums.length;</span><br><span class="line">        <span class="built_in">this</span>.tree = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span> * n];</span><br><span class="line">        <span class="built_in">this</span>.lazy = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span> * n];</span><br><span class="line">        build(<span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> x)</span>&#123; <span class="comment">// 单点修改(驱动): 增量式 nums[i] += x</span></span><br><span class="line">        add(i, x, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> x)</span>&#123; <span class="comment">// 单点修改(驱动): 覆盖式 nums[i] = x</span></span><br><span class="line">        update(i, x, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> i)</span>&#123; <span class="comment">// 单点查询 (驱动): 查询 nums[i]</span></span><br><span class="line">        <span class="keyword">return</span> query(i, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span>&#123; <span class="comment">// 区间修改(驱动): 增量式 [l,r] 区间所有元素加上x</span></span><br><span class="line">        add(l, r, x, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span>&#123; <span class="comment">// 区间查询(驱动): nums[l]~nums[r]之和</span></span><br><span class="line">        <span class="keyword">return</span> sum(l, r, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span>&#123; <span class="comment">// 区间查询 (驱动): 查询[l,r]中的最小值</span></span><br><span class="line">        <span class="keyword">return</span> min(l, r, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span>&#123; <span class="comment">// 区间查询 (驱动): 查询[l,r]中的最大值</span></span><br><span class="line">        <span class="keyword">return</span> max(l, r, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单点修改: 增量式 令nums[idx] += x。修改叶子结点，无关标记。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> x, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) &#123;</span><br><span class="line">            tree[i] += x; <span class="comment">// 增量更新</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(lazy[i] != <span class="number">0</span>) pushDown(s, c, t, i); <span class="comment">// 是否推送标记</span></span><br><span class="line">        <span class="keyword">if</span>(idx &lt;= c) add(idx, x, s, c, i * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">else</span> add(idx, x, c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        pushUp(i); <span class="comment">// 后序动作，自底向上更新结点区间和 tree[i]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单点修改: 覆盖式 令nums[idx] = x。修改叶子结点，无关标记。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> x, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) &#123;</span><br><span class="line">            tree[i] = x; <span class="comment">// 覆盖更新</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(lazy[i] != <span class="number">0</span>) pushDown(s, c, t, i); <span class="comment">// 是否推送标记</span></span><br><span class="line">        <span class="keyword">if</span>(idx &lt;= c) update(idx, x, s, c, i * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">else</span> update(idx, x, c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        pushUp(i);  <span class="comment">// 后序动作，自底向上更新结点区间和 tree[i]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单点查询 (具体): 查询 nums[i]，尾递归</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) <span class="keyword">return</span> tree[i];</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(lazy[i] != <span class="number">0</span>) pushDown(s, c, t, i); <span class="comment">// 是否推送标记</span></span><br><span class="line">        <span class="keyword">if</span>(idx &lt;= c) <span class="keyword">return</span> query(idx, s, c, i * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> query(idx, c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区间修改: 增量式 [l,r] 区间所有元素加上x</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= s &amp;&amp; t &lt;= r)&#123; <span class="comment">// 当前结点代表的区间在所求区间之内</span></span><br><span class="line">            tree[i] += (t - s + <span class="number">1</span>) * x; <span class="comment">// 结点i的区间和加上t-s+1个x</span></span><br><span class="line">            <span class="keyword">if</span>(s != t) lazy[i] += x; <span class="comment">// 结点i不是叶子结点，懒标记值加上x</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(lazy[i] != <span class="number">0</span>) pushDown(s, c, t, i); <span class="comment">// 是否推送标记</span></span><br><span class="line">        <span class="keyword">if</span>(l &lt;= c) add(l, r, x, s, c, i * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(r &gt; c) add(l, r, x, c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        pushUp(i); <span class="comment">// 后序动作，自底向上更新结点区间和 tree[i]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区间查询: 求 nums[l]~nums[r]之和</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= s &amp;&amp; t &lt;= r) <span class="keyword">return</span> tree[i]; <span class="comment">// 当前结点代表的区间在所求区间之内</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(lazy[i] != <span class="number">0</span>) pushDown(s, c, t, i); <span class="comment">// 是否推送标记</span></span><br><span class="line">        <span class="keyword">if</span>(l &lt;= c) sum += sum(l, r, s, c, i * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(r &gt; c) sum += sum(l, r, c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区间查询: 查询[l,r]中的最小值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) <span class="keyword">return</span> tree[i]; <span class="comment">// 叶子结点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>, lmin = Integer.MAX_VALUE, rmin = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">if</span>(lazy[i] != <span class="number">0</span>) pushDown(s, c, t, i); <span class="comment">// 是否推送标记</span></span><br><span class="line">        <span class="keyword">if</span>(l &lt;= c) lmin = min(l, r, s, c, i * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(r &gt; c) rmin = min(l, r, c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> Math.min(lmin, rmin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区间查询: 查询[l,r]中的最大值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) <span class="keyword">return</span> tree[i];</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>, lmax = Integer.MIN_VALUE, rmax = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">if</span>(lazy[i] != <span class="number">0</span>) pushDown(s, c, t, i);</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= c) lmax = max(l, r, s, c, i * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(r &gt; c) rmax = max(l, r, c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> Math.max(lmax, rmax);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构建线段树(tree数组)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) &#123; <span class="comment">// s: start,nums当前结点区间起点下标，t: terminal,nums当前结点区间末尾下标</span></span><br><span class="line">            tree[i] = nums[s];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        build(s, c, i * <span class="number">2</span>);</span><br><span class="line">        build(c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        pushUp(i);  <span class="comment">// 后序动作，自底向上更新结点区间和 tree[i]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// pushup: 更新 tree[i]</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pushUp</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        tree[i] = tree[i * <span class="number">2</span>] + tree[i * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// pushdown: 更新当前结点及其左右子结点的懒标记</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pushDown</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> c, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        tree[i * <span class="number">2</span>] += (c - s + <span class="number">1</span>) * lazy[i]; <span class="comment">// 更新其左子结点的区间和</span></span><br><span class="line">        lazy[i * <span class="number">2</span>] += lazy[i]; <span class="comment">// 传递懒标记(增量标记)</span></span><br><span class="line">        tree[i * <span class="number">2</span> + <span class="number">1</span>] += (t - c) * lazy[i];</span><br><span class="line">        lazy[i * <span class="number">2</span> + <span class="number">1</span>] += lazy[i];</span><br><span class="line">        lazy[i] = <span class="number">0</span>; <span class="comment">// 重置当前结点懒惰标记值（增量标记置0）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h5 id="覆盖式区间修改版"><a href="#覆盖式区间修改版" class="headerlink" title="覆盖式区间修改版"></a>覆盖式区间修改版</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 静态线段树 (带懒标记，覆盖式区间修改为)</span></span><br><span class="line"><span class="comment"> * 支持：单点修改 / 单点查询 / 区间求和 / 覆盖式区间修改</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SegmentTreeUpdate</span>&#123;</span><br><span class="line">    <span class="type">int</span>[] nums, tree, lazy;</span><br><span class="line">    <span class="type">boolean</span>[] updated;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SegmentTreeUpdate</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.nums = nums;</span><br><span class="line">        <span class="built_in">this</span>.n = nums.length;</span><br><span class="line">        <span class="built_in">this</span>.tree = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span> * n];</span><br><span class="line">        <span class="built_in">this</span>.lazy = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span> * n];</span><br><span class="line">        <span class="built_in">this</span>.updated = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">4</span> * n];</span><br><span class="line">        build(<span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> x)</span>&#123; <span class="comment">// 单点修改(驱动): 增量式 nums[i] += x</span></span><br><span class="line">        add(i, x, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> x)</span>&#123; <span class="comment">// 单点修改(驱动): 覆盖式 nums[i] = x</span></span><br><span class="line">        update(i, x, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> i)</span>&#123; <span class="comment">// 单点查询 (驱动): 查询 nums[i]</span></span><br><span class="line">        <span class="keyword">return</span> query(i, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span>&#123; <span class="comment">// 区间修改(驱动): 覆盖式 [l,r] 区间所有元素改为x</span></span><br><span class="line">        update(l, r, x, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span>&#123; <span class="comment">// 区间查询(驱动): nums[l]~nums[r]之和</span></span><br><span class="line">        <span class="keyword">return</span> sum(l, r, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span>&#123; <span class="comment">// 区间查询 (驱动): 查询[l,r]中的最小值</span></span><br><span class="line">        <span class="keyword">return</span> min(l, r, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span>&#123; <span class="comment">// 区间查询 (驱动): 查询[l,r]中的最大值</span></span><br><span class="line">        <span class="keyword">return</span> max(l, r, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单点修改: 增量式 令nums[idx] += x。修改叶子结点，无关标记。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> x, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) &#123;</span><br><span class="line">            tree[i] += x; <span class="comment">// 增量更新</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(updated[i]) pushDown(s, c, t, i); <span class="comment">// 是否推送标记</span></span><br><span class="line">        <span class="keyword">if</span>(idx &lt;= c) add(idx, x, s, c, i * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">else</span> add(idx, x, c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        pushUp(i); <span class="comment">// 后序动作，自底向上更新结点区间和 tree[i]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单点修改: 覆盖式 令nums[idx] = x。修改叶子结点，无关标记。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> x, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) &#123;</span><br><span class="line">            tree[i] = x; <span class="comment">// 覆盖更新</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(updated[i]) pushDown(s, c, t, i); <span class="comment">// 是否推送标记</span></span><br><span class="line">        <span class="keyword">if</span>(idx &lt;= c) update(idx, x, s, c, i * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">else</span> update(idx, x, c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        pushUp(i);  <span class="comment">// 后序动作，自底向上更新结点区间和 tree[i]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单点查询 (具体): 查询 nums[i]，尾递归</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) <span class="keyword">return</span> tree[i];</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(updated[i]) pushDown(s, c, t, i); <span class="comment">// 当前结点懒惰标记不为0</span></span><br><span class="line">        <span class="keyword">if</span>(idx &lt;= c) <span class="keyword">return</span> query(idx, s, c, i * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> query(idx, c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区间修改: 覆盖式 [l,r] 区间所有元素改为x</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= s &amp;&amp; t &lt;= r)&#123; <span class="comment">// 当前结点代表的区间在所求区间之内</span></span><br><span class="line">            tree[i] = (t - s + <span class="number">1</span>) * x; <span class="comment">// 结点i的区间和等于t-s+1个x</span></span><br><span class="line">            <span class="keyword">if</span>(s != t) &#123; <span class="comment">// 结点i不是叶子结点</span></span><br><span class="line">                lazy[i] = x; <span class="comment">// 更新懒标记</span></span><br><span class="line">                updated[i] = <span class="literal">true</span>; <span class="comment">// 更新updated</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(updated[i]) pushDown(s, c, t, i); <span class="comment">// 是否推送标记</span></span><br><span class="line">        <span class="keyword">if</span>(l &lt;= c) update(l, r, x, s, c, i * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(r &gt; c) update(l, r, x, c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        pushUp(i); <span class="comment">// 后序动作，自底向上更新结点区间和 tree[i]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区间查询: 求 nums[l]~nums[r]之和</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= s &amp;&amp; t &lt;= r) <span class="keyword">return</span> tree[i]; <span class="comment">// 当前结点代表的区间在所要求的区间之内</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(updated[i]) pushDown(s, c, t, i); <span class="comment">// 是否推送标记</span></span><br><span class="line">        <span class="keyword">if</span>(l &lt;= c) sum += sum(l, r, s, c, i * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(r &gt; c) sum += sum(l, r, c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区间查询: 查询[l,r]中的最小值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) <span class="keyword">return</span> tree[i]; <span class="comment">// 叶子结点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>, lmin = Integer.MAX_VALUE, rmin = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">if</span>(updated[i]) pushDown(s, c, t, i); <span class="comment">// 是否推送标记</span></span><br><span class="line">        <span class="keyword">if</span>(l &lt;= c) lmin = min(l, r, s, c, i * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(r &gt; c) rmin = min(l, r, c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> Math.min(lmin, rmin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区间查询: 查询[l,r]中的最大值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) <span class="keyword">return</span> tree[i];</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>, lmax = Integer.MIN_VALUE, rmax = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">if</span>(updated[i]) pushDown(s, c, t, i);</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= c) lmax = max(l, r, s, c, i * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(r &gt; c) rmax = max(l, r, c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> Math.max(lmax, rmax);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构建线段树(tree数组)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) &#123; <span class="comment">// s: start,nums当前结点区间起点下标，t: terminal,nums当前结点区间末尾下标</span></span><br><span class="line">            tree[i] = nums[s];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        build(s, c, i * <span class="number">2</span>);</span><br><span class="line">        build(c + <span class="number">1</span>, t, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        pushUp(i);  <span class="comment">// 后序动作，自底向上更新结点区间和 tree[i]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// pushup: 更新 tree[i]</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pushUp</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        tree[i] = tree[i * <span class="number">2</span>] + tree[i * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// pushdown: 更新当前结点及其左右子结点的懒标记和updated</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pushDown</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> c, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        tree[i * <span class="number">2</span>] = (c - s + <span class="number">1</span>) * lazy[i]; <span class="comment">// 更新其左子结点的区间和</span></span><br><span class="line">        lazy[i * <span class="number">2</span>] = lazy[i]; <span class="comment">// 传递懒标记(覆盖式标记)</span></span><br><span class="line">        updated[i * <span class="number">2</span>] = <span class="literal">true</span>;</span><br><span class="line">        tree[i * <span class="number">2</span> + <span class="number">1</span>] = (t - c) * lazy[i];</span><br><span class="line">        lazy[i * <span class="number">2</span> + <span class="number">1</span>] = lazy[i];</span><br><span class="line">        updated[i * <span class="number">2</span> + <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">        lazy[i] = <span class="number">0</span>; <span class="comment">// 重置当前结点懒惰标记值</span></span><br><span class="line">        updated[i] = <span class="literal">false</span>; <span class="comment">// 重置当前结点updated[i]为false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>学会了带懒惰标记的线段树后，对于「区间问题」，我们终于掌握了一个比「树状数组」更强大的工具。对于大小为 $n$ 的序列 $nums$ ，带懒惰标记的线段树，同时以 $O(logn)$  时间复杂度支持 <strong>「单点修改」、「单点查询」、「区间修改」和「区间查询」</strong> 。其中，「区间修改」支持增量式或覆盖式，「区间查询」除了能求区间和，也可以求区间最值，但是要注意 $tree[]$ 定义为「区间和」或「区间最值」时，求区间最值的方法时间复杂度不同，这一点我们在「区间最值查询」小节中已作讨论。</p><p>实际上线段树经过一些调整，能够实现更多的区间运算。</p><br /><h3 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h3><p>当我们满怀信心带着已掌握的工具试图求解线段树题目时，我们马上会遇到一个难题 ── <strong>空间爆炸</strong>！仍以 <a href="https://leetcode.cn/problems/falling-squares/">699. 掉落的方块</a> 为例，题意不难理解，实际上就是要实现「覆盖式区间修改」和「区间最大值查询」操作。根据题目的数据范围提示，求解区间从 1 到 <strong>最右边方块的右界</strong> 为止，这个值是 $n&#x3D;10^8+10^6$ 。按照我们目前为止讲解的堆式线段树的做法，$tree[]$ 的大小将达到 $4<em>n&#x3D;4</em>(10^8+10^6)$ ，会 $MLE$ 。</p><p>解决该问题的办法我们实际上已在「<a href="https://leetcode.cn/circle/discuss/qGREiN/">树状数组</a>」中介绍过，那就是在不影响求解的情况下，先将求解区间离散化。以 699 题为例，方块 $[l,l+h]$ 掉落时，我们首先在 $[l,l+h-1]$ 区间内查询最大高度 $height$ ，然后将此区间修改为 $h + height$ 。我们发现，只要保证所有方块的左右界的前后关系 (大小关系) 保持不变， 则像下图那样将所有方块的左右界一起离散化后，原问题的解不变。具体求解过程和代码可参考 <a href="https://leetcode.cn/problems/falling-squares/solution/-by-yukiyama-lxtu/">题解</a> 。</p><p><img src="https://pic.leetcode-cn.com/1658738555-GFbSIZ-image.png" alt="image.png"></p><p>离散化主要分为紧离散和松离散，它们都基于排序，二者的区别已在「<a href="https://leetcode.cn/circle/discuss/qGREiN/">树状数组</a>」中讲解过。</p><br /><h4 id="紧离散"><a href="#紧离散" class="headerlink" title="紧离散"></a>紧离散</h4><p>借助 $set$ 去重，使得离散化后的有效数字更少，取值范围更小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 紧离散</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;Integer, Integer&gt; <span class="title function_">discrete</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123; </span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> num : nums) set.add(num);</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(set);</span><br><span class="line">    Collections.sort(list);</span><br><span class="line">    <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> num : list) map.put(num, ++idx);</span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h4 id="松离散"><a href="#松离散" class="headerlink" title="松离散"></a>松离散</h4><p>不借助 $set$ 去重，离散化后的有效数字更多 (存在相同的数字)，取值范围更大。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 松离散</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">discrete</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123; </span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span>[] tmp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    System.arraycopy(nums, <span class="number">0</span>, tmp, <span class="number">0</span>, n);</span><br><span class="line">    Arrays.sort(tmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        nums[i] = Arrays.binarySearch(tmp, nums[i]) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><p>举例而言，对于 $nums&#x3D;{2,4,4,6}$ ，松离散得到 $nums&#x3D;{1,2,2,4}$，离散化后的 $nums$ 大小与原来相同；紧离散得到 $map&#x3D;{(2,1),(4,2),(6,3)}$ ， $key$ 为 $nums$ 中的元素，对应的 $value$ 为其离散化值，$value$  一定是从 1 开始的没有重复的连续正整数。</p><p>两种方式离散化后虽然有效数字不同，取值范围也不同，但通常都是有效的。松离散无需哈希计算，通常速度更快，但有的题目可能更适合返回 $map$ 的紧离散，可根据实际情况选取合适的离散化方式。</p><br /><h3 id="动态开点"><a href="#动态开点" class="headerlink" title="动态开点"></a>动态开点</h3><p>现在，有了「离散化」这一工具，我们重新出发。在用「离散化」锤掉 699 题之后，继续尝试解决 <a href="https://leetcode.cn/problems/range-module/">715. Range 模块</a> 一题。按如下理解题意，不难看出这也是一道非常典型的线段树题目。可用支持覆盖式「区间修改」和「区间查询 (求和)」的线段树实现。</p><ul><li>$addRange$ 方法即覆盖式「区间修改」，我们可以视作将区间 $[left,right-1]$ 的每个元素修改为 1。</li><li>$queryRange$ 方法即「区间查询」，对区间 $[left,right-1]$ 求和，若 $sum &#x3D; right-left$  返回 $true$ ，否则返回 $false$ 。</li><li>$removeRange$ 方法也是覆盖式「区间修改」，将区间 $[left,right-1]$ 的每个元素修改为 0。</li></ul><p>根据题目给出的取值范围，我们看到「区间」范围为 $[1,10^9]$ ，直接用堆式线段树则 $tree[]$ 数组大小达到 $4*10^9$ ，会 $MLE$ 。当我们打算通过「离散化」来缩小区间时，发现本题是 <strong><a href="https://en.wikipedia.org/wiki/Online_algorithm">强制在线</a></strong> 的，也就是并未提前告诉我们所有涉及询问和修改的区间范围，因此无法离散化。</p><p>※ $log(4<em>10^9) &gt; 31 ，2^{31} &#x3D; 2Gbit$  ，因此要创建大小为 $4</em>10^9$ 的数组，就需要超过 $2Gb$ 的空间。</p><p>现在请看向本小节的标题 —— <strong>「动态开点」</strong> ，如果你此前有瞥过一些线段树的文章，你应该没少看到过这个词。总之你大概知道既然不能在程序开始时就完成初始「线段树」的构建的话，那就在区间查询或区间修改时，根据届时传入的区间信息来「动态地」创建结点，那么如何做到呢？</p><p>为了引出如何动态创建结点，我们先回顾「堆式线段树」的操作。每个结点代表一个确定的区间，当我们需要查询或修改区间 $[l,r]$ 时，就要找到代表 $[l,r]$ 的若干结点，操作它们的 $tree[i]$ 值和相应的 $lazy&#x2F;updated$ (如果有的话)。我们需要知道搜索过程中结点代表的区间范围 $[s,t]$ ，通过与 $[l,r]$ 的比较来确定是否是目标区间，同时也要知道这个结点的下标 $i$ 使得我们能够操作 $tree[i]$ ，因此 $s,t,i$ 三者是绑定的。总之，查找目标区间的关键是:</p><blockquote><p><strong>方法执行过程中保证结点值 (指 $tree[i]$，一般为区间和 ) 和该结点代表的区间 $[s,t]$ 是同时获知的</strong>。</p></blockquote><p>堆式线段树通过 $i, 2<em>i, 2</em>i+1$ 下标关系实现了这一点。但只要我们能实现以上描述，线段树不必是「堆式」的。</p><p>一个直接的想法是不再由 <code>int[] tree</code> 来存储结点值信息，而是以 <code>Node[] tree</code> 来维护结点信息，$Node$ 可以作为线段树类中的嵌套类，它持有结点的值信息 $val$ (一般为区间和) ，此外还持有它的左右孩子的下标 $lIdx, rIdx$ ，这样当我们要递归进入左右孩子结点 (左右子区间) 时，就可以直接从当前结点读取下标，将 $tree[tree[i].lIdx]$ 或 $tree[tree[i].rIdx]$ 传入方法中，实现结点信息 ($tree[tree[i].lIdx].val$ 或 $tree[tree[i].rIdx].val$) 和 $[s,t]$ 的同时获知。</p><p>到这里，我们实际上已经给出了「动态开点线段树」的第一种实现方式 —— 结点数组法。</p><br /><h4 id="结点数组法"><a href="#结点数组法" class="headerlink" title="结点数组法"></a>结点数组法</h4><p>我们直接给出如下包含了构造器和区间修改 (增量式) 的代码，结合后图分析 <strong>「结点数组法动态线段树」</strong> 是如何「动态开点」的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DynamicSegmentTreeArrayAdd</span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        <span class="type">int</span> lIdx, rIdx, lazy, val;</span><br><span class="line">    &#125;</span><br><span class="line">    Node[] tree;</span><br><span class="line">    <span class="type">int</span> n, count;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DynamicSegmentTreeArrayAdd</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">        <span class="built_in">this</span>.count = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">this</span>.tree = <span class="keyword">new</span> <span class="title class_">Node</span>[m];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span>&#123; <span class="comment">// 区间修改(驱动): 增量式 [l,r] 区间所有元素加上x</span></span><br><span class="line">        add(l, r, x, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">// 区间修改: 增量式 [l,r] 区间所有元素加上x</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= s &amp;&amp; t &lt;= r)&#123; <span class="comment">// 当前结点代表的区间在所求区间之内</span></span><br><span class="line">            tree[i].val += (t - s + <span class="number">1</span>) * x; <span class="comment">// 结点i的区间和加上t-s+1个x</span></span><br><span class="line">            <span class="keyword">if</span>(s != t) tree[i].lazy += x; <span class="comment">// 结点i不是叶子结点，懒标记值加上x</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        addNode(i); <span class="comment">// 动态开点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(tree[i].lazy != <span class="number">0</span>) pushDown(s, c, t, i); <span class="comment">// 是否推送标记</span></span><br><span class="line">        <span class="keyword">if</span>(l &lt;= c) add(l, r, x, s, c, tree[i].lIdx);</span><br><span class="line">        <span class="keyword">if</span>(r &gt; c) add(l, r, x, c + <span class="number">1</span>, t, tree[i].rIdx);</span><br><span class="line">        pushUp(i); <span class="comment">// 后序动作，自底向上更新结点区间和 tree[i]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 动态开点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addNode</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tree[i] == <span class="literal">null</span>) tree[i] = <span class="keyword">new</span> <span class="title class_">Node</span>(); <span class="comment">// 当前结点未建，创建之</span></span><br><span class="line">        <span class="keyword">if</span>(tree[i].lIdx == <span class="number">0</span>) &#123; <span class="comment">// 若 tree[i] 结点无左孩子，添加之</span></span><br><span class="line">            tree[i].lIdx = ++count; <span class="comment">// 赋予结点标号</span></span><br><span class="line">            tree[tree[i].lIdx] = <span class="keyword">new</span> <span class="title class_">Node</span>(); <span class="comment">// 开辟实例</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tree[i].rIdx == <span class="number">0</span>) &#123; <span class="comment">// 若 tree[i] 结点无右孩子，添加之</span></span><br><span class="line">            tree[i].rIdx = ++count;</span><br><span class="line">            tree[tree[i].rIdx] = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先看构造器。$n$ 是输入区间的大小，它的范围是 $[0,n-1]$ 。 <strong>整个区间的范围是必须知道的</strong> ，因为我们要从输入区间开始不断划分左右区间，因此要传入 $n$ 。 $m$ 是 $tree$ 的大小，因为在这个实现中 $tree[]$ 是 $Node$ 数组，初始化它必须要给出数组大小。在堆式线段树中，这个大小是 $4*n$ ，但前面已经说过 $n$ 特别大，且由于「强制在线」而无法离散化，因此这个大小需要 <strong>「估计」</strong> ，估计方法后述。</p><p>接着看区间修改的驱动方法和具体的区间修改方法，它们与我们前面给出的堆式线段树的写法几乎相同，区别只在于多了一行 <code>addNode(i)</code> 。 $add$ 运行到此处时，之后会划分当前区间为左右子区间，然后带着区间信息和左右子结点的信息递归调用 $add$ (递进到左右子结点中) 。但是我们 <strong>尚未创建左右子结点，甚至当前结点也可能尚未创建</strong> ，因此必须执行 <code>addNode(i)</code> ，根据方法中的判断结果来决定是否要创建当前结点 $tree[i]$ 、左子结点 $tree[tree[i].lIdx]$  或右子结点 $tree[tree[i].rIdx]$ 。我们注意到结点编号是从 1 开始递增的，因此判断是否存在子结点时， 可以不必像判断当前结点是否存在那样执行 <code>tree[tree[i].lIdx] == null</code> 而是通过 <code>tree[i].lIdx == 0</code> 来判断即可。</p><p>同样地，对于其他查询或修改方法，与堆式线段树的实现的区别都只是是在方法中多了 <code>addNode(i)</code> 这一行「开点」语句，如此就实现了 <strong>只在查询或修改时按需动态地创建结点</strong> 这一目标。 完整的类实现我们放在稍后的「类的实现代码」中。如下 ①~⑨ 是在区间为 $[0,14]$ 的输入序列上修改区间 $[1,3]$ 时依次动态创建的结点，注意结点标号是从 1 开始递增的。</p><p><img src="https://pic.leetcode-cn.com/1658817308-RgfxZv-image.png" alt="image.png"></p><br /><h5 id="预估结点数"><a href="#预估结点数" class="headerlink" title="预估结点数"></a>预估结点数</h5><p>$tree[]$ 的大小 $m$ 需要预估。从上图过程中我们看到，每次查询或修改操作的「开点」次数与树高有关，我们知道树高 $h$ 与叶子结点数 $n$ (即我们必须知道的区间大小) 的关系，因此只要能够提前知道操作总次数 (查询和修改) ，并假设查询或修改的区间 <strong>不太大</strong>，我们就能估计经过所有操作后创建的总的结点数，即线段树的大小 $m$。 如下：</p><ol><li>整棵线段树的结点数不会超过 $4*n$ 。</li><li>每次查询从根结点往下，在假设查询或修改的区间 <strong>只有一个值</strong> ，则每次操作从根结点到表示该值的叶子结点的路径上，每一层只会经过一个区间，开两个点。于是开点次数为树高 $h &#x3D; \lceil log_{2}(4<em>n) \rceil -1&#x3D;log_{2}(4</em>n)$  (根结点高 0)，每次开两个点，一次查询最多新建 $2<em>h$ 个结点。但平均而言操作的区间当然不会只有一个值，因此这里我们要适当放大倍数，根据经验可放大到 $6</em>h$ 。</li><li>假设有 $k$ 次操作，则有估计 $m&#x3D;6<em>k</em>log_{2}(4<em>n)$ ，省略 $6</em>k<em>2$ 后得到 $m &#x3D; 6</em>k*logn$  。</li></ol><p>现在，在参考「类的实现代码」中「结点数组法」版本的代码以及 <a href="https://leetcode.cn/problems/range-module/solution/yukiyama-by-yukiyama-lyg5/">题解</a> 的基础上，应当很容易写出「结点数组法动态线段树」解决  <a href="https://leetcode.cn/problems/range-module/">715. Range 模块</a> 。</p><p>应用结点数组法动态线段树解决 715题 时，我们会感到  <strong>$m$ 的预估相对麻烦</strong> ，估计偏小时还可能出现数组越界的错误。让我们考虑更严格的情况。假设操作次数也未知，那么我们将无法估计 $m$ ，也就无法很好地使用结点上数组法来实现动态线段树，除非像 $ArrayList$ 内部动态扩展数组那样，当空间不够时再将当前 $tree[]$ 拷贝到新申请的更大的 $Node$ 数组中，但如此一来单次查询或修改的时间复杂度就不保证是 $O(logn)$ 了。</p><p>避免数组大小预估的思考引出下面的 <strong>「结点指针 (引用)」法动态线段树」</strong> 。</p><br /><h4 id="结点指针-引用-法"><a href="#结点指针-引用-法" class="headerlink" title="结点指针 (引用) 法"></a>结点指针 (引用) 法</h4><p>避免数组大小预估的办法很简单。我们不再通过数组来保存结点信息，而是在 $Node$ 中持有同样是 $Node$ 类型的左子结点 $lChild$ 和右子结点 $rChild$ 。如此一来，在处理到代表区间 $[l,r]$ 的当前结点 $cur$  时，我们总是能够将左右子区间分别与 $cur.lChild$ 或 $cur.rChild$ 「绑定」起来。其实只要读者熟悉二叉树的一些操作，该方法反而比结点数组法要更容易想到。</p><p>结点指针法实现的动态线段树是简单的。我们直接给出如下包含了构造器和区间修改 (增量式) 的代码，对比「结点数组」法的代码，主要区别为：</p><ul><li>指针法的查询或修改方法，直接传入当前结点 <code>Node cur</code> 。</li><li>指针法的线段树类维护根结点 $root$ 。</li><li>动态开点方法 $addNode$ 不同。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DynamicSegmentTreePointerAdd</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        <span class="type">int</span> lazy, val;</span><br><span class="line">        Node lChild, rChild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    Node root;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DynamicSegmentTreePointerAdd</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">        <span class="built_in">this</span>.root = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span>&#123; <span class="comment">// 区间修改(驱动): 增量式 [l,r] 区间所有元素加上x</span></span><br><span class="line">        add(l, r, x, <span class="number">0</span>, n - <span class="number">1</span>, root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单点修改: 增量式 令nums[idx] += x。修改叶子结点，无关标记。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> x, <span class="type">int</span> s, <span class="type">int</span> t, Node cur)</span>&#123; </span><br><span class="line">        <span class="keyword">if</span>(s == t) &#123;</span><br><span class="line">            cur.val += x; <span class="comment">// 增量更新</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        addNode(cur); <span class="comment">// 动态开点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur.lazy != <span class="number">0</span>) pushDown(s, c, t, cur); <span class="comment">// 当前结点懒惰标记不为0，推送标记</span></span><br><span class="line">        <span class="keyword">if</span>(idx &lt;= c) add(idx, x, s, c, cur.lChild);</span><br><span class="line">        <span class="keyword">else</span> add(idx, x, c + <span class="number">1</span>, t, cur.rChild);</span><br><span class="line">        pushUp(cur); <span class="comment">// 后序动作，自底向上更新结点区间和 tree[i]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 动态开点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addNode</span><span class="params">(Node node)</span>&#123; </span><br><span class="line">        <span class="keyword">if</span>(node.lChild == <span class="literal">null</span>) node.lChild = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        <span class="keyword">if</span>(node.rChild == <span class="literal">null</span>) node.rChild = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整实现请参考「类的实现代码」。</p><p>从前面一步步看到这里，我们明显感到动态开点的线段树并不复杂，相比静态线段树，实现上的区别不过是引入了一个 $addNode$ 方法，并在查询和修改方法的适当位置调用该方法动态地创建结点而已。</p><p>现在，在参考「类的实现代码」中「结点指针 (引用) 法」版本的代码以及 <a href="https://leetcode.cn/problems/range-module/solution/yukiyama-by-yukiyama-lyg5/">题解</a> 的基础上，应当很容易写出「结点指针 (引用) 法动态线段树」解决  <a href="https://leetcode.cn/problems/range-module/">715. Range 模块</a> 。</p><br /><h4 id="类的实现代码-2"><a href="#类的实现代码-2" class="headerlink" title="类的实现代码"></a>类的实现代码</h4><h5 id="结点数组法-1"><a href="#结点数组法-1" class="headerlink" title="结点数组法"></a>结点数组法</h5><h6 id="增量式区间修改版-1"><a href="#增量式区间修改版-1" class="headerlink" title="增量式区间修改版"></a>增量式区间修改版</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态开点线段树数组版 (带懒标记，覆盖式区间修改)</span></span><br><span class="line"><span class="comment"> * 支持：单点修改 / 单点查询 / 区间求和 / 覆盖式区间修改</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DynamicSegmentTreeArrayAdd</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        <span class="type">int</span> lIdx, rIdx, lazy, val;</span><br><span class="line">    &#125;</span><br><span class="line">    Node[] tree;</span><br><span class="line">    <span class="type">int</span> n, count;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DynamicSegmentTreeArrayAdd</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">        <span class="built_in">this</span>.count = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">this</span>.tree = <span class="keyword">new</span> <span class="title class_">Node</span>[m];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> x)</span>&#123; <span class="comment">// 单点修改(驱动): 增量式 nums[i] += x</span></span><br><span class="line">        add(i, x, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> x)</span>&#123; <span class="comment">// 单点修改(驱动): 覆盖式 nums[i] = x</span></span><br><span class="line">        update(i, x, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> i)</span>&#123; <span class="comment">// 单点查询 (驱动): 查询 nums[i]</span></span><br><span class="line">        <span class="keyword">return</span> query(i, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span>&#123; <span class="comment">// 区间修改(驱动): 增量式 [l,r] 区间所有元素加上x</span></span><br><span class="line">        add(l, r, x, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span>&#123; <span class="comment">// 区间查询(驱动): nums[l]~nums[r]之和</span></span><br><span class="line">        <span class="keyword">return</span> sum(l, r, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span>&#123; <span class="comment">// 区间查询 (驱动): 查询[l,r]中的最小值</span></span><br><span class="line">        <span class="keyword">return</span> min(l, r, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span>&#123; <span class="comment">// 区间查询 (驱动): 查询[l,r]中的最小值</span></span><br><span class="line">        <span class="keyword">return</span> max(l, r, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单点修改: 增量式 令nums[idx] += x。修改叶子结点，无关标记。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> x, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) &#123;</span><br><span class="line">            tree[i].val += x; <span class="comment">// 增量更新</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        addNode(i); <span class="comment">// 动态开点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(tree[i].lazy != <span class="number">0</span>) pushDown(s, c, t, i); <span class="comment">// 是否推送标记</span></span><br><span class="line">        <span class="keyword">if</span>(idx &lt;= c) add(idx, x, s, c, tree[i].lIdx);</span><br><span class="line">        <span class="keyword">else</span> add(idx, x, c + <span class="number">1</span>, t, tree[i].rIdx);</span><br><span class="line">        pushUp(i); <span class="comment">// 后序动作，自底向上更新结点区间和 tree[i]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单点修改: 覆盖式 令nums[idx] = x。修改叶子结点，无关标记。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> x, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) &#123;</span><br><span class="line">            tree[i].val = x; <span class="comment">// 覆盖更新</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        addNode(i); <span class="comment">// 动态开点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(tree[i].lazy != <span class="number">0</span>) pushDown(s, c, t, i); <span class="comment">// 是否推送标记</span></span><br><span class="line">        <span class="keyword">if</span>(idx &lt;= c) update(idx, x, s, c, tree[i].lIdx);</span><br><span class="line">        <span class="keyword">else</span> update(idx, x, c + <span class="number">1</span>, t, tree[i].rIdx);</span><br><span class="line">        pushUp(i);  <span class="comment">// 后序动作，自底向上更新结点值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单点查询 (具体): 查询 nums[i]，尾递归</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) <span class="keyword">return</span> tree[i].val;</span><br><span class="line">        addNode(i); <span class="comment">// 动态开点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(tree[i].lazy != <span class="number">0</span>) pushDown(s, c, t, i); <span class="comment">// 是否推送标记</span></span><br><span class="line">        <span class="keyword">if</span>(idx &lt;= c) <span class="keyword">return</span> query(idx, s, c, tree[i].lIdx);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> query(idx, c + <span class="number">1</span>, t, tree[i].rIdx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区间修改: 增量式 [l,r] 区间所有元素加上x</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= s &amp;&amp; t &lt;= r)&#123; <span class="comment">// 当前结点代表的区间在所求区间之内</span></span><br><span class="line">            tree[i].val += (t - s + <span class="number">1</span>) * x; <span class="comment">// 结点i的区间和加上t-s+1个x</span></span><br><span class="line">            <span class="keyword">if</span>(s != t) tree[i].lazy += x; <span class="comment">// 结点i不是叶子结点，懒标记值加上x</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        addNode(i); <span class="comment">// 动态开点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(tree[i].lazy != <span class="number">0</span>) pushDown(s, c, t, i); <span class="comment">// 是否推送标记</span></span><br><span class="line">        <span class="keyword">if</span>(l &lt;= c) add(l, r, x, s, c, tree[i].lIdx);</span><br><span class="line">        <span class="keyword">if</span>(r &gt; c) add(l, r, x, c + <span class="number">1</span>, t, tree[i].rIdx);</span><br><span class="line">        pushUp(i); <span class="comment">// 后序动作，自底向上更新结点区间和 tree[i]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区间查询: 求 nums[l]~nums[r]之和</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= s &amp;&amp; t &lt;= r) <span class="keyword">return</span> tree[i].val; <span class="comment">// 当前结点代表的区间在所求区间之内</span></span><br><span class="line">        addNode(i); <span class="comment">// 动态开点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(tree[i].lazy != <span class="number">0</span>) pushDown(s, c, t, i); <span class="comment">// 是否推送标记</span></span><br><span class="line">        <span class="keyword">if</span>(l &lt;= c) sum += sum(l, r, s, c, tree[i].lIdx);</span><br><span class="line">        <span class="keyword">if</span>(r &gt; c) sum += sum(l, r, c + <span class="number">1</span>, t, tree[i].rIdx);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区间查询: 查询[l,r]中的最小值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) <span class="keyword">return</span> tree[i].val; <span class="comment">// 叶子结点</span></span><br><span class="line">        addNode(i); <span class="comment">// 动态开点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>, lmin = Integer.MAX_VALUE, rmin = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">if</span>(tree[i].lazy != <span class="number">0</span>) pushDown(s, c, t, i); <span class="comment">// 是否推送标记</span></span><br><span class="line">        <span class="keyword">if</span>(l &lt;= c) lmin = min(l, r, s, c, tree[i].lIdx);</span><br><span class="line">        <span class="keyword">if</span>(r &gt; c) rmin = min(l, r, c + <span class="number">1</span>, t, tree[i].rIdx);</span><br><span class="line">        <span class="keyword">return</span> Math.min(lmin, rmin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区间查询: 查询[l,r]中的最大值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) <span class="keyword">return</span> tree[i].val;</span><br><span class="line">        addNode(i); <span class="comment">// 动态开点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>, lmax = Integer.MIN_VALUE, rmax = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">if</span>(tree[i].lazy != <span class="number">0</span>) pushDown(s, c, t, i);</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= c) lmax = max(l, r, s, c, tree[i].lIdx);</span><br><span class="line">        <span class="keyword">if</span>(r &gt; c) rmax = max(l, r, c + <span class="number">1</span>, t, tree[i].rIdx);</span><br><span class="line">        <span class="keyword">return</span> Math.max(lmax, rmax);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// pushup: 更新 cur.val</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pushUp</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> tree[i], lChild = tree[cur.lIdx], rChild = tree[cur.rIdx];</span><br><span class="line">        cur.val = lChild.val + rChild.val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// pushdown: 更新当前结点及其左右子结点的懒标记</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pushDown</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> c, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> tree[i], lChild = tree[cur.lIdx], rChild = tree[cur.rIdx];</span><br><span class="line">        lChild.val += (c - s + <span class="number">1</span>) * cur.lazy; <span class="comment">// 更新其左子结点的区间和</span></span><br><span class="line">        lChild.lazy += cur.lazy; <span class="comment">// 传递懒标记</span></span><br><span class="line">        rChild.val += (t - c) * cur.lazy;</span><br><span class="line">        rChild.lazy += cur.lazy;</span><br><span class="line">        cur.lazy = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 动态开点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addNode</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tree[i] == <span class="literal">null</span>) tree[i] = <span class="keyword">new</span> <span class="title class_">Node</span>(); <span class="comment">// 当前结点未建，创建之</span></span><br><span class="line">        <span class="keyword">if</span>(tree[i].lIdx == <span class="number">0</span>) &#123; <span class="comment">// 若 tree[i] 结点无左孩子，添加之</span></span><br><span class="line">            tree[i].lIdx = ++count; <span class="comment">// 赋予结点标号</span></span><br><span class="line">            tree[tree[i].lIdx] = <span class="keyword">new</span> <span class="title class_">Node</span>(); <span class="comment">// 开辟实例</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tree[i].rIdx == <span class="number">0</span>) &#123; <span class="comment">// 若 tree[i] 结点无右孩子，添加之</span></span><br><span class="line">            tree[i].rIdx = ++count;</span><br><span class="line">            tree[tree[i].rIdx] = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h6 id="覆盖式区间修改版-1"><a href="#覆盖式区间修改版-1" class="headerlink" title="覆盖式区间修改版"></a>覆盖式区间修改版</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态开点线段树数组版 (带懒标记，覆盖式区间修改为)</span></span><br><span class="line"><span class="comment"> * 支持：单点修改 / 单点查询 / 区间求和 / 覆盖式区间修改</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DynamicSegmentTreeArrayUpdate</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        <span class="type">int</span> lIdx, rIdx, lazy, val;</span><br><span class="line">        <span class="type">boolean</span> updated;</span><br><span class="line">    &#125;</span><br><span class="line">    Node[] tree;</span><br><span class="line">    <span class="type">int</span> n, count;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DynamicSegmentTreeArrayUpdate</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">        <span class="built_in">this</span>.count = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">this</span>.tree = <span class="keyword">new</span> <span class="title class_">Node</span>[m];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> x)</span>&#123; <span class="comment">// 单点修改(驱动): 增量式 nums[i] += x</span></span><br><span class="line">        add(i, x, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> x)</span>&#123; <span class="comment">// 单点修改(驱动): 覆盖式 nums[i] = x</span></span><br><span class="line">        update(i, x, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> i)</span>&#123; <span class="comment">// 单点查询 (驱动): 查询 nums[i]</span></span><br><span class="line">        <span class="keyword">return</span> query(i, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span>&#123; <span class="comment">// 区间修改(驱动): 覆盖式 [l,r] 区间所有元素改为x</span></span><br><span class="line">        update(l, r, x, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span>&#123; <span class="comment">// 区间查询(驱动): nums[l]~nums[r]之和</span></span><br><span class="line">        <span class="keyword">return</span> sum(l, r, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span>&#123; <span class="comment">// 区间查询 (驱动): 查询[l,r]中的最小值</span></span><br><span class="line">        <span class="keyword">return</span> min(l, r, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span>&#123; <span class="comment">// 区间查询 (驱动): 查询[l,r]中的最大值</span></span><br><span class="line">        <span class="keyword">return</span> max(l, r, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单点修改: 增量式 令nums[idx] += x。修改叶子结点，无关标记。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> x, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) &#123;</span><br><span class="line">            tree[i].val += x; <span class="comment">// 增量更新</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        addNode(i); <span class="comment">// 动态开点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(tree[i].updated) pushDown(s, c, t, i); <span class="comment">// 是否推送标记</span></span><br><span class="line">        <span class="keyword">if</span>(idx &lt;= c) add(idx, x, s, c, tree[i].lIdx);</span><br><span class="line">        <span class="keyword">else</span> add(idx, x, c + <span class="number">1</span>, t, tree[i].rIdx);</span><br><span class="line">        pushUp(i); <span class="comment">// 后序动作，自底向上更新结点区间和 tree[i]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单点修改: 覆盖式 令nums[idx] = x。修改叶子结点，无关标记。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> x, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) &#123;</span><br><span class="line">            tree[i].val = x; <span class="comment">// 覆盖更新</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        addNode(i); <span class="comment">// 动态开点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(tree[i].updated) pushDown(s, c, t, i); <span class="comment">// 是否推送标记</span></span><br><span class="line">        <span class="keyword">if</span>(idx &lt;= c) update(idx, x, s, c, tree[i].lIdx);</span><br><span class="line">        <span class="keyword">else</span> update(idx, x, c + <span class="number">1</span>, t, tree[i].rIdx);</span><br><span class="line">        pushUp(i);  <span class="comment">// 后序动作，自底向上更新结点区间和 tree[i]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单点查询 (具体): 查询 nums[i]，尾递归</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) <span class="keyword">return</span> tree[i].val;</span><br><span class="line">        addNode(i); <span class="comment">// 动态开点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(tree[i].updated) pushDown(s, c, t, i); <span class="comment">// 是否推送标记</span></span><br><span class="line">        <span class="keyword">if</span>(idx &lt;= c) <span class="keyword">return</span> query(idx, s, c, tree[i].lIdx);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> query(idx, c + <span class="number">1</span>, t, tree[i].rIdx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区间修改: 覆盖式 [l,r] 区间所有元素改为x</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= s &amp;&amp; t &lt;= r)&#123; <span class="comment">// 当前结点代表的区间在所求区间之内</span></span><br><span class="line">            tree[i].val = (t - s + <span class="number">1</span>) * x; <span class="comment">// 结点i的区间和等于t-s+1个x</span></span><br><span class="line">            <span class="keyword">if</span>(s != t) &#123;</span><br><span class="line">                tree[i].lazy = x; <span class="comment">// 更新懒标记</span></span><br><span class="line">                tree[i].updated = <span class="literal">true</span>; <span class="comment">// 更新updated</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        addNode(i); <span class="comment">// 动态开点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(tree[i].updated) pushDown(s, c, t, i); <span class="comment">// 是否推送标记</span></span><br><span class="line">        <span class="keyword">if</span>(l &lt;= c) update(l, r, x, s, c, tree[i].lIdx);</span><br><span class="line">        <span class="keyword">if</span>(r &gt; c) update(l, r, x, c + <span class="number">1</span>, t, tree[i].rIdx);</span><br><span class="line">        pushUp(i); <span class="comment">// 后序动作，自底向上更新结点值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区间查询: 求 nums[l]~nums[r]之和</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= s &amp;&amp; t &lt;= r) <span class="keyword">return</span> tree[i].val; <span class="comment">// 当前结点代表的区间在所求区间之内</span></span><br><span class="line">        addNode(i); <span class="comment">// 动态开点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(tree[i].updated) pushDown(s, c, t, i); <span class="comment">// 是否推送标记</span></span><br><span class="line">        <span class="keyword">if</span>(l &lt;= c) sum += sum(l, r, s, c, tree[i].lIdx);</span><br><span class="line">        <span class="keyword">if</span>(r &gt; c) sum += sum(l, r, c + <span class="number">1</span>, t, tree[i].rIdx);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区间查询: 查询[l,r]中的最小值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) <span class="keyword">return</span> tree[i].val; <span class="comment">// 叶子结点</span></span><br><span class="line">        addNode(i); <span class="comment">// 动态开点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>, lmin = Integer.MAX_VALUE, rmin = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">if</span>(tree[i].updated) pushDown(s, c, t, i); <span class="comment">// 是否推送标记</span></span><br><span class="line">        <span class="keyword">if</span>(l &lt;= c) lmin = min(l, r, s, c, tree[i].lIdx);</span><br><span class="line">        <span class="keyword">if</span>(r &gt; c) rmin = min(l, r, c + <span class="number">1</span>, t, tree[i].rIdx);</span><br><span class="line">        <span class="keyword">return</span> Math.min(lmin, rmin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区间查询: 查询[l,r]中的最大值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) <span class="keyword">return</span> tree[i].val;</span><br><span class="line">        addNode(i); <span class="comment">// 动态开点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>, lmax = Integer.MIN_VALUE, rmax = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">if</span>(tree[i].updated) pushDown(s, c, t, i); <span class="comment">// 是否推送标记</span></span><br><span class="line">        <span class="keyword">if</span>(l &lt;= c) lmax = max(l, r, s, c, tree[i].lIdx);</span><br><span class="line">        <span class="keyword">if</span>(r &gt; c) rmax = max(l, r, c + <span class="number">1</span>, t, tree[i].rIdx);</span><br><span class="line">        <span class="keyword">return</span> Math.max(lmax, rmax);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新 cur.val</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pushUp</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> tree[i], lChild = tree[cur.lIdx], rChild = tree[cur.rIdx];</span><br><span class="line">        cur.val = lChild.val + rChild.val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// pushdown: 更新当前结点及其左右子结点的懒标记和updated</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pushDown</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> c, <span class="type">int</span> t, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> tree[i], lChild = tree[cur.lIdx], rChild = tree[cur.rIdx];</span><br><span class="line">        lChild.val = (c - s + <span class="number">1</span>) * cur.lazy; <span class="comment">// 更新左子结点的区间和</span></span><br><span class="line">        lChild.lazy = cur.lazy; <span class="comment">// 传递懒标记(增量标记)到左子结点中</span></span><br><span class="line">        lChild.updated = <span class="literal">true</span>; <span class="comment">// 更新左子结点updated</span></span><br><span class="line">        rChild.val = (t - c) * cur.lazy;</span><br><span class="line">        rChild.lazy = cur.lazy;</span><br><span class="line">        rChild.updated = <span class="literal">true</span>;</span><br><span class="line">        cur.lazy = <span class="number">0</span>; <span class="comment">// 重置当前结点懒惰标记值</span></span><br><span class="line">        cur.updated = <span class="literal">false</span>; <span class="comment">// 更新updated</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 动态开点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addNode</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tree[i] == <span class="literal">null</span>) tree[i] = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        <span class="keyword">if</span>(tree[i].lIdx == <span class="number">0</span>) &#123; <span class="comment">// 若 tree[i] 结点无左孩子，添加之</span></span><br><span class="line">            tree[i].lIdx = ++count; <span class="comment">// 赋予结点标号</span></span><br><span class="line">            tree[tree[i].lIdx] = <span class="keyword">new</span> <span class="title class_">Node</span>(); <span class="comment">// 开辟实例</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tree[i].rIdx == <span class="number">0</span>) &#123; <span class="comment">// 若 tree[i] 结点无右孩子，添加之</span></span><br><span class="line">            tree[i].rIdx = ++count;</span><br><span class="line">            tree[tree[i].rIdx] = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h5 id="结点指针-引用-法-1"><a href="#结点指针-引用-法-1" class="headerlink" title="结点指针 (引用) 法"></a>结点指针 (引用) 法</h5><h6 id="增量式区间修改版-2"><a href="#增量式区间修改版-2" class="headerlink" title="增量式区间修改版"></a>增量式区间修改版</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态开点线段树指针版 (带懒标记，增量式区间修改)</span></span><br><span class="line"><span class="comment"> * 支持：单点修改 / 单点查询 / 区间求和 / 增量式区间修改</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DynamicSegmentTreePointerAdd</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        <span class="type">int</span> lazy, val;</span><br><span class="line">        Node lChild, rChild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    Node root;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DynamicSegmentTreePointerAdd</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">        <span class="built_in">this</span>.root = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> x)</span>&#123; <span class="comment">// 单点修改(驱动): 增量式 nums[i] += x</span></span><br><span class="line">        add(i, x, <span class="number">0</span>, n - <span class="number">1</span>, root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> x)</span>&#123; <span class="comment">// 单点修改(驱动): 覆盖式 nums[i] = x</span></span><br><span class="line">        update(i, x, <span class="number">0</span>, n - <span class="number">1</span>, root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> i)</span>&#123; <span class="comment">// 单点查询 (驱动): 查询 nums[i]</span></span><br><span class="line">        <span class="keyword">return</span> query(i, <span class="number">0</span>, n - <span class="number">1</span>, root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span>&#123; <span class="comment">// 区间修改(驱动): 增量式 [l,r] 区间所有元素加上x</span></span><br><span class="line">        add(l, r, x, <span class="number">0</span>, n - <span class="number">1</span>, root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span>&#123; <span class="comment">// 区间查询(驱动): nums[l]~nums[r]之和</span></span><br><span class="line">        <span class="keyword">return</span> sum(l, r, <span class="number">0</span>, n - <span class="number">1</span>, root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span>&#123; <span class="comment">// 区间查询 (驱动): 查询[l,r]中的最小值</span></span><br><span class="line">        <span class="keyword">return</span> min(l, r, <span class="number">0</span>, n - <span class="number">1</span>, root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span>&#123; <span class="comment">// 区间查询 (驱动): 查询[l,r]中的最大值</span></span><br><span class="line">        <span class="keyword">return</span> max(l, r, <span class="number">0</span>, n - <span class="number">1</span>, root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单点修改: 增量式 令nums[idx] += x。修改叶子结点，无关标记。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> x, <span class="type">int</span> s, <span class="type">int</span> t, Node cur)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) &#123;</span><br><span class="line">            cur.val += x; <span class="comment">// 增量更新</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        addNode(cur); <span class="comment">// 动态开点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur.lazy != <span class="number">0</span>) pushDown(s, c, t, cur); <span class="comment">// 是否推送标记</span></span><br><span class="line">        <span class="keyword">if</span>(idx &lt;= c) add(idx, x, s, c, cur.lChild);</span><br><span class="line">        <span class="keyword">else</span> add(idx, x, c + <span class="number">1</span>, t, cur.rChild);</span><br><span class="line">        pushUp(cur); <span class="comment">// 后序动作，自底向上更新结点区间和 tree[i]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单点修改: 覆盖式 令nums[idx] = x。修改叶子结点，无关标记。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> x, <span class="type">int</span> s, <span class="type">int</span> t, Node cur)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) &#123;</span><br><span class="line">            cur.val = x; <span class="comment">// 覆盖更新</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        addNode(cur); <span class="comment">// 动态开点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur.lazy != <span class="number">0</span>) pushDown(s, c, t, cur); <span class="comment">// 是否推送标记</span></span><br><span class="line">        <span class="keyword">if</span>(idx &lt;= c) update(idx, x, s, c, cur.lChild);</span><br><span class="line">        <span class="keyword">else</span> update(idx, x, c + <span class="number">1</span>, t, cur.rChild);</span><br><span class="line">        pushUp(cur);  <span class="comment">// 后序动作，自底向上更新结点区间和 tree[i]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单点查询: 查询 nums[i]，尾递归</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> s, <span class="type">int</span> t, Node cur)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) <span class="keyword">return</span> cur.val;</span><br><span class="line">        addNode(cur); <span class="comment">// 动态开点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur.lazy != <span class="number">0</span>) pushDown(s, c, t, cur); <span class="comment">// 是否推送标记</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt;= c) <span class="keyword">return</span> query(i, s, c, cur.lChild);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> query(i, c + <span class="number">1</span>, t, cur.rChild);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区间修改: 增量式 [l,r] 区间所有元素加上x</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> s, <span class="type">int</span> t, Node cur)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= s &amp;&amp; t &lt;= r)&#123; <span class="comment">// 当前结点代表的区间在所求区间之内</span></span><br><span class="line">            cur.val += (t - s + <span class="number">1</span>) * x; <span class="comment">// 结点i的区间和加上t-s+1个x</span></span><br><span class="line">            <span class="keyword">if</span>(s != t) cur.lazy += x; <span class="comment">// 结点i不是叶子结点，懒标记值加上x</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        addNode(cur); <span class="comment">// 动态开点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur.lazy != <span class="number">0</span>) pushDown(s, c, t, cur); <span class="comment">// 是否推送标记</span></span><br><span class="line">        <span class="keyword">if</span>(l &lt;= c) add(l, r, x, s, c, cur.lChild);</span><br><span class="line">        <span class="keyword">if</span>(r &gt; c) add(l, r, x, c + <span class="number">1</span>, t, cur.rChild);</span><br><span class="line">        pushUp(cur); <span class="comment">// 后序动作，自底向上更新结点区间和 tree[i]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区间查询: 求 nums[l]~nums[r]之和</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> s, <span class="type">int</span> t, Node cur)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= s &amp;&amp; t &lt;= r) <span class="keyword">return</span> cur.val; <span class="comment">// 当前结点代表的区间在所求区间之内</span></span><br><span class="line">        addNode(cur); <span class="comment">// 动态开点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur.lazy != <span class="number">0</span>) pushDown(s, c, t, cur); <span class="comment">// 是否推送标记</span></span><br><span class="line">        <span class="keyword">if</span>(l &lt;= c) sum += sum(l, r, s, c, cur.lChild);</span><br><span class="line">        <span class="keyword">if</span>(r &gt; c) sum += sum(l, r, c + <span class="number">1</span>, t, cur.rChild);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区间查询: 查询[l,r]中的最小值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> s, <span class="type">int</span> t, Node cur)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) <span class="keyword">return</span> cur.val; <span class="comment">// 叶子结点</span></span><br><span class="line">        addNode(cur); <span class="comment">// 动态开点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>, lmin = Integer.MAX_VALUE, rmin = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">if</span>(cur.lazy != <span class="number">0</span>) pushDown(s, c, t, cur); <span class="comment">// 是否推送标记</span></span><br><span class="line">        <span class="keyword">if</span>(l &lt;= c) lmin = min(l, r, s, c, cur.lChild);</span><br><span class="line">        <span class="keyword">if</span>(r &gt; c) rmin = min(l, r, c + <span class="number">1</span>, t, cur.rChild);</span><br><span class="line">        <span class="keyword">return</span> Math.min(lmin, rmin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区间查询: 查询[l,r]中的最大值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> s, <span class="type">int</span> t, Node cur)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) <span class="keyword">return</span> cur.val;</span><br><span class="line">        addNode(cur);</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>, lmax = Integer.MIN_VALUE, rmax = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">if</span>(cur.lazy != <span class="number">0</span>) pushDown(s, c, t, cur);</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= c) lmax = max(l, r, s, c, cur.lChild);</span><br><span class="line">        <span class="keyword">if</span>(r &gt; c) rmax = max(l, r, c + <span class="number">1</span>, t, cur.rChild);</span><br><span class="line">        <span class="keyword">return</span> Math.max(lmax, rmax);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// pushup: 更新 cur.val</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pushUp</span><span class="params">(Node cur)</span>&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">lChild</span> <span class="operator">=</span> cur.lChild, rChild = cur.rChild;</span><br><span class="line">        cur.val = lChild.val + rChild.val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// pushdown: 更新当前结点及其左右子结点的懒标记</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pushDown</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> c, <span class="type">int</span> t, Node cur)</span>&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">lChild</span> <span class="operator">=</span> cur.lChild, rChild = cur.rChild;</span><br><span class="line">        lChild.val += (c - s + <span class="number">1</span>) * cur.lazy; <span class="comment">// 更新其左子结点的区间和</span></span><br><span class="line">        lChild.lazy += cur.lazy; <span class="comment">// 传递懒标记</span></span><br><span class="line">        rChild.val += (t - c) * cur.lazy;</span><br><span class="line">        rChild.lazy += cur.lazy;</span><br><span class="line">        cur.lazy = <span class="number">0</span>; <span class="comment">// 重置当前结点懒惰标记值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 动态开点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addNode</span><span class="params">(Node node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node.lChild == <span class="literal">null</span>) node.lChild = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        <span class="keyword">if</span>(node.rChild == <span class="literal">null</span>) node.rChild = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h6 id="覆盖式区间修改版-2"><a href="#覆盖式区间修改版-2" class="headerlink" title="覆盖式区间修改版"></a>覆盖式区间修改版</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态开点线段树指针版 (带懒标记，覆盖式区间修改)</span></span><br><span class="line"><span class="comment"> * 支持：单点修改 / 单点查询 / 区间查询 / 覆盖式区间修改</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DynamicSegmentTreePointerUpdate</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        <span class="type">int</span> lazy, val;</span><br><span class="line">        <span class="type">boolean</span> updated;</span><br><span class="line">        Node lChild, rChild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    Node root;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DynamicSegmentTreePointerUpdate</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">        <span class="built_in">this</span>.root = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> x)</span>&#123; <span class="comment">// 单点修改(驱动): 增量式 nums[i] += x</span></span><br><span class="line">        add(i, x, <span class="number">0</span>, n - <span class="number">1</span>, root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> x)</span>&#123; <span class="comment">// 单点修改(驱动): 覆盖式 nums[i] = x</span></span><br><span class="line">        update(i, x, <span class="number">0</span>, n - <span class="number">1</span>, root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> i)</span>&#123; <span class="comment">// 单点查询(驱动): 查询 nums[i]</span></span><br><span class="line">        <span class="keyword">return</span> query(i, <span class="number">0</span>, n - <span class="number">1</span>, root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span>&#123; <span class="comment">// 区间修改(驱动): 增量式 [l,r] 区间所有元素加上x</span></span><br><span class="line">        update(l, r, x, <span class="number">0</span>, n - <span class="number">1</span>, root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span>&#123; <span class="comment">// 区间查询(驱动): nums[l]~nums[r]之和</span></span><br><span class="line">        <span class="keyword">return</span> sum(l, r, <span class="number">0</span>, n - <span class="number">1</span>, root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span>&#123; <span class="comment">// 区间查询(驱动): 查询[l,r]中的最小值</span></span><br><span class="line">        <span class="keyword">return</span> min(l, r, <span class="number">0</span>, n - <span class="number">1</span>, root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span>&#123; <span class="comment">// 区间查询(驱动): 查询[l,r]中的最大值</span></span><br><span class="line">        <span class="keyword">return</span> max(l, r, <span class="number">0</span>, n - <span class="number">1</span>, root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单点修改: 增量式 令nums[idx] += x。修改叶子结点，无关标记。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> x, <span class="type">int</span> s, <span class="type">int</span> t, Node cur)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) &#123;</span><br><span class="line">            cur.val += x; <span class="comment">// 增量更新</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        addNode(cur); <span class="comment">// 动态开点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur.updated) pushDown(s, c, t, cur); <span class="comment">// 是否推送标记</span></span><br><span class="line">        <span class="keyword">if</span>(idx &lt;= c) add(idx, x, s, c, cur.lChild);</span><br><span class="line">        <span class="keyword">else</span> add(idx, x, c + <span class="number">1</span>, t, cur.rChild);</span><br><span class="line">        pushUp(cur); <span class="comment">// 后序动作，自底向上更新结点区间和 tree[i]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单点修改: 覆盖式 令nums[idx] = x。修改叶子结点，无关标记。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> x, <span class="type">int</span> s, <span class="type">int</span> t, Node cur)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) &#123;</span><br><span class="line">            cur.val = x; <span class="comment">// 覆盖更新</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        addNode(cur); <span class="comment">// 动态开点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur.updated) pushDown(s, c, t, cur); <span class="comment">// 是否推送标记</span></span><br><span class="line">        <span class="keyword">if</span>(idx &lt;= c) update(idx, x, s, c, cur.lChild);</span><br><span class="line">        <span class="keyword">else</span> update(idx, x, c + <span class="number">1</span>, t, cur.rChild);</span><br><span class="line">        pushUp(cur);  <span class="comment">// 后序动作，自底向上更新结点区间和 tree[i]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单点查询: 查询 nums[i]，尾递归</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> s, <span class="type">int</span> t, Node cur)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) <span class="keyword">return</span> cur.val;</span><br><span class="line">        addNode(cur); <span class="comment">// 动态开点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur.updated) pushDown(s, c, t, cur); <span class="comment">// 是否推送标记</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt;= c) <span class="keyword">return</span> query(i, s, c, cur.lChild);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> query(i, c + <span class="number">1</span>, t, cur.rChild);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区间修改: 覆盖式 [l,r] 区间所有元素改为x</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> s, <span class="type">int</span> t, Node cur)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= s &amp;&amp; t &lt;= r)&#123; <span class="comment">// 当前结点代表的区间在所求区间之内</span></span><br><span class="line">            cur.val = (t - s + <span class="number">1</span>) * x; <span class="comment">// 结点i的区间和等于t-s+1个x</span></span><br><span class="line">            <span class="keyword">if</span>(s != t) &#123; <span class="comment">// 结点i不是叶子结点</span></span><br><span class="line">                cur.lazy = x; <span class="comment">// 更新懒标记</span></span><br><span class="line">                cur.updated = <span class="literal">true</span>; <span class="comment">// 更新updated</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        addNode(cur); <span class="comment">// 动态开点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur.updated) pushDown(s, c, t, cur); <span class="comment">// 是否推送标记</span></span><br><span class="line">        <span class="keyword">if</span>(l &lt;= c) update(l, r, x, s, c, cur.lChild);</span><br><span class="line">        <span class="keyword">if</span>(r &gt; c) update(l, r, x, c + <span class="number">1</span>, t, cur.rChild);</span><br><span class="line">        pushUp(cur); <span class="comment">// 后序动作，自底向上更新结点区间和 tree[i]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区间查询: 求 nums[l]~nums[r]之和</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> s, <span class="type">int</span> t, Node cur)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= s &amp;&amp; t &lt;= r) <span class="keyword">return</span> cur.val; <span class="comment">// 当前结点代表的区间在所求区间之内</span></span><br><span class="line">        addNode(cur); <span class="comment">// 动态开点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur.updated) pushDown(s, c, t, cur); <span class="comment">// 是否推送标记</span></span><br><span class="line">        <span class="keyword">if</span>(l &lt;= c) sum += sum(l, r, s, c, cur.lChild);</span><br><span class="line">        <span class="keyword">if</span>(r &gt; c) sum += sum(l, r, c + <span class="number">1</span>, t, cur.rChild);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区间查询: 查询[l,r]中的最小值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> s, <span class="type">int</span> t, Node cur)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) <span class="keyword">return</span> cur.val; <span class="comment">// 叶子结点</span></span><br><span class="line">        addNode(cur); <span class="comment">// 动态开点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>, lmin = Integer.MAX_VALUE, rmin = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">if</span>(cur.updated) pushDown(s, c, t, cur); <span class="comment">// 是否推送标记</span></span><br><span class="line">        <span class="keyword">if</span>(l &lt;= c) lmin = min(l, r, s, c, cur.lChild);</span><br><span class="line">        <span class="keyword">if</span>(r &gt; c) rmin = min(l, r, c + <span class="number">1</span>, t, cur.rChild);</span><br><span class="line">        <span class="keyword">return</span> Math.min(lmin, rmin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区间查询: 查询[l,r]中的最大值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> s, <span class="type">int</span> t, Node cur)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == t) <span class="keyword">return</span> cur.val;</span><br><span class="line">        addNode(cur);</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s + (t - s) / <span class="number">2</span>, lmax = Integer.MIN_VALUE, rmax = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">if</span>(cur.updated) pushDown(s, c, t, cur);</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= c) lmax = max(l, r, s, c, cur.lChild);</span><br><span class="line">        <span class="keyword">if</span>(r &gt; c) rmax = max(l, r, c + <span class="number">1</span>, t, cur.rChild);</span><br><span class="line">        <span class="keyword">return</span> Math.max(lmax, rmax);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// pushup: 更新 cur.val</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pushUp</span><span class="params">(Node cur)</span>&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">lChild</span> <span class="operator">=</span> cur.lChild, rChild = cur.rChild;</span><br><span class="line">        cur.val = lChild.val + rChild.val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// pushdown: 更新当前结点及其左右子结点的懒标记和updated</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pushDown</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> c, <span class="type">int</span> t, Node cur)</span>&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">lChild</span> <span class="operator">=</span> cur.lChild, rChild = cur.rChild;</span><br><span class="line">        lChild.val = (c - s + <span class="number">1</span>) * cur.lazy; <span class="comment">// 更新其左子结点的区间和</span></span><br><span class="line">        lChild.lazy = cur.lazy; <span class="comment">// 传递懒标记(增量标记)</span></span><br><span class="line">        lChild.updated = <span class="literal">true</span>;</span><br><span class="line">        rChild.val = (t - c) * cur.lazy;</span><br><span class="line">        rChild.lazy = cur.lazy;</span><br><span class="line">        rChild.updated = <span class="literal">true</span>;</span><br><span class="line">        cur.lazy = <span class="number">0</span>; <span class="comment">// 重置当前结点懒惰标记值（增量标记置0）</span></span><br><span class="line">        cur.updated = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 动态开点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addNode</span><span class="params">(Node node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node.lChild == <span class="literal">null</span>) node.lChild = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        <span class="keyword">if</span>(node.rChild == <span class="literal">null</span>) node.rChild = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文从基本的静态线段树到动态线段树，介绍了如下内容。</p><ul><li><strong>基本原理：</strong> 通过 <strong>「完全二叉树下标性质」</strong> 和 <strong>「分治算法」</strong> 来理解基本线段树的工作原理。</li><li><strong>基本 (静态) 线段树：</strong> 首先实现了支持「单点修改」和「区间查询」的基本线段树，可解决 <a href="https://leetcode.cn/problems/range-sum-query-mutable/">307. 区域和检索 - 数组可修改</a> 。</li><li><strong>懒惰标记：</strong> 引入 <strong>「懒惰标记」</strong> 和 <strong>「延迟修改」</strong> 的概念，用以实现 $O(logn)$ 时间复杂度的 「区间修改」。</li><li><strong>离散化：</strong> 当区间问题与区间元素的绝对位置无关而只与它们的相对位置有关时，可以采用 <strong>「离散化」</strong> 压缩区间范围，典型题目如 <a href="https://leetcode.cn/problems/falling-squares/">699. 掉落的方块</a> 。具体的离散化方法包括 <strong>「紧离散」</strong> 和 <strong>「松离散」</strong> 。</li><li><strong>动态开点：</strong> 当区间问题具有「<a href="https://en.wikipedia.org/wiki/Online_algorithm">强制在线</a>」的特点时，由于无法离散化，迫使我们思考能否实现 <strong>「动态开点」</strong>  (动态地创建结点) 的线段树。典型题目如 <a href="https://leetcode.cn/problems/range-module/">715. Range 模块</a> 。<ul><li><p><strong>数组法动态线段树：</strong> 若能提前估计树的大小，可用  <strong>「结点数组法」</strong> 实现动态开点线段树。给出结点数估计方法。</p><ul><li><strong>结点数估计</strong>: 在已知操作次数上限的情况下可以预估结点数，以便于初始化「结点数组」。</li></ul></li><li><p><strong>指针法动态线段树：</strong> 通过 <strong>「结点指针 (引用) 法」</strong> 实现的动态开点线段树，无需预估树的大小。</p></li></ul></li></ul><p>文中我们给出了如下十种线段树的完整的类代码。</p><table><thead><tr><th>线段树类</th><th>描述</th></tr></thead><tbody><tr><td>1. $SegmentTreeBasic1$</td><td>基本静态线段树，不带懒惰标记，只支持单点修改和区间查询，实时维护 $nums$</td></tr><tr><td>2. $SegmentTreeBasic2$</td><td>基本静态线段树，不带懒惰标记，只支持单点修改和区间查询，不维护 $nums$</td></tr><tr><td>3. $SegmentTreeAdd$</td><td>静态线段树，带懒惰标记，支持单点修改&#x2F;单点查询&#x2F;增量式区间修改&#x2F;区间查询</td></tr><tr><td>4. $SegmentTreeUpdate$</td><td>静态线段树，带懒惰标记，支持单点修改&#x2F;单点查询&#x2F;覆盖式区间修改&#x2F;区间查询</td></tr><tr><td>5. $DynamicSegmentTreeArrayAdd$</td><td>结点数组法动态线段树，带懒惰标记，支持单点修改&#x2F;单点查询&#x2F;增量式区间修改&#x2F;区间查询</td></tr><tr><td>6. $DynamicSegmentTreeArrayUpdate$</td><td>结点数组法动态线段树，带懒惰标记，支持单点修改&#x2F;单点查询&#x2F;覆盖式区间修改&#x2F;区间查询</td></tr><tr><td>7. $DynamicSegmentTreePointerAdd$</td><td>结点指针法动态线段树，带懒惰标记，支持单点修改&#x2F;单点查询&#x2F;增量式区间修改&#x2F;区间查询</td></tr><tr><td>8. $DynamicSegmentTreePointerUpdate$</td><td>结点指针法动态线段树，带懒惰标记，支持单点修改&#x2F;单点查询&#x2F;覆盖式区间修改&#x2F;区间查询</td></tr><tr><td>9. $SegmentTreeBasicRangeMax$</td><td>区间最大值基本静态线段树，无懒标记，不维护 $nums[i]$，支持单点修改&#x2F;单点查询&#x2F;区间查询</td></tr><tr><td>10. $SegmentTreeBasic$</td><td>扩展区间查询基本静态线段树，无懒标记，不维护 $nums[i]$，支持单点修改&#x2F;单点查询&#x2F;区间查询</td></tr></tbody></table><p>注意，1<del>8 的实现中，$tree[]$ 记录的是「区间和」，9记录的「最大值」，10以三个线段树数组同时记录「区间和」、「区间最大值」以及「区间最小值」。总之，将 1</del>8 中的 $tree[]$ 用于记录「区间最值」，经过我们在「区间最值查询」小节中的调整，即可得到相应的以 $O(logn)$ 时间复杂度实现区间最值查询的线段树版本。</p><p>线段树的应用是十分灵活而强大的，本文只讲解了作者所知的最基本的一些内容，更多的应用已然超出了作者的水平。好在这些内容已基本足够求解力扣上几乎所有线段树题目。</p><p>※ 推荐清华大学张昆玮写的一份 101 页的 ppt 材料 <a href="https://github.com/tiankonguse/lab/blob/master/acm/paper/%E7%BB%9F%E8%AE%A1%E7%9A%84%E5%8A%9B%E9%87%8F%E2%80%94%E2%80%94%E7%BA%BF%E6%AE%B5%E6%A0%91%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B.pdf">统计的力量 —— 线段树全接触</a> ，可作为线段树应用的总览材料。</p><br /><h3 id="实战应用"><a href="#实战应用" class="headerlink" title="实战应用"></a>实战应用</h3><table><thead><tr><th>题目</th><th>难度</th><th>题解</th></tr></thead><tbody><tr><td><a href="https://leetcode.cn/problems/range-sum-query-mutable/">307. 区域和检索 - 数组可修改</a></td><td>中等</td><td><a href="https://leetcode.cn/problems/range-sum-query-mutable/solution/yukiyama-by-yukiyama-euo5/">题解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/falling-squares/">699. 掉落的方块</a></td><td>困难</td><td><a href="https://leetcode.cn/problems/falling-squares/solution/-by-yukiyama-lxtu/">题解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/range-module/">715. Range 模块</a></td><td>困难</td><td><a href="https://leetcode.cn/problems/range-module/solution/yukiyama-by-yukiyama-lyg5/">题解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/the-skyline-problem/">218. 天际线问题</a></td><td>困难</td><td><a href="https://leetcode.cn/problems/the-skyline-problem/solution/by-yukiyama-l4rc/">题解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/my-calendar-i/">729. 我的日程安排表 I</a></td><td>中等</td><td><a href="https://leetcode.cn/problems/my-calendar-i/solution/by-yukiyama-kddx/">题解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/my-calendar-ii/">731. 我的日程安排表 II</a></td><td>中等</td><td><a href="https://leetcode.cn/problems/my-calendar-ii/solution/yukiyama-by-yukiyama-uuvj/">题解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/my-calendar-iii/">732. 我的日程安排表 III</a></td><td>困难</td><td><a href="https://leetcode.cn/problems/my-calendar-iii/solution/by-yukiyama-7zz5/">题解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/meeting-rooms-ii/">253. 会议室 II</a></td><td>中等</td><td><a href="https://leetcode.cn/problems/meeting-rooms-ii/solution/yukiyama-by-yukiyama-9cml/">题解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/longest-increasing-subsequence-ii/">2407. 最长递增子序列 II</a></td><td>困难</td><td><a href="https://leetcode.cn/problems/longest-increasing-subsequence-ii/solution/-by-yukiyama-khmm/">题解</a></td></tr><tr><td>&#x3D;&#x3D;&#x3D;&#x3D; 更多题目追加中 &#x3D;&#x3D;&#x3D;&#x3D;</td><td></td><td></td></tr></tbody></table><br /><hr><p><strong>文章更新日志</strong></p><p>[2022-09-18]</p><ul><li>增加了少量内容，说明 $tree[]$ 代表「区间和」和「区间最值」时，求最值的方法 ($max$ , $min$) 的时间复杂度的区别。即当 $tree[]$ 代表「区间和」时，求最值的方法的时间复杂度为 $O(n)$ ，代表「区间最值」时，为 $O(logn)$ 。</li></ul><p>[2022-08-03]</p><ul><li>在「实战应用」中增加 <a href="https://leetcode.cn/problems/meeting-rooms-ii/">253. 会议室 II</a> 的 <a href="https://leetcode.cn/problems/meeting-rooms-ii/solution/yukiyama-by-yukiyama-9cml/">题解</a> 。</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法与数据结构 </tag>
            
            <tag> 区间问题 </tag>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图论算法从入门到放下</title>
      <link href="/2022/06/15/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E4%B8%8B/"/>
      <url>/2022/06/15/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E4%B8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="图论算法，拿得起放得下"><a href="#图论算法，拿得起放得下" class="headerlink" title="图论算法，拿得起放得下"></a>图论算法，拿得起放得下</h1><blockquote><ul><li><p>可在作者的 <a href="https://github.com/iyukiyama/leetcode-posts">github仓库</a> 中获取本文和其他文章的 markdown 源文件及相关代码。</p></li><li><p>欢迎评论或仓库 PR 指出文章错漏或与我讨论相关问题，我将长期维护所有文章。</p></li><li><p>所有文章均用 Typora 完成写作，可使用 Typora 打开文章 md 文件，以获得最佳阅读体验。</p></li></ul></blockquote><p>⚠️ ⚠️ ⚠️ <strong>本文巨巨巨长，正文近六万字 (不含题解)，尽最大努力全面细致地讲解 bfs&#x2F;dfs、拓扑排序、最短路、最小生成树、最大流，包括不仅限于给出每个专题内容的不同的常见算法 (如在最短路会讲解 DAG SSSP, Dijkstra, Bellman-Ford, SPFA, Floyd-Warshall 等算法)，每一个算法的每一步操作的细节、算法正确性证明、复杂度证明以及完整的可应用的实现代码。全面、细致、系统、准确是本文的追求。</strong></p><p>❗️ <strong>【NEW】</strong> ❗️</p><ul><li>9-15:  <a href="https://leetcode.cn/circle/discuss/SwgIJV/">红黑树从入门到看开</a></li></ul><hr><blockquote><p>$keywords$:</p><p>图的基本概念 &#x2F; 邻接矩阵 &#x2F; 邻接表 &#x2F; 链式向前星 &#x2F; $bfs$ &#x2F; $dfs$ &#x2F; 无向图连通性 &#x2F; 并查集 &#x2F; 无向图判圈 &#x2F; 有向图判圈 &#x2F; $Kahn$ 拓扑排序 &#x2F; $Tarjan$ 拓扑排序 &#x2F; 拓扑排序判圈 &#x2F; 无权单源最短路径 &#x2F; 带权单源最短路径 &#x2F; $Dijkstra$ &#x2F; DAG 单源最短路径 &#x2F; 负边图 &#x2F; 有圈图 &#x2F; $Bellman-Ford$ &#x2F; $SPFA$ &#x2F; 带权全源最短路径 &#x2F; $Floyd-Warshall$ &#x2F; 最小生成树 &#x2F; $Prim$ &#x2F; $Kruskal$ &#x2F; 网络流 &#x2F; 增广路径 &#x2F; 饱和边 &#x2F; 最大流最小割定理 &#x2F; $Ford-Fulkerson$ &#x2F; $Edmonds-Karp$ &#x2F; $Dinic$</p></blockquote><p>这是 yuki 最近一段时间学习图论的总结，发出来跟大家分享 <strong>亿点点</strong> 🤏心得。写这篇文章的契机是前段时间看 Weiss 那本 「数算Java描述」，看着看着发现到图论那章作者就只提供伪代码了 (之前的章节会提供完整的可运行代码)，而且感觉 Weiss 在那一章里什么都提一点，但匆匆抛出几个结论就跑路，整章看下来比较难受。找了好多资料，包括力扣上几本相关的 leetbook，都不太满意。于是乎花了点时间探索整理了一下，写成本文，(我认为的) 优点有四。</p><ol><li><strong>面向小白，入门友好</strong> 。主要针对像我一样的初学者，或者粗浅地看过一些图论算法，但感觉不是特别踏实的朋友。这里的「不踏实」指的是在题解区看到一个问题有眼花缭乱的多种图论方法，但自己只知道常用的那种，有的压根没听过；也可以指的是虽然知道怎么做，但相关算法的正确性证明或复杂度证明，未曾确切地把握过。</li><li><strong>循序渐进，反馈及时</strong> 。特别突出了各章节之间的联系与过渡。为了使读者能够在每一章学习中都有及时的正反馈，每介绍一个算法，我都会配套一道力扣上的原题 (力扣没有典型题目则采用其他平台的题目)。</li><li><strong>编排得当，重点全面。</strong> 内容编排上作者也颇费苦心，例如「初探图搜索 (遍历)」一节，推敲几日，最终决定用「无向图连通性」问题引入 $bfs&#x2F;dfs$ 。然后再以「无向图判圈」和「有向图判圈」问题，一面加强对 $bfs&#x2F;dfs$ 写法变化的把握，一面也突出有向图和无向图中 $bfs&#x2F;dfs$ 写法的差异。再如「最短路径」中，从无权单源到带权单源，包括带权单源中的 DAG 情形，再到带权全源，网罗各种情形下的最短路算法，朴素版和优化版都详细给出算法过程，复杂度分析，一些特殊情形的讨论，以及针对具体题目的实现代码等。</li><li><strong>证明翔实，有根有据</strong> 。在「最短路」和「最大流」这两个章节中，对所有不易看出的结论均给出了详细的，较为严格的证明。<strong>包括且不限于对 Dijkstra、Prim、Bellman-Ford、SPFA、Floyd-Warshall 算法的正确性证明，对「最大流最小割定理」的证明，对 Edmonds-Karp、Dinic 算法复杂度的证明等。</strong> 部分证明着实耗尽了作者的最后一点智商，导致目前 <strong>智商欠费，大脑停机</strong> 。</li></ol><p>本文所涉具已呈于「主要内容一览」中，如果朋友们觉得合适，不妨一看。希望朋友们能感受到 yuki 的 <strong>亿点用心</strong> 。</p><br /><p><strong>本文标题</strong> 意在表达作者的一种「希望」，即通过本文的学习，看似沉重的图论算法，也能 <strong>重重拿起，轻轻放下</strong> 。</p><p>然而不幸的是，作者能力水平十分有限，文章虽已审视几轮，所列代码也悉经验证，但根据之前几篇文章的经验，这一篇也会毫无例外地出现一些错误。因此本文既是心得分享，也是小白 yuki 再次向大家请教的一次机会，<strong>文中若有疏漏之处，请各位不吝赐教</strong> 🤝。</p><p>※ Dinic 的代码还需一些时间验证，暂不列出。「实战应用」中目前有十几题，会持续增加，整篇文章也会持续维护。</p><p>※ 部分算法正确性证明及复杂度证明以单篇文章发布过，但为了保持本文完整度，也一并呈现。</p><p>※ 内容可能较多，可根据目录选择性阅读。</p><hr><p>yuki的其他文章如下，欢迎阅读指正！</p><blockquote><p>如下所有文章同时也在我的 github <a href="https://github.com/iyukiyama/leetcode-posts">仓库</a> 中维护。</p></blockquote><table><thead><tr><th>文章</th><th>[发布时间] 字数&#x2F;览&#x2F;藏&#x2F;赞 (~2022-10-20)</th></tr></thead><tbody><tr><td><a href="https://leetcode.cn/circle/discuss/eBo9UB/">十大排序从入门到入赘</a>  🔥🔥🔥</td><td>[20220516]  2.5万字&#x2F;64.8k览&#x2F;3.7k藏&#x2F;937赞</td></tr><tr><td><a href="https://leetcode.cn/circle/discuss/ooxfo8/">二分查找从入门到入睡</a> 🔥🔥🔥</td><td>[20220509]  2.3万字&#x2F;38.4k览&#x2F;2.1k藏&#x2F;503赞</td></tr><tr><td><a href="https://leetcode.cn/circle/discuss/qmjuMW/">并查集从入门到出门</a> 🔥🔥</td><td>[20220514]  1.2万字&#x2F;17.9k览&#x2F;1.0k藏&#x2F;321赞</td></tr><tr><td><a href="https://leetcode.cn/circle/discuss/FyPTTM/">图论算法从入门到放下</a> 🔥🔥</td><td>[20220617]  5.6万字&#x2F;19.9k览&#x2F;1.3k藏&#x2F;365赞</td></tr><tr><td>树ADT系列 (预计13篇)</td><td>系列文章，连载中</td></tr><tr><td>3. <a href="https://leetcode.cn/circle/discuss/wPzlSb/">二叉查找树</a></td><td>[20220801]  5千字</td></tr><tr><td>4. <a href="https://leetcode.cn/circle/discuss/zbwD3p/">AVL树</a></td><td>[20220817]  5千字</td></tr><tr><td>5. <a href="https://leetcode.cn/circle/discuss/BCK17f/">splay树</a></td><td>[20220817]  5千字</td></tr><tr><td>6. <a href="https://leetcode.cn/circle/discuss/SwgIJV/">红黑树从入门到看开</a> 🔥🤯🤯🤯</td><td>[20220915]  3万字&#x2F;5.3k览&#x2F;269藏&#x2F;72赞</td></tr><tr><td>10. <a href="https://leetcode.cn/circle/discuss/qGREiN/">树状数组从入门到下车</a> 🔥🤯</td><td>[20220722]  1.4万字&#x2F;5.8k览&#x2F;196藏&#x2F;72赞</td></tr><tr><td>11. <a href="https://leetcode.cn/circle/discuss/H4aMOn/">线段树从入门到急停</a> 🔥🤯</td><td>[20220726]  2.5万字&#x2F;8.7k览&#x2F;481藏&#x2F;138赞</td></tr><tr><td><a href="https://leetcode.cn/circle/discuss/GV0JrV/">图论相关证明系列</a></td><td>系列文章</td></tr><tr><td>1. <a href="https://leetcode.cn/circle/discuss/jJQn7V/">Dijkstra正确性证明</a> 🤯</td><td>[20220531]</td></tr><tr><td>2. <a href="https://leetcode.cn/circle/discuss/VVEc8f/">Prim正确性证明</a> 🤯</td><td>[20220919]</td></tr><tr><td>3. <a href="https://leetcode.cn/circle/discuss/xeEwYl/">Bellman-Ford及SPFA正确性证明</a></td><td>[20220602]</td></tr><tr><td>4. <a href="https://leetcode.cn/circle/discuss/Nbzix4/">Floyd正确性证明</a></td><td>[20220602]</td></tr><tr><td>5. <a href="https://leetcode.cn/circle/discuss/tMIy36/">最大流最小割定理证明</a> 🤯🤯</td><td>[20220719]</td></tr><tr><td>6. <a href="https://leetcode.cn/circle/discuss/tN3sZc/">Edmonds-Karp复杂度证明</a> 🤯🤯</td><td>[20220515]</td></tr><tr><td>7. <a href="https://leetcode.cn/circle/discuss/T9Xa1R/">Dinic复杂度证明</a> 🤯🤯</td><td>[20220531]</td></tr></tbody></table><hr><p>[2022-09-28]</p><ul><li>进一步完善了 Prim 算法正确性证明过程。</li></ul><p>[2022-09-20]</p><ul><li>修改了 Bellman-Ford 方法求解 <a href="https://leetcode.cn/problems/network-delay-time/">743. 网络延迟时间</a> 的代码中的一处 bug 。即若本次全量松弛执行了松弛操作，则 <code>finished = false</code> ，随后在开始下一次全量松弛前应将 <code>finished</code> 置回 <code>true</code>。感谢 <a href="/u/nTouKxAnj3/">@nTouKxAnj3</a> (@河) 、 <a href="/u/rain-roc/">@rain-roc</a> (@RainRoc) 指出。</li></ul><p>[2022-09-08]</p><ul><li>新增了 Prim 算法正确性证明小节。（小节路径: 最小生成树 &gt; Prim &gt; 朴素版 &gt; 正确性证明）</li></ul><hr><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>[TOC]</p><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><h3 id="内容一览"><a href="#内容一览" class="headerlink" title="内容一览"></a>内容一览</h3><p><img src="https://pic.leetcode-cn.com/1655634577-VLJzzl-graph-mind.png" alt="graph-mind.png"></p><br /><h3 id="图论算法复杂度一览"><a href="#图论算法复杂度一览" class="headerlink" title="图论算法复杂度一览"></a>图论算法复杂度一览</h3><p>以下列出本文讲解的全部图论算法的时空复杂度。</p><table><thead><tr><th>分类</th><th>算法</th><th>时间复杂度</th></tr></thead><tbody><tr><td>图遍历</td><td>bfs</td><td>$O(V+E)$</td></tr><tr><td></td><td>dfs</td><td>$O(V+E)$</td></tr><tr><td>拓扑排序</td><td>Kahn</td><td>$O(V+E)$</td></tr><tr><td></td><td>Tarjan (TopoSort)</td><td>$O(V+E)$</td></tr><tr><td>最短路</td><td>无权SSSP 朴素版</td><td>$O(V^2)$</td></tr><tr><td></td><td>无权SSSP 队列版</td><td>$O(V+E)$</td></tr><tr><td></td><td>Dijkstra 朴素版</td><td>$O(V^2)$</td></tr><tr><td></td><td>Dijkstra 优先队列版</td><td>$O(ElogV)$</td></tr><tr><td></td><td>DAG SSSP</td><td>$O(V+E)$</td></tr><tr><td></td><td>Bellman-Ford</td><td>$O(VE)$</td></tr><tr><td></td><td>SPFA (BFM)</td><td>$O(VE)$</td></tr><tr><td></td><td>Floyd-Warshall</td><td>$O(V^3)$</td></tr><tr><td>最小生成树</td><td>Prim 朴素版</td><td>$O(V^2)$</td></tr><tr><td></td><td>Prim 优先队列版</td><td>$O(ElogV)$</td></tr><tr><td></td><td>Kruskal</td><td>$O(ElogV)$</td></tr><tr><td>最大流</td><td>Ford-Fulkerson</td><td>$O(E*f)$</td></tr><tr><td></td><td>Edmonds-Karp</td><td>$O(VE^2)$</td></tr><tr><td></td><td>Dinic (Dinitz)</td><td>$O(V^2E)$</td></tr></tbody></table><p>※  $V$ 和 $E$ 表示点集和边集，表格中涉及到「数量」的 $V$ 和 $E$，应为 $|V|$ 和 $|E|$ (半角 “|” 会影响 markdown 表格的显示)。</p><p>※ 空间复杂度主要取决于建图方式，以「邻接矩阵」建图时为 $O(|V|^2)$，以「邻接表」建图时为 $O(|V|+|E|)$ ，表中不再列出。</p><br /><h3 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h3><table><thead><tr><th>概念</th><th>描述</th></tr></thead><tbody><tr><td>顶点 &amp; 边<br /><em>vertex &amp; edge</em></td><td>一对顶点 $(u, v), u, v ∈ V$ 。$V$ 为顶点集。所有边构成边集  $E$。<br /> 边的条数表为 $E$ ，顶点的个数表为 $V$ 。</td></tr><tr><td>图<br /><em>graph</em></td><td>顶点集 $V$ 和边集 $E$ 构成图。</td></tr><tr><td>权 &#x2F; 值<br /><em>weight &#x2F; cost</em></td><td>边的权重。</td></tr><tr><td>邻接<br /><em>adjacent</em></td><td>顶点 $u$ 与 $v$ 邻接当且仅当 $(u, v) ∈ E$ 。</td></tr><tr><td>邻接矩阵<br /><em>adjacent matrix</em></td><td>以矩阵表示图。对每条边 $(u, v)$ 置矩阵的 $A[u, v]$ 为 $true$，无 $(u, v)$ 边则为 $false$。<br />若边有权，则 $A[u, v]$ 等于该值，以一个很大或很小的数表示该边不存在。</td></tr><tr><td>邻接表<br /><em>adjacency list</em></td><td>对每一个顶点，以一个表存放其邻接顶点，共以 $V$ 个表表示图。</td></tr><tr><td>无向图<br /><em>undirected graph</em></td><td>点无序的图，$(u, v)$ 与 $(v, u)$ 为同一条边。</td></tr><tr><td>有向图<br /><em>directed graph &#x2F; digraph</em></td><td>点对有序的图，$(u, v)$ 与 $(v, u)$ 为两条不同的边。</td></tr><tr><td>度<br /><em>degree</em></td><td>对无向图顶点 $v$ 而言，其边的数量，也即其邻接顶点的数量。</td></tr><tr><td>入度<br /><em>indegree</em></td><td>对有向图顶点 $v$ 而言，$(u, v)$ 边的数量</td></tr><tr><td>出度<br /><em>outdegree</em></td><td>对有向图顶点 $v$ 而言，$(v, u)$ 边的数量</td></tr><tr><td>路径<br /><em>path</em></td><td>为一顶点序列 $v_1, v_2, v_3,…,v_N$ 使得 $(v_i, v_{i+1}) ∈ E, 1&lt;&#x3D;i&lt;&#x3D;N-1$ <br />一个顶点到他自身也可以看成是一条路径，如果路径不包含边，则路径长为 0 。</td></tr><tr><td>路径长度<br /><em>path length</em></td><td>无向图中指路径上的边数，有向图中指路径边权和。</td></tr><tr><td>简单路径<br /><em>simple path</em></td><td>所有顶点都不同的路径。</td></tr><tr><td>圈<br /><em>cycle</em></td><td>满足 $v_1 &#x3D; v_N$ 的长至少为 1 的路径。</td></tr><tr><td>环 &#x2F; 自环<br /><em>loop</em></td><td>一个顶点到它自身的边 $(v, v)$ ，此概念不常用。<br />通常环也被视作圈。中文语境下「环」与「圈」通常不做区分，具体需联系上下文理解。</td></tr><tr><td>有向无环(圈)图<br /><em>directed acyclic graph, DAG</em></td><td>无(环)圈的有向图。</td></tr><tr><td>连通图<br /><em>connected graph</em></td><td>从一顶点 $w$ 到另一顶点 $v$ 有路径相连称 $w$ 与 $v$ 连通，<br />任意两顶点之间连通的图称为连通图。有向连通图两点之间的路径上的边同向。</td></tr><tr><td>连通分量<br /><em>connected component</em></td><td>对于无向图而言，一个极大连通子图为一个连通分量。<br />所有连通分量构成互相没有相同顶点的子图集合。</td></tr><tr><td>基础图<br /><em>underlying graph</em></td><td>有向图去掉边的方向后的图称为该有向图的基础图 (无向图)。</td></tr><tr><td>强连通<br /><em>strongly connected</em></td><td>称有向连通图是强连通的。</td></tr><tr><td>强连通分量<br /><em>strongly connected component (SCC)</em></td><td>对于有向图基础图的一个连通分量，<br />若其中的顶点两两连通，则称此连通分量为强连通分量。</td></tr><tr><td>弱连通<br /><em>weakly connected</em></td><td>有向图不是强连通的，但其基础图是连通的，则称该有向图是弱连通的。</td></tr><tr><td>完全图<br /><em>complete graph</em></td><td>每一对顶点间都有边相连的图。</td></tr></tbody></table><p>在后续叙述中，我会假定你已熟悉该表所罗列概念。</p><br /><h2 id="图的表示"><a href="#图的表示" class="headerlink" title="图的表示"></a>图的表示</h2><p>求解图上问题，首先要以合适的方式存储图。图的基本信息是顶点、边、边的方向以及边权，通过「邻接矩阵」或「邻接表」来存储图，可以很好地组织上述信息。本节简单介绍这两种存图方式，但暂不呈现相关代码，在后续章节解决实际问题时，我们会看到程序中是如何应用这两种方式存图以及提取图中的信息的。（本文大部分实现均采用「邻接表」法存图，若读者想立即参考「邻接矩阵」的具体写法，可参考「最短路径」-「带权全源最短路」-「Floyd-Warshall」-「代码」一节的代码。）</p><br /><h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><p>用二维数组 $edges[][]$ (或者二维容器，例如哈希表) 表示图的方法称为「邻接矩阵」存图法。当顶点可以用整数，尤其是从 0 到 $|V| - 1$ 的整数表示时，以二维数组存图，此时 $edges[u][v]$ 表示顶点 $u$ 指向顶点 $v$ 的边，若为带权图，其值表示边权；若为无权图，可令值为 1 或 0 等；若边不存在，可令值为 -1 或 $Infinity$ 等。邻接矩阵表示法所需空间为 $O(|V|^2)$，显然，当图较稀疏时，大量空间将被浪费，利用「邻接表」存图效率更高。</p><br /><h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><p>对每一个顶点，以一个列表来存储其邻接顶点和相应的边权信息，于是图信息被存储在 $|V|$ 个列表中，所有这些列表存储了 $|E|$ 条边的信息，因此邻接表所需空间为 $O(|V|+|E|)$ 。当顶点可以用整数，尤其是从 0 到 $|V| - 1$ 的整数表示时，普遍以线性表来存图。对于无权图，以 <code>List&lt;List&lt;Integer&gt;&gt; graph</code> 存图，通过 <code>graph.get(u).get(v)</code> 来获取边 $(u, v)$ 信息。对于带权图，由于需要存储边权，因此邻接表中的泛型为 $int[]$ ，即以 <code>List&lt;List&lt;int[]&gt;&gt; graph</code> 存图，对于 <code>int[] v_weight = graph.get(u)</code>  ，$v_weight$ 的大小为 2 ， $v_weight[0]$ 为 $u$ 的邻接顶点 $v$，$v_weight[1]$ 为 $|(u,v)|$。 也可以用 <code>List&lt;List&lt;Pair&gt;&gt; graph</code> 存图，但本文不采用此种写法。</p><p>当顶点不适合用非负整数表示时，例如为字符串或其他引用类型，则可用哈希表存图，$ke y$ 为顶点 (字符串或其他引用类型)，$value$ 仍是列表，内部存储顶点 $key$ 邻接顶点。</p><br /><h3 id="链式向前星"><a href="#链式向前星" class="headerlink" title="链式向前星"></a>链式向前星</h3><p>相比前两种存图法，「链式向前星」存图法是一种极具技巧性的存图方式，虽不太直观，但有不少优点，我们先来介绍其具体实现，再分析其优点。</p><p>首先，链式向前星的 <strong>本质也是「邻接表」</strong> ，与邻接表法的显式邻接表 (即 $graph.get(u)$ 获取 $u$ 的 $List$ 类型邻接表) 不同，链式向前星并不显式地存储与顶点对应的邻接表，而是将边编号，通过 <strong>「边下标指针」</strong> 来获取一个顶点的邻边信息。我们直接给出链式向前星具体的存图结构，然后再描述如何通过这样的安排来存图，使得我们能够获取图的相关信息，例如遍历一个顶点的所有边 (邻接顶点)。</p><ul><li><p>边从 $1$ 到 $|E|$ 编号。</p></li><li><p>$ends[]$ 数组大小为 $|E|+1$ ，$ends[edgeNum]$ 表示下标  (编号) 为 $edgeNum$ 的边的终点。</p></li><li><p>$weights[]$ 数组大小为 $|E|+1$ ，用于带权图，$weights[edgeNum]$ 表示下标为 $edgeNum$ 的边的边权。</p></li><li><p>$nexts[]$ 数组大小为 $|E|+1$ ，对于顶点 $u$ ，$nexts[edgeNum]$ 表示下标为 $edgeNum$ 的边 <strong>「在其所在的顶点邻接表」</strong> 中的下一条边。</p></li><li><p>$heads[]$ 数组大小为 $|V|$ ，对于顶点 $u$ ，$heads[u]$表示顶点 $u$ 的第一条边。</p></li></ul><p>链式向前星通过「插头法」加边建图，伪代码如下，建议结合后图分析此伪代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 带权有向图</span></span><br><span class="line"><span class="type">int</span> n, m, edgeNum <span class="comment">// n 为顶点数，m 为边数，edgeNum 为边下标(编号)</span></span><br><span class="line"><span class="type">int</span>[] heads = <span class="keyword">new</span> <span class="title class_">int</span>[n]</span><br><span class="line"><span class="type">int</span>[] weights = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>], ends = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>], nexts = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> u, v, weight <span class="comment">// 添加边(u,v)</span></span><br><span class="line">++edgeNum <span class="comment">// 作为第 edgeNum 条边加入</span></span><br><span class="line">weights[edgeNum] = weight <span class="comment">// 边权</span></span><br><span class="line">ends[edgeNum] = v <span class="comment">// 该边的终点为 v</span></span><br><span class="line"><span class="comment">// heads[u] 表示建图至当前状态时 u 的邻接表中的第一条边(u,w)的下标</span></span><br><span class="line"><span class="comment">// (u,v)是 u 的邻接表中新加入的边，此句表示边(u,v)的下一条边是(u,w)</span></span><br><span class="line"><span class="comment">// 这也就是链式向前星「插头法」的体现，也是较难理解的一句</span></span><br><span class="line">nexts[edgeNum] = heads[u] </span><br><span class="line"><span class="comment">// 因为(u,v)插入了 u 的邻接表中原首边(u,w)之前，则此时的首边为(u,v)</span></span><br><span class="line">heads[u] = edgeNum</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无权无向图</span></span><br><span class="line"><span class="type">int</span> n, m, edgeNum <span class="comment">// n 为顶点数，m 为边数，edgeNum 为边下标(编号)</span></span><br><span class="line"><span class="type">int</span>[] heads = <span class="keyword">new</span> <span class="title class_">int</span>[n]</span><br><span class="line"><span class="type">int</span>[] ends = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span> * m + <span class="number">1</span>], nexts = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span> * m + <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> u, v, val <span class="comment">// 添加边(u,v)和(v,u)</span></span><br><span class="line"><span class="comment">// 以下添加 (u,v)</span></span><br><span class="line">++edgeNum <span class="comment">// 作为第 edgeNum 条边加入</span></span><br><span class="line">ends[edgeNum] = v <span class="comment">// 该边的终点为 v</span></span><br><span class="line">nexts[edgeNum] = heads[u] </span><br><span class="line">heads[u] = edgeNum</span><br><span class="line"><span class="comment">// 以下添加 (v,u)</span></span><br><span class="line">++edgeNum <span class="comment">// 作为第 edgeNum 条边加入</span></span><br><span class="line">ends[edgeNum] = u <span class="comment">// 该边的终点为 v</span></span><br><span class="line">nexts[edgeNum] = heads[v] </span><br><span class="line">heads[v] = edgeNum</span><br></pre></td></tr></table></figure><p>通过下图展示顶点 $u$ 的边是如何被存放和表达的 (只展现关键的 $edgeNum, heads, nexts$ 是如何关连的)。黑色实心圆点表示 $u$ 的第一条边，即 $heads[u]$ 。</p><ul><li><p>在遍历边建图之前，<code>heads[u] = 0</code> ，表示此时 $u$ 无边，图中用蓝色虚线箭头表达。</p></li><li><p>在遍历到第 4 条边时 (前三条边与 $u$ 无关，它们的存图过程与 $u$ 类似)，遇到 $u$ 的第一条边 $(u,x)$ ，该边的编号为 $edgeNum &#x3D; 4$，于是立即让这条新边作为首边 $heads[u] &#x3D; 4$，然后让这条边的后继为上一条边 $nexts[4] &#x3D; 0$ ，但是这需要先保存 0，例如下面这样操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> heads[u]; <span class="comment">// tmp = 0</span></span><br><span class="line">heads[u] = edgeNum; <span class="comment">// heads[u] = 4</span></span><br><span class="line">nexts[edgeNum] = tmp; <span class="comment">// nexts[4] = 0</span></span><br></pre></td></tr></table></figure><p> 实际上我们可以先设置 $nexts[edgeNum]$ 再更新 $heads[u]$ ，就无需 $tmp$ 了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nexts[edgeNum] = heads[u]; <span class="comment">// nexts[4] = 0</span></span><br><span class="line">heads[u] = edgeNum; <span class="comment">// heads[u] = 4</span></span><br></pre></td></tr></table></figure></li><li><p>继续遍历边建图，我们在遍历到第 7 条边时遇到第二条 $u$ 的边 $(u,y)$ ，遍历到第 10 条边时遇到 $u$ 的第三条边 $(u,z)$ 。同样地，每次我们都令新边指向当前首边，然后将新边作为当前首边。</p></li></ul><p><img src="https://pic.leetcode-cn.com/1656653408-mTLGdW-image.png" alt="image.png"></p><p>从上述伪代码和图示中我们感到 <code>nexts[edgeNum] = heads[u]</code> 较难理解，且此行是体现链式向前星「插头法」的核心，建图过程中我们总是以 $heads[u]$ 「实时地」更新顶点 $u$ 的首边。完成建图后，对于任意顶点 $u$ ，$edgeNum &#x3D; heads[u]$ 为 $u$ 的首边下标，通过 $edgeNum &#x3D; nexts[edgeNum]$ 可以「链式」地遍历 $u$ 的所有邻边，直到最后 $edgeNum &#x3D; nexts[edgeNum] &#x3D; 0$，遍历完成。此时我们能够很容易地写出「链式向前星」遍历顶点 $u$ 的邻边的写法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">edgeNum</span> <span class="operator">=</span> heads[u]; edgeNum != <span class="number">0</span>; edgeNum = nexts[edgeNum])&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> ends[edgeNum]; </span><br><span class="line">    <span class="type">int</span> <span class="variable">weight</span> <span class="operator">=</span> weights[edgeNum]; <span class="comment">// 若为带权图</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果还是不太好理解，我们可以把 $edge$ 看作是边类 $Edge$ 的实例，$nexts[edgeNum]$ 是其属性 $edge.next$ ，是此边的下一条边 (的引用)。顶点也看作一个类，每个顶点持有一个 $headEdge$ 属性，表示 $u$ 的首边， $head[u]$ 就是 $u.headEdge$ 。 那么基于数组写法就可以写成 (可能) 我们更熟悉的类的写法 (伪代码，仅作示意)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">遍历到 u 的新边 edge 后的「插头」操作</span><br><span class="line">edge.next = u.headEdge;</span><br><span class="line">u.headEdge = edge;</span><br><span class="line"></span><br><span class="line">遍历 u 的边</span><br><span class="line"><span class="keyword">for</span>(<span class="type">Edge</span> <span class="variable">edge</span> <span class="operator">=</span> u.headEdge; edge != <span class="literal">null</span>; edge = edge.next)</span><br></pre></td></tr></table></figure><p>现在我们能够看出「链式向前星」的如下优点：</p><ol><li>空间复杂度为 $O(|V|+|E|)$ 。且相比利用泛型线性表的邻接表法，空间开销会更小，因为 $List$ 的内部数组通常比实际大小更大。</li><li>由于存粹以数组存图，因此处理速度也会比 $List$ 更快。</li><li>由于对边编号，在某些需要处理一条边的反向边的场景下 (例如最大流算法中)，可以很方便地操作反向边 (具体看「小结」)。</li></ol><p>读者若想尽快把握该存图操作，可直接查看如下位置的相应代码。</p><blockquote><p>无权无向图: 「初探图搜索 (遍历)」-「无向图连通性」-「BFS」-「代码」</p><p>带权有向图: 「最短路径」-「带权单源最短路」-「Dijkstra」-「优先队列版」-「代码」</p></blockquote><p>※ 从前面的图示可以看出「链式向前星」这个命名是很贴切的。根据知乎问题 <a href="https://www.zhihu.com/question/306076815">链式前向星的发明者是谁？</a> ，知乎用户「Malash」似乎是中文「链式向前星」一词的命名者。根据该问题下 「Yixiao Huang」 用户的回答，该存图方式似乎出自此篇发表于 1987 年的论文 <a href="https://dl.acm.org/doi/pdf/10.1145/214762.214769">A versatile data structure for edge-oriented graph algorithms</a> 。</p><br /><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>本节学习了三种图的表示方法，各有特点，也有各自适合的应用场景。</p><ul><li>对已知「稠密图」建图，或需要频繁地根据两个顶点来读写边权的场景时，考虑「邻接矩阵」。</li><li>对已知「稀疏图」建图，或只需根据顶点 $u$ 遍历其邻边 (邻接顶点) 的场景时，考虑「邻接表」或「链式向前星」。这种场景较为常见，因「邻接表」更易实现，因此本文若为该场景，皆采用「邻接表」建图。</li><li>在希望空间复杂度更优，又需要操作「反向边」的场景，考虑「链式向前星」。</li></ul><table><thead><tr><th>操作</th><th>邻接矩阵</th><th>邻接表</th><th>链式向前星</th></tr></thead><tbody><tr><td>编写</td><td>容易</td><td>容易</td><td>相对复杂</td></tr><tr><td>空间</td><td>$O(V^2)$</td><td>$O(V+E)$</td><td>$O(V+E)$<br />比邻接表更优</td></tr><tr><td>遍历 $u$ 的邻边 (邻接顶点)</td><td>遍历 $dists[u]$ <br />$O(V)$</td><td>遍历 $graph.get(u)$<br />$O(V)$</td><td>$edgeNum &#x3D; heads[u]$ 和<br />$edgeNum &#x3D; nexts[edgeNum]$  配合<br />$O(V)$</td></tr><tr><td>根据 $u, v$ 取边 $(u,v)$</td><td>$dists[u][v]$<br />$O(1)$</td><td>遍历 $graph.get(u)$<br />$O(V)$</td><td>$edgeNum &#x3D; heads[u]$ 和<br />$edgeNum &#x3D; nexts[edgeNum]$  配合<br />$O(V)$</td></tr><tr><td>根据 $(u,v)$ 取反向边 $(v,u)$</td><td>$dists[v][u]$<br />$O(1)$</td><td>遍历 $graph.get(v)$<br />$O(V)$</td><td>若已知 $(u,v)$ 编号  <code>k</code> ，<br />则可将边编号为 $[2,E+1] ，$<br />则 $(v, u)$  的编号为 <code>k^1</code> <br />$O(1)$</td></tr></tbody></table><p>另外，并非所有图论问题都需要「建图」，因为问题的输入本身就包含了图的信息，只不过通常需要组织成适合算法操作的结构，若该输入可直接被算法操作，也就不必再另外「建图」了。例如在「最小生成树」-「Kruskal」一节中，利用输入 $connections$ 即可完成求解，无需另外建图。 </p><br /><h2 id="初探图搜索-遍历"><a href="#初探图搜索-遍历" class="headerlink" title="初探图搜索 (遍历)"></a>初探图搜索 (遍历)</h2><p>图的搜索 ($search$) 或者说遍历  ($traversal$) 算法是其他更高级的图论算法的基础，因此熟练掌握图的搜索算法非常重要。<strong>「搜索」</strong> 一词的重点在于关注图中的一个 $target$ ，可以是顶点，也可以是边或其他，找到即完成任务；<strong>「遍历」</strong> 一词的重点在于对整张图无遗漏地探索，多数时候这两个词是通用的。如同「树」的 <strong>深度优先搜索</strong>  ($dfs$) 和 <strong>广度优先搜索</strong>  ($bfs$)，图的基本搜索方法也是这两种。实际上我们知道树是一种特殊的图，在学习本节代码的过程中你会发现二者有很多相似之处。</p><p>$bfs$ 和 $dfs$ 的应用非常丰富，可用于解决许多图上的问题，但只需掌握其 <strong>基本写法</strong> ，就足以支撑我们学习后续更高级的图论算法。为了能够在学习中及时得到反馈，本节以如下三道基本题目引入并详细介绍最基本的 $bfs$ 和 $dfs$ 写法，读者在开始相应子章节前应熟读对应题目。学习解法后应尝试独立写出并提交以得到反馈，最后再参照本节给出的代码来自查。</p><table><thead><tr><th>问题</th><th>题目</th><th>难度</th><th>题解</th></tr></thead><tbody><tr><td>无向图的连通性</td><td><a href="https://leetcode.cn/problems/number-of-connected-components-in-an-undirected-graph/">323. 无向图中连通分量的数目</a></td><td>中等</td><td><a href="https://leetcode.cn/problems/number-of-connected-components-in-an-undirected-graph/solution/by-yukiyama-y5l4/">题解</a></td></tr><tr><td>无向图判圈</td><td><a href="https://leetcode.cn/problems/redundant-connection/">684. 冗余连接</a></td><td>中等</td><td><a href="https://leetcode.cn/problems/redundant-connection/solution/-by-yukiyama-mlqi/">题解</a></td></tr><tr><td>有向图判圈</td><td><a href="https://leetcode.cn/problems/course-schedule/">207. 课程表</a></td><td>中等</td><td><a href="https://leetcode.cn/problems/course-schedule/solution/yukiyama-by-yukiyama-lbz3/">题解</a></td></tr></tbody></table><p>※ 当讨论「连通性」时，通常是对「无向图」而言的，即不关注边方向，只关注那些通过边互相连通的连通分量。在「有向图」中，另有「强连通分量」概念，我们已在「基本概念」中给出定义。</p><p>※ 这三道题均有适用性更强的「并查集」解法。如果你尚未学习过「并查集」或仍觉得不太熟练，可以参考我写的 <a href="https://leetcode.cn/circle/discuss/qmjuMW/">并查集从入门到出门</a> ，全文 1w+ 字，尝试透彻分析并查集的基本内容，2022年5月中旬在力扣讨论区发布后半个月内收获 5k 阅读量，500+ 收藏，100+ 点赞。</p><br /><h3 id="无向图连通性"><a href="#无向图连通性" class="headerlink" title="无向图连通性"></a>无向图连通性</h3><p>首先通过考察「无向图连通性」问题  <a href="https://leetcode.cn/problems/number-of-connected-components-in-an-undirected-graph/">323. 无向图中连通分量的数目</a> 来学习最基本的图的 $bfs &#x2F; dfs$ 算法。</p><p>虽然此时我们还不知道要如何具体写出这两种算法的细节，但我们知道通过 $bfs &#x2F; dfs$，可以从一个顶点 $u$ 出发，「搜索」到与之连通的所有顶点。于是我们不难构思出通过「搜索」来寻找所有不相交的「连通分量」的过程。</p><ol><li>依次访问所有顶点，对于当前顶点 $u$，先检查它是否已经被访问过，若未被访问，以它为起始点进行「搜索」，在开始搜索后立即将 $u$ 标记为已访问。</li><li>搜索过程中，跳过那些「已访问」的顶点，对于「未访问」的顶点，显然它们与 $u$ 同属一个连通分量。</li><li>因为从 $u$ 开始的「搜索」一定能够找到所有与 $u$ 在同一连通分量的顶点，因此能够以多少个顶点为「起点」开始搜索，就有多少个连通分量。</li></ol><p>上述过程的实现需要设置一个 $boolean$ $visited$ 数组，大小为顶点数，表示在此后的搜索中是否访问过。「搜索」可以采用 $bfs$ 或 $dfs$。</p><p>※ 通过 $bfs &#x2F; dfs$ 来 <strong>逐渐标记整张图 (的所有顶点)</strong>  的做法，也被形象地称之为 <a href="https://en.wikipedia.org/wiki/Flood_fill"><strong>flood fill (泛洪)</strong></a> 或 seed fill (播种)，本质上是 <strong>「记忆化搜索」</strong> 的应用。</p><p>※ 若采用 $bfs$ 时，不只是对单个顶点按层搜索，而是对整张图按层搜索，也即初始时找到最外层的所有顶点 (对无向图来说度为 1，对有向图来说入度为 0 的顶点)，然后将这些顶点的邻接顶点作为下一层顶点，以此类推，按层操作。那么这种处理方式也被形象地称为「涟漪法」、「波纹法」、「涨潮法」等。 后续在「拓扑排序」、「无权单源最短路」中都能看到此方法的应用。</p><br /><h4 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h4><p>采用 $bfs$ ，如同树的 $bfs$， 需要借助队列。每次对「未访问」的顶点 $u$ 执行「搜索」时，将其放入队列中，随即置 $u$ 为已访问。然后通过 $while(!q.isEmpty())$ 来完成以 $u$ 为起始点的搜索。只要队不空，则队首 $v$ 出队，访问 $v$ 的所有邻接顶点 $w$ ，并将它们都放入队中。通过这个方式，一定可以 <strong>按层</strong> 完成所有与 $u$ 相连通的顶点的标记。代码如下。需要注意的是，无向图要 <strong>双向建边</strong> 。</p><p>一般可用哈希表 $Map&lt;k, v&gt;$ 来存储图信息，$k$ 为顶点，$v$ 为该顶点的邻接顶点列表。当顶点为一组连续整数时 (通常为 ${0,1,2,…,n-1}$，$n$ 为顶点总数)，用 <code>List&lt;List&lt;Integer&gt;&gt;</code> 存图效率更高，下标表示顶点，其对应的 <code>List&lt;Integer&gt;</code> 即为该顶点的邻接顶点表。通过下标可快速获取顶点的邻接表。</p><p>第一份代码以 <strong>哈希表</strong> 存图，适合于无法用连续的整数来表示顶点的场景。本题中，顶点可以被表示为 ${0, 1,2,3,…n - 1}$ ，因此采用第二份以 <strong>线性表</strong> 存图的代码效率更高。之后的内容，只要能够以线性表存图，就不再列出哈希表存图的版本。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以HashMap存图</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countComponents</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] edges)</span> &#123;</span><br><span class="line">        Map&lt;Integer, List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] edge : edges)&#123; <span class="comment">// 建图</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> edge[<span class="number">0</span>], v = edge[<span class="number">1</span>];</span><br><span class="line">            List&lt;Integer&gt; uAdj = graph.getOrDefault(u, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">            uAdj.add(v);</span><br><span class="line">            graph.put(u, uAdj); <span class="comment">// 无向图边 (u,v)</span></span><br><span class="line">            List&lt;Integer&gt; vAdj = graph.getOrDefault(v, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">            vAdj.add(u);</span><br><span class="line">            graph.put(v, vAdj); <span class="comment">// 无向图边 (v,u)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> <span class="number">0</span>; u &lt; n; u++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[u]) &#123;</span><br><span class="line">                count++; <span class="comment">// 只要顶点 u 此时尚未被访问，说明它不再此前的链路(连通分量)中，以它为新的连通分量起点</span></span><br><span class="line">                bfs(u, visited, graph);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(<span class="type">int</span> u, <span class="type">boolean</span>[] visited, Map&lt;Integer, List&lt;Integer&gt;&gt; graph)</span>&#123;</span><br><span class="line">        visited[u] = <span class="literal">true</span>; <span class="comment">// 立即置为已访问</span></span><br><span class="line">        Queue&lt;Integer&gt; q = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        q.add(u);</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> q.remove();</span><br><span class="line">            List&lt;Integer&gt; vAdj = graph.get(v);</span><br><span class="line">            <span class="keyword">if</span>(vAdj != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> w : graph.get(v)) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(!visited[w]) &#123; <span class="comment">// 已访问的顶点属于此前搜索过的连通分量</span></span><br><span class="line">                        q.add(w);</span><br><span class="line">                        visited[w] = <span class="literal">true</span>; <span class="comment">// 立即置为已访问</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以List存图</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countComponents</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] edges)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) graph.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] edge : edges)&#123; <span class="comment">// 建图</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> edge[<span class="number">0</span>], v = edge[<span class="number">1</span>];</span><br><span class="line">            graph.get(u).add(v); <span class="comment">// 无向图边 (u,v)</span></span><br><span class="line">            graph.get(v).add(u); <span class="comment">// 无向图边 (v,u)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> <span class="number">0</span>; u &lt; n; u++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[u]) &#123;</span><br><span class="line">                count++; <span class="comment">// 只要顶点 u 此时尚未被访问，说明它不在此前的链路(连通分量)中，以它为新的连通分量起点</span></span><br><span class="line">                bfs(u, visited, graph);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(<span class="type">int</span> u, <span class="type">boolean</span>[] visited, List&lt;List&lt;Integer&gt;&gt; graph)</span>&#123;</span><br><span class="line">        visited[u] = <span class="literal">true</span>; <span class="comment">// 立即置为已访问</span></span><br><span class="line">        Queue&lt;Integer&gt; q = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        q.add(u);</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> q.remove();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> w : graph.get(v)) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!visited[w]) &#123; <span class="comment">// 避免同一分量中重复访问</span></span><br><span class="line">                    q.add(w);</span><br><span class="line">                    visited[w] = <span class="literal">true</span>; <span class="comment">// 立即置为已访问</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 链式向前星存图</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countComponents</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] edges)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> edges.length, edgeNum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] ends = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span> * m + <span class="number">1</span>], nexts = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span> * m + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span>[] heads = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] edge : edges)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> edge[<span class="number">0</span>], v = edge[<span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 添加边 (u, v)</span></span><br><span class="line">            ++edgeNum;</span><br><span class="line">            ends[edgeNum] = v;</span><br><span class="line">            nexts[edgeNum] = heads[u];</span><br><span class="line">            heads[u] = edgeNum;</span><br><span class="line">            <span class="comment">// 添加边 (v, u)</span></span><br><span class="line">            ++edgeNum;</span><br><span class="line">            ends[edgeNum] = u;</span><br><span class="line">            nexts[edgeNum] = heads[v];</span><br><span class="line">            heads[v] = edgeNum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> <span class="number">0</span>; u &lt; n; u++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[u]) &#123;</span><br><span class="line">                count++; <span class="comment">// 只要顶点 u 此时尚未被访问，说明它不再此前的链路(连通分量)中，以它为新的连通分量起点</span></span><br><span class="line">                bfs(u, visited, heads, ends, nexts);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(<span class="type">int</span> u, <span class="type">boolean</span>[] visited, <span class="type">int</span>[] heads, <span class="type">int</span>[] ends, <span class="type">int</span>[] nexts)</span>&#123;</span><br><span class="line">        Queue&lt;Integer&gt; q = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        q.add(u);</span><br><span class="line">        visited[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> q.remove();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">edgeNum</span> <span class="operator">=</span> heads[v]; edgeNum != <span class="number">0</span>; edgeNum = nexts[edgeNum]) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> ends[edgeNum];</span><br><span class="line">                <span class="keyword">if</span>(!visited[w]) &#123;</span><br><span class="line">                    q.add(w);</span><br><span class="line">                    visited[w] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是图的 <strong>最基本</strong> 的 $bfs$ 写法，也是后续应用了 $bfs$ 的更高级的图论算法的基础，读者应当熟练掌握。</p><br /><h4 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h4><p>若搜索采用 $dfs$ ，每次对「未访问」的顶点 $u$ 执行「搜索」，进入 $dfs$ 方法后立即置 $visited[u] &#x3D; true$ ，然后以 $for$ 循环依次地，对其「未访问」的邻接顶点执行 $dfs$ 即可。$dfs$ 结束时，$u$ 所在连通分量的所有顶点 <strong>必然</strong> 都被标记为「已访问」。代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countComponents</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] edges)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) graph.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] edge : edges)&#123; <span class="comment">// 建图</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> edge[<span class="number">0</span>], v = edge[<span class="number">1</span>];</span><br><span class="line">            graph.get(u).add(v); <span class="comment">// 无向图边 (u,v)</span></span><br><span class="line">            graph.get(v).add(u); <span class="comment">// 无向图边 (v,u)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> <span class="number">0</span>; u &lt; n; u++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[u]) &#123;</span><br><span class="line">                count++; <span class="comment">// 只要顶点 u 此时尚未被访问，说明它不在此前的链路(连通分量)中，以它为新的连通分量起点</span></span><br><span class="line">                dfs(u, visited, graph);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">boolean</span>[] visited, List&lt;List&lt;Integer&gt;&gt; graph)</span>&#123;</span><br><span class="line">        visited[u] = <span class="literal">true</span>; <span class="comment">// 立即置为已访问</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> v : graph.get(u)) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[v]) dfs(v, visited, graph);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是图的 <strong>最基本</strong> 的 $dfs$ 写法，也是后续应用了 $dfs$ 的更高级的图论算法的基础，读者应当熟练掌握。</p><br /><h4 id="时空复杂度"><a href="#时空复杂度" class="headerlink" title="时空复杂度"></a>时空复杂度</h4><p><strong>时间复杂度:</strong></p><p>无论是 $bfs$ 实现还是 $dfs$ 实现，遍历顶点 $v$ 并从 $v$ 开始泛洪。考虑图所有顶点构成完全图 (即只有一个连通分量)，那么对第一个顶点 $v$ 执行搜索后，每个顶点都会询问所有他的 $|V| - 1$ 个邻接顶点是否已被访问。最坏和平均时间复杂度为 $O(|V|^2)$。</p><p><strong>空间复杂度:</strong> 存图空间 $O(|V|+|E|)$ ， $visited$ 空间 $O(|V|)$，递归栈或队列空间 $O(|V|)$。总的空间复杂度为 $O(|V|+|E|)$ ，该空间体现了图的规模，也称图的 <strong>线性空间复杂度</strong> 。</p><br /><h4 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h4><p>并查集是一种用来解决「连通分量」问题的专用性很强的数据结构，对于 323 题，最为直观合适且高效的办法是「并查集」。并查集本身也属「图论」范畴，我已经在另一篇文章中做过讲解，因此本文不再重复。作为图论的重要一环，并查集的学习是非常必要的，在后续「最小生成树」一节中，我们会再次看到它的身影。总之，如果你还不熟悉并查集，可以阅读我写的 <a href="https://leetcode.cn/circle/discuss/qmjuMW/">并查集从入门到出门</a> (全文1w+字，尝试透彻分析并查集的基本内容，2022年5月中旬在力扣讨论区发布后半个月内收获 5k 阅读量，500+ 收藏，100+ 点赞) 。</p><br /><h3 id="判断图是否有圈"><a href="#判断图是否有圈" class="headerlink" title="判断图是否有圈"></a>判断图是否有圈</h3><p>下面我们考察如何判断图是否有圈。以 <a href="https://leetcode.cn/problems/redundant-connection/">684. 冗余连接</a> 一题学习如何利用 $bfs &#x2F; dfs$  <strong>在无向图中判圈</strong> ，以 <a href="https://leetcode.cn/problems/course-schedule/">207. 课程表</a> 一题学习如何利用 $bfs &#x2F; dfs$  <strong>在有向图中判圈</strong> 。通过这两道题目，我们进一步加深对 $bfs &#x2F; dfs$ 的理解，并体会它们此处的应用相比在「无向图连通性」应用中的变化。我们还会看到在「无向图」和「有向图」中，利用「加边法」或「减边法」判圈的代码，只有很细微的差别。</p><br /><h4 id="无向图判圈"><a href="#无向图判圈" class="headerlink" title="无向图判圈"></a>无向图判圈</h4><p>对于 <a href="https://leetcode.cn/problems/redundant-connection/">684. 冗余连接</a>，题目要求我们找到使得图产生圈的 (在 $edges$ 中)  <strong>最后出现的边</strong> 。有了上一节的经验，我们很容易想到，从某顶点 $v$ 出发，对其执行 $bfs$ 或 $dfs$ ，若能在此过程中找到 $v$ ，则我们确定 $v$ 是该圈上的一个顶点。对于所有的顶点，我们都执行同样的搜索，就可以确定圈上的所有顶点，然后对照 $edges$ ，就可以找出最后出现的边。但这种通过点来找边的做法比较繁琐，其实我们可以直接从「边」入手解决本题。现给出如下 <strong>「加边法」</strong> 和 <strong>「减边法」</strong> ，均为「泛洪法」。</p><br /><p><strong>加边法 &amp; 减边法</strong></p><ol><li><p>加边法: 建图过程中，每加入一条边 $(u, v)$ 前，搜索在当前图上，能否从 $u$ 搜索到 $v$，如果可以，则说明此时 $u$ 与 $v$ 已经连通，再加入 $(u, v)$ 将导致成圈。由于我们从前到后依次取 $edges$ 中的边加入，因此导致成圈的那条边就是所求。</p></li><li><p>减边法：加边法的逆过程。先完整建图，之后从 $edges$ 中逆序取边 $(u, v)$ ，从当前图中减去该边并检测从 $u$ 是否能连通  $v$，若仍能连通，说明 $(u, v)$ 是圈上的一条边，由于我们逆序取边，则该边就是所求。</p></li></ol><p>这两种方法都很好理解，应用 $bfs &#x2F; dfs$ 执行搜索，我们给出如下加边法的两份代码，减边法和其他方法代码此处不列出，可参考「实战应用」中本题的 <a href="https://leetcode.cn/problems/redundant-connection/solution/-by-yukiyama-mlqi/">题解</a> 。</p><p>比较此处的代码与「无向图连通性」一节的代码，可以看到基本框架一样，仅有以下三处不同，这些不同都是为适应本题所做的简单调整。</p><ul><li>本题多了一个 $hasCycle$ 布尔变量用于记录是否找到圈。</li><li>本题搜索过程需要实时地判断是否找到了 $target$ 顶点。</li><li>本题中，每次搜索结束后，若未找到圈，需要重置 $visited$。</li></ul><br /><h5 id="BFS-加边法代码"><a href="#BFS-加边法代码" class="headerlink" title="BFS 加边法代码"></a>BFS 加边法代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加边法 + bfs</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; graph;</span><br><span class="line">    <span class="type">boolean</span>[] visited;</span><br><span class="line">    <span class="type">boolean</span> hasCycle;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findRedundantConnection(<span class="type">int</span>[][] edges) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> edges.length;</span><br><span class="line">        <span class="built_in">this</span>.graph = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="built_in">this</span>.visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">        <span class="built_in">this</span>.hasCycle = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) graph.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] edge : edges)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> edge[<span class="number">0</span>] - <span class="number">1</span>, target = edge[<span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">            bfs(u, target); <span class="comment">// 准备加入 (u, target) 之前，以bfs搜索当前图中，u是否与target连通</span></span><br><span class="line">            <span class="keyword">if</span>(hasCycle) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;u + <span class="number">1</span>, target + <span class="number">1</span>&#125;; <span class="comment">// 搜索后判断是否有圈，有圈则返回当前边</span></span><br><span class="line">            Arrays.fill(visited, <span class="literal">false</span>); <span class="comment">// 每次搜索后要重置visited</span></span><br><span class="line">            graph.get(u).add(target); <span class="comment">// 加边 (u,target)</span></span><br><span class="line">            graph.get(target).add(u); <span class="comment">// 加边 (target,u)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">        Queue&lt;Integer&gt; q = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        q.add(u);</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> q.remove();</span><br><span class="line">            visited[v] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> w : graph.get(v))&#123;</span><br><span class="line">                <span class="keyword">if</span>(w == target)&#123; <span class="comment">// 若找到，置hasCycle为true后返回</span></span><br><span class="line">                    hasCycle = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(!visited[w]) q.add(w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h5 id="DFS-加边法代码"><a href="#DFS-加边法代码" class="headerlink" title="DFS 加边法代码"></a>DFS 加边法代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加边法 + dfs</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; graph;</span><br><span class="line">    <span class="type">boolean</span>[] visited;</span><br><span class="line">    <span class="type">boolean</span> hasCycle;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findRedundantConnection(<span class="type">int</span>[][] edges) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> edges.length;</span><br><span class="line">        <span class="built_in">this</span>.graph = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="built_in">this</span>.visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">        <span class="built_in">this</span>.hasCycle = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) graph.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] edge : edges)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> edge[<span class="number">0</span>] - <span class="number">1</span>, target = edge[<span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">            dfs(u, target); <span class="comment">// 准备加入 (u, target) 之前，以dfs搜索当前图中，u是否与target连通</span></span><br><span class="line">            <span class="keyword">if</span>(hasCycle) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;u + <span class="number">1</span>, target + <span class="number">1</span>&#125;; <span class="comment">// 搜索后判断是否有圈，有圈则返回当前边</span></span><br><span class="line">            Arrays.fill(visited, <span class="literal">false</span>); <span class="comment">// 每次搜索后要重置visited</span></span><br><span class="line">            graph.get(u).add(target); <span class="comment">// 加边 (u,target)</span></span><br><span class="line">            graph.get(target).add(u); <span class="comment">// 加边 (target,u)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">        visited[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> v : graph.get(u)) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[v]) &#123;</span><br><span class="line">                <span class="keyword">if</span>(v == target)&#123; <span class="comment">// 若找到，置hasCycle为true后返回</span></span><br><span class="line">                    hasCycle = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">               dfs(v, target); <span class="comment">// 否则继续dfs搜索</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h5 id="时空复杂度-1"><a href="#时空复杂度-1" class="headerlink" title="时空复杂度"></a>时空复杂度</h5><p><strong>时间复杂度:</strong> 最坏和平均时间复杂度都是 $O(|V|^2)$。分析与「无向图连通性」的泛洪解法一致，不再赘述。</p><p><strong>空间复杂度:</strong> 存图空间 $O(|V|+|E|)$ ， $visited$ 空间 $O(|V|)$，递归栈或队列空间 $O(|V|)$ 。总体为线性空间复杂度 $O(|V|+|E|)$ 。</p><br /><h4 id="有向图判圈"><a href="#有向图判圈" class="headerlink" title="有向图判圈"></a>有向图判圈</h4><p>684 题的图为无向图，现在我们通过 <a href="https://leetcode.cn/problems/course-schedule/">207. 课程表</a> 一题来学习应用 $bfs &#x2F; dfs$ 在 <strong>有向图中判圈</strong> 。</p><p>读题后不难看出课程之间的依赖关系可抽象成「图」。每一门课程为一个顶点，课程 $v$ 依赖课程 $u$ 表示有向边 $(u, v)$ 。仔细理解题意后我们有如下结论，<strong>当且仅当</strong> 这些课程构成的有向图 <strong>「无圈」</strong> 时，能够完成所有课程的学习。也就是我们只需要根据输入构建有向图，然后判断该图是否有圈即可，无圈返回 $true$ ， 有圈返回 $false$ 。</p><p>类似「无向图判圈」，我们同样可以用「加边法」或「减边法」来求解此题。差别仅在于如下几点。</p><ul><li>本题为有向图，建图时只需单向建边。</li><li>考察边 $(u, v)$ 加入 (加边法) 或减去 (减边法) 后，该边两点是否还连通时，根据圈方向的 <strong>单向性</strong> ，应当以 $v$ 作为起点， $u$ 作为目标来搜索。</li><li>若存在自环，即 $(u, u)$ 这样的圈，加边前或减边后都无法再搜索到 $target$ (即 $u$ ) ，将导致误判。因此对于自环，需要特殊判断。</li></ul><p>这些差别体现在代码中只有两三行的区别，有了之前的经验，我们能够轻松实现。应用 $bfs &#x2F; dfs$ 执行搜索，给出如下加边法的两份代码，减边法和其他方法代码此处不列出，可参考「实战应用」中本题的 <a href="https://leetcode.cn/problems/course-schedule/solution/yukiyama-by-yukiyama-lbz3/">题解</a> 。</p><br /><h5 id="BFS-加边法代码-1"><a href="#BFS-加边法代码-1" class="headerlink" title="BFS 加边法代码"></a>BFS 加边法代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加边法 + BFS</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; graph;</span><br><span class="line">    <span class="type">boolean</span>[] visited;</span><br><span class="line">    <span class="type">boolean</span> hasCycle;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canFinish</span><span class="params">(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.graph = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="built_in">this</span>.visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[numCourses];</span><br><span class="line">        <span class="built_in">this</span>.hasCycle = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">            graph.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] edge : prerequisites)&#123; <span class="comment">// 建图 &amp; 计算入度</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> edge[<span class="number">0</span>], u = edge[<span class="number">1</span>]; <span class="comment">// 要学习v先学习u，因此 u -&gt; v</span></span><br><span class="line">            <span class="keyword">if</span>(u == v) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 自环特判</span></span><br><span class="line">            bfs(v, u); <span class="comment">// 检测是否可以从v到u</span></span><br><span class="line">            <span class="keyword">if</span>(hasCycle) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 每次搜索后检测是否有圈</span></span><br><span class="line">            Arrays.fill(visited, <span class="literal">false</span>); <span class="comment">// 重置visited</span></span><br><span class="line">            graph.get(u).add(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">        visited[u] = <span class="literal">true</span>; <span class="comment">// 立即置为true</span></span><br><span class="line">        Queue&lt;Integer&gt; q = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        q.add(u);</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123; </span><br><span class="line">            <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> q.remove();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> w : graph.get(v))&#123;</span><br><span class="line">                <span class="keyword">if</span>(w == target)&#123; <span class="comment">// 找到 target 表示有圈</span></span><br><span class="line">                    hasCycle = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(!visited[w]) &#123;</span><br><span class="line">                    q.add(w);</span><br><span class="line">                    visited[w] = <span class="literal">true</span>; <span class="comment">// 立即置为true</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h5 id="DFS-加边法代码-1"><a href="#DFS-加边法代码-1" class="headerlink" title="DFS 加边法代码"></a>DFS 加边法代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加边法 + DFS</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; graph;</span><br><span class="line">    <span class="type">boolean</span>[] visited;</span><br><span class="line">    <span class="type">boolean</span> hasCycle;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canFinish</span><span class="params">(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.graph = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="built_in">this</span>.visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[numCourses];</span><br><span class="line">        <span class="built_in">this</span>.hasCycle = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">            graph.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] edge : prerequisites)&#123; <span class="comment">// 建图 &amp; 计算入度</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> edge[<span class="number">0</span>], u = edge[<span class="number">1</span>]; <span class="comment">// 要学习v先学习u，因此 u -&gt; v</span></span><br><span class="line">            <span class="keyword">if</span>(u == v) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 自环特判</span></span><br><span class="line">            dfs(v, u); <span class="comment">// 根据有向图特点，检测是否可以从v到u</span></span><br><span class="line">            <span class="keyword">if</span>(hasCycle) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 每次搜索后检测是否有圈</span></span><br><span class="line">            Arrays.fill(visited, <span class="literal">false</span>); <span class="comment">// 重置visited</span></span><br><span class="line">            graph.get(u).add(v);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">        visited[u] = <span class="literal">true</span>; <span class="comment">// 立即置为true</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> v : graph.get(u))&#123;</span><br><span class="line">            <span class="keyword">if</span>(v == target)&#123; <span class="comment">// 找到 target 表示有圈</span></span><br><span class="line">                hasCycle = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!visited[v]) dfs(v, target);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h5 id="时空复杂度-2"><a href="#时空复杂度-2" class="headerlink" title="时空复杂度"></a>时空复杂度</h5><p><strong>时间复杂度:</strong> 最坏和平均时间复杂度都是 $O(|V|^2)$。分析与「无向图连通性」的泛洪解法一致，不再赘述。</p><p><strong>空间复杂度:</strong> 存图空间 $O(|V|+|E|)$ ， $visited$ 空间 $O(|V|)$，递归栈或队列空间 $O(|V|)$ 。总体为线性空间复杂度 $O(|V|+|E|)$ 。</p><br /><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>在本节中，我们通过「无向图的连通性」展示了图搜索 (遍历) 最基本的 $bfs &#x2F; dfs$ 写法。接着，在「判断图是否有圈」中，进一步展示了在 <strong>「无向图」和「有向图」</strong> 中如何应用节本的 $bfs &#x2F; dfs$ 写法，通过些许调整来适应新的场景。</p><p>当我们重新审视「图判圈」问题时，我们会感觉到泛洪做法中有很多重复操作。我们每次加边前 (或减边后) 泛洪都是在当前整张图上进行的，我们自然会想，能否通过对原图的一次「遍历」来找到圈呢？答案是可以的，只需要在基本 $bfs$ &#x2F; $dfs$ 的基础上，配合其他一些量再做调整即可，该方法就是著名的 <strong>「拓扑排序」</strong> ，属于图论算法中比 $bfs$ &#x2F; $dfs$ 稍微进阶一些的算法。利用「拓扑排序」来判圈，时间复杂度将降为 $O(|V|+|E|)$ 。在「拓扑排序」一节的最后，我们将给出相应代码。</p><p>现在你已经牢固掌握了图的 $bfs$ &#x2F; $dfs$ 原理和写法，接下来我们就可以满怀信心地从「拓扑排序」开始学习更高级更复杂的图论算法。</p><br /><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p><a href="https://en.wikipedia.org/wiki/Topological_sorting">拓扑排序 (Topological Sorting)</a> : 对有向图的顶点的排序，如果存在从顶点 $u$ 到顶点 $v$ 的路径，那么拓扑排序要求 $u$ 一定在 $v$ 之前，一定不能出现 $v$ 在 $u$ 之前的排序结果。由此可以看出，拓扑排序存在的前提是 <strong>有向图无圈</strong>。且只要图为 $DAG$ (Directed Acyclic Graph)，则该图 <strong>至少有一种拓扑排序</strong> 。此外，是否存在拓扑排序与图是否存在不连通的分量无关，这是显然的，因为互不连通的分量互不依赖，在拓扑排序中这些分量的顺序是任意的。</p><p>拓扑排序的主要实现为基于 $BFS$ 的 <strong>「Kahn算法」</strong> 以及基于 $DFS$ 的 <strong>「Tarjan拓扑排序算法」</strong> 。我们将看到，这两种算法实现的拓扑排序在求解过程上是 <strong>「互逆」</strong> 的。wiki 中对拓扑排序有如下 <strong>更准确的表述</strong> ，后续我们会再次提到该表述。</p><blockquote><p>Precisely, a topological sort is a graph traversal in which each node $v$ is visited only after all its dependencies are visited. </p><p>更准确地，拓扑排序是对图的一种遍历，在这种遍历中，对一个顶点 $v$ 的访问只发生在它所依赖的顶点被访问之后。</p></blockquote><p>※ 大家思考过为什么这种排序要冠以「拓扑」之名吗？根据作者有限的了解，「拓扑学 (Topology)」研究的是平面或立体图形 (多维?) 连续变形过程中的性质。说一个什么事物是「拓扑的 (Topological)」似乎在表达这个事物变形前后的关系，看起来「拓扑排序」跟数学上的「拓扑」并没有什么关联，因为点或边或整张图并未有什么变化。查了一下，这篇讨论 <a href="https://cstheory.stackexchange.com/questions/30659/why-is-topological-sorting-topological">Why is “topological sorting” topological?</a> 的高赞回答表示该命名大概只是想体现 “network topology” 的味道 (sense)。</p><p>作者点评: 适当地探索一个技术名词的「语源」，能够加深我们对其的理解 🤔。</p><p>在前一节中，我们提到「图判圈」问题，也就是 <a href="https://leetcode.cn/problems/redundant-connection/">684. 冗余连接</a> 和 <a href="https://leetcode.cn/problems/course-schedule/">207. 课程表</a> 两题可通过「拓扑排序」解决，且时间复杂度为 $O(|V|+|E|)$。但解决的过程中并不会真正地「排序」。为了能体现完整的拓扑排序算法，我们先以 <a href="https://leetcode.cn/problems/course-schedule-ii/">210. 课程表 II</a> 一题为分析对象，该题目描述的内容常作为介绍拓扑排序的一个经典的现实例子 (具体看原题描述)。在本节最后再给出 684 和 207 题的「拓扑排序」解法，在学完本节后，相应解法是很容易写出的。更多「拓扑排序」相关题目请参考「实战应用」。</p><br /><h3 id="Kahn"><a href="#Kahn" class="headerlink" title="Kahn"></a>Kahn</h3><h4 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h4><p><a href="https://en.wikipedia.org/wiki/Topological_sorting">Kahn算法</a>：基于 $BFS$ 的拓扑排序算法。之前我们提到过「拓扑排序准确表述」，该算法通过入度信息很好地体现了「表述」，即当访问一个顶点 $v$ ，若其 <strong>「入度」</strong> 为 0 ，即说明它所依赖的顶点一定已经被访问过了，此时即可将其输出 (将其排序)。具体来说，先计算所有顶点的入度，然后将入度为 0 的顶点放入队列中，从队列输出队首顶点并依次将其所有 <strong>邻接顶点入度减 1</strong> ，每一个邻接顶点入度减 1 后，判断其入度是否减至 0 ，若为 0 将其入队。重复上述过程，直到队列为空 (所有顶点均已入队又出队)。容易看出，一个顶点入度减至 0 ，<strong>当前仅当</strong> 它所依赖的顶点的入度在此之前已减至 0。算法结束时，顶点出队的顺序即为拓扑排序，这是一个 <strong>「顺序」</strong> 拓扑排序过程。</p><p>判圈: 某个节点出队时对其存在的邻边入度减 1 后，若这些邻边入度均未减至 0，则说明该图 <strong>有圈</strong> 。可以通过在 $while$ 结束后考察 <strong>出队顶点数与总顶点数是否相等</strong> 来判圈。</p><blockquote><p>A. B. Kahn于1962年发表的 <a href="https://dl.acm.org/doi/pdf/10.1145/368996.369025"><em>Topological Sorting of Large Networks</em> </a> 论文中描述了该算法。</p></blockquote><br /><h4 id="算法过程"><a href="#算法过程" class="headerlink" title="算法过程"></a>算法过程</h4><p>算法的详细过程如下，也即该算法求解拓扑排序问题时的编程范式。具体代码见「代码」部分，在参考之前，你应当通过此处给出的算法过程尝试自己写出。</p><ol><li><p>根据输入建图及计算入度。</p></li><li><p>建图。</p><p>一般可用哈希表 $Map&lt;k, v&gt;$ 来存储图信息，$k$ 为顶点，$v$ 为该顶点的邻接顶点列表。当顶点为一组连续整数时 (通常为 ${0,1,2,…,n-1}$，$n$ 为顶点总数)，用 <code>List&lt;List&lt;Integer&gt;&gt;</code> 存图效率更高，下标表示顶点，其对应的 <code>List&lt;Integer&gt;</code> 即为该顶点的邻接顶点表。通过下标可快速获取顶点的邻接表。</p></li><li><p>计算入度。</p><p>入度信息一般用大小为顶点数的数组 $indegrees[]$ 表示，入度计算通常与建图同时进行。遍历输入信息，遇到边 $(u, v)$ 时，执行 <code>indegree[v]++</code> 。当所有边都被考察后，入度信息即已完备。</p></li><li><p>拓扑排序。<br>有了入度信息和图信息，开始拓扑排序。</p><ol><li>设置一个队列 $q$ 、一个用于保存拓扑排序结果列表 $res$ 、一个用于后续判断图是否有圈的计数变量 $count$ 。</li><li>遍历 $indegrees$ 数组将入度为 0 的顶点入队 (若已知图为有向无圈 <strong>连通图</strong> ，则 <strong>有且只有一个</strong> 顶点入度为 0，可在找到后立即跳出遍历)。</li><li>以一个 $while$ 检查当前队列是否为空，不空则队首顶点 $u$ 出队，放入输出结果 $res$ 中。同时 <code>count++</code> ，表明 $u$ 已被排序。</li><li>遍历 $u$ 的邻接顶点 $v$ ，使 $v$ 的入度减 1，并检查减 1 后是否为 0 ，为 0 则 $v$ 入队。</li><li>当 $while$ 结束后，在返回前判圈。 <strong>图有圈则存在入度不可能减至 0  的顶点</strong> ，则已拓扑排序 (已出队) 的顶点个数 $count$ 必小于顶点总数。若满足 $count &#x3D;&#x3D; n$ 则返回拓扑排序结果，否则无结果。</li></ol></li></ol><br /><h4 id="时空复杂度-3"><a href="#时空复杂度-3" class="headerlink" title="时空复杂度"></a>时空复杂度</h4><p><strong>时间复杂度:</strong></p><ol><li>建图及计算所有顶点入度需遍历所有边，时间复杂度为 $O(|E|)$。</li><li>队列中每个顶点均入队一次，出队一次，$O(|V|)$ 。</li><li>更新并检查邻接顶点的 $for$ 中，更新和检查的总次数等于边数 $O(|E|)$ 。</li></ol><p>故总的时间复杂度为 $O(|V|+|E|)$ 。此时间复杂度体现了图的规模，因此也称之为图的 <strong>线性时间复杂度</strong> 。 若图是连通的 ，由于 $|E| ≥ |V|$ (仅在图为链状有向图时 $|E| &#x3D; |V| - 1$)，因此通常也可以粗略地记做 $O(|E|)$ 。</p><p><strong>空间复杂度:</strong> 存图空间 $O(|V|+|E|)$ ， $res &#x2F; indegrees$ 空间 $O(|V|)$，队列空间 $O(|V|)$。总体为线性空间复杂度 $O(|V|+|E|)$ 。</p><br /><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>Kahn 拓扑排序算法实现 <a href="https://leetcode.cn/problems/course-schedule-ii/">210. 课程表 II</a> 。在掌握了 $BFS$ 算法写法及理解 Kahn 算法过程的基础上，我们很容易写出如下代码。</p><p>第一份代码以 <strong>哈希表</strong> 存图，适合于无法用连续的整数来表示顶点的场景。本题中，顶点可以被表示为 ${0, 1,2,3,…n - 1}$ ，因此采用第二份以 <strong>线性表</strong> 存图的代码效率更高。此写法为普遍的标准的 Kahn 拓扑排序写法，读者应对该写法 <strong>熟稔于心</strong> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以HashMap存图</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findOrder(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites) &#123;</span><br><span class="line">        <span class="comment">// 1. 【建图 + 计算入度】</span></span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses], indegrees = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">        Map&lt;Integer, List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] edge : prerequisites)&#123; <span class="comment">// 建图 &amp; 计算入度</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> edge[<span class="number">0</span>], u = edge[<span class="number">1</span>]; <span class="comment">// u是v的先修课程, u -&gt; v</span></span><br><span class="line">            List&lt;Integer&gt; adjs = graph.getOrDefault(u, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;()); <span class="comment">// u的邻接表</span></span><br><span class="line">            adjs.add(v); <span class="comment">// v为u的邻接顶点</span></span><br><span class="line">            graph.put(u, adjs);</span><br><span class="line">            indegrees[v]++; <span class="comment">// v的入度加1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. 【拓扑排序】</span></span><br><span class="line">        <span class="comment">// 2-1. 遍历入度数组，将入度为 0 的顶点入队。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Queue&lt;Integer&gt; q = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> <span class="number">0</span>; u &lt; numCourses; u++)&#123; <span class="comment">// 找到入度为0的顶点并入队</span></span><br><span class="line">            <span class="keyword">if</span>(indegrees[u] == <span class="number">0</span>) q.add(u);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2-2. 利用队列完成拓扑排序</span></span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> q.remove();</span><br><span class="line">            res[count++] = u; <span class="comment">// 入度为0，输出到res，同时count++</span></span><br><span class="line">            List&lt;Integer&gt; adjs = graph.get(u);</span><br><span class="line">            <span class="keyword">if</span>(adjs != <span class="literal">null</span>)&#123; <span class="comment">// 有的顶点可能无邻接顶点</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> v : adjs)&#123;</span><br><span class="line">                    indegrees[v]--; <span class="comment">// v的入度减1</span></span><br><span class="line">                    <span class="keyword">if</span>(indegrees[v] == <span class="number">0</span>) q.add(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2-3. 返回前判圈。</span></span><br><span class="line">        <span class="keyword">return</span> count == numCourses ? res : <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;&#125;; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以List存图</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findOrder(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites) &#123;</span><br><span class="line">        <span class="comment">// 1. 【建图 + 计算入度】</span></span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses], indegrees = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prerequisites.length;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; i++) graph.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] edge : prerequisites)&#123; <span class="comment">// 建图 &amp; 计算入度</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> edge[<span class="number">0</span>], u = edge[<span class="number">1</span>]; <span class="comment">// u是v的先修课程，u -&gt; v</span></span><br><span class="line">            graph.get(u).add(v); <span class="comment">// v为u的邻接顶点</span></span><br><span class="line">            indegrees[v]++; <span class="comment">// v的入度加1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. 【拓扑排序】</span></span><br><span class="line">        <span class="comment">// 2-1. 遍历入度数组，将入度为 0 的顶点入队。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Queue&lt;Integer&gt; q = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> <span class="number">0</span>; u &lt; numCourses; u++)&#123; <span class="comment">// 找到入度为0的顶点并入队</span></span><br><span class="line">            <span class="keyword">if</span>(indegrees[u] == <span class="number">0</span>) q.add(u);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2-2. 利用队列完成拓扑排序</span></span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123; </span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> q.remove();</span><br><span class="line">            res[count++] = u; <span class="comment">// 入度为0，输出到res，同时count++</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> v : graph.get(u))&#123;</span><br><span class="line">                indegrees[v]--; <span class="comment">// v的入度减1</span></span><br><span class="line">                <span class="keyword">if</span>(indegrees[v] == <span class="number">0</span>) q.add(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2-3. 返回前判圈。</span></span><br><span class="line">        <span class="keyword">return</span> count == numCourses ? res : <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;&#125;; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h3 id="Tarjan-Topological-Sorting"><a href="#Tarjan-Topological-Sorting" class="headerlink" title="Tarjan (Topological Sorting)"></a>Tarjan (Topological Sorting)</h3><h4 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h4><p><a href="https://en.wikipedia.org/wiki/Topological_sorting">Tarjan拓扑排序算法</a>：基于 $DFS$ 的拓扑排序算法。回顾之前提到的「拓扑排序准确表述」中的「对一个顶点 $v$ 的访问只发生在它所依赖的顶点被访问之后」，我们从中可以嗅到「层层深入」的味道，即对于 $v$ ，「层层深入」它所依赖的顶点后访问到它，这是一个 $dfs$ 的过程，「表述」中要求，完成 $v$ 的访问的前提是完成它所依赖的顶点的访问，那么我们可以在 $dfs$ 到 $v$ 的过程中，<strong>「缓存」</strong> 路径上 $v$ 所依赖的顶点的状态 (即暂不处理)，当我们要处理 $v$ 的时候，已经保证了它所依赖的顶点会在此后「回溯」的过程中处理，因为它们此刻都在 <strong>递归栈的更靠顶部的空间中 (也就是在返回路径上)</strong> 缓存着。换句话说，我们只需要将 $v$ 放在当前用于存放拓扑排序结果的空间的最后侧 (这是栈的特点，称之为结果栈)，此后的回溯一定会将它所依赖的顶点放在它的前面。那么我们什么时候处理 $v$ 呢？自然是无法从它再深入到任何顶点的时候，可以是其无 (依赖关系的) 后继顶点时，也可以是其后继顶点均已被排序 (被放入结果栈中) 时。理解了这一点，我们即可给出如下 Tarjan 拓扑排序的主要过程。建图过程无需多言。</p><p>顶点在算法过程中有三个状态， <strong>未搜索，搜索中、已完成 (访问)</strong> 。算法从遍历顶点开始，每遇到一个「未搜索」的顶点 $u$ ，就以其为起点开始 $dfs$ 。进入 $dfs$ 方法时我们首先将 $u$ 标记为「搜索中」，然后以 $for$ 循环依次考察 $u$ 的邻接顶点 $v$ 。</p><ul><li>若其状态为「未搜索」，对其递归调用 $dfs$ ，重复前述过程。</li><li>若其状态为「搜索中」，表明我们此前进入过 $v$ 的 $dfs$ 过程，而此时又遇到了 $v$ ，显然 $v$ 是通过一个圈回到了 $v$。于是将 $hasCycle$ 标记为 $true$ 并返回。</li><li>注意我们不必处理「已完成」的 $v$ ，无判断分支会直接跳过。</li></ul><p>如前一段所说，当 $u$ 无法再深入到任何顶点时，我们标记其状态为「已完成」。每以一个「未搜索」的顶点为起点完成 $dfs$ 后，检测一次 $hasCycle$ 是否为 $true$，是则结束，否则当程序终止时，顺序输出结果栈即为正确的拓扑排序。</p><blockquote><p>该算法并不总是被冠以 Tarjan 之名，在 wiki 中有下面这段话，用的是「…seems to…」。另外，Cormen et al. (2001) 指的是那本著名的「算法导论」。</p><p>This depth-first-search-based algorithm is the one described by <a href="https://en.wikipedia.org/wiki/Topological_sorting#CITEREFCormenLeisersonRivestStein2001">Cormen et al. (2001)</a>, it seems to have been first described in print by Tarjan in <a href="https://link.springer.com/article/10.1007/BF00268499">1976</a>.</p></blockquote><p>※ 之所以称「Tarjan拓扑排序算法」而非「Tarjan算法」，是因为由 <a href="https://en.wikipedia.org/wiki/Robert_Tarjan">Tarjan</a> 发明或合作发明或有重大贡献的算法和数据结构非常之多，如「<a href="https://en.wikipedia.org/wiki/Lowest_common_ancestor#History">最近公共祖先(LCA)</a>」、「<a href="https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm#cite_note-Tarjan-1">强连通分量(SCC)</a>」、「<a href="https://en.wikipedia.org/wiki/Splay_tree">伸展树 (Splay Tree)</a>」、「<a href="https://en.wikipedia.org/wiki/Fibonacci_heap">斐波那契堆 (Fibonacci Heaps)</a>」、「<a href="https://en.wikipedia.org/wiki/Disjoint-set_data_structure">并查集 (Union-Find Set)</a>」等等。狭义上的「Tarjan算法」指的是「强连通分量」算法。实际上将基于 $BFS$ 的拓扑排序算法冠以 Kahn 之名比之将基于 $DFS$ 的拓扑排序冠以 Tarjan 之名更为流行，原因除了前者发明时间更早，且更易于理解之外，还在于后者只是 Tarjan 所发明的寻找「强连通分量」算法的副产品，而未作为一个独立的算法发表 (由此也可见 Tarjan 之强大)。详见 <a href="https://stackoverflow.com/questions/32750511/does-tarjans-scc-algorithm-give-a-topological-sort-of-the-scc">Does Tarjan’s SCC algorithm give a topological sort of the SCC?</a>。</p><blockquote><p>… And his algorithm (SCC) also does topological sorting <strong>as a byproduct</strong>. —- by Knuth</p></blockquote><br /><h4 id="算法过程-1"><a href="#算法过程-1" class="headerlink" title="算法过程"></a>算法过程</h4><p>算法的详细过程如下，也即该算法求解拓扑排序问题时的编程范式。具体代码见「代码」部分，在参考之前，你应当通过此处给出的算法过程尝试自己写出。</p><ol><li><p>根据输入建图及准备 $visited$ 数组、 $hasCycle$ 布尔值、拓扑排序结果栈 $res$ 以及栈底下标 $idx$ (初始时为 $|V| - 1$)。</p><ol><li><p>建图。与 kahn 算法一致。</p></li><li><p>$visited$ 数组下标为顶点，有三种取值，表示顶点在拓扑排序过程中的三种状态。0: 未搜索 1: 搜索中 2: 已完成 (搜索)。初始时 $hasCycle &#x3D; false$ 。</p></li></ol></li><li><p>拓扑排序。遍历所有顶点，对「未搜索」状态的顶点 $u$ 执行 $dfs$ 。</p><ol><li>进入 $dfs$ 后，首先置 $visited[u] &#x3D; 1$，表示 $u$ 处于搜索中状态。</li><li>以 $for$ 循环依次考察 $u$ 的邻接顶点 $v$ 。<ol><li>若 $visited[v] &#x3D;&#x3D; 0$ ，状态为「未搜索」。对其递归调用 $dfs$ ，也就是看它是否是其他顶点的「依赖」，使其置于「缓存」之中。</li><li>若 $visited[v] &#x3D;&#x3D; 1$ ，状态为「搜索中」。表明我们此前进入过 $v$ 的 $dfs$ 过程，而此时又遇到了 $v$ ，显然 $v$ 是通过一个圈回到了 $v$。于是将 $hasCycle$ 标记为 $true$ 并返回。</li><li>若 $visited[v] &#x3D;&#x3D; 2$ ，状态为「已完成」。跳过。</li></ol></li><li>对于 $u$，若其完成了 $for$，表明要么其无 (依赖关系中的) 后继顶点，要么其后继顶点均已被排序 (被放入结果栈中)。也就是 $u$ 是当前所有未完成排序的顶点中位于依赖关系最后面的顶点，于是将其放入当前结果栈中的的底部。</li></ol></li><li><p>若能完成所有顶点的遍历而无圈，说明所有顶点已被拓扑排序，返回 $res$。</p></li></ol><br /><h4 id="时空复杂度-4"><a href="#时空复杂度-4" class="headerlink" title="时空复杂度"></a>时空复杂度</h4><p><strong>时间复杂度:</strong> </p><ol><li><p>建图及需遍历所有边，时间复杂度为 $O(|E|)$。</p><p>每个顶点至多被标记两次，$O(|V|)$ 。</p></li><li><p>检查邻接顶点的 $for$ 的总次数等于边数 $O(|E|)$ 。</p></li></ol><p>故总的时间复杂度为同 Kahn 算法一样也是线性时间复杂度 $O(|V|+|E|)$ 。若图是连通的 ，由于 $|E| ≥ |V|$ (仅在 $|V| &#x3D; 2$，且只有一条边时 $|E| &lt; |V|$)，因此通常也可以粗略地记做 $O(|E|)$ 。</p><p><strong>空间复杂度:</strong> 存图空间 $O(|V|+|E|)$ ， $res &#x2F; visited$ 空间 $O(|V|)$，递归栈空间 $O(|V|)$。总体为线性空间复杂度 $O(|V|+|E|)$ 。</p><br /><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><p>Tarjan 拓扑排序算法实现 <a href="https://leetcode.cn/problems/course-schedule-ii/">210. 课程表 II</a> 。此写法为普遍的标准的 Tarjan 拓扑排序写法，读者应对该写法 <strong>熟稔于心</strong> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; graph;</span><br><span class="line">    <span class="type">int</span>[] visited, res;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">hasCycle</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> idx;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findOrder(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites) &#123;</span><br><span class="line">        <span class="comment">// 1. 建图 + 准备 visited / hasCycle / res / idx</span></span><br><span class="line">        <span class="built_in">this</span>.graph = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="built_in">this</span>.visited = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses]; <span class="comment">// 0: 未搜索 1: 搜索中 2: 已完成</span></span><br><span class="line">        <span class="built_in">this</span>.res = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses]; <span class="comment">// 存储拓扑排序结果的栈</span></span><br><span class="line">        <span class="built_in">this</span>.idx = numCourses - <span class="number">1</span>; <span class="comment">// 栈底下标</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">            graph.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] edge : prerequisites)&#123; <span class="comment">// 建图</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> edge[<span class="number">0</span>], u = edge[<span class="number">1</span>]; <span class="comment">// 要学习v先学习u，因此 u -&gt; v</span></span><br><span class="line">            graph.get(u).add(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. 遍历所有顶点，对「未搜索」状态的顶点 u 执行 dfs</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> <span class="number">0</span>; u &lt; numCourses; u++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[u] == <span class="number">0</span>) &#123; <span class="comment">// 对未搜索的顶点执行 dfs</span></span><br><span class="line">                dfs(u);</span><br><span class="line">                <span class="keyword">if</span>(hasCycle) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;&#125;; <span class="comment">// 每次搜索后，若检测出圈，返回空数组</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> u)</span>&#123;</span><br><span class="line">        visited[u] = <span class="number">1</span>; <span class="comment">// 立即标记为搜索中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> v : graph.get(u)) &#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[v] == <span class="number">0</span>) &#123; <span class="comment">// 邻接顶点为「未搜索」状态，dfs之</span></span><br><span class="line">                dfs(v);</span><br><span class="line">                <span class="keyword">if</span>(hasCycle) <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(visited[v] == <span class="number">1</span>) &#123; <span class="comment">// 若邻接顶点为「搜索中」状态，说明有圈</span></span><br><span class="line">                hasCycle = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[u] = <span class="number">2</span>; <span class="comment">// 完成搜索，表明在对u进行dfs的过程中未遇到正在搜索中的其他顶点</span></span><br><span class="line">        res[idx--] = u; <span class="comment">// 此时u所依赖的顶点都在栈中「缓存」等待后续处理，因此可以将其放入此时结果栈中的底部。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h3 id="拓扑排序判圈"><a href="#拓扑排序判圈" class="headerlink" title="拓扑排序判圈"></a>拓扑排序判圈</h3><p>在学习了本节内容后，我们再回到 <a href="https://leetcode.cn/problems/redundant-connection/">684. 冗余连接</a> 和 <a href="https://leetcode.cn/problems/course-schedule/">207. 课程表</a> 这两题的，给出它们的拓扑排序解法。需要注意的是，应用 Kahn 拓扑排序时，对于「无向图」上的顶点，考虑的是无关方向的 <strong>「度」</strong> ，开始排序时要将 <strong>度为 1</strong> 的顶点入队；对于「有向图」上的顶点，考虑的是 <strong>「入度」</strong> ，开始排序时要将 <strong>入度为 0</strong> 的顶点入队。</p><br /><h4 id="无向图判圈-1"><a href="#无向图判圈-1" class="headerlink" title="无向图判圈"></a>无向图判圈</h4><p>对于 684 题，因为题目要求返回构成圈的在 $edges$ 中的最后一条边，因此只「判圈」还不够，若应用 Kahn 拓扑排序算法，则排序结束后可根据度大于 1 的顶点信息，在 $edges$ 中找到符合要求的最后的那条边。 <strong>若只要求判圈，那么也可以采用Tarjan拓扑排序算法</strong> 。如下我们只给出 Kahn 排序算法解 684 题的代码。</p><ul><li>时间复杂度: 由于本题  $|V| &#x3D; |E|$，因此拓扑排序时间复杂度为 $O(|V|)$，排序结束后在 $edges$ 中「构成圈的最后一条边」的时间复杂度为 $O(|V|)$ 。</li><li>空间复杂度: 存图空间 $O(|V|)$ ， $degrees$ 空间 $O(|V|)$，队列空间 $O(|V|)$。总体为线性空间复杂度 $O(|V|)$ 。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findRedundantConnection(<span class="type">int</span>[][] edges) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> edges.length;</span><br><span class="line">        <span class="type">int</span>[] degrees = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) graph.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] edge : edges)&#123; <span class="comment">// 建图 + 计算顶点的度</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> edge[<span class="number">0</span>] - <span class="number">1</span>, v = edge[<span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">            degrees[u]++; <span class="comment">// u度+1</span></span><br><span class="line">            degrees[v]++; <span class="comment">// v度+1</span></span><br><span class="line">            graph.get(u).add(v);</span><br><span class="line">            graph.get(v).add(u);</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;Integer&gt; q = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123; <span class="comment">// 度为1的顶点入队</span></span><br><span class="line">            <span class="keyword">if</span>(degrees[i] == <span class="number">1</span>) q.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123; <span class="comment">// 拓扑排序过程</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> q.remove();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> v : graph.get(u))&#123;</span><br><span class="line">                degrees[v]--;</span><br><span class="line">                <span class="keyword">if</span>(degrees[v] == <span class="number">1</span>) q.add(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123; <span class="comment">// 在edges中从后往前寻找圈上边，该边的两个顶点的度均大于1</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> edges[i][<span class="number">0</span>] - <span class="number">1</span>, v = edges[i][<span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(degrees[u] &gt; <span class="number">1</span> &amp;&amp; degrees[v] &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;u + <span class="number">1</span>, v + <span class="number">1</span>&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h4 id="有向图判圈-1"><a href="#有向图判圈-1" class="headerlink" title="有向图判圈"></a>有向图判圈</h4><p>对于 <a href="https://leetcode.cn/problems/course-schedule/">207. 课程表</a> 题，其拓扑排序解法与 <a href="https://leetcode.cn/problems/course-schedule-ii/">210. 课程表 II</a> 题的区别仅在于前者无需真正排序，只需判断是否存在圈即可。以下给出 Kahn 和 Tarjan 两种拓扑排序算法的代码。</p><p><strong>Kahn拓扑排序算法</strong></p><ul><li>时间复杂度: 拓扑排序时间复杂度为 $O(|V|+|E|)$ 。</li><li>空间复杂度: 存图空间 $O(|V|+|E|)$ ， $indegrees$ 空间 $O(|V|)$，队列空间 $O(|V|)$。总体为线性空间复杂度 $O(|V|+|E|)$ 。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Kahn拓扑排序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canFinish</span><span class="params">(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span>[] indegrees = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">            graph.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] edge : prerequisites)&#123; <span class="comment">// 建图 &amp; 计算入度</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> edge[<span class="number">0</span>], u = edge[<span class="number">1</span>]; <span class="comment">// 要学习v先学习u，因此 u -&gt; v</span></span><br><span class="line">            graph.get(u).add(v);</span><br><span class="line">            indegrees[v]++;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;Integer&gt; q = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> <span class="number">0</span>; u &lt; numCourses; u++)&#123; <span class="comment">// 入度为0的顶点入队</span></span><br><span class="line">            <span class="keyword">if</span>(indegrees[u] == <span class="number">0</span>) q.add(u);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 已拓扑排序的顶点数</span></span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123; <span class="comment">// 拓扑排序</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> q.remove();</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> v : graph.get(u))&#123;</span><br><span class="line">                indegrees[v]--;</span><br><span class="line">                <span class="keyword">if</span>(indegrees[v] == <span class="number">0</span>) q.add(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count == numCourses;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Tarjan拓扑排序算法</strong></p><ul><li>时间复杂度: 拓扑排序时间复杂度为 $O(|V|+|E|)$ 。</li><li>空间复杂度: 存图空间 $O(|V|+|E|)$ ， $visited$ 空间 $O(|V|)$，递归栈空间 $O(|V|)$。总体为线性空间复杂度 $O(|V|+|E|)$ 。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Tarjan拓扑排序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; graph;</span><br><span class="line">    <span class="type">int</span>[] visited;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">hasCycle</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canFinish</span><span class="params">(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.graph = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="built_in">this</span>.visited = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses]; <span class="comment">// 0: 未搜索 1: 搜索中 2: 已完成</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">            graph.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] edge : prerequisites)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> edge[<span class="number">0</span>], u = edge[<span class="number">1</span>]; <span class="comment">// 要学习v先学习u，因此 u -&gt; v</span></span><br><span class="line">            graph.get(u).add(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> <span class="number">0</span>; u &lt; numCourses; u++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[u] == <span class="number">0</span>) &#123;</span><br><span class="line">                dfs(u);</span><br><span class="line">                <span class="keyword">if</span>(hasCycle) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 每次搜索后，若检测出圈，返回false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> u)</span>&#123;</span><br><span class="line">        visited[u] = <span class="number">1</span>; <span class="comment">// 搜索中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> v : graph.get(u)) &#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                dfs(v);</span><br><span class="line">                <span class="keyword">if</span>(hasCycle) <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(visited[v] == <span class="number">1</span>) &#123;</span><br><span class="line">                hasCycle = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[u] = <span class="number">2</span>; <span class="comment">// 完成搜索，表明在对u进行dfs的过程中未遇到正在搜索中的其他顶点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>在本节中，我们分别介绍了基于 $bfs$ 的 Kahn 算法和基于 $dfs$ 的 Tarjan 拓扑排序算法，并给出了这两种方法解决 <a href="https://leetcode.cn/problems/course-schedule-ii/">210. 课程表 II</a> 一题的代码。我们还展示了利用「拓扑排序」，可以在「图判圈」这一问题上，实现线性时间复杂度求解，比「初探图搜索 (遍历)」一节的方法更好，显示了拓扑排序这一方法的优点。在之后的章节中，我们还会看到拓扑排序是如何继续发挥作用的。</p><br /><h2 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h2><p>本节我们将学习图论算法中古老而经典的「<a href="https://en.m.wikipedia.org/wiki/Shortest_path_problem">最短路径</a>」问题，该算法在地图、交通等许多领域中的重要性无须多言。我们将按照如下三大类进行讲解。</p><ul><li><p><strong>无权单源最短路：</strong> <em>(Single Source Shortest Path, SSSP)</em> 给定一张无权图 $G$ 和一个顶点 $s$ ，找出从 $s$ 到 $G$ 中每一个顶点的最短路径。</p></li><li><p><strong>带权单源最短路：</strong> <em>(Single Source Shortest Path, SSSP)</em> 给定一张带权图 $G$ 和一个顶点 $s$ ，找出从 $s$ 到 $G$ 中每一个顶点的最短路径。</p></li><li><p><strong>带权全源最短路：</strong> <em>(All Pairs Shortest Path, APSP)</em> 给定一张带权图 $G$  ，找出 $G$ 中所有点对的最短路径。</p></li></ul><p>我们指出，除了特定情形的图 (如 DAG)， 最短路径算法不区分图的边是否有向，建图时对有向图&#x2F;无向图正确建图即可 (有向图单向建边，无向图双向建边)。为了使读者在学习过程中及时地得到反馈，我将在介绍每一种算法后，利用该算法实际解决如下对应题目。读者应当在理解算法内容之后尝试独立求解，然后再与文中给出的代码相比照。</p><table><thead><tr><th>最短路分类</th><th>配套例题</th></tr></thead><tbody><tr><td>无权单源最短路</td><td>814. 无向图中的最短路径</td></tr><tr><td>带权单源最短路</td><td><a href="https://leetcode.cn/problems/network-delay-time/">743. 网络延迟时间</a></td></tr><tr><td>带权全源最短路</td><td><a href="https://leetcode.cn/problems/network-delay-time/">743. 网络延迟时间</a><br /><a href="https://leetcode.cn/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/">1334. 阈值距离内邻居最少的城市</a></td></tr></tbody></table><br /><h3 id="无权单源最短路"><a href="#无权单源最短路" class="headerlink" title="无权单源最短路"></a>无权单源最短路</h3><p>我们首先介绍最简单的「无权单源最短路」，力扣上似乎没有相应的题目，不过力扣友商平台上的 <strong>814.无向图中的最短路径</strong> 一题比较匹配 (请自行搜索)，我们通过这题来学习本节。虽然该题只须求给定两点之间的最短距离，但我们仍然按给定一点 (源点 $s$)，求其到其他所有顶点的距离来做，只须在返回指顶定点的距离即可。</p><p>需要注意的是，本小节给出的例题的图虽是无向图，但有向图解法是一致的。「有向无权单源最短路」与「无向无权单源最短路」的求解方法的唯一区别只在与建图时是双向建边 (无向图) 还是单向 (有向图) 建边。后续「带权图」的最短路问题也一样，有向无向并不影响算法过程，因此 <strong>对于「最短路」问题，通常不强调「无向」还是「有向」</strong> 。</p><br /><h4 id="朴素版"><a href="#朴素版" class="headerlink" title="朴素版"></a>朴素版</h4><p>虽然我们早已熟悉利用队列来辅助 $bfs$ 过程的写法，但我还是决定先介绍不用队列的 <strong>朴素版本</strong> ，以此为契机再次思考使用队列实现 $bfs$ 的优点。如果你确信自己理解了这一点，你也可以跳过「朴素版」直接看「队列优化版」。</p><br /><h5 id="算法描述-2"><a href="#算法描述-2" class="headerlink" title="算法描述"></a>算法描述</h5><p>在熟悉 $bfs$ 泛洪算法后我们很容易想到求这种情形最短路的方法。从源点 $s$ 开始，以 $bfs$ 方式确定 $s$ 到其他所有顶点的最短路径。首先，程序主体为一个使得距离 (指源点到其他顶点的距离，此后若无特别说明，「距离」一词均为此意) 能够按层推进的 $for$ 循环，<code>for(int dist = 0; dist &lt; |V| - 1; dist++)</code> ，$dist &#x3D; 0$ 表示一开始距离为 0 ，此后会逐层增加距离。该 $for$ 内接着一个内层 $for$ 循环，用于 <strong>遍历所有顶点</strong> ，找到那些 <strong>距离已确定</strong> 且为当前 $dist$ 顶点 $u$。对每一个 $u$ ，再以一个 $for$ 循环遍历它的邻接顶点 $v$ ，使那些 <strong>距离未确定</strong> 的 $v$ 的距离为 $dist + 1$。这样就能够按层推进访问所有顶点并确定这些顶点的距离。</p><p>具体来说，对于 $s$ ，首先置其距离为 0，然后开始外层 $for$ 。遍历顶点后只有 $s$ 满足条件，于是其 <strong>邻接顶点</strong> 的距离 +1，(如果要求返回具体路径，可以在此时将其前驱顶点置为 $s$ ，以便将来用于返回路径)。接着遍历顶点，对上一层顶点，也就是之前距离被置为 1 的顶点 $u$ 考察它们的 <strong>距离未确定</strong> 的邻接顶点 $v$ ，使 $v$ 的距离 +1，(如前，若需要，此时将 $v$ 的前驱顶点置为 $u$ )。以 $for$ 循环重复上述过程，循环开始时 $dist &#x3D; 0$，循环次数上限为顶点个数减 1，每次执行后 $dist+1$，表示距离不断按层递增，且距离 $≤|V|-1$ (当图为链状取到最大距离，为 $|V|-1$ )。</p><br /><h5 id="算法过程-2"><a href="#算法过程-2" class="headerlink" title="算法过程"></a>算法过程</h5><ol><li><p>设置一个用于泛洪标记 (访问状态) 的 $visited$ 哈希表，一个记录所有顶点距离的哈希表 $dists$ 。</p></li><li><p>置给定源点 $s$ (题中的 $A$) 的距离为 0，并立即置其为「已访问」。</p></li><li><p>外层 (第一层) $for$ 循环按距离递增。初始 $dist&#x3D;0$ ，以 $|V| - 1$ 为最大遍历次数，每次 $dist$ 加 1，表示距离以 1 为单位不断递增，最大不超过 $|V|-1$。</p><ol><li>第二层 $for$ 循环遍历所有顶点，找到距离已确定且为 $dist$ 的顶点 $u$ (即刚刚处理完的上一层顶点)。<ol><li>第三层 $for$ 循环遍历 $u$ 的邻接顶点 $v$ ，置其中距离未确定的 $v$ 的距离为 $dist+1$ 。(若有需要，可在此时置 $v$ 的前驱为 $u$ ，本题不需要)。</li></ol></li></ol></li><li><p>最外层 $for$ 循环结束后所有顶点距离被确定，算法结束。</p></li></ol><p>※ 该题的输入中，顶点的 $label$ 虽是唯一的，但并不连续，因此对于 $visited$ 和 $dists$ ，不适合用我们之前已经习惯的数组来表示，改用哈希表表示。另外，此题输入已经给出了图的完整邻接表信息，无需建图过程。</p><br /><h5 id="时空复杂度-5"><a href="#时空复杂度-5" class="headerlink" title="时空复杂度"></a>时空复杂度</h5><p>时间复杂度：虽然程序有三层循环，但总体的效果是对所有顶点询问一次它们的邻接顶点，并不总能进入第三层，因此时间复杂度取决于前两层 $for$  的时间复杂度，为 $O(|V|^2)$ 。</p><p>空间复杂度： 存图空间 $O(|V|+|E|)$ (本题已给出，实际上无需此空间)， $visited&#x2F;dists$ 空间 $O(|V|)$。总体为线性空间复杂度 $O(|V|+|E|)$  (对于本题实际上是 $O(|V|)$ )。</p><br /><h5 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for Undirected graph.</span></span><br><span class="line"><span class="comment"> * class UndirectedGraphNode &#123;</span></span><br><span class="line"><span class="comment"> *     int label;</span></span><br><span class="line"><span class="comment"> *     List&lt;UndirectedGraphNode&gt; neighbors;</span></span><br><span class="line"><span class="comment"> *     UndirectedGraphNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         label = x;</span></span><br><span class="line"><span class="comment"> *         neighbors = new ArrayList&lt;UndirectedGraphNode&gt;();</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">shortestPath</span><span class="params">(List&lt;UndirectedGraphNode&gt; graph, UndirectedGraphNode A, UndirectedGraphNode B)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(A == B) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 特判</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> graph.size(), a = A.label, b = B.label;</span><br><span class="line">        Set&lt;Integer&gt; visited = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        Map&lt;Integer, Integer&gt; dists = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        dists.put(a, <span class="number">0</span>); <span class="comment">// 首先置源点距离为0</span></span><br><span class="line">        visited.add(a); <span class="comment">// 立即置为已访问</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">dist</span> <span class="operator">=</span> <span class="number">0</span>; dist &lt; n - <span class="number">1</span>; dist++)&#123; <span class="comment">// 按层推进</span></span><br><span class="line">            <span class="keyword">for</span>(UndirectedGraphNode uNode : graph)&#123; <span class="comment">// 遍历顶点</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> uNode.label;</span><br><span class="line">                <span class="keyword">if</span>(visited.contains(u) &amp;&amp; dists.get(u) == dist)&#123; <span class="comment">// 寻找刚确定好距离的上一层顶点</span></span><br><span class="line">                    <span class="keyword">for</span>(UndirectedGraphNode vNode : uNode.neighbors)&#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> vNode.label;</span><br><span class="line">                        <span class="keyword">if</span>(!visited.contains(v)) &#123; <span class="comment">// 距离未确定的v</span></span><br><span class="line">                            dists.put(v, dist + <span class="number">1</span>); <span class="comment">// 确定当前层顶点的距离</span></span><br><span class="line">                            visited.add(v); <span class="comment">// 立即置为已访问</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="comment">// 外层for结束后求得源点A到所有顶点的距离</span></span><br><span class="line">        <span class="keyword">return</span> visited.contains(b) ? dists.get(b) : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h4 id="队列优化版"><a href="#队列优化版" class="headerlink" title="队列优化版"></a>队列优化版</h4><h5 id="算法描述-3"><a href="#算法描述-3" class="headerlink" title="算法描述"></a>算法描述</h5><p>朴素版做法的明显缺点是在程序运行到后期，大部分顶点的距离已确定，但每次距离加 1 后，仍要遍历所有顶点，我们已经知道使用队列可以优化这部分时间。从源点 $s$ 开始执行 $bfs$ ，一开始将 $s$ 放入队列中。每次处理一层顶点，在一个 $for$ 循环内依次将该层顶点出队，对每一个当前层的顶点 $u$ ，遍历它的邻接顶点 $v$ ，只要它未被标记为「已访问」，则它是下一层顶点，此时即可赋予其当前距离，此距离每处理一层增加 1，将 $v$ 入队并置 $v$ 为「已访问」。当 $q$ 中顶点全都出队时，我们就得到了 $s$ 到所有顶点的最短路径距离。</p><br /><h5 id="算法过程-3"><a href="#算法过程-3" class="headerlink" title="算法过程"></a>算法过程</h5><ol><li>设置一个队列 $q$ ，一个用于泛洪标记 (访问状态) 的 $visited$ 哈希表，一个记录所有顶点距离的哈希表 $dists$ 。</li><li>首先将源点 $s$ 入队，并立即置其访问状态为「已访问」。</li><li>执行 $while(!q.isEmpty())$ ，开始 $bfs$ 泛洪。每次以一个 $for$ 循环处理 <strong>一层</strong> 顶点，$dist++$ ，表示当前层的距离。<ol><li>对每一个当前层的顶点 $u$ ，以一个 $for$ 循环遍历它的邻接顶点 $v$ ，只要它未被标记为「已访问」，则它是下一层顶点，此时即可赋予其当前距离，将 $v$ 入队 并置 $v$ 为「已访问」。</li></ol></li><li>当 $q$ 中顶点全都出队时，我们就得到了 $s$ 到所有顶点的最短路径距离。</li></ol><br /><h5 id="时空复杂度-6"><a href="#时空复杂度-6" class="headerlink" title="时空复杂度"></a>时空复杂度</h5><p>时间复杂度: $BFS$ 一次泛洪的时间复杂度 $O(|V|+|E|)$ 。可如此分析: 每个顶点均入队一次出队一次，时间复杂度为 $O(|V|)$ ，每个顶点都会遍历其邻接顶点，总的来看就是总边数，时间复杂度为 $O(|E|)$。因此总时间复杂度为线性时间复杂度 $O(|V|+|E|)$ 。</p><p>空间复杂度: 存图空间 $O(|V|+|E|)$ (本题已给出，实际上无需此空间)， $visited&#x2F;dists&#x2F;q$ 空间 $O(|V|)$。总体为线性空间复杂度 $O(|V|+|E|)$  (对于本题实际上是 $O(|V|)$ )。</p><br /><h5 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h5><p>给出如下代码。由于该题的输入中，顶点的 $label$ 虽是唯一的，但并不连续，因此对于 $visited$ 和 $dists$ ，用哈希表来代替数组。该题入参 $graph$ 已经包含了完整的邻接表信息，无需再建图。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">shortestPath</span><span class="params">(List&lt;UndirectedGraphNode&gt; graph, UndirectedGraphNode A, UndirectedGraphNode B)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(A == B) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> graph.size(), dist = <span class="number">0</span>, a = A.label, b = B.label;</span><br><span class="line">        Set&lt;Integer&gt; visited = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(); <span class="comment">// 用set来存放已访问元素</span></span><br><span class="line">        HashMap&lt;Integer, Integer&gt; dists = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(); <span class="comment">// 用哈希表记录每个顶点的距离</span></span><br><span class="line">        Queue&lt;UndirectedGraphNode&gt; q = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        q.add(A);</span><br><span class="line">        visited.add(a); <span class="comment">// 将源点置为「已访问」</span></span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123; <span class="comment">// 泛洪</span></span><br><span class="line">            dist++; <span class="comment">// 当前层顶点的「距离」</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> q.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)&#123; <span class="comment">// 一次处理一层</span></span><br><span class="line">                <span class="type">UndirectedGraphNode</span> <span class="variable">uNode</span> <span class="operator">=</span> q.remove();</span><br><span class="line">                <span class="keyword">for</span>(UndirectedGraphNode vNode : uNode.neighbors)&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> vNode.label;</span><br><span class="line">                    <span class="keyword">if</span>(!visited.contains(v))&#123; <span class="comment">// 若v「未访问」</span></span><br><span class="line">                        dists.put(v, dist); <span class="comment">// v的距离在此时确定</span></span><br><span class="line">                        q.add(vNode);</span><br><span class="line">                        visited.add(v); <span class="comment">// 立即置为「已访问」</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> visited.contains(b) ? dists.get(b) : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果只是为了求解该题，无需记录所有顶点的距离，只要遇到顶点 $B$，返回当前距离即可，如下。(有意思的是用数组 $visited$ 也能通过所有样例，不过这不重要。)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">shortestPath</span><span class="params">(List&lt;UndirectedGraphNode&gt; graph, UndirectedGraphNode A, UndirectedGraphNode B)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(A == B) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 特判</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> graph.size(), dist = <span class="number">0</span>;</span><br><span class="line">        <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[n + <span class="number">1</span>];</span><br><span class="line">        Queue&lt;UndirectedGraphNode&gt; q = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        q.add(A);</span><br><span class="line">        visited[A.label] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">            dist++;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> q.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">                <span class="type">UndirectedGraphNode</span> <span class="variable">uNode</span> <span class="operator">=</span> q.remove();</span><br><span class="line">                <span class="keyword">for</span>(UndirectedGraphNode vNode : uNode.neighbors)&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> vNode.label;</span><br><span class="line">                    <span class="keyword">if</span>(vNode == B) <span class="keyword">return</span> dist;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(!visited[v])&#123;</span><br><span class="line">                        q.add(vNode);</span><br><span class="line">                        visited[v] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h3 id="带权单源最短路"><a href="#带权单源最短路" class="headerlink" title="带权单源最短路"></a>带权单源最短路</h3><p>当图为有权图时，我们将无法简单地通过层数增加来确定每一层顶点的距离，因为从源点若有多条路径可到达顶点 $v$，更深的路径完全可以比更浅的路径具有更少的路径长 (路径上的边的权之和) 。本节我们将学习几种不同的 <strong>「带权单源最短路」</strong> 算法来求解经典的带权单源最短路问题 <a href="https://leetcode.cn/problems/network-delay-time/">743. 网络延迟时间</a> 。再次强调，图「有向」或「无向」，对于这些算法，区别仅在于建图时为双向边还是单向边，除非特别说明 (例如 DAG )，否则 <strong>最短路算法不区分有向图或是无向图</strong> 。</p><br /><h4 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h4><p>一种基于贪心思想的求解 <strong>无负边图单源最短路径</strong> 的算法 (后续会说明为何不适用于负边图)。该算法可能是「最短路」算法家族中最知名的一个。Dijkstra 算法提出年代早，为贪心思想的极佳应用，另外，其在「20分钟」内被发明的故事也为人所乐道，具体可看相关 wiki 词条。</p><blockquote><p>Dijkstra 在1956年构思出此算法，并于1959年发表的 <a href="http://www-m3.ma.tum.de/foswiki/pub/MN0506/WebHome/dijkstra.pdf"><em>A Note on Two Problems in Connexion with Graphs</em> </a> 论文中描述了该算法。</p></blockquote><p>本节中，我将仍旧先给出「朴素版」，专注学习 Dijkastra 的过程，并给出严谨的正确性证明。随后，我们提出应用 「优先队列」 的改进版，并通过对这两个版本时间复杂度的分析，指出对于「稠密图」，应当使用「朴素版」，对于「稀疏图」，应当使用「优先队列版」。接着，我会以一个小例子直观地展示为何 Dijkstra 无法处理具有负边的图。</p><br /><h5 id="朴素版-1"><a href="#朴素版-1" class="headerlink" title="朴素版"></a>朴素版</h5><h6 id="算法描述-4"><a href="#算法描述-4" class="headerlink" title="算法描述"></a>算法描述</h6><p><a href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm">Dijkstra算法 (狄杰斯特拉)</a>: Dijkstra 算法的 <strong>基本操作</strong> 是将所有顶点区分为距离 <strong>已确定</strong> 和 <strong>未确定</strong> 的顶点。算法开始前所有顶点的距离均未确定(一般置为$Infinity$)，初始时置 $s$ 的距离为 0。以一个 $while$ 循环查询当前 <strong>是否有距离未确定</strong> 的顶点，若有则将 <strong>其中距离最小者</strong>  $u$ 选为 <strong>当前顶点</strong>，并<strong>使其距离已知</strong>。然后以 $bfs$ 的方式松弛 $u$ 的邻接顶点 $v$ ，如之前所述，若要求返回完整路径，则可在此时更新 $v$ 的前驱为 $u$。当不再有未确定距离的顶点时算法结束，此时每一个顶点的距离均最小，若需要返回源点到某顶点的完整路径，可通过不断寻找节点的前驱得到 $s$ 到该顶点的具体的最短路径。</p><p><strong>松弛操作 (relax)</strong> 是 Dijkstra 算法的关键，也是后续其他最短路径算法的关键。「松弛」指的是在确定当前顶点 $u$ 的距离 (最新成为已确定距离的顶点) 后，立即尝试更新其邻接顶点 $v$ 的距离。更新条件为 $du + |(u,v)| &lt; dv$ ，表示当前从源点经过 $u$ 到达 $v$ 的距离，要小于此时 $v$ 的距离，也就是发现了一条比当前源点到 $v$ 的路径距离更短的路径。以下图举例说明。</p><p>$s$ 经过若干个顶点 (用曲线表现经过多个顶点的路径) 到 $a$ 和 $b$，$a$ 和 $b$ 邻接 $c$。假设此时 $dv &#x3D; Inifinity$，$da &#x3D; 5$，$db &#x3D; 10$。</p><ul><li>松弛顺序为先 $a$ 后 $b$<ul><li>$a$ 成为当前顶点时，由于 $da + |(a, v)| &#x3D; 9 &lt; Infinity$，故 $a$ 松弛 $dv$，(若需要，此时可将 $v$ 的前驱置为 $a$ )。</li><li>$b$ 成为当前顶点时，由于 $db + |(b, v)| &#x3D; 8 &lt; 9$，故 $b$ 松弛 $dv$，(若需要，此时可将 $v$ 的前驱置为 $b$ )。</li></ul></li><li>松弛顺序为先 $b$ 后 $a$<ul><li>$b$ 成为当前顶点时，由于 $db + |(b, v)| &#x3D; 8 &lt; Infinity$，故 $b$ 松弛 $dv$，(若需要，此时可将 $v$ 的前驱置为 $b$ )。</li><li>$a$ 成为当前顶点时，由于 $da + |(a, v)| &#x3D; 9 &gt;&#x3D; 8$，故 $a$ 无法松弛 $dv$。</li></ul></li></ul><p><img src="https://pic.leetcode-cn.com/1655190992-ovhCwD-image.png" alt="image.png"></p><p>通过这个例子我们能够直观地观察到，来自 $v$ 入边的松弛，使得 $dv$ 总有机会更新至所有可能的路径距离的最小值 (而无论先通过那一条入边来松弛)。后续讲解 Bellman-Ford 和 Floyd 算法时，我们还会继续强调松弛操作。另外，松弛这一动词的宾语，现实生活中一般是「松弛边」，不过算法里的松弛，实际上是更新一个点的距离，虽说这个距离是源点到该点的路径长，但毕竟是该点的一个属性。总之你也会看「松弛顶点」的表述，不用特意区分。</p><p>至此我们已能够理解如下内容。Dijkstra 算法分成 $|V|$ 个阶段，每个阶段确定当前距离最小者的顶点 $v$ 的距离 $dv$ 为最短距离 (第一个阶段直接给出 $s$ 的距离为 0)，$|V|$ 个阶段即可确定所有顶点的距离。一个阶段确定一个顶点距离正是该算法 <strong>「贪心」</strong> 的体现，其正确性在于，之后不可能通过除 $v$ 外的其他顶点来松弛 $v$ ，因为其他能够用来松弛它的顶点的距离都大于等于此时的 $dv$ ，而那些距离未更新的 (仍为 $Infinity$ ) 的顶点，在此后的松弛中，距离也一定是大于 $dv$ 的，因为松弛它的必定是此前具有有效距离的顶点。总之，我们能够不很严谨地理解 Dijkstra 算法的正确性。如果读者诸君仍觉不放心，也不必担心，我将在「正确性证明」中，用结合「反证法」的「数学归纳法」，严格地证明 Dijkstra 算法的正确性。</p><br /><h6 id="算法过程-4"><a href="#算法过程-4" class="headerlink" title="算法过程"></a>算法过程</h6><ol><li><p>建图及初始化。</p><ol><li>构建带权图。</li><li>设置一个大小为 $|V|$ 的用于标记顶点距离是否「已确定」的 $boolean$ 数组 $visited[]$ ，下标表示顶点。</li><li>设置一个大小为 $|V|$ 的距离数组 $dists[]$ ，下标表示顶点。初始化所有顶点到源点 $s$ 的距离为 $Infinity$ ，表示该顶点到 $s$ 的距离尚未确定。</li><li>置 $s$ 到其自身距离为 0。</li></ol></li><li><p>以一个循环寻找 <strong>当前距离未确定顶点中距离最小者</strong> $u$ ，立即置 $u$ 的距离为「已确定」。</p></li><li><p>松弛操作。尝试松弛 $u$ 的所有 <strong>距离未确定的</strong> 邻接顶点 $v$ 的距离 $dv$。即 $dv &#x3D; min{dv, du + |(u,v)|}$ 。若需要求完整路径，可在松弛的同时更新 $v$ 的前驱为 $u$。</p></li><li><p>循环结束时，每个顶点到源点的最短路径距离被求出。</p></li></ol><p>设下图 $v_1$ 为源点，应用 Dijkstra 算法求解的过程如下。</p><table><thead><tr><th>阶段</th><th>距离已确定</th><th>距离未确定</th><th>松弛</th></tr></thead><tbody><tr><td>初始</td><td></td><td>$v_1(∞)$, $v_2(∞)$, $v_3(∞)$, $v_4(∞)$, $v_5(∞)$, $v_6(∞)$, $v_7(∞)$</td><td>$v_1(0)$</td></tr><tr><td>1</td><td>$v_1(0)$</td><td>$v_2(∞)$, $v_3(∞)$, $v_4(∞)$, $v_5(∞)$, $v_6(∞)$, $v_7(∞)$</td><td>$v_2(2),$ $v_4(1)$</td></tr><tr><td>2</td><td>$v_4(1)$</td><td>$v_2(2)$, $v_3(∞)$, $v_5(∞)$, $v_6(∞)$, $v_7(∞)$</td><td>$v_3(3)$, $v_5(3)$, $v_6(9)$, $v_7(5)$</td></tr><tr><td>3</td><td>$v_2(2)$</td><td>$v_3(3)$, $v_5(3)$, $v_6(9)$, $v_7(5)$</td><td></td></tr><tr><td>4</td><td>$v_3(3)$</td><td>$v_5(3)$, $v_6(9)$, $v_7(5)$</td><td>$v_6(8)$</td></tr><tr><td>5</td><td>$v_5(3)$</td><td>$v_6(8)$, $v_7(5)$</td><td></td></tr><tr><td>6</td><td>$v_7(5)$</td><td>$v_6(8)$</td><td>$v_6(5)$</td></tr><tr><td>7</td><td>$v_6(5)$</td><td></td><td></td></tr></tbody></table><p><img src="https://pic.leetcode-cn.com/1655274120-MLEFZO-image.png" alt="image.png"></p><br /><h6 id="正确性证明"><a href="#正确性证明" class="headerlink" title="正确性证明"></a>正确性证明</h6><p>如下，利用数学归纳法 (结合反证法) 严格证明 Dijkstra 算法正确性。</p><blockquote><p>本证明参考了<a href="https://www.zhihu.com/question/57206374">这个帖子</a>。</p></blockquote><p>a) 首先回顾数学归纳法的证明过程。</p><ol><li>起始验证。对于命题 $P(n)$，当 $n &#x3D; 1$ 时命题 $P$ 成立。</li><li>假设命题成立。假设命题 $P(n)$ 在 $n &#x3D; m (m &gt; 1, m ∈ N)$ 时成立。</li><li>递推证明。根据2的假设，若能证明 $n &#x3D; m + 1$ 时命题 $P$ 成立，则命题得证。</li></ol><p>例如，有命题 $P：1+2+3…+n &#x3D; n*(n+1)&#x2F;2$，按照数学归纳法证明如下：</p><ol><li><p>起始验证。当 $n$ 等于 $1$ 时，$1 &#x3D; 1*(1+1)&#x2F;2$，命题成立。</p></li><li><p>假设命题成立。假设命题等于 $m$ 时成立，$1+2+3+…+m &#x3D; m*(m+1)&#x2F;2$。</p></li><li><p>递推证明。根据 2 的假设，如果能证明 $n &#x3D; m+1$ 时命题正确，则命题 $P$ 成立。</p><p>证明：在 2 所示式子左右两边加上 $m+1$，得到 $1+2+3+…+m+(m+1) &#x3D; m*(m+1)&#x2F;2 + (m+1)$</p><p>等号右边可以写成 $(m+1)*(m+2)&#x2F;2$，显然该形式就是将 $n &#x3D; m+1$代入原命题 $P$ 的形式，证毕。</p></li></ol><p>b) 利用数学归纳法证明如下命题。</p><p>命题 $P$：Dijkstra 算法第 $n$ 次进入 $wh ile$ 时，会将第 $n$ 个顶点加入距离已确定顶点集合 $A$ 中，此时对于顶点 $∀v ∈ A($共 $n$ 个)，总有 $dv &#x3D; δv$。</p><p>※ $dv$ 表示由 Dijkstra 算法得到的最短距离估计 ( <em>tentative shortest distance</em> )，对于源点 $s$ ，在程序开始时赋予 $ds &#x3D; 0$，对于其他顶点，由松弛操作得到。$δv$ 表示实际的顶点 $v$ 到源点的最短距离。</p><ol><li><p>起始验证。当 $n$ 等于 $1$ 时，$A$ 集合中只有源点 $s$ 自身，$ds &#x3D; 0$ (程序开始时赋值得到)，且知 $δv &#x3D; 0$，故 $n&#x3D;1$ 时命题正确。</p></li><li><p>假设命题成立。假设命题 $P$ 在 $n$ 等于 $m$ 时，$P(m)$ 成立，即算法经过 $m$ 次while，得到具有 $m$ 个顶点的集合 $A$，对于顶点 $∀v ∈ A$ (共 $m$ 个)，总有 $dv &#x3D; δv$。</p></li><li><p>$P(m+1)$ 递推证明。根据 2 的假设，如果能证明第 $m+1$ 个顶点 $u$ 被放入集合 $A$ 时有 $du &#x3D; δu$，则命题 $P$ 成立。</p><p>更详细地，$|A| &#x3D; m$ 时，在点集 $B (B &#x3D; S - A)$ 中根据算法规则找到距离最短的顶点 $u$，将该顶点将作为第 $m+1$ 个顶点放入 $A$ 中，放入后 $|A| &#x3D; m + 1$，如果能证明 $du &#x3D; δu$，使得 $P(m+1)$ 成立，则对于顶点 $∀v ∈ A$ (共 $m+1$ 个)，有 $dv &#x3D; δv$。</p><p>以反证法证明之。</p><p>3.1 假设 $m+1$ 时 $du &#x3D; δu$ 不成立，即有如下式(1)， 之后的目标是根据已知条件导出某种矛盾情形，推翻该假设。</p><p>(1)    $δu &lt; du$     </p><p>※ $δu$ 是实际的 $u$ 到源点的最短距离，$du &#x3D; δu$ 不成立时只能是 $δu &lt; du$。算法保证了从 $s$ 到 $u$ 的过程一定是一条由图中的有向边构成的连续路径，只要是连续路径，无论有多少条这样的路径。一定有一条最短路径，其长度记作 $δu$。</p><p>3.2 根据3.1的假设，存在一条从源点 $s$ 到 $u$ 的路径 $Pu$，该路径是 $s$ 到 $u$ 的最短路径，即 $|Pu| &#x3D; δu  &lt; du$。路径 $Pu$ 一定有不在 $A$ 集内的顶点 (至少有 $u$ 不在 $A$ 集中)，同时也有在 $A$ 集中的点 (至少有 $s$ 点在 $A$ 集中)，可以假设 $Pu$ 经过 $x$ 和 $y$，其中 $x$ 在A中 (可以是 $s$)，$y$ 在B中 (可以是 $u$ 本身)，$y$ 到 $u$ 的过程中也可以再进入 $A$，如下图。$Px$ 为 $Pu$ 在顶点 $x$ 结束的子路径，因为路径 $Px + (x, y)$ 为路径 $Pu$ 的一部分，所以有：</p><p>(2)    $|Px| + |(x, y)| ≤ |Pu| &#x3D; δu$       </p><p>这是显然的，因为 $Px + (x, y)$ 是 $Pu$ 的一部分，当 $y&#x3D;u$ 时取到等号。</p><p><img src="https://pic.leetcode-cn.com/1655273910-YSxESy-image.png" alt="image.png"></p><p>3.3 在 $x$ 被选中进入 $A$ 集内时，对其邻接顶点 $y$ 执行过 <strong>松弛操作</strong>，该操作会比较 $dx + |(x, y)|$ 是否小于 $dy$，若小于则以 $dx + |(x, y)|$ 更新 $dy$ 的值，所以如果更新了，更新之后有 $dy &#x3D; dx + |(x, y)|$ ，如果没更新，说明 $dy &lt; dx + |(x, y)|$。假设之后 $y$ 还会被 $y$ 的其他前驱顶点更新 $dy$ 值 (当该前驱顶点进入 $A$ 集时)，那 $dy$ 只会变得更小，所以一定有：</p><p>(3)    $dy ≤ dx + |(x, y)|$      </p><p>比较式 (2) 和式 (3) 中的 $|Px|$ 和 $dx$，因为 $dx &#x3D; δx$  (由步骤2的 $P(m)$ 假设给出，顶点 $x$ 是 $P(m)$ 假设的 $m$ 个顶点之一)，而 $Px$ 只是若干从 $s$ 到 $x$ 的路径之一，因此必有 $d(x) ≤ |Px|$，当 $Px$ 恰是 $s$ 到 $x$ 的最短路径时取到等号。所以根据式 (2) 和式 (3) 有：</p><p>$dy ≤ dx + |(x, y)| ≤ |Px| + |(x, y)| ≤ |Pu|$，即 </p><p>(4)    $dy ≤ |Pu| &#x3D; δu$       </p><p>3.4 顶点 $y$ 与 $u$ 均在 $B$ 集中，根据算法规则，$u$ 之所以是第 $m+1$ 个被放入 $A$ 集中的顶点，是因为第 $m+1$ 次进入while时，$u$ 在 $B$ 集中相比于 $B$ 集中的其他顶点(自然也包括 $y$ )，到源点 $s$ 的距离最小，显然有：</p><p>(5)    $du ≤ dy$        </p><p>结合式 (1)，式 (4)，式 (5) 得到：</p><p>(6)    $δu &lt; du ≤ dy ≤ |Pu| &#x3D; δu$ ，即  $δu &lt; δu$</p></li></ol><p>至此，由 3.1 的假设 「$d(u) &#x3D; δ(u)$ 不成立」导出了矛盾，所以 $d(u) &#x3D; δ(u)$ 是成立的，<strong>Dijkstra 算法正确性得证</strong> 。</p><br /><h6 id="时空复杂度-7"><a href="#时空复杂度-7" class="headerlink" title="时空复杂度"></a>时空复杂度</h6><p>时间复杂度：$O(|V|^2 + |E|)$，由于 $|E| &lt; |V|^2$ ，所以也可以写为 $O(|V|^2)$ 。</p><ol><li><p>寻找拥有最小距离的顶点的时间为 $O(|V|^2)$ 。 每次遍历寻找时间复杂度为 $O(|V|)$ ，需寻找 $|V|$ 次 。</p></li><li><p>所有顶点的距离被松弛的次数上限为 $O(|E|)$ 。由算法可知顶点距离松弛只发生在找到当前距离未确定且距离最小的顶点之后，一次更新的次数是该顶点的邻接顶点数 (即出边数，出度)。每一次循环松弛某一个顶点的所有出边。所有顶点的出边数即总边数 $|E|$ 。故总松弛次数，也即所有顶点的距离被更新的次数时间复杂度为 $O(|E|)$ 。</p></li></ol><p>空间复杂度：存图空间 $O(|V|+|E|)$ ， $visited&#x2F;dists$ 空间 $O(|V|)$。总体为线性空间复杂度 $O(|V|+|E|)$ 。</p><br /><h6 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h6><p>现在，我们利用上述知识来实际编程解决 <a href="https://leetcode.cn/problems/network-delay-time/">743. 网络延迟时间</a> 。仔细读题后可知，从某个节点 $k$ 发出一个信号，要使所有节点都收到信号，只要使距离 $k$ 最远的那个顶点收到信号即可。所以这题是典型的带权单源最短路问题，应用本节的朴素版 Dijkstra 算法，以顶点 $k$ 为源点，求出其他所有顶点到 $k$ 的最短路长度，返回其中最大者即可。需要注意以下几点。</p><ul><li>构建带权图时，需要记录边权，因此顶点的邻接表以 <code>List&lt;int[]&gt;</code> 表示，对于顶点 $u$ ，其邻接表中的 <code>int[] v_weight</code> ，<code>v_weight[0]</code> 为 $u$ 的邻接顶点， <code>v_weight[1]</code> 为边权 $|(u, v)|$ 。</li><li>为了清晰地看出「在当前距离未确定的顶点中找到距离最小者」这一「贪心」动作，我们将其写为 $getMin$ 方法。</li><li>当存在与源点不连通的顶点时，该顶点的距离将得不到松弛，因此存在未松弛顶点时返回 -1。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">networkDelayTime</span><span class="params">(<span class="type">int</span>[][] times, <span class="type">int</span> n, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">        List&lt;List&lt;<span class="type">int</span>[]&gt;&gt; graph = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) graph.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] edge : times)&#123; <span class="comment">// 建带权图</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> edge[<span class="number">0</span>] - <span class="number">1</span>, v = edge[<span class="number">1</span>] - <span class="number">1</span>, weight = edge[<span class="number">2</span>];</span><br><span class="line">            graph.get(u).add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;v, weight&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>, INF = Integer.MAX_VALUE; <span class="comment">// max为距离源点最远顶点的距离，INF为所有顶点距离初始值</span></span><br><span class="line">        <span class="type">int</span>[] dists = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">        Arrays.fill(dists, INF); <span class="comment">// 距离初始化</span></span><br><span class="line">        dists[k - <span class="number">1</span>] = <span class="number">0</span>; <span class="comment">// 源点距离置0</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// 当前距离未确定顶点中的距离最小者</span></span><br><span class="line">        <span class="keyword">while</span>((u = getMin(dists, visited)) != -<span class="number">1</span>) &#123; <span class="comment">// 遍历顶点，寻找当前距离未确定顶点中的距离最小者</span></span><br><span class="line">            visited[u] = <span class="literal">true</span>; <span class="comment">// 立即置为距离已确定</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span>[] v_weight : graph.get(u)) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> v_weight[<span class="number">0</span>], weight = v_weight[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(!visited[v]) &#123; <span class="comment">// 对于u的距离未确定的邻接顶点v，松弛v的距离</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">dv</span> <span class="operator">=</span> dists[u] + weight;</span><br><span class="line">                    <span class="keyword">if</span>(dv &lt; dists[v]) &#123; <span class="comment">// 松弛条件</span></span><br><span class="line">                        dists[v] = dv; <span class="comment">// 更新dv</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> dist : dists)&#123; <span class="comment">// 找最短路长度最大者</span></span><br><span class="line">            <span class="keyword">if</span>(dist == INF) <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 存在距离未更新的顶点直接返回 -1</span></span><br><span class="line">            <span class="keyword">if</span>(dist &gt; max) max = dist;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getMin</span><span class="params">(<span class="type">int</span>[] dists, <span class="type">boolean</span>[] visited)</span>&#123; <span class="comment">// 在当前距离未确定的顶点中找距离最小者</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> dists.length, min = Integer.MAX_VALUE, minVertex = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> <span class="number">0</span>; u &lt; n; u++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[u] &amp;&amp; dists[u] &lt; min) &#123; </span><br><span class="line">                min = dists[u];</span><br><span class="line">                minVertex = u;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minVertex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h5 id="优先队列版"><a href="#优先队列版" class="headerlink" title="优先队列版"></a>优先队列版</h5><h6 id="算法描述-5"><a href="#算法描述-5" class="headerlink" title="算法描述"></a>算法描述</h6><p>针对朴素版「算法过程」第 2 步「在当前距离未确定顶点中寻找距离最小者」，我们很容易想到利用优先队列 (小顶堆) $pq(priority_queue)$ 来优化，除此之外其他过程与朴素版一致。需要注意的是一个顶点 $v$ 的距离在被确定前可能经过多次松弛，每次松弛都会入 $pq$ ，于是同一时间，堆中可能有多个相同的顶点 (松弛过几次就有几个) 。这其中最靠顶的将会先出堆，出堆即表明该顶点距离已确定，所以顶点出堆时要判断是否是第一次出堆，若不是则跳过。</p><br /><h6 id="算法过程-5"><a href="#算法过程-5" class="headerlink" title="算法过程"></a>算法过程</h6><ol><li>建图及初始化。<ol><li>构建带权图。</li><li>设置一个小顶堆 $pq$ 。</li><li>设置一个大小为 $|V|$ 的用于标记顶点距离是否「已确定」的 $boolean$ 数组 $visited[]$ ，下标表示顶点。</li><li>设置一个大小为 $|V|$ 的距离数组 $dists[]$ ，下标表示顶点。初始化所有顶点到源点 $s$ 的距离为 $Infinity$ ，表示该顶点到 $s$ 的距离尚未确定。</li><li>置 $s$ 到其自身距离为 0。</li><li>$s$ 入堆。</li></ol></li><li>一次出堆完成一个顶点最短路径的确定。以 $while$ 循环对 $pq$ 判空，若不空，堆顶顶点 $u$ 出堆，此时 $u$ 为距离未确定顶点中距离最小者，置 $u$ 的距离为已确定。</li><li>松弛操作。尝试松弛 $u$ 的所有 <strong>距离未确定的</strong> 邻接顶点 $v$ 的距离 $dv$。即 $dv &#x3D; min{dv, du + |(u,v)|}$ 。若需要求完整路径，可在松弛的同时更新 $v$ 的前驱为 $u$。</li><li>循环结束时，每个顶点到源点的最短路径距离被求出。</li></ol><br /><h6 id="时空复杂度-8"><a href="#时空复杂度-8" class="headerlink" title="时空复杂度"></a>时空复杂度</h6><p>时间复杂度：$O(|E|log|E|+|E|log|E|)$ ，化简为 $O(|E|log|E|)$ ，可进一步化简为 $O(|E|log|V|)$  ，具体如下。</p><ol><li><p><strong>在当前距离未确定顶点中寻找距离最小者的总时间复杂度</strong> 为 $O(|E|log|E|)$ 。</p><ol><li>$while$ 中 $pq$ 判空次数与堆大小有关，堆的大小为 $O(|E|)$ ，注意不是 $O(|V|)$ 而是 $O(|E|)$，后述。</li><li>获取距离最小者耗时为堆的查找时间复杂度， $O(log|E|)$ 。</li><li>故此部分时间复杂度为 $O(|E|log|E|)$ 。</li></ol><p>※ 优先队列判空操作 $isEmpty()$ 本身是常数时间操作，但总共要执行 $O(|E|)$ 次。</p></li><li><p>考虑所有顶点的距离被更新 (松弛) 导致的 <strong>总的顶点入堆时间复杂度</strong> 为 $O(|E|log(|E|))$ 。</p><ol><li>由算法可知顶点 $u$ 松弛其邻接顶点 $v$ 的距离只发生在找到 $u$ 为当前距离未确定且距离最小的顶点之后 ( $u$ 出堆后)。(尝试) 松弛的次数是其邻接顶点 $v$ 的个数 (即 $u$ 的出边数，出度)。每一次循环确定一个这样的顶点，也就是每一次循环松弛 <strong>当前距离被确定的顶点</strong> 的所有出边。所有顶点的出边即总边数为 $|E|$ 。故总松弛次数，也即所有顶点的距离被更新的次数，也即顶点入堆总次数为 $O(|E|)$ 。</li><li>$dv$ 被松弛时 $v$ 入堆，插入操作的时间复杂度为 $O(log|E|)$。由上述，入堆次数与更新次数相同，于是 <strong>所有顶点的距离更新</strong> 以及该更新导致的 <strong>顶点入堆的总时间复杂度</strong> 为 $O(|E| + |E|log|E|)$ 。</li></ol><p>※ 根据上述顶点入堆次数取决于总边数的分析，堆的大小上限不是 $O(|V|)$ 而是 $O(|E|)$ ，所以 $dv$ 更新时 $v$ 入堆的时间复杂度为 $O(log|E|)$ ，只是借助边数与顶点数的关系，可化简为 $O(log|V|)$ 。 $|E| &lt; |V|^2$ ，即有 $log|E| &lt; 2log|V|$，可化简为 $O(log|V|)$ 。</p></li></ol><p>空间复杂度：存图空间 $O(|V|+|E|)$ ， $visited&#x2F;dists$ 空间 $O(|V|)$， $pq$ 空间 $O(|E|)$ 。总体为线性空间复杂度 $O(|V|+|E|)$ 。</p><blockquote><p> ※ tip1: 连通图顶点数与边数有如下关系。</p><p> 无向连通图：$|V| - 1 &lt;&#x3D; |E| &lt;&#x3D; |V|*(|V| - 1) &#x2F; 2$ </p><p> 链状时 $|E|$ 取到最小 $|V|-1$ ，完全连通即两两相连时取到最大 $|V|*(|V| - 1) &#x2F; 2$ 。</p><p> 有向连通图：$|V| - 1 &lt;&#x3D; |E| &lt;&#x3D; |V|*(|V| - 1)$ </p><p> 链状时 $|E|$ 取到最小 $|V|-1$ ，完全连通即两两相连且正反向成对时取到最大 $|V|*(|V| - 1)$ 。</p><p> ※ 利用 Fibonacci堆的 Dijkstra 算法时间复杂度为 $O(|E|+|V|log|V|)$ ，本文不做介绍 (我不会)。</p></blockquote><p>对比「朴素版」的时间复杂度，不难看出，当图为 <strong>「稠密图」</strong> 时，「优先队列版」复杂度可表为 $O(|V|^2log|V|)$ ，这是比「朴素版」更差的复杂度。因此对于稠密图，我们可采用更优的「朴素版」。当图为 <strong>「稀疏图」</strong> 时，「优先队列版」复杂度可表为 $O(|V|log|V|)$ ，显然此时应采用「优先队列版」。</p><br /><h6 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h6><p>现在，我们给出如下利用优先队列的 Dijkstra 算法代码来解决 <a href="https://leetcode.cn/problems/network-delay-time/">743. 网络延迟时间</a> 。其与朴素版的差别仅在于每个「阶段」寻找当前距离未确定顶点中距离最小者的方式不同。该写法为 Dijkstra 算法写法的模版写法，读者应 <strong>牢记于心</strong> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dijkstra优先队列 (邻接表存图)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">networkDelayTime</span><span class="params">(<span class="type">int</span>[][] times, <span class="type">int</span> n, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">        List&lt;List&lt;<span class="type">int</span>[]&gt;&gt; graph = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) graph.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] edge : times)&#123; <span class="comment">// 建带权图</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> edge[<span class="number">0</span>] - <span class="number">1</span>, v = edge[<span class="number">1</span>] - <span class="number">1</span>, weight = edge[<span class="number">2</span>];</span><br><span class="line">            graph.get(u).add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;v, weight&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>, INF = Integer.MAX_VALUE; <span class="comment">// max为距离源点最远顶点的距离，INF为所有顶点距离初始值</span></span><br><span class="line">        <span class="type">int</span>[] dists = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">        Arrays.fill(dists, INF); <span class="comment">// 距离初始化</span></span><br><span class="line">        dists[k - <span class="number">1</span>] = <span class="number">0</span>; <span class="comment">// 源点距离置0</span></span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(((u, v) -&gt; u[<span class="number">1</span>] - v[<span class="number">1</span>])); <span class="comment">// 小顶堆</span></span><br><span class="line">        pq.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;k - <span class="number">1</span>, <span class="number">0</span>&#125;); <span class="comment">// 源点入堆</span></span><br><span class="line">        <span class="keyword">while</span>(!pq.isEmpty()) &#123; </span><br><span class="line">            <span class="type">int</span>[] u_dist = pq.remove();</span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> u_dist[<span class="number">0</span>];</span><br><span class="line">            visited[u] = <span class="literal">true</span>; <span class="comment">// 立即置u的距离为已确定</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span>[] v_weight : graph.get(u)) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> v_weight[<span class="number">0</span>], weight = v_weight[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(!visited[v]) &#123; <span class="comment">// 对于u的距离未确定的邻接顶点v，松弛v的距离</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">dv</span> <span class="operator">=</span> dists[u] + weight;</span><br><span class="line">                    <span class="keyword">if</span>(dv &lt; dists[v]) &#123; <span class="comment">// 松弛条件</span></span><br><span class="line">                        dists[v] = dv; <span class="comment">// 更新dv</span></span><br><span class="line">                        pq.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;v, dv&#125;); <span class="comment">// v入堆</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> dist : dists)&#123; <span class="comment">// 找最短路长度最大者</span></span><br><span class="line">            <span class="keyword">if</span>(dist == INF) <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 存在距离未更新的顶点</span></span><br><span class="line">            <span class="keyword">if</span>(dist &gt; max) max = dist;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dijkstra优先队列 (链式向前星存图)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">networkDelayTime</span><span class="params">(<span class="type">int</span>[][] times, <span class="type">int</span> n, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> times.length, edgeNum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] heads = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span>[] ends = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>], nexts = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>], weights = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] edge : times)&#123; <span class="comment">// 建带权图</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> edge[<span class="number">0</span>] - <span class="number">1</span>, v = edge[<span class="number">1</span>] - <span class="number">1</span>, weight = edge[<span class="number">2</span>];</span><br><span class="line">            edgeNum++;</span><br><span class="line">            weights[edgeNum] = weight;</span><br><span class="line">            ends[edgeNum] = v;</span><br><span class="line">            nexts[edgeNum] = heads[u];</span><br><span class="line">            heads[u] = edgeNum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>, INF = Integer.MAX_VALUE; <span class="comment">// max为距离源点最远顶点的距离，INF为所有顶点距离初始值</span></span><br><span class="line">        <span class="type">int</span>[] dists = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">        Arrays.fill(dists, INF); <span class="comment">// 距离初始化</span></span><br><span class="line">        dists[k - <span class="number">1</span>] = <span class="number">0</span>; <span class="comment">// 源点距离置0</span></span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(((u, v) -&gt; u[<span class="number">1</span>] - v[<span class="number">1</span>])); <span class="comment">// 小顶堆</span></span><br><span class="line">        pq.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;k - <span class="number">1</span>, <span class="number">0</span>&#125;); <span class="comment">// 源点入堆</span></span><br><span class="line">        <span class="keyword">while</span>(!pq.isEmpty()) &#123; </span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> pq.remove()[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span>(visited[u]) <span class="keyword">continue</span>;</span><br><span class="line">            visited[u] = <span class="literal">true</span>; <span class="comment">// 立即置u的距离为已确定</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">edgeNo</span> <span class="operator">=</span> heads[u]; edgeNo != <span class="number">0</span>; edgeNo = nexts[edgeNo]) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> ends[edgeNo], weight = weights[edgeNo];</span><br><span class="line">                <span class="keyword">if</span>(!visited[v]) &#123; <span class="comment">// 对于u的距离未确定的邻接顶点v，松弛v的距离</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">dv</span> <span class="operator">=</span> dists[u] + weight;</span><br><span class="line">                    <span class="keyword">if</span>(dv &lt; dists[v]) &#123; <span class="comment">// 松弛条件</span></span><br><span class="line">                        dists[v] = dv; <span class="comment">// 更新dv</span></span><br><span class="line">                        pq.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;v, dv&#125;); <span class="comment">// v入堆</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> dist : dists)&#123; <span class="comment">// 找最短路长度最大者</span></span><br><span class="line">            <span class="keyword">if</span>(dist == INF) <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 存在距离未更新的顶点</span></span><br><span class="line">            <span class="keyword">if</span>(dist &gt; max) max = dist;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h5 id="负边图"><a href="#负边图" class="headerlink" title="负边图"></a>负边图</h5><p>以下图为例说明 Dijkstra 算法为何无法处理负边图。</p><p>顶点 $s$ 是源点，从 $s$ 开始执行算法，$du$ 和 $dv$ 被更新为 1, 2，在距离未确定的顶点 $u$ 和 $v$ 中 $du$ 更小，$u$ 的距离设为已确定，$du &#x3D; 1$ 。然而实际上从 $s$ 到 $v$ 再到 $u$ 会得到一条长度为 -1 的更短的路径。</p><p>由此我们也可以看到，Dijkstra 「贪心」能够成立的一个隐含前提是路径边数的增长 <strong>必须</strong> 使得路径长 (边权和) 是 <strong>「非递减」</strong> 的。存在负边则导致路径边数增长后边权和递减，使得「贪心」成立的前提不成立。</p><p><img src="https://pic.leetcode-cn.com/1655208750-gqyCdb-image.png" alt="image.png"></p><br /><h4 id="DAG-SSSP"><a href="#DAG-SSSP" class="headerlink" title="DAG SSSP"></a>DAG SSSP</h4><h5 id="算法描述-6"><a href="#算法描述-6" class="headerlink" title="算法描述"></a>算法描述</h5><p>若最短路的求解对象是 DAG ，那么根据其无圈的特点，可以采用「拓扑排序」的方式求单源最短路，使得时间复杂度仅为线性的 $O(|V|+|E|)$ 。</p><p><strong>有向无圈图</strong> 一定存在拓扑排序，从一个入度为 0 的源点 $s$ 开始以拓扑排序方式实现 Dijkstra 算法。具体而言，准备一个普通队列 $q$ ，首先将 $s$ 入队，然后开始 $while(!q.isEmpty())$ 。每次将入度为 0 的顶点 $u$ 出队，由于其已无入边，故该顶点距离 $du$ 不会再被更新，此时 $du$ 即已为确定的最短距离。标准的 Dijkstra 算法总是通过这样的操作来确定一个顶点的距离，即「在当前距离未确定的顶点中寻找距离最小者，并置其距离为已确定」，所以也可以将 DAG 情形的算法看作是省去了上述关键操作的 Dijkstra 算法，也就是顶点 $u$  <strong>入队</strong> 时其距离即确定。</p><br /><h5 id="有负边的-DAG"><a href="#有负边的-DAG" class="headerlink" title="有负边的 DAG"></a>有负边的 DAG</h5><p>DAG版的 Dijkstra 算法 <strong>可应用于有负边的DAG。</strong> 因为对任意顶点 $u$ ，仅在其入度减为 0 时其距离才被确定，而此时来自其入边的松弛一定都已执行过，因此 $u$ 是否存在负权值的入边，$du$ 都可以被正确松弛到最短。以下图为例，从 $s$ 开始执行算法，$s$ 出队，$du$ 和 $dv$ 被更新为 1 和 2 ，然后 $u, v$ 入度减为 1, 0，$v$ 无入边，其距离不会再被更新，即 $dv &#x3D; 2$ 即为 $v$ 的最终距离，$v$ 入队。接着 $v$ 出队，$du$ 被更新为 -1 ，$u$ 的入度减为 0，此时 $u$ 无入边，其距离不会再被更新，即其距离被最终确定为 $du &#x3D; -1$ 。可以看到 $u$ 的距离 <strong>在其入度减至 0 的过程中总会更新至最短</strong> 。</p><p><img src="https://pic.leetcode-cn.com/1655208750-gqyCdb-image.png" alt="image.png"></p><br /><h5 id="贪心-amp-动态规划"><a href="#贪心-amp-动态规划" class="headerlink" title="贪心 &amp; 动态规划"></a>贪心 &amp; 动态规划</h5><p>这个小部分是我的一点思考🤔，与读者们探讨一下 Dijkstra 和 DAG 拓扑排序式的 SSSP 算法所分别体现的「贪心」和「动态规划」思想。</p><p>我们已经知道，无论是一般的 Dijkstra 还是本节的 DAG 上的 SSSP 算法，在求顶点 $v$ 的距离时，本质上都是通过这样的「动态规划」式的递推式求解的， $(u, v)$ 是所有 $v$ 的入边。</p><p>$$dv &#x3D; min{dv, du + |(u, v)|}, (u, v) ∈ E$$</p><p>主要区别在于，在 Dijkstra 中，我们不必 <strong>「全部算完」</strong> 所有入边带来的松弛，而是在 $dv$ 为当前未确定距离顶点中最小时，就「提前」确定了距离。因此它既是「动态规划」，又因为这个「提前」确定的特点，更多地被人强调为「贪心」。而本节 DAG 的 SSSP 算法，一定会计算所有入边的松弛，因此他更具有典型的「打表」式的「动态规划」特点。这大概是 Dijkstra 总与「贪心」相联系而不太被人指出其「动态规划」的特点的原因？</p><br /><h5 id="算法过程-6"><a href="#算法过程-6" class="headerlink" title="算法过程"></a>算法过程</h5><ol><li>建图及初始化。<ol><li>设置一个大小为 $|V|$ 的入度数组 $indegrees[]$ ，下标表示顶点。</li><li>构建带权图并同时计算入度。</li><li>设置一个队列 $q$ 。</li><li>设置一个大小为 $|V|$ 的距离数组 $dists[]$ ，下标表示顶点。初始化所有顶点到源点 $s$ 的距离为 $Infinity$ ，表示该顶点到 $s$ 的距离尚未确定。</li><li>置 $s$ 到其自身距离为 0。</li><li>$s$ 入队。</li></ol></li><li>通过 $while(!q.isEmpty())$ 不断将当前入度为 0 的顶点出队，出队时置其距离已确定。</li><li>松弛操作。尝试松弛 $u$ 的所有 <strong>距离未确定的</strong> 邻接顶点 $v$ 的距离 $dv$。即 $dv &#x3D; min{dv, du + |(u,v)|}$ 。若需要求完整路径，可在松弛的同时更新 $v$ 的前驱为 $u$。</li><li>将上述 $v$ 的入度减 1，并考察是否减至 0，若减至 0，则 $v$ 的距离在此时确定， $v$ 入队。</li><li>循环结束时，每个顶点到源点的最短路径距离被求出。</li></ol><br /><h5 id="时空复杂度-9"><a href="#时空复杂度-9" class="headerlink" title="时空复杂度"></a>时空复杂度</h5><p>时间复杂度：即拓扑排序的时间复杂度，为线性时间复杂度 $O(|V|+|E|)$ 。</p><p>空间复杂度：存图空间 $O(|V|+|E|)$ ， $visited&#x2F;dists$ 空间 $O(|V|)$， $q$ 空间 $O(|V|)$ 。总体为线性空间复杂度 $O(|V|+|E|)$ 。</p><br /><h5 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h5><p>如下是假设 <a href="https://leetcode.cn/problems/network-delay-time/">743. 网络延迟时间</a> 的输入为无圈图的前提下的代码。但实际部分测试用例是有圈的，测试了一下只能过 15 个用例，然后就碰到有圈图了。等找到合适的输入限制为 DAG 图的题之后再更新。总之，DAG 上「拓扑排序」式的 SSSP 算法，或者干脆称 DAG 版的 Dijkstra 算法的写法如下。如果我们确定输入为 DAG，则应该优先考虑此版本算法， <strong>以获得线性时间复杂度</strong> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">networkDelayTime</span><span class="params">(<span class="type">int</span>[][] times, <span class="type">int</span> n, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">        List&lt;List&lt;<span class="type">int</span>[]&gt;&gt; graph = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span>[] indegrees = <span class="keyword">new</span> <span class="title class_">int</span>[n]; <span class="comment">// 入度信息</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) graph.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] edge : times)&#123; <span class="comment">// 建带权图 &amp; 计算入度</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> edge[<span class="number">0</span>] - <span class="number">1</span>, v = edge[<span class="number">1</span>] - <span class="number">1</span>, weight = edge[<span class="number">2</span>];</span><br><span class="line">            graph.get(u).add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;v, weight&#125;);</span><br><span class="line">            indegrees[v]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>, INF = Integer.MAX_VALUE; <span class="comment">// max为距离源点最远顶点的距离，INF为所有顶点距离初始值</span></span><br><span class="line">        <span class="type">int</span>[] dists = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Arrays.fill(dists, INF); <span class="comment">// 距离初始化</span></span><br><span class="line">        dists[k - <span class="number">1</span>] = <span class="number">0</span>; <span class="comment">// 源点距离置0</span></span><br><span class="line">        Queue&lt;Integer&gt; q = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;(); </span><br><span class="line">        q.add(k - <span class="number">1</span>); <span class="comment">// 源点入队</span></span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty()) &#123; <span class="comment">// 拓扑排序过程</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> q.remove();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span>[] v_weight : graph.get(u)) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> v_weight[<span class="number">0</span>], weight = v_weight[<span class="number">1</span>];</span><br><span class="line">                <span class="type">int</span> <span class="variable">dv</span> <span class="operator">=</span> dists[u] + weight;</span><br><span class="line">                <span class="keyword">if</span>(dv &lt; dists[v]) &#123; <span class="comment">// 松弛条件</span></span><br><span class="line">                    dists[v] = dv; <span class="comment">// 更新dv</span></span><br><span class="line">                &#125;</span><br><span class="line">                indegrees[v]--; <span class="comment">// v入度减1</span></span><br><span class="line">                <span class="keyword">if</span>(indegrees[v] == <span class="number">0</span>) q.add(v); <span class="comment">// v入队</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> dist : dists)&#123; <span class="comment">// 找最短路长度最大者</span></span><br><span class="line">            <span class="keyword">if</span>(dist == INF) <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 存在距离未更新的顶点</span></span><br><span class="line">            <span class="keyword">if</span>(dist &gt; max) max = dist;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h4 id="Bellman-Ford"><a href="#Bellman-Ford" class="headerlink" title="Bellman-Ford"></a>Bellman-Ford</h4><p>之前我们指出，Dijkstra 算法因其「贪心」的特点，在还未穷尽顶点所有入边的松弛时就「过早地」确定了该顶点的距离，导致其无法处理具有负边的图。与之相对地， DAG 最短路算法中，通过「入度」信息， <strong>确保了任意顶点一定能够穷尽所有入边的松弛</strong> ，因此可以适用于有负边的图 (DAG) ，但为了确保入度能减至 0 ，要求图不能有圈。我们自然会想，有没有什么办法能够结合二者的优点，使得最短路算法能够同时处理有圈且有负边的图呢？答案是肯定的，只要我们通过某种方式，在不借助入度的情况下保证所有顶点都能够执行其所有入边的松弛，就可以实现上述要求。本节介绍的 Bellman-Ford 算法就是具有这样特点的最短路算法。</p><p>本节中我会给出叙述式的 Bellman-Ford 算法正确性证明 (说明)，并展示其「动态规划」的本质。为了能够更好地理解算法过程，在「实例说明」中展示算法运行的详细过程。在「负边图 &amp; 负圈图」一节中说明该算法能够处理负边图以及不能够处理负圈图的原因。</p><p>在「代码」中，我们仍旧通过 <a href="https://leetcode.cn/problems/network-delay-time/">743. 网络延迟时间</a> 一题来展示 Bellman-Ford 的写法。</p><blockquote><p>Bellman-Ford 在1950年代中后期被多个学者独立发明，以至于在算法冠名权上有些争议。Jeff Erickson 在他的 <em>Algorithms</em> 一书的 8.7 节开头，做了如下介绍。</p><p>The simplest implementation of Ford’s generic shortest-path algorithm was first sketched by Alfonso Shimbel in 1954, described in more detail by Edward Moore in 1957, and independently rediscovered by Max Woodbury and George Dantzig in 1957, by Richard Bellman in 1958, and by George Minty in 1958. (Neither Woodbury and Dantzig nor Minty published their algorithms.) In full compliance with Stigler’s Law, the algorithm is almost universally known as <strong>Bellman-Ford</strong>, because Bellman explicitly used Ford’s 1956 formulation of relaxing edges, although some authors refer to “Bellman-Kalaba” and a few early sources refer to “Bellman-Shimbel”.</p><p>于是 Jeff Erickson 干脆十分公允地写道:</p><p>The Shimbel &#x2F; Moore &#x2F; Woodbury-Dantzig &#x2F; Bellman-Ford &#x2F; Kalaba &#x2F; Minty &#x2F; Brosh algorithm can be summarized in one line:</p><p>Bellman-Ford: Relax <strong>ALL</strong> the tense edges, then recurse.</p></blockquote><br /><h5 id="算法描述-7"><a href="#算法描述-7" class="headerlink" title="算法描述"></a>算法描述</h5><p><a href="https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm">Bellman-Ford Algorithm(贝尔曼-福特算法)</a>: 与 Dijkstra 算法的相同点是对边 (或者说对顶点) <strong>不断执行松弛操作</strong> ，以逐渐得到所有顶点到源点的最短距离。Dijkstra 每次循环「贪心地」完成 <strong>一个</strong> 顶点最短路径的确定，而 BF 算法则对图的 <strong>所有边</strong> ( $|E|$ 条边) ，简单地进行 $|V|-1$ 次 <strong>全量松弛操作</strong> ，第 $i$ 次「全量松弛」使得位于第 $i+1$ 层的顶点的距离被确定。从一次全量松弛确定一层顶点距离这个角度上来说， BF 算法也是「贪心」思想的应用。任意顶点最多居于第 $|V|$ 层 (以源点 $s$ 为第 1 层)，因此算法结束时，保证 (无负圈图) 所有顶点距离最短。</p><p>※ 实际上任何最短路算法都无法求出「负圈图」的最短路，因为通过在负圈上不断绕圈，路径长度可以无限小，也就是 <strong>负圈上的顶点不存在「最短路」</strong> 。后面我们将看到，虽无法给出负圈图的最短路结果 (因为本来就没有)，但 <strong>BF 算法能够判断图是否存在负圈</strong> 。</p><p>※ 作者看过一些资料称全量松弛次数为 $|V|$ 次，这是不够严谨的，只需 $|V| - 1$ 次即可。</p><br /><h5 id="算法过程-7"><a href="#算法过程-7" class="headerlink" title="算法过程"></a>算法过程</h5><ol><li>建图及初始化。<ol><li>构建带权图。</li><li>设置一个大小为 $|V|$ 的距离数组 $dists[]$ ，下标表示顶点。初始化所有顶点到源点 $s$ 的距离为 $Infinity$ ，表示该顶点到 $s$ 的距离尚未确定。</li><li>设置一个 $finished$ 布尔变量用于实现「提前结束优化」(不是必须的)。</li><li>置 $s$ 到其自身距离为 0。</li></ol></li><li>外层循环执行  $|V|-1$ 次，每一次都 <strong>「松弛所有边」</strong> 。<ol><li><p>进入外层循环后按顶点顺序依次对所有顶点 $u$ 考察其所有邻接顶点 $v$ 是否有 $du + |(u, v)| &lt; dv$，若有，松弛之，即令 $dv &#x3D; du + |(u, v)|$。同时置 $finished &#x3D; false$ ，表示松弛未结束。若需要求完整路径，可在松弛的同时更新 $v$ 的前驱为 $u$。</p></li><li><p>在一次「松弛所有边」的操作中，若没有任何边被松弛，表明所有可能的松弛已完成 (负圈图除外)， 此时可 <strong>「提前」退出最外层循环</strong> 。</p></li></ol></li><li>外层循环结束时，(若无负圈) 每个顶点到源点的最短路径距离被求出。</li><li>检查图是否有负圈。再次对所有边执行松弛操作， <strong>若有边可被松弛，则有负圈</strong> ，结束程序，否则正常结束，所有顶点最短路径被求出。</li></ol><br /><h5 id="正确性证明-说明"><a href="#正确性证明-说明" class="headerlink" title="正确性证明 (说明)"></a>正确性证明 (说明)</h5><ol><li><p>已知若一个顶点 $v$ 的所有入边若完成了所有可能的松弛 (一条入边可被多次松弛)，则在 <strong>最后一次松弛</strong> 后，必有 $dv&#x3D;δv$ 。 ($dv$ 表示由算法得到的 $v$ 的距离， $δv$ 表示实际的 $v$ 的最短距离)。</p></li><li><p>易知，第 $i$ 次全量松弛，第 $i$ 层顶点的出边 <strong>必被松弛</strong> 。例如第 1 次全量松弛，$s$ (第 1 层顶点) 的出边必被松弛。第 2 次全量松弛，由于有了第 1 次全量松弛的结果，第 2 层顶点 ($s$ 的邻接顶点) 的出边必被松弛。</p></li><li><p>$|edges(s, v)|$ 表示 $s$ 到 $v$ 的路径的边数，最多为 $|V|-1$ ，当 $s$ 到 $v$ 为链状时为 $|V|-1$  。当 $v$ 的入边是第 1 层入边时，将在第 1 次全量松弛时被松弛，若是第 2 层入边，则会在第 2 次全量松弛时被松弛 (这条入边的发出顶点在第 1 次全量松弛时已被松弛)，以此类推，第 $i$ 层入边会在第 $i$ 次全量松弛时被松弛。所有顶点的入边组成了该图的所有边，任意一边一定是某一层次的入边 (可以同时属于多个层次) 。</p></li><li><p>由此，$v$ 的入边能否被全部松弛只取决于其最深的入边能否被松弛 (当一条入边属于多个层次时，取其最深层次)，也即取决于 $s$ 到 $v$ 的最长路径 $\max{|edges(s, v)|, v ∈ V}$ 的边数。如前述，  $\max{|edges(s, v)|, v ∈ V} ≤ |V|-1$ ，故至多经过 $|V| - 1$ 次全量松弛， <strong>图的所有入边必定都松弛过且完成了所有可能的松弛</strong>  (某条入边属于多个层次时，可能经过多次松弛) 。如果把图看成以 $s$ 为根的树，也可以说为了求得所有顶点的最短路径，所需的全量松弛的次数取决于 <strong>树的高度</strong> 。对某一顶点，可以说该顶点至多经过其 <strong>最大深度减 1 次</strong> 全量松弛后取得最短路径。</p></li><li><p>上述过程对任意顶点均成立，故 BF 算法正确性得证。</p></li></ol><p>此证明也可以看作如下「动态规划」过程。为单串 $O(1)$ 依赖动态规划 (「 $O(1)$ 依赖」指当前元素的更新只依赖常数个元素)。</p><ol><li><p>定义: $dp[j]$ 表示源点 $s$ 到顶点 $j$ 的最短路径长度。</p></li><li><p>边界: $dp[s] &#x3D; 0$ 。</p></li><li><p>递推: $dp[j] &#x3D; dp[j - 1] + |(j - 1, j)|$ 。$j - 1$ 表示 $s-j$ 最短路径上的前一个顶点。</p></li></ol><p>根据前述，$j - 1$ 顶点最大层深必比 $j$ 小 1，故 $dp[j - 1]$ 一定在求 $dp[j]$ 之前就已求出，递推式成立。</p><br /><h5 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h5><p>以下实际考察 BF 算法对下图的求解过程，重点关注顶点 $v$ 。 (图裂了的话可以看<a href="https://tva1.sinaimg.cn/large/008i3skNly1gyelpsd4sfj30f60cqdga.jpg">这里</a>)</p><p><img src="https://pic.leetcode-cn.com/1655273524-wroqDD-image.png" alt="image.png"></p><p>$p(s, v)$ 有如下四种可能：</p><p>$p1: s &gt; v ，|p1| &#x3D; 15$ ，$(s, v)$ 是 $v$ 的第 1 层入边</p><p>$p2: s &gt; a &gt; v，|p2| &#x3D; 14$ ，$(a, v)$ 是 $v$ 的第 2 层入边</p><p>$p3: s &gt; b &gt; a &gt; v ，|p3| &#x3D; 12$ ，$(a, v)$ 是 $v$ 的第 3 层入边</p><p>$p4: s &gt; b &gt; c &gt; v ，|p4| &#x3D; 6$ ，$(c, v)$ 是 $v$ 的第 3 层入边</p><p>可以看到 $(a, v)$ 边同时属于 $v$ 的第 2 和第 3 层入边。这四条路径最长者长 3 (指边数，$p3$ 和 $p4$ )，根据上述分析，只需要执行 3 次全量松弛即可完成对 $v$ 最短路径的确定。又因为源点到所有顶点的所有路径中最长的长度也是 3，所以执行 3 次全量松弛可以确定所有顶点的最短路径。假设全量松弛时顶点的处理顺序为 $s, a, c, b, v$ ，下表展示算法对该图的运行过程 (第 3 次之后的全量松弛不会再松弛任何边，省略)。</p><table><thead><tr><th>松弛过程</th><th>$ds$</th><th>$da$</th><th>$dc$</th><th>$db$</th><th>$dv$</th></tr></thead><tbody><tr><td>初始</td><td><strong>0 (*)</strong></td><td>∞</td><td>∞</td><td>∞</td><td>∞</td></tr><tr><td>第1次全量松弛</td><td>0</td><td><strong>∞ &gt; 9</strong></td><td>∞</td><td><strong>∞ &gt; 3 (*)</strong></td><td><strong>∞ &gt; 15</strong></td></tr><tr><td>第2次全量松弛</td><td>0</td><td><strong>9 &gt; 7 (*)</strong></td><td><strong>∞ &gt; 5 (*)</strong></td><td>3</td><td><strong>15 &gt; 14</strong></td></tr><tr><td>第3次全量松弛</td><td>0</td><td>7</td><td>5</td><td>3</td><td><strong>14 &gt; 12 &gt; 6 (*)</strong></td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">备注：</span><br><span class="line">1. 初始时令 ds 为0，(*)表示已取得该顶点最短路径。</span><br><span class="line">2. 第1次。(s, a), (s,b), (s, v)属于第1层入边，被松弛。</span><br><span class="line">   且b只有一条入边，即经过这趟松弛操作，使得 db = δb。</span><br><span class="line">3. 第2次。第1层入边不会再被松弛。第2层入边(a, v), (b, a), (b, c)被松弛。</span><br><span class="line">   经过这趟松弛操作，a, c的全部入边松弛完毕，使得 da = δa，dc = δc。</span><br><span class="line">4. 第3次。第1，2层入边不会再被松弛，第3层入边(a, v), (c, v)被松弛。</span><br><span class="line">   v 的全部入边松弛完毕，使得 dv = δv。</span><br></pre></td></tr></table></figure><br /><h5 id="负边图-amp-负圈图"><a href="#负边图-amp-负圈图" class="headerlink" title="负边图 &amp; 负圈图"></a>负边图 &amp; 负圈图</h5><ul><li><p>负边图。由于该算法在 $|V|-1$ 次对所有边的松弛操作中会穷尽所有边被松弛的可能，类似以拓扑排序方式针对 DAG 图的 Dijkstra 算法 (通过入度为 0 保证穷尽所有松弛的可能)，所以也适用于有负边的图。</p></li><li><p>负圈图。当图存在负圈时，$s$ 到圈上任意顶点的距离都可以通过不断绕圈趋于无限小。因此若不能保证输入的图无负圈，可以在 $|V| - 1$ 次全量松弛后再执行一次全量松弛，若仍有边可被松弛，说明存在负圈。</p></li></ul><br /><h5 id="提前结束优化"><a href="#提前结束优化" class="headerlink" title="提前结束优化"></a>提前结束优化</h5><p>当某一次全量松弛过程中没有边被松弛，说明所有可能的松弛已被穷尽，可提前结束程序。</p><br /><h5 id="最坏情形"><a href="#最坏情形" class="headerlink" title="最坏情形"></a>最坏情形</h5><p>当图中存在两点间路径长度为 $|V|-1$ ，且在最后一次「全量松弛」时仍有边被松弛时间达到最坏情形。此情况下，需要对所有边执行 $|V|-1$ 次松弛后才能求得所有顶点的最短路径。对于一链状图 $s &gt; a &gt; b &gt; c &gt; v$ ，其中 $|(s, a)| &#x3D; 1$，$|(a, b)| &#x3D; 2$，$|(b, c)| &#x3D; 3$，$|(c, v)| &#x3D; 4$。 (图裂了的话可以看<a href="https://tva1.sinaimg.cn/large/008i3skNgy1gxekg5u1idj30ts04i0sz.jpg">这里</a>)</p><p><img src="https://pic.leetcode-cn.com/1655273767-xzliNL-image.png" alt="image.png"></p><br /><h5 id="时空复杂度-10"><a href="#时空复杂度-10" class="headerlink" title="时空复杂度"></a>时空复杂度</h5><p>时间复杂度：每次全量松弛要操作 $|E|$ 条边，共 $|V|-1$ 次，复杂度为 $O((|V|-1)|E|)$ ，即 $O(|V||E|)$  。</p><p>空间复杂度：存图空间 $O(|V|+|E|)$ ， $dists$ 空间 $O(|V|)$。总体为线性空间复杂度 $O(|V|+|E|)$ 。</p><br /><h5 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h5><p>如下是 <a href="https://leetcode.cn/problems/network-delay-time/">743. 网络延迟时间</a> 的 Bellman-Ford 解法。代码中设置了 $finished$ 布尔变量实现「提前结束优化」，并在通过在外层 $for$ 结束后再执行一次全量松弛实现「负圈检测」，由于本题已保证了不存在负值边，也就不存在负圈，因此负圈检测可以省略。</p><p>此代码是 Bellman-Ford 算法的较为普遍的写法 (提前结束优化 + 负圈检测)，读者应熟练掌握。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 提前退出优化 Bellman-Ford ，带「负圈检测」</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">networkDelayTime</span><span class="params">(<span class="type">int</span>[][] times, <span class="type">int</span> n, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">        List&lt;List&lt;<span class="type">int</span>[]&gt;&gt; graph = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) graph.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] edge : times)&#123; <span class="comment">// 建带权图</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> edge[<span class="number">0</span>] - <span class="number">1</span>, v = edge[<span class="number">1</span>] - <span class="number">1</span>, weight = edge[<span class="number">2</span>];</span><br><span class="line">            graph.get(u).add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;v, weight&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>, INF = Integer.MAX_VALUE; <span class="comment">// max为距离源点最远顶点的距离，INF为所有顶点距离初始值</span></span><br><span class="line">        <span class="type">int</span>[] dists = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Arrays.fill(dists, INF); <span class="comment">// 距离初始化</span></span><br><span class="line">        dists[k - <span class="number">1</span>] = <span class="number">0</span>; <span class="comment">// 源点距离置0</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">finished</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123; <span class="comment">// |V| - 1次 </span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> <span class="number">0</span>; u &lt; n; u++) &#123; <span class="comment">// 全量松弛</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span>[] v_weight : graph.get(u))&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> v_weight[<span class="number">0</span>], weight = v_weight[<span class="number">1</span>];</span><br><span class="line">                    <span class="type">long</span> <span class="variable">dv</span> <span class="operator">=</span> (<span class="type">long</span>) dists[u] + (<span class="type">long</span>) weight; <span class="comment">// 等号右边可能会溢出，临时转为long</span></span><br><span class="line">                    <span class="keyword">if</span>(dv &lt; dists[v]) &#123; <span class="comment">// 松弛条件</span></span><br><span class="line">                        dists[v] = (<span class="type">int</span>) dv; <span class="comment">// 更新dv</span></span><br><span class="line">                        finished = <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(finished) <span class="keyword">break</span>; <span class="comment">// 某一次全量松弛未松弛任何边时，提前结束</span></span><br><span class="line">            <span class="keyword">else</span> finished = <span class="literal">true</span>; <span class="comment">// 否则finished置回true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 负圈检测</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> <span class="number">0</span>; u &lt; n; u++) &#123; <span class="comment">// 执行一次全量松弛</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span>[] v_weight : graph.get(u))&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> v_weight[<span class="number">0</span>], weight = v_weight[<span class="number">1</span>];</span><br><span class="line">                <span class="type">long</span> <span class="variable">dv</span> <span class="operator">=</span> (<span class="type">long</span>) dists[u] + (<span class="type">long</span>) weight; <span class="comment">// 等号右边可能会溢出，临时转为long</span></span><br><span class="line">                <span class="keyword">if</span>(dv &lt; dists[v]) &#123; <span class="comment">// 发现仍能松弛，表明存在负圈</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;Negtive Cycle Found!&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> dist : dists)&#123; <span class="comment">// 找最短路长度最大者</span></span><br><span class="line">            <span class="keyword">if</span>(dist == INF) <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 存在距离未更新的顶点</span></span><br><span class="line">            <span class="keyword">if</span>(dist &gt; max) max = dist;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h4 id="SPFA-BFM"><a href="#SPFA-BFM" class="headerlink" title="SPFA (BFM)"></a>SPFA (BFM)</h4><p>学习 Bellman-Ford 时我们隐隐感觉到「全量松弛」做了许多无意义的松弛尝试，自然地，我们想能否优化松弛次数，在保证穷尽顶点所有入边松弛这一前提下，尽量少地松弛呢？或者干脆说，我们希望所有的松弛，都是有效松弛，也就是顶点所有入边的松弛是无遗漏且不重复的。本节中，我们将看到 SPFA (BFM) 算法在 BF 的基础上是如何借助队列轻松地实现这一改进的。</p><blockquote><p>BFM 即 Bellman-Ford-Moore，这一改进由 Edward F. Moore 他于1959 年发表的 <a href="https://mathscinet.ams.org/mathscinet-getitem?mr=0114710"><em>The shortest path through a maze</em></a> 论文中提出。1994年，西南交通大学的段凡丁在该年4月的《西南交通大学学报》里发表了题为<a href="https://link.zhihu.com/?target=https://xueshu.baidu.com/usercenter/paper/show?paperid=39798c8bf2d1b5236cdaae3152d490ed&site=xueshu_se">关于最短路径的SPFA快速算法</a> 的论文，<strong>重新提出了Moore的改进</strong> ，并且给了个比较通俗的名字 Shortest Path Fast Algorithm。</p></blockquote><br /><h5 id="算法描述-8"><a href="#算法描述-8" class="headerlink" title="算法描述"></a>算法描述</h5><p><a href="https://en.wikipedia.org/wiki/Shortest_Path_Faster_Algorithm">SPFA算法(最短路径快速算法)</a>：SPFA 算法是对 BF 算法的一种改进。在BF 算法的说明中我们指出，第 $i$ 次「全量松弛」操作，只有第 $i+1$ 层的顶点距离会被更新至最短，也就是说每次全量松弛中，有效的松弛都是「一层」顶点，这明显地具有 $bfs$ 特点，因此可以考虑不通过「全量松弛」来松弛第 $i+1$ 层顶点，而是以 $bfs$ 的方式，借助队列 $q$ ，每松弛一层顶点，将它们入队，出队时，尝试松弛到其所有邻接顶点的距离，即可在第 $i$ 层顶点出队时松弛第 $i+1$ 顶点并使这些第 $i+1$ 顶点距离取得最小。因为顶点「按层」入队出队，层深最大为 $|V|$ (无负圈图)，因此算法可以结束。</p><p>我们还可以这样看，一个顶点 $v$ 的距离能够被更新，隐含着这样一个 <strong>前提</strong> ：$v$ 的前驱 $u$ 的距离被更新过 。因为 $du + |(u, v)| &lt; dv$ 时才会更新 $dv$，而 $|(u, v)|$ 是不变的，初始时 $du$ 和 $dv$ 都是无穷大，所以只有 $du$ 更新 (变小)，$dv$ 才有机会更新 (变小)。从源点出发指向其邻接顶点，对一个连通的有向图，总能遍历所有顶点，每次考察已松弛的顶点 $u$ 是否能松弛其邻接顶点 $v$ ，$v$ 成为已松弛的顶点后再考察是否能松弛 $v$ 的邻接顶点，重复此操作直到「当前已松弛顶点均无法再松弛任何顶点」为止。设置一个队列 $q$，程序开始时置源点s的距离为 0，$s$ 入队。$while$ 对 $q$ 判空，不空时队首顶点 $u$ 出队，松弛其边 (更新 $u$ 的邻接顶点 $v$ 的距离)，根据上述分析，如果 $dv$ 被更新，那它的邻接顶点将 <strong>有机会被更新</strong> ，所以将 $v$ 入队，等待之后出队时尝试松弛 $v$ 的边。 <strong>需要注意的是</strong> ，$v$ 入队前需要检查当前队列中是否已有 $v$ ，若有则无需入队。该检查使得时间复杂度为 $O(|V||E|)$ ， <strong>否则这一复杂度将无法得到保证</strong> 。重复上述过程，当 $q$ 为空时 (无负圈图) 代表所有被更新过距离的顶点，都 <strong>无法再触发其邻接顶点距离的更新</strong> 。也可以说对任意一个顶点 $u$ 来说，$s$ 到 $u$ 的所有路径带来的所有可能的对 $du$ 的更新已被穷尽。程序结束时得到所有顶点到源点的最短路径。</p><br /><h5 id="算法过程-8"><a href="#算法过程-8" class="headerlink" title="算法过程"></a>算法过程</h5><ol><li><p>建图及初始化。</p><ol><li>构建带权图。</li><li>设置一个大小为 $|V|$ 的距离数组 $dists[]$ ，下标表示顶点。初始化所有顶点到源点 $s$ 的距离为 $Infinity$ ，表示该顶点到 $s$ 的距离尚未确定。</li><li>设置一个大小为 $|V|$ 的距离数组 $inCounts[]$ ，下标表示顶点。记录顶点的入队次，用于负圈检测 (不是必须的)。</li><li>设置一个队列 $q$ 。</li><li>置 $s$ 到其自身距离为 0。</li><li>$s$ 入队。</li></ol></li><li><p>通过 $while(!q.isEmpty())$ 不断将队首顶点 $u$ 出队，对 $u$  <strong>尝试松弛其所有邻边</strong> 。</p><ol><li>对顶点 $u$ 考察其所有邻接顶点 $v$ 是否有 $du + |(u, v)| &lt; dv$，若有，松弛之，即令 $dv &#x3D; du + |(u, v)|$。同时考察是否有 <code>inCounts[v] &gt; |V| - 1</code> ，若满足，说明存在负圈，可直接结束程序，否则 <code>inCounts[v]++</code> 。若需要求完整路径，可在松弛的同时更新 $v$ 的前驱为 $u$。</li></ol></li><li><p>$while$ 结束时，(若无负圈) 每个顶点到源点的最短路径距离被求出。</p></li></ol><br /><h5 id="正确性证明-说明-1"><a href="#正确性证明-说明-1" class="headerlink" title="正确性证明 (说明)"></a>正确性证明 (说明)</h5><p>SPFA 算法与 BF 算法的核心内容都在于 <strong>穷尽所有路径带来的所有可能的松弛</strong> 。BF 算法通过 $|V|-1$ 次全量松弛来实现这一点，但第 $i$ 次全量松弛中， <strong>有效松弛</strong> 仅作用于第 $i+1$ 层顶点，其他层深顶点不能够被松弛却还是会被尝试，这就产生了冗余操作。SPFA 算法利用前述顶点的距离能够被松弛的隐含前提， <strong>通过队列来减少松弛的次数</strong> 。第 $i$ 层顶点出队时发生的松弛，效果上相当于 BF 算法外层循环第 $i$ 次对所有边的全量松弛。在连通且无负圈的情况下，按层推进一定能够执行最大层深第 $|V|$ 层，因此该算法是正确的。</p><br /><h5 id="实例说明-1"><a href="#实例说明-1" class="headerlink" title="实例说明"></a>实例说明</h5><p>仍以前一张网络图为例考察 SPFA 算法的求解过程，进一步看清其正确性及 SPFA 与 BF 的关系。</p><p>第 1 层顶点只有 $s$ ，所以第 2 步 $s$ 出队相当于 BF 算法中第 1 次全量松弛。$a,b,v$ 是第 2 层顶点，所以第 3，4，5 步相当于 BF 算法中第 2 次全量松弛。此时 $v,a,c$ 是第 3 层顶点 (根据所在路径层深的不同，一个顶点可以属于不同层) ，所以接下来的第 6，7 相当于 BF 算法中的第 3 次全量松弛。最后一步使得队列为空，结束。</p><table><thead><tr><th>松弛过程</th><th>$ds$</th><th>$da$</th><th>$dc$</th><th>$db$</th><th>$dv$</th><th>队列 $q$</th></tr></thead><tbody><tr><td>1. 初始</td><td><strong>0 (*)</strong></td><td>∞</td><td>∞</td><td>∞</td><td>∞</td><td>s;</td></tr><tr><td>2. s出</td><td>0</td><td><strong>∞ &gt; 9</strong></td><td>∞</td><td><strong>∞ &gt; 3 (*)</strong></td><td><strong>∞ &gt; 15</strong></td><td><strong>a, b, v</strong>;</td></tr><tr><td>3. a出</td><td>0</td><td>9</td><td>∞</td><td>3</td><td><strong>15 &gt; 14</strong></td><td>b, v;</td></tr><tr><td>4. b出</td><td>0</td><td><strong>9 &gt; 7 (*)</strong></td><td><strong>∞ &gt; 5 (*)</strong></td><td>3</td><td>14</td><td>v; <strong>a, c</strong></td></tr><tr><td>5. v出</td><td>0</td><td>7</td><td>5</td><td>3</td><td>14</td><td>a, c;</td></tr><tr><td>6. a出</td><td>0</td><td>7</td><td>5</td><td>3</td><td><strong>14 &gt; 12</strong></td><td>c; <strong>v</strong></td></tr><tr><td>7. c出</td><td>0</td><td>7</td><td>5</td><td>3</td><td><strong>12 &gt; 6 (*)</strong></td><td>v;</td></tr><tr><td>8. v出</td><td>0</td><td>7</td><td>5</td><td>3</td><td>14</td><td>空</td></tr></tbody></table><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1. 初始时令 ds 为0，(*)表示已取得该顶点最短路径。「;」是层的分隔符。</span><br><span class="line">2. s 出队时松弛 (s, a), (s,b), (s, v)。</span><br><span class="line">   且 b 只有一条路径，即经过这趟松弛操作，使得 db = δb。</span><br><span class="line">3. a 出队时松弛 (a, v)，这是 v 的距离第 2 次被松弛。</span><br><span class="line">4. b 出队时松弛 (b, a), (b, c)，a 有两条路径，c 只有一条，</span><br><span class="line">   于是 da = δa，dc = δc。</span><br><span class="line">5. 无可松弛边。</span><br><span class="line">6. a 出队时松弛 (a, v)，这是 v 的距离第 3 次被松弛。</span><br><span class="line">7. c 出队时松弛 (c, v)，这是 v 的距离第 4 次被松弛。</span><br><span class="line">   此时 p(s, v) 所有可能的路径带来的 v 的入边的松弛均已完成，于是 dv = δv 。</span><br><span class="line">8. 无可松弛边，队列空，程序结束。</span><br></pre></td></tr></table></figure><br /><h5 id="负边图-amp-负圈图-1"><a href="#负边图-amp-负圈图-1" class="headerlink" title="负边图 &amp; 负圈图"></a>负边图 &amp; 负圈图</h5><ul><li><p>负边图。<strong>SPFA 能够处理有负权的非负圈图</strong> ，原因与 BF 算法一样，因为算法会处理所有顶点的 <strong>所有入边的松弛</strong> 。</p></li><li><p>负圈图。若图存在负圈，负圈上的顶点将无限循环入队，算法无法结束。</p></li></ul><p><strong>负圈判定：</strong> 记录每个顶点入队的次数，顶点 $v$ 的距离更新后判断当前更新次数是否超过了 $|V|-1$ 次，若超过则说明存在负圈，若不超过则将更新次数加 1。以层为单位追踪顶点入队出队的过程，不难理解无负圈情况下，一个顶点的距离至多被松弛 (顶点入队) $|V|-1$ 次，若超过则说明存在经过该顶点的负圈。</p><p>当图只有一个节点时，要小心处理负圈检测。如下伪代码，次数检测写在次数加一之前可以 <strong>避免单节点图被误判为负圈</strong> 。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if(!q.contains(w)) &#123; // 检查w是否已经在q中</span><br><span class="line">    q.add(w) // 将w加入队列  </span><br><span class="line">    if(w.inCount &gt; |V| - 1) &#123; // 若大于|V|-1则检出负圈</span><br><span class="line">        System.err.println(&quot;存在负圈！&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    else w.inCount++ // 记录入队次数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然也可以调换次数检测和加一的顺序，并把  $&gt; |V| - 1$ 改成  $&gt; |V|$ ，如下，效果相同。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if(!q.contains(w)) &#123; // 检查w是否已经在q中</span><br><span class="line">    q.add(w) // 将w加入队列  </span><br><span class="line">    w.inCount++ // 记录入队次数</span><br><span class="line">    if(w.inCount &gt; |V|) &#123; // 若大于|V|则检出负圈</span><br><span class="line">        System.err.println(&quot;存在负圈！&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h5 id="Bellman-Ford-Moore-和-SPFA"><a href="#Bellman-Ford-Moore-和-SPFA" class="headerlink" title="Bellman-Ford-Moore 和 SPFA"></a>Bellman-Ford-Moore 和 SPFA</h5><p>本节开头我们已经说过，SPFA 实际上应当称作 Bellman-Ford-Moore 算法。根据Wiki词条 <a href="https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm">Bellman-Ford algorithm</a> 的介绍，「对所有的边，简单地松弛 $|V| - 1$ 轮」的朴素 BF 算法在相近的几年里被三个人分别独立发明。只是不知道什么原因算法名称后来定型成了 Bellman-Ford。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1955年 Alfonso Shimbel</span><br><span class="line">1956年 Lester Ford Jr.</span><br><span class="line">1958年 Richard Bellman</span><br></pre></td></tr></table></figure><p>又过了一年，1959年的时候 Edward F. Moore 提出了 BF 算法的一个<a href="https://link.zhihu.com/?target=https://mathscinet.ams.org/mathscinet-getitem?mr=0114710">改进</a>，即前文的伪代码 (SPFA &#x2F; Bellman-Ford-Moore) 。</p><blockquote><p>A variation of the Bellman-Ford algorithm known as <a href="https://en.wikipedia.org/wiki/Shortest_Path_Faster_Algorithm">Shortest Path Faster Algorithm</a>, first described by <a href="https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm#CITEREFMoore1959">Moore (1959)</a>, reduces the number of relaxation steps that need to be performed within each iteration of the algorithm.</p></blockquote><p>1994年，西南交通大学的段凡丁在该年4月的《西南交通大学学报》里发表了题为《<a href="https://link.zhihu.com/?target=https://xueshu.baidu.com/usercenter/paper/show?paperid=39798c8bf2d1b5236cdaae3152d490ed&site=xueshu_se">关于最短路径的SPFA快速算法</a>》的论文，<strong>重新提出了Moore的改进</strong> ，并且给了个比较通俗的名字 Shortest Path Fast Algorithm。段老师显然没看过 Moore 当初的论文，否则不会给出一个错误的复杂度估计（给出的复杂度是 $O(k|E|)$ ）。有意思的是，现在用 Google 搜 SPFA，即便在英文论坛，许多人对这个改进也称之为 SPFA，而非 BFM，可谓是「喧宾夺主」了。</p><br /><h5 id="时空复杂度-11"><a href="#时空复杂度-11" class="headerlink" title="时空复杂度"></a>时空复杂度</h5><p>时间复杂度：$O(|V||E|)$ 。为严谨说明，列出 SPFA 伪代码如下。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SPFA (Bellman-Ford-Moore) 算法伪代码:</span><br><span class="line">1    Queue q</span><br><span class="line">2    q.add(s) // s的距离初始为0, 其他顶点的距离初始为Infinity</span><br><span class="line">3    while(!q.isEmpty())</span><br><span class="line">4        v = q.remove()</span><br><span class="line">5        for (w : v.adjs)  // w是v的邻接顶点</span><br><span class="line">6            if(dv + d(v, w) &lt; dw)</span><br><span class="line">7                dw = dv + d(v, w)</span><br><span class="line">8                if(!q.contains(w)) //检查w是否在当前队列中，不在则入队</span><br><span class="line">9                    q.add(w)</span><br></pre></td></tr></table></figure><p>按层分析很容易得到 SPFA 的复杂度。顶点一层一层地入队出队，一张图最多有 $|V|$ 层 (以 $s$ 为第 1 层)，所以 <strong>按层计</strong> ，任何顶点最多只能入队 $|V| - 1$ 次 (应用第8行入队前检查)。第 1 层顶点个数为 1，其余每层顶点数不会超过 $|V| - 1$ （第8行所保证）。再次强调，虽然一个顶点可能会通过不同的路径重复属于某一层，例如 $s &gt; a &gt; c，s &gt; b &gt; c$ ，$c$ 在第 2 层中出现两次，但有了第 8 行的检查，使得 <strong>一个顶点最多只能在一层顶点里出现一次</strong> 。考虑每层顶点个数小于 $|V|$ ，每层顶点的松弛次数少于 $|E|$ 次，因此复杂度为 $O(|V||E|)$ 。</p><p>第 8 行 <code>if(!q.contains(w))</code> 是SPFA 作为改进 BF 的关键，有必要继续进一步说明为何加了这个检查优化 <strong>不影响结果的正确性</strong> 。假设从 $s$ 经过长度相同的不同路径到达若干个不同顶点，这些顶点都指向 $v$ ，每条路径带来的松弛都能执行到 (BFS 所保证)，只是除了第一次之外不把 $v$ 放入队列。将 $v$ 放入队列的目的是在之后使其邻接顶点 $w$ 有被松弛的机会。对于 $w$ ，来自 $v$ 的松弛机会只需一次即可，所以无需每次都将 $v$ 放入队列中。</p><p>SPFA 每出队第 $i$ 层顶点，使得在最短路径上第 $i+1$ 层的顶点得到松弛。不厌其烦地，SPFA第 $i$ 层顶点出队的效果等同于 BF 第 $i$ 轮对边的全量松弛的效果，比 BF 的操作更有效率的地方在于，SPFA 仅仅松弛它够得着得邻边。BF 暴力地松弛所有边，但有效的只有第 $i+1$ 层，其他更深或更浅的顶点无法松弛，但一律以 <code>if(dv + |(v, w)| &lt; dw)</code> 询问了一次。于是，SPFA 便实现了对顶点的 <strong>「无遗漏且不重复」</strong> 的松弛这一改进。</p><p>空间复杂度：存图空间 $O(|V|+|E|)$ ， $dists&#x2F;inCounts&#x2F;q$ 空间 $O(|V|)$。总体为线性空间复杂度 $O(|V|+|E|)$ 。</p><p>对时间复杂度的分析可以看出，稀疏图中顶点 $v$ 的 $p(s, v)$ 路径平均条数很少，相比 BF，SPFA 实际运行速度会很快，稠密图下则无明显优势。</p><br /><h5 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h5><p>如下是 <a href="https://leetcode.cn/problems/network-delay-time/">743. 网络延迟时间</a> 的 SPFA(BFM) 解法。代码中应用了「负圈检测」，由于本题已保证了不存在负值边，也就不存在负圈，因此负圈检测可以省略。</p><p>此代码是 SPFA 算法的较为普遍的写法 (带负圈检测)，读者应熟练掌握。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPFA(BFM)+负圈检测</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">networkDelayTime</span><span class="params">(<span class="type">int</span>[][] times, <span class="type">int</span> n, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">        List&lt;List&lt;<span class="type">int</span>[]&gt;&gt; graph = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) graph.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] edge : times)&#123; <span class="comment">// 建带权图</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> edge[<span class="number">0</span>] - <span class="number">1</span>, v = edge[<span class="number">1</span>] - <span class="number">1</span>, weight = edge[<span class="number">2</span>];</span><br><span class="line">            graph.get(u).add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;v, weight&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>, INF = Integer.MAX_VALUE; <span class="comment">// max为距离源点最远顶点的距离，INF为所有顶点距离初始值</span></span><br><span class="line">        <span class="type">int</span>[] dists = <span class="keyword">new</span> <span class="title class_">int</span>[n], inCounts = <span class="keyword">new</span> <span class="title class_">int</span>[n]; <span class="comment">// inCounts记录顶点入队次数，用于负圈检测</span></span><br><span class="line">        Arrays.fill(dists, INF); <span class="comment">// 距离初始化</span></span><br><span class="line">        dists[k - <span class="number">1</span>] = <span class="number">0</span>; <span class="comment">// 源点距离置0</span></span><br><span class="line">        Queue&lt;Integer&gt; q = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        q.add(k - <span class="number">1</span>); <span class="comment">// 源点入队</span></span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> q.remove();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span>[] v_weight : graph.get(u))&#123; <span class="comment">// 松弛u的邻接顶点</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> v_weight[<span class="number">0</span>], weight = v_weight[<span class="number">1</span>];</span><br><span class="line">                <span class="type">int</span> <span class="variable">dv</span> <span class="operator">=</span> dists[u] + weight;</span><br><span class="line">                <span class="keyword">if</span>(dv &lt; dists[v])&#123;</span><br><span class="line">                    dists[v] = dv;</span><br><span class="line">                    <span class="keyword">if</span>(!q.contains(v)) &#123; <span class="comment">// 入队的前提是此时v不在q中，否则程序虽正确，但复杂度将不再是O(|V||E|)</span></span><br><span class="line">                        q.add(v);</span><br><span class="line">                        <span class="keyword">if</span>(inCounts[v] &gt; n - <span class="number">1</span>) &#123; <span class="comment">// 负圈检测 (本题不需要)</span></span><br><span class="line">                            System.out.println(<span class="string">&quot;Negtive Cycle Found!&quot;</span>);</span><br><span class="line">                            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> inCounts[v]++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> dist : dists)&#123; <span class="comment">// 找最短路长度最大者</span></span><br><span class="line">            <span class="keyword">if</span>(dist == INF) <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 存在距离未更新的顶点</span></span><br><span class="line">            <span class="keyword">if</span>(dist &gt; max) max = dist;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h3 id="带权全源最短路"><a href="#带权全源最短路" class="headerlink" title="带权全源最短路"></a>带权全源最短路</h3><p>在「带权单源最短路」中，我们介绍了 Dijkstra &#x2F; DAG SSSP (归为特殊 Dijkstra) &#x2F; Bellman-Ford &#x2F; SPFA (BFM) 最短路算法。若想求图上任意两点的距离，在这些算法中将不得不一个个计算，我们不禁会想，有没有什么算法可以一次求解所有顶点对 (all pairs) 的最短路径呢？本节我们介绍的就是这样一种一次性求解所有点对最短距离的算 Floyd-Warshall 算法。</p><blockquote><p>Jeff Erickson 在他的 <em>Algorithms</em> 一书的 9.8 节开头，介绍了 Floyd-Warshall 算法被多人相继独立发明 (发现) 的历史。</p><p>…A difffferent formulation of shortest paths that removes this logarithmic factor was proposed twice in 1962, first by Robert Floyd and later independently by Peter Ingerman, both slightly generalizing an algorithm of Stephen Warshall published earlier in the same year. In fact, Warshall’s algorithm was previously discovered by Bernard Roy in 1959, and the underlying recursion pattern was used by Stephen Kleene in 1951.</p></blockquote><p>除了展示 Floyd-Warshall 算法可用于解决求单源最短路的 <a href="https://leetcode.cn/problems/network-delay-time/">743. 网络延迟时间</a> 一题，我们还会展示更适合用它来求解的全源最短路问题 <a href="https://leetcode.cn/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/">1334. 阈值距离内邻居最少的城市</a> 。</p><br /><h4 id="Floyd-Warshall"><a href="#Floyd-Warshall" class="headerlink" title="Floyd-Warshall"></a>Floyd-Warshall</h4><p><a href="https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm">Floyd-Warshall算法(弗洛伊德算法)</a>: 求解图中任意两点的最短路径的算法。算法以 3 重循环考察任意顶点 $i$ 到任意顶点 $j$ 是否有经过任意顶点 $k$ 的可松弛路径，即对每一个顶点 $k$ (外层循环)，考察是否有 $d(i, k) + d(k, j) &lt; d(i, j)$ ，若有则更新 $d(i, j) &#x3D; d(i, k) + d(k, j)$ 。</p><p>可以这样理解其工作过程。已知确定的任意两点 $i, j$ 间有确定的最短路径 $p(i, j)$ （只要无负圈，必有最短路径，不连通时最短路径长度为 $Infinity$ ），$p(i, j)$ 由多次松弛操作得到。先假设算法是正确的 (详细证明见后述)，那么在 $p(i, j)$ 的最后一次松弛后 (通过顶点 $y$ 松弛)，得到 $p(i, j) &#x3D; p(i, y) + p(y, j)$ 。同理，$p(i, y)$ 和 $p(y, j)$ 是 $p(i, j)$ 的两个部分，它们由之前的松弛操作得到。例如松弛顶点 $x$ 后得到 $p(i, y)$ ，可知 $p(i, y) &#x3D; p(i, x) + p(x, y)$ ，松弛顶点 $z$ 后得到 $p(y, j)$ ，可知 $p(y, j) &#x3D; p(y, z) + p(z, j)$ 。路径 $p(i, j)$ 的构建过程可以一直拆分溯源到某三个相邻顶点的连接。例如在 $p(i, j)$ 上有三个相邻顶点为 $i &gt; a &gt; b$ ，那么在外层循环处理 $a$ ，中层循环处理 $i$ ，内层循环处理 $b$ 时，松弛操作将 $i &gt; a &gt; b$ <strong>「连接起来」</strong>（因为 <strong>最短路径上的任意子路径都是最短的</strong> ，必松弛）。顺着算法执行过程不难看出，算法通过外循环的 $k$ 来连接边，通过不断连接短路径产生长路径，最终增长为完整的最短路径。</p><p>在「正确性证明 (说明)」中我们将进一步透过「动态规划」来把握该算法正确性。</p><br /><h5 id="算法过程-9"><a href="#算法过程-9" class="headerlink" title="算法过程"></a>算法过程</h5><ol><li><p>建图及初始化。</p><ol><li>构建带权图。在 Floyd-Warshall 算法中，以「邻接矩阵」构建带权图是更方便也更普遍的做法。</li><li>设置一个大小为 $|V|<em>|V|$ 的距离矩阵 (二维数组) $dists[][]$ ，下标表示顶点。初始化所有顶点对距离为 $Infinity$ ，表示所有点对间距离尚未确定。若要求输出入境本身，还需设置一个 $|V|</em>|V|$ 大小的路径信息矩阵。</li></ol></li><li><p>外层循环执行  $|V|$ 次， 每次固定顶点 $k$。</p><ol><li><p>中层循环执行 $|V|$ 次，每次固定顶点 $i$ 。</p><ol><li><p>内层循环执行 $|V|$ 次，每次固定顶点 $j$ 。</p><p>考察是否有 $d(i, k) + d(k, j) &lt; d(i, j)$ ，若有，松弛之，即令 $d(i, j) &#x3D; d(i, k) + d(k, j)$ 。若要求输出入境本身，还要对应更新路径信息矩阵。</p></li></ol></li></ol></li><li><p>外层循环结束时，(若无负圈) 所有顶点对的最短路径距离被求出。</p></li><li><p>检查图是否有负圈。再次对所有边执行松弛操作， <strong>若有边可被松弛，则有负圈</strong> ，结束程序，否则正常结束，所有顶点最短路径被求出。</p></li></ol><p>※ 以下展示如何通过路径信息的矩阵 $p$ ，递归地输出路径。</p><p>$p[i] [j]$ 的值是 $k$ ，即 $i$ 经过 $k$ 到 $j$ ，在每次松弛时更新 $k$ 。例如有最短路径 $i &gt; a &gt; b &gt; c &gt; j$ 。程序结束后得到的路径信息矩阵如下。</p><table><thead><tr><th>顶点</th><th>$i$</th><th>$a$</th><th>$b$</th><th>$c$</th><th>$j$</th></tr></thead><tbody><tr><td>$i$</td><td>$null$</td><td>$null$</td><td>$a$</td><td>$null$</td><td>$b$</td></tr><tr><td>$a$</td><td>$null$</td><td>$null$</td><td>$null$</td><td>$null$</td><td>$null$</td></tr><tr><td>$b$</td><td>$null$</td><td>$null$</td><td>$null$</td><td>$null$</td><td>$c$</td></tr><tr><td>$c$</td><td>$null$</td><td>$null$</td><td>$null$</td><td>$null$</td><td>$null$</td></tr><tr><td>$j$</td><td>$null$</td><td>$null$</td><td>$null$</td><td>$null$</td><td>$null$</td></tr></tbody></table><p>利用该矩阵，通过递归即可找到 $i &gt; a &gt; b &gt; c &gt; j$ 。递归过程大致如下，顶点输出顺序即为路径顺序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">i &gt; j, 找到b</span><br><span class="line">  i &gt; b，找到a</span><br><span class="line">    i &gt; a为null，输出i</span><br><span class="line">    a &gt; b为null，输出a</span><br><span class="line">  b &gt; j，找到c</span><br><span class="line">    b &gt; c为null，输出b</span><br><span class="line">    c &gt; j为null，输出c</span><br><span class="line"> 最后输出j</span><br></pre></td></tr></table></figure><br /><h5 id="正确性证明-说明-2"><a href="#正确性证明-说明-2" class="headerlink" title="正确性证明 (说明)"></a>正确性证明 (说明)</h5><p>该算法的 <strong>本质是动态规划</strong> ，以状态转移方程的形式描述如下，其中 $dp[k][i][j]$ 表示 <strong>经过前 $k$ 个顶点的松弛，得到的顶点 $i$ 到顶点 $j$ 的最短路径长度</strong> 。注意第一维的 $k$ 表示 $k$ 个顶点，第二维和第三维表示具体的顶点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 定义: dp[k][i][j] 表示经过前 k 个顶点的松弛，得到的顶点 i 到顶点 j 的最短路径长度。</span><br><span class="line">2. 边界: dp[0][i][j] = Infinity</span><br><span class="line">3. 递推: dp[k][i][j]  = min&#123;dp[k-1][i][j], dp[k-1][i][k]  + dp[k-1][k][j]&#125;</span><br></pre></td></tr></table></figure><p>最短路径 <strong>不经过</strong> 第 $k$ 个顶点 (顶点 $k$ ): $dp[k][i][j] &#x3D; dp[k-1][i][j]$  </p><p>最短路径 <strong>经过</strong> 第 $k$ 个顶点 (顶点 $k$ ):   $dp[k][i][j] &#x3D; dp[k-1][i][k] + dp[k-1][k][j]$   </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// floyd核心伪代码</span></span><br><span class="line"><span class="keyword">for</span>(k : V)</span><br><span class="line">  <span class="keyword">for</span>(i : V)</span><br><span class="line">    <span class="keyword">for</span>(j : V)</span><br><span class="line">      <span class="keyword">if</span>(d(i, k) + d(k, j) &lt; d(i, j))</span><br><span class="line">        d(i, j) = d(i, k) + d(k, j)</span><br></pre></td></tr></table></figure><p>补充说明：已知点 $i, j$ 之间的最短路径为 $p(i, j)$ ，那么 $p(i, j)$ 上的任意两点 $a, c$ 的最短路径确定在 $p(i, j)$ 上。反证法简单可证。假设 $p(i, j)$ 上两点 $a, c$ 之间的最短路径经过一不在 $p(i, j)$ 上的顶点 $b$ ，那 $i, j$ 的最短路径也就不是 $p(i, j)$ ，而是 $p(i, a) + p(a, b) + p(b, c)+ p(c, j)$ 。</p><br /><h5 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h5><p>下面通过一个例子观察 Floyd 算法的动态规划过程，对其正确性可以有更直观的感受。由于算法总是在整张图上进行处理，展示整张图将使过程变得杂乱，因此我们只选取一条 $i$ 到 $j$ 的最短路径，展现该路径的构建过程。由于这条路径是随意选取的，其他所有在图上的 <strong>任意两点</strong> 的路径的构成都是类似的。</p><p>设图 $G$ 中 $i, j$ 间最短路径 $p$ 为  $i &gt; a &gt; b &gt; c &gt; d &gt; e &gt; f &gt; g &gt; h &gt; j$ 。最外层循环对该路径上顶点的处理顺序可以是任意顺序，例如 $b, h, i, g, a, e, j, f, c, d$ (分别标上序号 1, 2, 3, 4, 5, 6, 7, 8, 9, 10，表示外层循环处理的先后顺序)。现在我们以溯源的方式从处理最后一个顶点 $d$ 得到 $d(i, j)$ 开始观察，且只观察程序对上述十个顶点的处理（对其他顶点的处理形成其他路径）。该路径的取得只与三个循环对该路径上的顶点的操作有关，循环对其他顶点的操作不影响结果，因为其他顶点不在该最短路径上，由它们导致的松弛不影响路径 $p$ ，或者说 $p$ 会从若干条 $i$ 到 $j$ 的路径中胜出。</p><p>外层循环处理 $d$ 之后由 $d(i, d) + d(d, j)$ 的结果得到 $i$ 到 $j$ 的最短路径长 $d(i, j)$ ，因此 $d(i, d)$ 和 $d(d, j)$ 此时必是已知的。继续溯源，看看 $d(i, d)$ 和 $d(d, j)$ 是如何得到的。到 $d$ 的路径上 $c$ 是最后被处理的，处理 $c$ 时计算 $d(i, d) &#x3D; d(i, c) + d(c, d)$ ，其中 $d(c, d)$ 是边长，这是程序开始时已知， $d(i, c)$ 需要继续溯源， $d(i, c) &#x3D; d(i, a) + d(a, c)$ ，其中 $d(i, a)$ 是边长， $d(a, c) &#x3D; d(a, b) + d(b, c)$ ， $d(a, b)$ 和 $d(b, c)$ 是边长。其余过程如图，标红处表示相邻的顶点的边长，在程序开始时得到。</p><p>可以看出，外层循环处理 i 到 j 的最短路径的所有顶点的过程中，先处理的顶点得到 <strong>子路径总能够为后处理的顶点构建更长的子路径</strong> ，直到处理 (最短路径上的) 最后一个顶点时，将两个子路径连接起来形成最终的最短路径，这正是动态规划过程的体现。</p><p>不同于 BF 动态规划过程的单串 $O(1)$ 依赖，Floyd 动态规划是单串 <strong>$O(n)$ 依赖</strong> 的。也可以描述为某一次的松弛形成的路径 <strong>不一定直接作用于下一次松弛</strong> ，而是在之后某一次松弛中发生作用。例如处理 $b(1)$ 和处理 $h(2)$ 是外层循环的两次相邻的操作，它们分别产生了两条不相连的子路径 $a&gt;b&gt;c$ 和 $g&gt;h&gt;j$ 。之后外层循环处理 $a(5)$ 时 $a&gt;b&gt;c$ 增长为 $i&gt;a&gt;b&gt;c$ ，处理 $c(9)$ 时增长为 $i&gt;a&gt;b&gt;c&gt;d$ 。 $g&gt;h&gt;j$ 在外层循环处理 $g(4)$ 时增长为 $f&gt;g&gt;h&gt;j$ ，处理 $f(8)$ 时增长为 $d&gt;e&gt;f&gt;g&gt;h&gt;j$  ( $d&gt;e&gt;f$  在外层循环处理 $e(6)$ 时得到)。最终在处理 $d(10)$ 时得到 $i &gt; a &gt; b &gt; c &gt; d &gt; e &gt; f &gt; g &gt; h &gt; j$ 。</p><p><img src="https://pic.leetcode-cn.com/1655284508-aMzIvW-image.png" alt="image.png"></p><p><img src="https://pic.leetcode-cn.com/1654173930-rzqKaj-flyod_demo.gif" alt="flyod_demo.gif"></p><p>总结 Floyd 算法的过程，外层循环执行完第 $k$ 次，给出由 $k+1$ 条边组成的路径，下一次会利用长度为 $1, 2, … , k+1$ 的路径连接出长度为 $k+2$ 的路径。这就好像将任意两点连成单边线（只要这两点之间存在路径），然后再将两条单边线作为零件连成长度为 2 的线，因为具备所有单边线，所以无论长度为 2 的线是由哪些单边线组成的，都可以找到并连起来。然后再利用长度为 1，2 的线作为零件连成长度为 3 的线，因为无论一条长度为 3 的线是如何构成的，构成它的单边线和 2 边线都已具备。以此类推直到连出所有可能长度的线。</p><br /><h5 id="负边图-amp-负圈图-2"><a href="#负边图-amp-负圈图-2" class="headerlink" title="负边图 &amp; 负圈图"></a>负边图 &amp; 负圈图</h5><ul><li><p>负边图。<strong>Floyd-Warshall 能够处理有负权的非负圈图</strong> ，原因与 BF 算法一样，因为算法会处理所有顶点的 <strong>所有入边的松弛</strong> 。</p></li><li><p>负圈图。当图存在负圈时，$s$ 到圈上任意顶点的距离都可以通过不断绕圈趋于无限小。因此若不能保证输入的图无负圈，可以在 3 重循环后再执行一次全量松弛，若仍有边可被松弛，说明存在负圈。</p></li></ul><br /><h5 id="时空复杂度-12"><a href="#时空复杂度-12" class="headerlink" title="时空复杂度"></a>时空复杂度</h5><p>时间复杂度: 3 重循环，$O(|V|^3)$ 。</p><p>空间复杂度: 邻接矩阵、距离矩阵、路径信息矩阵 (若有的话) 均为 $O(|V|^2)$ 。总的空间复杂度为 $O(|V|^2)$ 。</p><br /><h5 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h5><p>如下是 <a href="https://leetcode.cn/problems/network-delay-time/">743. 网络延迟时间</a> 的 Floyd-Warshall 解法。代码中应用了「负圈检测」，由于本题已保证了不存在负值边，也就不存在负圈，因此负圈检测可以省略。另外，此实现采用了 <strong>「邻接矩阵」</strong> 存图。</p><p>此代码是 Floyd-Warshall 算法的较为普遍的写法 (带负圈检测)，读者应熟练掌握。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Floyd-Warshall (带负圈检测)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">networkDelayTime</span><span class="params">(<span class="type">int</span>[][] times, <span class="type">int</span> n, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[][] dists = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>, INF = Integer.MAX_VALUE; <span class="comment">// max为距离源点最远顶点的距离，INF为所有顶点距离初始值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] distRow : dists) Arrays.fill(distRow, INF); <span class="comment">// 距离初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> <span class="number">0</span>; u &lt; n; u++) dists[u][u] = <span class="number">0</span>; <span class="comment">// 顶点到自身距离为0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; times.length; i++)&#123; <span class="comment">// 建图 (邻接矩阵)</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> times[i][<span class="number">0</span>] - <span class="number">1</span>, v = times[i][<span class="number">1</span>] - <span class="number">1</span>, weight = times[i][<span class="number">2</span>];</span><br><span class="line">            dists[u][v] = weight;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k1</span> <span class="operator">=</span> <span class="number">0</span>; k1 &lt; n; k1++) &#123; <span class="comment">// 对所有顶点 k</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123; <span class="comment">// 对所有顶点 i</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++)&#123; <span class="comment">// 对所有顶点 j</span></span><br><span class="line">                    <span class="type">long</span> <span class="variable">ik</span> <span class="operator">=</span> dists[i][k1], kj = dists[k1][j], ij = dists[i][j]; <span class="comment">// 为防止溢出，临时转为 long</span></span><br><span class="line">                    <span class="keyword">if</span>(ik + kj &lt; ij) &#123; <span class="comment">// 松弛条件</span></span><br><span class="line">                        dists[i][j] = (<span class="type">int</span>) (ik + kj);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> dist : dists[k - <span class="number">1</span>])&#123; <span class="comment">// 注意题目为「单源」</span></span><br><span class="line">            <span class="keyword">if</span>(dist == INF) <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 存在距离未更新的顶点</span></span><br><span class="line">            <span class="keyword">if</span>(dist &gt; max) max = dist;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 负圈检测</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> <span class="number">0</span>; u &lt; n; u++) &#123; <span class="comment">// 全量松弛</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> <span class="number">0</span>; v &lt; n; v++)&#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">dv</span> <span class="operator">=</span> (<span class="type">long</span>) dists[k - <span class="number">1</span>][u] + (<span class="type">long</span>) dists[u][v]; <span class="comment">// 等号右边可能会溢出，临时转为long</span></span><br><span class="line">                <span class="keyword">if</span>(dv &lt; dists[k - <span class="number">1</span>][v]) &#123; <span class="comment">// 松弛条件</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;Negtive Cycle Found!&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们展示 Floyd-Warshall 解决 <a href="https://leetcode.cn/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/">1334. 阈值距离内邻居最少的城市</a> 一题的代码如下。该题是典型的「所有点对」最短距离问题。求解过程十分简单。</p><ol><li>应用 Floyd-Warshall 算法求出所有点对间最短距离，存于矩阵 $dists[][]$ 中。</li><li>遍历 $dists$ 矩阵，统计每一个顶点在距离阈值内 (小于等于) 的邻接顶点个数，实时地记录其中最小者。</li><li>因为 $u$ 是从小到大遍历的，若有多个满足要求的顶点，记录的就是编号最大的那一个。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findTheCity</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] edges, <span class="type">int</span> distanceThreshold)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">INF</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span>[][] dists = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] distRow : dists) Arrays.fill(distRow, INF);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> <span class="number">0</span>; u &lt; n; u++) dists[u][u] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] edge : edges)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> edge[<span class="number">0</span>], v = edge[<span class="number">1</span>], weight = edge[<span class="number">2</span>];</span><br><span class="line">            dists[u][v] = weight;</span><br><span class="line">            dists[v][u] = weight;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; n; k++)&#123; <span class="comment">// floyd求出dists</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                    <span class="type">long</span> <span class="variable">ik</span> <span class="operator">=</span> dists[i][k], kj = dists[k][j], ij = ik + kj;</span><br><span class="line">                    <span class="keyword">if</span>(ij &lt; dists[i][j])&#123;</span><br><span class="line">                        dists[i][j] = (<span class="type">int</span>) ij;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>, minCount = n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> <span class="number">0</span>; u &lt; n; u++)&#123; <span class="comment">// 遍历dists寻找答案</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> <span class="number">0</span>; v &lt; n; v++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dists[u][v] &lt;= distanceThreshold) count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(count &lt;= minCount) &#123;</span><br><span class="line">                minCount = count;</span><br><span class="line">                ans = u;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p>总结「最短路径」算法如下。</p><table><thead><tr><th>算法</th><th>时间复杂度</th><th>负边</th><th>正圈</th><th>负圈</th></tr></thead><tbody><tr><td><strong>无权 SSSP</strong></td><td></td><td></td><td></td><td></td></tr><tr><td>● 朴素版</td><td>$O(V^2)$</td><td>-</td><td>Yes</td><td>-</td></tr><tr><td>● 队列版</td><td>$O(V+E)$</td><td>-</td><td>Yes</td><td>-</td></tr><tr><td><strong>带权 SSSP</strong></td><td></td><td></td><td></td><td></td></tr><tr><td>● Dijkstra 朴素版</td><td>$O(V^2)$</td><td>No</td><td>Yes</td><td>No(不可检测)</td></tr><tr><td>● Dijkstra 小顶堆版</td><td>$O(ElogV)$</td><td>No</td><td>Yes</td><td>No(不可检测)</td></tr><tr><td>● Dijkstra DAG</td><td>$O(V+E)$</td><td>Yes</td><td>No (可检测)</td><td>No (可检测)</td></tr><tr><td>● Bellman-Ford</td><td>$O(VE)$</td><td>Yes</td><td>Yes</td><td>No (可检测)</td></tr><tr><td>● SPFA (BFM)</td><td>$O(VE)$</td><td>Yes</td><td>Yes</td><td>No (可检测)</td></tr><tr><td><strong>带权 APSP</strong></td><td></td><td></td><td></td><td></td></tr><tr><td>●x Floyd-Warshall</td><td>$O(V^3)$</td><td>Yes</td><td>Yes</td><td>No (可检测)</td></tr></tbody></table><p>※ 本文未涉及「无权 APSP」，无权图的所有点对最短路可通过对所有顶点执行无权单源最短路算法求得，时间复杂度为 $O((|V|+|E|)*|V|)$ 。对此问题有更多兴趣的读者可参考 <a href="https://math.stackexchange.com/questions/58198/all-pairs-shortest-path-in-undirected-and-unweighted-graphs">All pairs shortest path in undirected and unweighted graphs</a> 。</p><p>※ 空间复杂度主要取决于建图方式，以「邻接矩阵」建图时为 $O(|V|^2)$，以「邻接表」建图时为 $O(|V|+|E|)$ ，表中不再列出。</p><br /><h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><p>在最短路径问题中，研究的是如何找到图中两点的最短路径，当我们将整张图作为对象考虑时，很自然地会想，在图上所有顶点都互相连通的基础上，如何找到最小的总路径和呢？这有点像是 <strong>以图为整体的「最短路径」</strong> 。很容易找到这个问题的现实意义，例如给一个科技园区铺装光纤，要求所有办公楼和厂房都互相连通且尽可能节省光纤用量。办公楼和厂房为图中顶点，互相之间的距离为边权，该场景实际上是要求找到能将所有顶点连通且边权和最小的边集。这个边集就是本节要介绍的 <strong>「最小生成树」</strong> 。</p><p><a href="https://en.wikipedia.ahmu.cf/wiki/Minimum_spanning_tree">最小生成树 ( <em>Minimum Spanning Tree, MST</em> )</a>: 通常指的无向图中的一个边集，该边集使得图中所有顶点互相连通，且边权总和最小。由于此边集构成的子图必然无圈，该子图为一棵树，因此称该边集为「最小生成树」。</p><p>本节讲解求图上 MST 的两种算法:  Prim 和 Kruskal，我们将看到前者几乎和 Dijkstra 一致，而后者只是并查集思想的简单应用。同样，为了在学习这两个算法过程中及时得到反馈，我们将以 <a href="https://leetcode.cn/problems/connecting-cities-with-minimum-cost/">1135. 最低成本联通所有城市</a> 一题作为配套，有了 Dijkstra 和并查集的基础，MST 的学习是十分轻松的。</p><br /><h3 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h3><p>Prim 算法与 Dijkstra 算法无论是从思想还是实际代码表现上都非常类似，在理解了 Dijkstra 的基础上，学习 Prim 几乎没有思考成本。后续我们以一个表格逐行比较二者的内容，读者将发现 <strong>二者最根本的差别只在于顶点距离的更新方法</strong> 。由于有了 Dijkstra 的基础，行文中，我们着重对比二者，对 Prim 算法只做必要的简略讲解。我们仍循前例，先介绍「朴素版」再介绍「优先队列版」。读者务必在阅读本节之前还阅读 Dijkstra 章节。</p><blockquote><p>与之前的几个算法类似，Prim算法也曾被多人在不同时间相继独立发明 (发现) 。Jeff Erickson 在他的 <em>Algorithms</em> 一书的 7.4 节开头，做了如下介绍。</p><p>The next oldest minimum spanning tree algorithm (Prim’s algorithm) was first described by the Czech mathematician Vojtěch Jarník in a 1929 letter to Borůvka; Jarník published his discovery the following year. The algorithm was independently rediscovered by Joseph Kruskal in 1956, (arguably) by Robert Prim in 1957, by Harry Loberman and Arnold Weinberger in 1957, and finally by Edsger Dijkstra in 1958. Prim, Lobermand and Weinberger, and Dijkstra all (eventually) knew of and even cited Kruskal’s paper, but since Kruskal also described two other minimum spanning-tree algorithms in the same paper, <em>this</em> algorithm is usually called “Prim’s algorithm”, or sometimes “the Prim&#x2F;Dijkstra algorithm”, even though by 1958 Dijkstra already had another algorithm (inappropriately) named after him.</p><p>Jeff Erickson 在他的书中几乎只将此算法称为 Jarník 算法，不过本文还是按照流行的说法称为 Prim 算法。</p></blockquote><br /><h4 id="朴素版-2"><a href="#朴素版-2" class="headerlink" title="朴素版"></a>朴素版</h4><h5 id="算法描述-9"><a href="#算法描述-9" class="headerlink" title="算法描述"></a>算法描述</h5><p><a href="https://en.wikipedia.ahmu.cf/wiki/Prim%27s_algorithm">Prim (普里姆算法)</a>:  一种基于贪心思想的求解无向图上 MST 的算法。我们直接将 Prim 算法和 Dijkstra 二者对比如下。</p><table><thead><tr><th>Dijkstra</th><th>Prim</th></tr></thead><tbody><tr><td>贪心算法</td><td>贪心算法</td></tr><tr><td>顶点分为 <strong>距离已确定</strong> 和 <strong>距离未确定</strong> 顶点</td><td>顶点分为 <strong>距离已确定 (已加入生成树)</strong> 和 <strong>距离未确定 (未加入生成树)</strong> 顶点</td></tr><tr><td>所有顶点距离初始化为 $Infinity$</td><td>所有顶点距离初始化为 $Infinity$</td></tr><tr><td>源点 $s$ 的距离初始化为 0</td><td>生成树起始点 $s$ 的距离初始化为 0</td></tr><tr><td>以一个循环寻找 <strong>当前距离未确定顶点中距离最小者</strong> $u$ ，<br />立即置 $u$ 的距离为「已确定」。</td><td>以一个循环寻找 <strong>当前距离未确定顶点中距离最小者</strong> $u$ ，<br />立即置 $u$ 的距离为「已确定」。</td></tr><tr><td>尝试以如下方式更新 (松弛) $u$ 的邻接顶点的距离 <br />$dv &#x3D; min(dv, du + d(u, v))$</td><td>尝试以如下方式更新 $u$ 的邻接顶点的距离 <br />$dv &#x3D; min(dv, d(u,v))$</td></tr><tr><td>$while$ 结束时所有顶点最短路径及其距离被求出</td><td>$while$ 结束时 MST 及其所有边权被求出</td></tr></tbody></table><p>我们看到这两个算法的每一步都几乎相同，不同点主要有三处，最主要的是第 3 点。</p><ol><li>Prim 用于在「无向图」中求 MST，因此建图时要「双向建边」。Dijkstra 应用于有向图时单向建边，应用于无向图时双向建边。</li><li>Dijkstra 中的「距离」指的是顶点到源点的距离。Prim 中的「距离」指的是顶点到其已在生成树上的邻接顶点 (父顶点) 的距离。</li><li><strong>顶点距离更新方式不同</strong> 。</li></ol><br /><h5 id="算法过程-10"><a href="#算法过程-10" class="headerlink" title="算法过程"></a>算法过程</h5><ol><li><p>建图及初始化。</p><ol><li>构建双向带权图。</li><li>设置一个大小为 $|V|$ 的用于标记顶点距离是否「已确定」的 $boolean$ 数组 $visited[]$ ，下标表示顶点。</li><li>设置一个大小为 $|V|$ 的距离数组 $dists[]$ ，下标表示顶点。初始化所有顶点的距离为 $Infinity$ ，表示所有顶点的距离尚未确定。</li><li><strong>任意选取</strong> 一个顶点作为起始顶点，置距离为 0，通常我们将第一个顶点的距离置为 0 。</li></ol></li><li><p>以一个循环寻找 <strong>当前距离未确定顶点中距离最小者</strong> $u$ ，立即置 $u$ 的距离为「已确定」。</p></li><li><p>距离更新。尝试更新 $u$ 的所有 <strong>距离未确定的</strong> 邻接顶点 $v$ 的距离 $dv$。即 $dv &#x3D; min{dv, |(u,v)|}$ 。</p></li><li><p>循环结束时，所有顶点距离被求出，也就是 MST 所有边权被求出。</p></li></ol><br /><h5 id="正确性证明-1"><a href="#正确性证明-1" class="headerlink" title="正确性证明"></a>正确性证明</h5><blockquote><p>如下证明参考了 <a href="https://home.uncg.edu/cmp/faculty/srtate/330/primsproof.pdf">参考1</a> 以及 <a href="https://www.cnblogs.com/sky-view/p/3250972.html">参考2</a>。</p></blockquote><p>虽然 Prim 算法过程与 Dijkstra 类似，但证明过程并不通用。如下是 Prim 算法的证明过程。</p><p>证明：在图 $G$ 上执行 Prim 算法得到的生成树 $S$ 是 MST。</p><ol><li><p>记 $G$ 上的 MST (之一) 是生成树 $S_{min}$，即证明 $|S| &#x3D; |S_{min}|$ ，绝对值表示生成树的边权和。</p></li><li><p>在 $S$ 生长过程中，<strong>首次</strong> 遇到的不属于 $S_{min}$ 的边为 $e&#x3D;(u, v)$ ，$u$ 在此前得到的点集中，$v$ 在剩余的顶点中。从 $S$ 中拿走 $e$ ，则 $S$ 剩下的不连通的两部分分别为包含 $u$ 的子树 $U$ 以及包含 $v$ 的子树 $V$ 。</p></li><li><p>$S_{min}$ 是 MST，其上必存在 $u$ 到 $v$ 的路径，且已知 $u$ 在 $U$ 中，$v$ 在 $V$ 中，由于 $(u,v)∉S_{min}$ ，则必然存在边 $f&#x3D;(a,b)∈S_{min}$ 穿过 $U → V$，即 $a$ 在 $U$ 中， $b$ 在 $V$ 中  (若 $a$ 是 $u$ ，则 $b$ 不是 $v$；若 $b$ 是 $v$，则 $a$ 不是 $u$) 。</p></li><li><p>当 $e$ 即将被加入 $S$ 时，顶点 $a$ 已在 $U$ 中 ( $U$ 是 $S$ 当前生长到的部分)。</p><ol><li>此时 $a$ 是「距离未确定」的顶点。因为如果 $a$ 是距离已确定的顶点，则在 $U$ 中存在一条边 $g$ 连接 $a$ 和另一顶点，我们已经知道 $e$ 是 $S$ 生长过程中 <strong>首次</strong> 遇到的不属于 $S_{min}$ 的边，也就是说 $g∈S_{min}$ ，这与 $f∈S_{min}$ 矛盾，因为 $a$ 一旦「距离确定」，后续就不会考察 $a$ 的连边，$f$ 也就不可能加入 $S_{min}$ 。</li><li>由于 $a$ 是「距离未确定」的顶点，考察顶点 $u$ 的连边时，顶点 $a$ 的连边也一定会被考察。由于 $e$ 在此轮考察中被 Prim 算法选入 $S$ 中，而 $f$ 未被选择，可知 $|e|≤|f|$ 。</li></ol></li><li><p>对于 $S_{min}$ ，断开 $f&#x3D;(a,b)$ ，则 $S_{min}$ 被分成不连通的两棵子树 $A$ 和 $B$，且 $u → a → b → v$ 被断开，说明 $u$ 与 $v$ 分别在不连通的两棵子树 $A, B$ 上。此时连上 $e&#x3D;(u,v)$ 得到的 $S_{AeB}$ 显然是一棵生成树。因为 $|e|≤|f|$ ，则必然有 $|e|&#x3D;|f|$ ， 否则 $S_{AeB}$ 边权之和更小，与 $S_{min}$ 是 MST 矛盾。因此 $|S_{AeB}|&#x3D;|S_{min}|$，即 $S_{AeB}$ 也是 MST。</p></li><li><p>重复上述过程，继续考察 $S$ 中下一条不属于 $S_{min}$ 的边，直到得到 $S$ 。每一次考察，都可以得到上述 5 的结论，最终有 $|S|&#x3D;|S_{min}|$，即 $S$ 是 MST。</p></li></ol><p><img src="https://pic.leetcode-cn.com/1662611819-AcmGHf-image.png" alt="image.png"></p><br /><h5 id="时空复杂度-13"><a href="#时空复杂度-13" class="headerlink" title="时空复杂度"></a>时空复杂度</h5><p>与朴素版 Dijkstra 算法相同，不赘述。</p><p>时间复杂度：$O(|V|^2)$ </p><p>空间复杂度：$O(|V|+|E|)$</p><br /><h5 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h5><p> <a href="https://leetcode.cn/problems/connecting-cities-with-minimum-cost/">1135. 最低成本联通所有城市</a> 一题是非常典型的求 MST 的题目，应用本节的朴素 Prim 解法轻松可解，而且你会发现，只需对 <a href="https://leetcode.cn/problems/network-delay-time/">743. 网络延迟时间</a> 的朴素 Dijkstra 解法做几行修改即可得到此代码。求解时需要注意以下两点。</p><ul><li>构建带权图时要双向建边。</li><li>当存在距离未更新的顶点时说明图不连通时，返回 -1。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumCost</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] connections)</span>&#123;</span><br><span class="line">        List&lt;List&lt;<span class="type">int</span>[]&gt;&gt; graph = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) graph.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] edge : connections)&#123; <span class="comment">// 建带权图</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> edge[<span class="number">0</span>] - <span class="number">1</span>, v = edge[<span class="number">1</span>] - <span class="number">1</span>, weight = edge[<span class="number">2</span>];</span><br><span class="line">            graph.get(u).add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;v, weight&#125;); <span class="comment">// 建边 (u,v)</span></span><br><span class="line">            graph.get(v).add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;u, weight&#125;); <span class="comment">// 建边 (v,u)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>, INF = Integer.MAX_VALUE; <span class="comment">// max为距离源点最远顶点的距离，INF为所有顶点距离初始值</span></span><br><span class="line">        <span class="type">int</span>[] dists = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">        Arrays.fill(dists, INF); <span class="comment">// 距离初始化</span></span><br><span class="line">        dists[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 生成树起始点距离置0 (可任选一个顶点)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// 当前距离未确定顶点中的距离最小者</span></span><br><span class="line">        <span class="keyword">while</span>((u = getMin(dists, visited)) != -<span class="number">1</span>) &#123; <span class="comment">// 遍历顶点，寻找当前距离未确定顶点中的距离最小者</span></span><br><span class="line">            visited[u] = <span class="literal">true</span>; <span class="comment">// 立即置为距离已确定</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span>[] v_weight : graph.get(u)) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> v_weight[<span class="number">0</span>], weight = v_weight[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(!visited[v]) &#123; <span class="comment">// 对于u的距离未确定的邻接顶点v，更新v的距离</span></span><br><span class="line">                    <span class="keyword">if</span>(weight &lt; dists[v]) &#123; <span class="comment">// 更新条件</span></span><br><span class="line">                        dists[v] = weight; <span class="comment">// 更新dv</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> dist : dists)&#123; <span class="comment">// 计算 MST 边权和</span></span><br><span class="line">            <span class="keyword">if</span>(dist == INF) <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 若有不连通的城市，返回 -1</span></span><br><span class="line">            sum += dist;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getMin</span><span class="params">(<span class="type">int</span>[] dists, <span class="type">boolean</span>[] visited)</span>&#123; <span class="comment">// 在当前距离未确定的顶点中找距离最小者</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> dists.length, min = Integer.MAX_VALUE, minVertex = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> <span class="number">0</span>; u &lt; n; u++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[u] &amp;&amp; dists[u] &lt; min) &#123; </span><br><span class="line">                min = dists[u];</span><br><span class="line">                minVertex = u;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minVertex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h4 id="优先队列版-1"><a href="#优先队列版-1" class="headerlink" title="优先队列版"></a>优先队列版</h4><h5 id="算法描述-10"><a href="#算法描述-10" class="headerlink" title="算法描述"></a>算法描述</h5><p>与 Dijkstra 一样，Prim 也可用优先队列 (小顶堆) 优化，内容一致，不赘述。</p><br /><h5 id="算法过程-11"><a href="#算法过程-11" class="headerlink" title="算法过程"></a>算法过程</h5><ol><li>建图及初始化。<ol><li>构建双向带权图。</li><li>设置一个小顶堆 $pq$ 。</li><li>设置一个大小为 $|V|$ 的用于标记顶点距离是否「已确定」的 $boolean$ 数组 $visited[]$ ，下标表示顶点。</li><li>设置一个大小为 $|V|$ 的距离数组 $dists[]$ ，下标表示顶点。初始化所有顶点距离为 $Infinity$ ，表示所有顶点距离尚未确定。</li><li>置任意一个顶点的距离为 0，通常我们将第一个顶点的距离置为 0 。</li><li>上述顶点入堆。</li></ol></li><li>一次出堆完成一个顶点距离的确定，即将该顶点加入 MST。以 $while$ 循环对 $pq$ 判空，若不空，堆顶顶点 $u$ 出堆，此时 $u$ 为距离未确定顶点中距离最小者，置 $u$ 的距离为已确定。</li><li>更新操作。尝试更新 $u$ 的所有 <strong>距离未确定的</strong> 邻接顶点 $v$ 的距离 $dv$。即 $dv &#x3D; min{dv, |(u,v)|}$ 。</li><li>循环结束时，所有顶点距离被求出，也就是 MST 所有边权被求出。</li></ol><br /><h5 id="时空复杂度-14"><a href="#时空复杂度-14" class="headerlink" title="时空复杂度"></a>时空复杂度</h5><p>与优先队列版 Dijkstra 算法相同，不赘述。</p><p>时间复杂度：$O(|E|log|V|)$ </p><p>空间复杂度：$O(|V|+|E|)$</p><p>同样地，当图为 <strong>「稠密图」</strong> 时，采用更优的「朴素版」；当图为 <strong>「稀疏图」</strong> 时，采用更优的「优先队列版」。</p><br /><h5 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h5><p>现在，我们给出如下利用优先队列的 Prim 算法代码来解决 <a href="https://leetcode.cn/problems/connecting-cities-with-minimum-cost/">1135. 最低成本联通所有城市</a> 。同样地，只需对 <a href="https://leetcode.cn/problems/network-delay-time/">743. 网络延迟时间</a> 的优先队列版 Dijkstra 解法做几行修改即可得到此代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumCost</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] connections)</span>&#123;</span><br><span class="line">        List&lt;List&lt;<span class="type">int</span>[]&gt;&gt; graph = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) graph.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] edge : connections)&#123; <span class="comment">// 建带权图</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> edge[<span class="number">0</span>] - <span class="number">1</span>, v = edge[<span class="number">1</span>] - <span class="number">1</span>, weight = edge[<span class="number">2</span>];</span><br><span class="line">            graph.get(u).add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;v, weight&#125;); <span class="comment">// 建边 (u,v)</span></span><br><span class="line">            graph.get(v).add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;u, weight&#125;); <span class="comment">// 建边 (v,u)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>, INF = Integer.MAX_VALUE; <span class="comment">// sum为MST边权和，即本题所求。INF为所有顶点距离初始值。</span></span><br><span class="line">        <span class="type">int</span>[] dists = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">        Arrays.fill(dists, INF); <span class="comment">// 距离初始化</span></span><br><span class="line">        dists[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 生成树起始点距离置0 (可任选一个顶点)</span></span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((u, v) -&gt; u[<span class="number">1</span>] - v[<span class="number">1</span>]); <span class="comment">// 小顶堆</span></span><br><span class="line">        pq.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>, <span class="number">0</span>&#125;); <span class="comment">// 起始点入堆</span></span><br><span class="line">        <span class="keyword">while</span>(!pq.isEmpty()) &#123; </span><br><span class="line">            <span class="type">int</span>[] u_dist = pq.remove();</span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> u_dist[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span>(visited[u]) <span class="keyword">continue</span>;</span><br><span class="line">            visited[u] = <span class="literal">true</span>; <span class="comment">// 立即置u的距离为已确定</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span>[] v_weight : graph.get(u)) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> v_weight[<span class="number">0</span>], weight = v_weight[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(!visited[v]) &#123; <span class="comment">// 对于u的距离未确定的邻接顶点v，更新v的距离</span></span><br><span class="line">                    <span class="keyword">if</span>(weight &lt; dists[v]) &#123; <span class="comment">// 更新条件</span></span><br><span class="line">                        dists[v] = weight; <span class="comment">// 更新dv</span></span><br><span class="line">                        pq.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;v, weight&#125;); <span class="comment">// v入堆</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> dist : dists)&#123; <span class="comment">// 计算 MST 边权和</span></span><br><span class="line">            <span class="keyword">if</span>(dist == INF) <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 若有不连通的城市，返回 -1</span></span><br><span class="line">            sum += dist;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h3 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h3><p>前述 Prim 算法从一个顶点出发，逐渐「长出」一棵 MST，而本节的 Kruskal 算法在「生成」MST 的过程上与 Prim 颇有相对之感，该方法令 MST 的各部分各自生长，最终合并成一棵完整的 MST。Kruskal 算法是并查集的典型应用，需要读者先了解并查集。在之前的「初探图搜索 (遍历)」 - 「无向图连通性」 - 「并查集」中我已提过，我在另一篇文章中对并查集做过较为全面的介绍，如果读者还不熟悉并查集，那么在开始本节之前，可以先阅读我写的 <a href="https://leetcode.cn/circle/discuss/qmjuMW/">并查集从入门到出门</a> （全文1w+ 字，尝试透彻分析并查集的基本内容，2022 年 5 月中旬在力扣讨论区发布后两周内收获 5k 阅读量，500+ 收藏，100+ 点赞及大量好评）。</p><p>后续内容在假设你已了解了「并查集」基本内容的基础上，均只做非常简要的说明 (因为详细内容都已在「并查集从入门到出门」中呈现)。</p><blockquote><p>Joseph B. Kruskal 于 1956 年发表的 <a href="https://doi.org/10.1090%2FS0002-9939-1956-0078686-7">论文</a> 中描述了该算法。</p></blockquote><br /><h4 id="算法描述-11"><a href="#算法描述-11" class="headerlink" title="算法描述"></a>算法描述</h4><p><a href="https://en.wikipedia.ahmu.cf/wiki/Kruskal%27s_algorithm">Kruskal (克鲁斯卡尔算法)</a>: 一种基于贪心思想的求解无向图上 MST 的算法。该算法首先将所有边按边权排序，接着应用「并查集」的「查询-合并」过程来决定将哪些边加入到 MST 中。算法内容的简要描述为: 对排序后的边权，依序 (按边权从小到大) 取边 $(u,v)$ ，若顶点 $u, v$ 还未连通，则将 $(u,v)$ 加入 MST ，直到加入的边数等于 $|V| - 1$   。</p><br /><h4 id="算法过程-12"><a href="#算法过程-12" class="headerlink" title="算法过程"></a>算法过程</h4><ol><li>构建双向带权图。</li><li>按边权从小到大排序所有边。</li><li>实现以顶点的并查集。</li><li>从排序后的边中依序 (按边权从小到大) 选取边 $(u, v)$ ，查询该边的两个顶点是否已在 MST 中 (即是否已连通) ，是则跳过，否则合并，也即将此边加入 MST 中。</li><li>当加入的边数等于 $|V| - 1$   时，表明所有在一个连通分量中的顶点构成了 MST，算法结束。</li><li>若依序取完所有的边后，加入 MST 的边数仍达不到 $|V| - 1$，说明此图不存在 MST，也即图中存在不连通的顶点。</li></ol><br /><h4 id="时空复杂度-15"><a href="#时空复杂度-15" class="headerlink" title="时空复杂度"></a>时空复杂度</h4><p>时间复杂度:  边权排序 $O(|E|log|E|)$ ，单次查询或合并均为 $O(\alpha(n))$，近似 $O(1)$  ，至多 $|V| - 1$ 次查询与合并。综合为 $O(|V|+|E|log|E|)$，化简为 $O(|E|log|V|)$ 。</p><p>空间复杂度:  建图 $O(|V|+|E|)$ (若输入已有图信息，也可以不用建图)，$parents &#x2F; rank$ 空间 $O(|V|)$。综合为 $O(|V|+|E|)$ 。 </p><br /><h4 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h4><p>现在，我们给出如下利用 Kruskal 算法代码来解决 <a href="https://leetcode.cn/problems/connecting-cities-with-minimum-cost/">1135. 最低成本联通所有城市</a> 。并查集采用「带路径压缩的查找 + 按秩合并」的组合。熟悉「并查集」之后我们能够非常轻松地写出该代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumCost</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] connections)</span> &#123;</span><br><span class="line">        Arrays.sort(connections, (a, b) -&gt; a[<span class="number">2</span>] - b[<span class="number">2</span>]); <span class="comment">// 先对边权排序</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] parents = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) parents[i] = i;</span><br><span class="line">        <span class="type">UnionFind</span> <span class="variable">uf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnionFind</span>(parents);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] edge : connections)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> edge[<span class="number">0</span>] - <span class="number">1</span>, v = edge[<span class="number">1</span>] - <span class="number">1</span>, weight = edge[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span>(uf.find(u) != uf.find(v))&#123;</span><br><span class="line">                uf.union(u, v); <span class="comment">// 合并</span></span><br><span class="line">                sum += weight; <span class="comment">// 实时地累计 MST 边权和</span></span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">if</span>(count == n - <span class="number">1</span>) <span class="keyword">return</span> sum; <span class="comment">// 若存在 MST，必能由此句返回</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 否则无MST</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span>&#123;</span><br><span class="line">    <span class="type">int</span>[] parents, rank;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UnionFind</span><span class="params">(<span class="type">int</span>[] parents)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.parents = parents;</span><br><span class="line">        <span class="built_in">this</span>.rank = <span class="keyword">new</span> <span class="title class_">int</span>[parents.length];</span><br><span class="line">        Arrays.fill(rank, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span>&#123; <span class="comment">// 带路径压缩的查找</span></span><br><span class="line">        <span class="keyword">if</span>(parents[x] == x) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">return</span> parents[x] = find(parents[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123; <span class="comment">// 按秩求并</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">xRoot</span> <span class="operator">=</span> find(x), yRoot = find(y);</span><br><span class="line">        <span class="keyword">if</span>(xRoot != yRoot)&#123;</span><br><span class="line">            <span class="keyword">if</span>(rank[yRoot] &lt;= rank[xRoot])&#123;</span><br><span class="line">                parents[yRoot] = xRoot;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> parents[xRoot] = yRoot;</span><br><span class="line">            <span class="keyword">if</span>(rank[xRoot] == rank[yRoot]) rank[xRoot]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h3 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h3><p>本节介绍了两种常见的求解「最小生成树」的算法，在掌握 Dijkstra 算法的基础上，Prim 只需简单对照学习即可完全掌握。对于 Kruskal，仅仅是并查集的典型应用，因此在掌握了并查集的基础上，学习 Kruskal 也是十分轻松的。</p><p>「最短路径」算法中，由于最短路是边权的累计，在无法穷尽松弛的算法中，例如 Dijkstra，我们特别强调了其无法处理负边图的特点，且所有的最短路径算法都不能求解负圈图 (有的可以检测出负圈) 。但「最小生成树」比较边权的大小而无「累计」效应，因此 <strong>负边和负圈都不影响算法的正确性</strong> ，也就是在讨论「最小生成树」时，我们 <strong>无需考虑图是否有圈以及是否有负边</strong> 。</p><br /><h2 id="网络流"><a href="#网络流" class="headerlink" title="网络流"></a>网络流</h2><p>图论中，除了关心顶点到顶点的「最短距离」和整张图的「最小生成树」之外，人们还关心 <strong>顶点间的「流量」</strong>。将图想象成一张信息网络，信息在顶点之间流动，每条边的权值限制了同一时间承载流量的上限，我们想知道，从一个顶点到另一个顶点，一次最多能够发送多少流量，这就是同样著名的「最大流」问题。在本节中我们将从著名的 <strong>「最大流最小割定理」</strong> 的证明开始，深入讨论该问题，并给出几种求最大流的算法。</p><br /><h3 id="最大流最小割定理"><a href="#最大流最小割定理" class="headerlink" title="最大流最小割定理"></a>最大流最小割定理</h3><p><a href="https://en.wikipedia.org/wiki/Max-flow_min-cut_theorem">最大流最小割定理(Max-flow min-cut theorem)</a>：对于一张网络图 $G$，从源点 $s$ 到汇点 $t$ 的 <strong>最大流量等于最小割所有割边容量之和</strong>。</p><p>以下将从 <strong>路径存在问题</strong> 引入 <strong>割和割的大小</strong> 的概念，再由割的大小与 $s-t$ 不相交路径数量的关系，证明该定理。证明过程中先假设有向图 (网络) 边无权 (或者说均为单位边权，即边权为1)，随后再推广至有权图。</p><blockquote><p>定理证明过程整理自B站南大老师蒋炎岩的授课视频: <a href="https://www.bilibili.com/video/BV1Q7411R7ie?spm_id_from=333.999.0.0">[算法竞赛入门] 网络流基础: 理解最大流&#x2F;最小割定理</a> ，同时也增加了作者的理解。</p></blockquote><p>在这里我们提前指出 <strong>Ford-Fulkerson 方法的正确性证明与最大流最小割定理的证明等价</strong> ，这意味着它们会被 <strong>同时证明</strong> 。如下，也就是 $k &#x3D; m$ 与 $k &#x3D; l$ 同时成立，后续我们将理解这一点。</p><ul><li>Ford-Fulkerson方法的正确性证明：图 $G$ 中 $s-t$ 的最大流为 $k$ ，FF 方法找到的流量为 $m$ ，证明 $k&#x3D;m$。</li><li>最大流最小割定理证明：图 $G$ 中 $s-t$ 的最大流为 $k$ ，$s-t$ 最小割大小为 $l$ ，证明 $k&#x3D;l$。</li></ul><blockquote><p><a href="https://en.wikipedia.org/wiki/L._R._Ford_Jr.">L. R. Ford Jr.</a> &amp; <a href="https://en.wikipedia.org/wiki/D._R._Fulkerson">D. R. Fulkerson</a> (1962) <em>Flows in Networks</em>, 这一 <a href="https://www.rand.org/content/dam/rand/pubs/reports/2007/R375.pdf">论文</a> 第23页，作者给出的最大流最小割定理描述如下。</p><p>Theorem 5.1 Max flow min cut theorem.</p><p>For any network the maximal flow value from $s$ to $t$ is equal to the minimal cut capacity  over cuts separating $s$ and $t$.</p></blockquote><br /><h4 id="从路径存在问题到割"><a href="#从路径存在问题到割" class="headerlink" title="从路径存在问题到割"></a>从路径存在问题到割</h4><p>$s-t$ 流 (flow) 存在的前提是 $s-t$ <strong>路径</strong> 存在。对于路径存在问题，通常以 $DFS&#x2F;BFS$ 算法判定，算法从 $s$ 出发找到 $t$ 则说明 $s-t$ 路径存在，否则不存在。为了引入割的概念，现在尝试以更本质的方式考察该问题。首先以排列组合的方式简单罗列所有可能的 $s-t$ 路径。例如一张包含顶点 $s, a, b ,c, d, t$ 的图，可以罗列出如下路径，暂不考虑边是否存在。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s &gt; t</span><br><span class="line">s &gt; a &gt; t</span><br><span class="line">s &gt; b &gt; t</span><br><span class="line">...</span><br><span class="line">s &gt; a &gt; b &gt; t</span><br><span class="line">s &gt; a &gt; c &gt; t</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>对于上述列表中的一条路径，若该路径中的每对相邻顶点构成的边均存在，则该路径为一条 $s-t$ 路径。若对于列表中的所有路径都能找到不存在的边，则证明该图不存在 $s-t$ 的路径。</p><p>对于路径存在问题，罗列所有可能路径并逐一判断的方法虽最严格，但显然不是证明的好办法。再次考虑 $DFS&#x2F;BFS$，算法从 $s$ 出发，会找到所有能到达的顶点，将这些顶点作为集合 $S$，剩下 $s$ 无法到达的顶点作为集合 $T$ 。$s-t$ 路径不存在， <strong>等价于 $S$ 中任意顶点到 $T$ 中任意顶点的连边都不存在</strong> ，由此引入如下 <strong>割</strong> 的概念。</p><p><strong>割的定义</strong>：割 (cut) 是图 $G$ 的 <strong>顶点集 $V$ 的划分</strong> 。有向图 $G(V, E)$ 的 $s-t$ 割 $C &#x3D; (S, T)$ 指 $V$ 被划分为顶点集 $S$ 和 $T$ ，且 $s ∈ S$，$t ∈ T$。</p><p><strong>割的大小</strong>：对于上述割，其大小指从 $S$ 到 $T$ 的边的数量，即边 $(u, v) ∈ E | u ∈ S, v ∈ T$ 的数量，称这些边为 <strong>割边</strong>。</p><p>根据割及其大小的定义，只要存在 $s-t$ 路径，无论如何划分 $V$ 得到 $s-t$ 割，总能在图中找到从 $S$ 到 $T$ 的边，即该割的大小一定大于0。例如下面的 $s-t$ 路径，$s, a, d, e, h ∈ S， b, c, f, g, i, t ∈ T$，红箭头表示 $s-t$ 割的边。只要满足 $s ∈ S$  ($s$ 在绿色阴影里)，$t ∈ T$ ($t$ 不在绿色阴影里)，在有路径的情况下，红箭头一定存在，而与绿色阴影的形状 (具体的 $s-t$ 割) 无关。反过来说就是 <strong>若 $s-t$ 路径存在，则所有 $s-t$ 割的大小都大于0</strong> 。</p><p>因此，要想证明 $s-t$ 路径不存在，<strong>只需要找到一个大小为 0 的 $s-t$ 割即可</strong> 。 注意，当 $s-t$ 路径不存在时，也可能存在大小不为 0 的 $s-t$ 割，很容易找到相关例子，因此重申，证明 $s-t$ 路径不存在是要找到一个大小为 0 的 $s-t$ 割。</p><p><img src="https://pic.leetcode-cn.com/1653988476-VnBvzk-image.png" alt="image.png"></p><br /><h4 id="不相交路径数量与割的大小"><a href="#不相交路径数量与割的大小" class="headerlink" title="不相交路径数量与割的大小"></a>不相交路径数量与割的大小</h4><p>现在，我们初步建立了「流」与「割」在特定情形下的联系，即上述分析给出的「$s-t$ 路径数量为 0 时 (流为0)，必存在大小为 0 的 $s-t$ 割」。这是 「$s-t$ 路径数量」 与 「$s-t$ 割大小」 的特定关系。再次回到定理内容，定理描述了「最大流」和「最小割边容量」(对无权图来说即割边数量) 的关系，不难理解，最大流就是 <strong>不相交的 $s-t$ 的路径</strong> 数量 (再次注意，我们当前讨论的是无权图，「数量」即「流量」)。$s-t$ 的 <strong>不相交</strong> 路径指对于多条 $s-t$ 路径，它们之间 <strong>没有公共边</strong> 。后续我们通过如下三个量的关系来证明定理，即证明 $k &#x3D; l$。</p><ul><li><p>$k$ 为图中 <strong>实际存在的</strong> $s-t$ 不相交路径数量。</p></li><li><p>$m$ 为 <strong>算法找到的</strong>  $s-t$ 不相交路径数量。</p></li><li><p>$l$ 为图中 <strong>最小</strong>  $s-t$ 割边数量。</p></li></ul><br /><h5 id="不相交路径数上界"><a href="#不相交路径数上界" class="headerlink" title="不相交路径数上界"></a>不相交路径数上界</h5><p>假设图有 $k$ 条 $s-t$ 的不相交路径，想要知道 $k$ 的大小，可以逐步假设 $k (k &#x3D; 0, k &#x3D; 1, k &#x3D; 2,…)$，再验证是否确实有那么多条。例如假设 $k&#x3D;0$ 时，实际上就是前述 $s-t$ 路径存在性问题，已经指出，若存在大小为 0 的 $s-t$ 割，则 $k&#x3D;0$。当 $k &gt; 0$ 时，考虑是否还能用 $s-t$ 割的大小表达不相交路径数量。</p><p>下图 $k&#x3D;1$，以图中的阴影表示 $s-t$ 割，可以看出该割的大小为 1。容易看出 <strong>不相交路径数量受到割边 $(b, c)$ 数量的限制</strong> ，如果所有 $s-t$ 割大小最小为1，那么任意 $s-t$ 路径一定都经过该唯一割边，即 $s-t$  <strong>不相交</strong> 路径至多为 1。若最小割大小为 2，则存在 2 条经过 2 条不同割边的 $s-t$ 路径。总之，**$s-t$ 割的大小 $c$ 决定了 $s-t$ 不相交路径数量 $k$ 的上界**，即 $k ≤ c$。如果 $c &#x3D; l$ ，自然就有 $k≤l$ ，任意 $s-t$ 割的大小 $c$ 是 $k$ 的一个 <strong>上界</strong> ，$l$ 是 $k$ 的 <strong>最紧上界</strong> 。现在我们离目标近了一步，即「割边数」$c$ 和「最大流」($s-t$ 不相交路径数量) $k$ 的关系满足: $k ≤ c$ ，最紧地有 $k≤l$ 。</p><p><img src="https://pic.leetcode-cn.com/1655467840-MXsmzl-image.png" alt="image.png"></p><br /><h5 id="不相交路径数下界"><a href="#不相交路径数下界" class="headerlink" title="不相交路径数下界"></a>不相交路径数下界</h5><p>上述以割边数给出了不相交路径数量 $k$ 的上界，而如果能直接找到 $m$ 条不相交路径，此 $m$ 可立即作为 $k$ 的一个下界，且若 $m &#x3D; l$，便可得到 $k &#x3D; l$。 直接地，我们用 $DFS&#x2F;BFS$ 求 $m$，在 $G$ 中寻找一条 $s-t$ 路径 $p$，找不到时 $k&#x3D;0$，若能找到，为了保证找到的路径总是 <strong>不相交</strong> 的，需要从 $G$ 中删去 $p$，然后 $k &#x3D; k + 1$。看起来有效，但实际操作后我们会发现一个问题，如下图，当第一次选择的路径为 $s &gt; d &gt; a &gt; t$ 后，由于该路径被删除，将无法再找到下一条路径，而该图显然有 $k&#x3D;2$ ($s &gt; a &gt; t, s &gt; d &gt; t$)，因此单纯使用 $DFS&#x2F;BFS$ 算法得到的 $m$ 并不一定是 $k$ 。而 Ford-Fulkerson 方法可以解决这一问题，即 FF 方法保证 $m &#x3D; k$ 。</p><p><img src="https://pic.leetcode-cn.com/1653988540-tRbAnE-image.png" alt="image.png"></p><br /><h5 id="反向边-路径"><a href="#反向边-路径" class="headerlink" title="反向边 (路径)"></a>反向边 (路径)</h5><p>L. R. Ford, JR &amp; D. R. Fulkerson 在1956年的<a href="http://www.cs.yale.edu/homes/lans/readings/routing/ford-max_flow-1956.pdf">论文</a>中修正了单纯以 $DFS&#x2F;BFS$ 找最大流的缺陷缺陷，并证明了改进后算法的正确性，这就是著名的 Ford-Fulkerson 方法。修正办法十分简单，即在每一次找到一条路径并删除该路径后，在 $t-s$ 的方向上 ($s-t$ 的反方向)  <strong>添加原路径的反向路径</strong>，仅此而已。如前图，找到 $s &gt; d &gt; a &gt; t$ 的路径后将其删除，立即添加 $t &gt; a &gt; d &gt; s$ 路径。该操作使得后续仍能找到一条 $s-t$ 路径，即 $s &gt; a &gt; d &gt; t$，继续删除并添加相应的反向路径，最终无法再找到 $s-t$ 路径，$m&#x3D;2$ 被正确求出。</p><p><img src="https://pic.leetcode-cn.com/1655468114-uQBxhD-image.png" alt="image.png"></p><p>$s-t$ 路径称为 **增广路径(Augmenting Path)**，可以将反向路径称作 <strong>反向增广路径</strong>。添加这一反向路径的操作是整个算法最为核心的部分，以下证明这一操作的正确性，即以「寻找增广路-删除该路径-添加反向路径」这一FF方法得到 $m$ 条 $s-t$ 路径，且 $m &#x3D; k$。稍等，我们不是要证明「最大流最小割定理」，也就是证明 $k &#x3D; l$ 吗？为何突然转为证明 $m&#x3D;k$ ？很快你会看到，这两点是等价的，且是同时证明的。</p><br /><h4 id="证明k-x3D-m"><a href="#证明k-x3D-m" class="headerlink" title="证明k&#x3D;m"></a>证明k&#x3D;m</h4><p>蒋岩炎老师的视频中不以严谨的数学证明，而是以图形化的直观方式证明了最大流最小割定理 (也即证明了 FF 方法的正确性)。</p><br /><h5 id="添加反向边的有效性"><a href="#添加反向边的有效性" class="headerlink" title="添加反向边的有效性"></a>添加反向边的有效性</h5><p>如下左图 (图中的 $s$ 和 $t$ 虽画出了多个点，但表示一个点)，$p1, p2, p3$ 是 $DFS&#x2F;BFS$ 找到的头 3 条 $s-t$ 不相交路径 (每次都会添加反向路径，但这三条恰好都还未经过反向边)，$p4$ 是第 4 条 (经过反向边)。$p4$ 由两种边组成，如下中图，一种是不与 $p1, p2, p3$ 交叠的边，即此前尚未出现在不相交路径上的 <strong>原边</strong>，另一种是与 $p2$ 和 $p3$ (反向) 交叠的边，这些边是找到 $p2$，$p3$ 后添加的 <strong>反向边</strong>，它们使得 $p4$ 可以沿着这样的反向边到达 $t$。假设此时 FF 方法已找不到 $s-t$ 路径，那么 FF 方法找到了 4 条不相交路径，即 $m &#x3D; 4$ 。</p><p>$p4$ 是通过添加反向边来间接得到的 (此路径并不存在于原图中)，现在的问题，由于 4 条路径是通过添加反向边找到的，它们并不都是原图中存在的路径。我们首先明确 <strong>原图</strong> 中确实有 4 条不相交路径。为了看出这一点，找到 $p4$ 后，在反向 $p4$ 之前，去掉 $p4$ 走过的反向边，然后将还原 $p1, p2, p3$ 反向过后的边 (再反回去) ，得到下右图。可以看到，$p1$不变，而 $p’2, p’3, p’4$ 就是 <strong>原图</strong> 中的 $s-t$  路径，它们显然不相交 。注意下右图本身就是原图的一部分，只不过一开始没找到 $p’2, p’3, p’4$ ，而是找到了 $p2, p3$，然后通过反向边找到了 $p4$。</p><p>尽管算法找到的路径与下右图显示的原图上的路径不同，<strong>但数量是正确的</strong>。如果还有 $p5$，仍然可以通过相同的方法证明原图中有 5 条不相交路径。<strong>在示意图中那些通过反向边得到的 (在原图中不存在的) 路径看起来就像是切开了起初得到的路径 ($p2, p3$)，并通过部分原边连接这些路径的断点，使得 $s$ 到 $t$ 可达</strong> 。</p><p><img src="https://pic.leetcode-cn.com/1653988618-MClSny-image.png" alt="image.png"></p><br /><h5 id="k的确定与最小割的大小"><a href="#k的确定与最小割的大小" class="headerlink" title="k的确定与最小割的大小"></a>k的确定与最小割的大小</h5><p>上述内容说明了添加反向边能够找到新的 (在不添加反向边时可能找不到的) 不相交路径，并且我们看到算法找到的路径与原图实际的路径 <strong>一一对应 (数量相等)</strong> 。有了这些准备工作，我们开始证明 $k &#x3D; m$ 。证明基于以下思路。</p><ol><li>已经知道 $m &#x3D; 4$，因此 $k ≥ m &#x3D; 4$ 。</li><li>如果找到原图 $G$ 的 $s-t$ 割 $C$，证明它是「最小割」且 $l &#x3D; 4$ ，那么证明就完成了。</li><li>对于 2，指出一个割，直接证明它是 <strong>「最小的」</strong> 是困难的，因此我们不必考虑它是不是最小，转而考虑在原图中寻找一个大小 $c&#x3D;4$ 的割 $C$ 。因为 $m≤k≤c$ ，那么 $m&#x3D;k&#x3D;c&#x3D;4$，确定了 $k&#x3D;4$ ，就不可能存在大小小于 4 的割，于是 $m&#x3D;k&#x3D;l&#x3D;c&#x3D;4$ 。</li><li>上述 3 就意味着 FF 方法 ($m&#x3D;k$) 和最大流最小割定理 ($k&#x3D;l$) 同时得证。</li></ol><p>根据这个思路，我们接着前图继续分析。再次强调，现在的目标是 <strong>在原图中寻找一个大小为 $c&#x3D;4$ 的割 $C$</strong> 。</p><p>以上中图为例，将 $p4$ 反向得到如下残留图 $G_{f’}$ 。</p><p><img src="https://pic.leetcode-cn.com/1653988645-jrvhAv-image.png" alt="image.png"></p><p><strong>残留图 $G_{f’}$ 有两种边</strong> ，一种是 $s-t$ 不相交路径的反向边（注意，这里说的 $s-t$ 不相交路径不是通过算法找到的路径，而是前述说明中 $p1, p’2, p’3, p’4$ 那样的原图中存在的 $s-t$ 路径），一种是其他不在不相交路径上的原边。显然，此时 $t-s$ 不相交路径就是原图上的 4 条 $s-t$ 不相交路径的反向路径。由于 $s-t$ 已不连通，可知此时在残留图中存在大小为 0 的 $s-t$ 割 $C$ 。我们指出如下具体的割 $C$ 。</p><blockquote><p>割 $C$ : 将 $G_{f’}$ 中 $s$ 能够到达的顶点划归 $S$，将剩下的顶点划归 $T$ 。</p></blockquote><p><strong>该割大小为 0</strong> ，反证法简单可证明。若有割边，也就是还能从 $S$ 找到一个顶点 $v$ 连到 $T$ 中的某个顶点 $u$，那么 $s$ 就能通过 $v$ 连通 $u$ ，这与我们的划分要求相矛盾 ，因为在 $G_{f’}$ 中已经将 $s$ 能到达的所有顶点都划入 $S$ 了。$u$ 也不可能是 $t$，因为  $G_{f’}$ 中 $s-t$ 不连通，因此假设不成立，此割无割边。  由此得到如下重要推论。</p><blockquote><p>推论: 割 $C$ 在原图 $G$ 中大小为 4。</p></blockquote><p>证明如下:</p><ol><li>割 $C$ 在残留图 $G_{f’}$ 中大小为 0 ，也就是 $S$ 中无顶点可到 $T$ 。 </li><li>残留图与原图的区别仅仅是 <strong>不相交路径的方向相反</strong> 。</li><li>在原图 $G$ 中，$S$ 中的顶点可分为不在 $s-t$ 路径上和在 $s-t$ 路径上的顶点。对于前者，根据 1，无顶点可到 $T$ ，对于后者，它们 <strong>贡献且仅贡献了 4 条割边</strong> 。<ol><li>也就是说每条 $s-t$ 路径只贡献一条割边，这要求每条 $s-t$ 路径都只穿过一次 $S-T$。</li><li>因为原图 $G$ 的 $s-t$ 路径是残留图 $G_{f’}$ 的 $t-s$ 路径的反向路径。因此证明原图中 $s-t$ 路径只穿过一次 $S-T$ 等价于证明残留图中 $t-s$ 路径只穿过一次 $T-S$。(记住，割 $C$ 在原图和残留图中是一样的)</li><li>假设在残留图 $G_{f’}$ 中 $t-s$ 路径穿过了两次 $T-S$，因为 <strong>路径是连续的</strong> ，穿越过程必然是 $T→S→T→S$，也就是会有边穿越 $S-T$ 。<strong>这与残留图 $G_{f’}$ 存在大小为 0 的 $s-t$ 割相矛盾</strong> ( $G_{f’}$ 上的割 $C$)。 </li><li>因此原图 $G$ 中的 $s-t$ 路径均只穿过一次 $S-T$，每条路径只贡献一条割边，也即割 $C$ 在原图 $G$ 中大小为 4 。</li></ol></li></ol><p>推论得证。</p><p>至此，通过找到残留图 $G_{f’}$ 上大小为 0 的割 $C$ ，我们证明了割 $C$ 在原图中大小为 4 ，实现了证明目标。最后总结如下。</p><ol><li>我们在指出原图 $G_f$ 上的割 $C$ 时，并不知道它是不是最小割，但证明了 $m &#x3D; c &#x3D; 4$，而我们知道 $m≤k≤c$  ，因此直接得到了 $k &#x3D; m &#x3D; 4$ 。因为 $k&#x3D;4$ ，所以原图上的任何 $s-t$ 割不可能比割 $C$ 更小，于是 <strong>割 $C$ 是一个最小割</strong> ，综上，有 $m&#x3D;k&#x3D;l&#x3D;c&#x3D;4$ 。</li><li>$m&#x3D;k$ 证明了 Ford-Fulkerson 方法的正确性， $k &#x3D; l$ 证明了最大流最小割定理，这就是我们在开始证明时提到「FF 方法正确性和最大流最小割定理的证明等价，它们会被同时证明」的原因。</li></ol><br /><h4 id="推广至有权图"><a href="#推广至有权图" class="headerlink" title="推广至有权图"></a>推广至有权图</h4><p>只需将边权为 $n$ 的边看作 $n$ 条单位边，转换成无权图即可适用前述证明。例如 $s &gt; a &gt; t$ 路径，$(s, a)$ 边权为 2，$(a, t)$ 边权为3，将边拆成单位边后，原容量为 2 的一条路径被分成两条单位容量的路径。</p><br /><h3 id="Ford-Fulkerson"><a href="#Ford-Fulkerson" class="headerlink" title="Ford-Fulkerson"></a>Ford-Fulkerson</h3><p>在「最大流最小割定理及其证明」中我们已经介绍了 Ford-Fulkerson 方法并证明了该方法的正确性。本节我们继续讲解该方法更详细的内容。</p><br /><h4 id="算法描述-12"><a href="#算法描述-12" class="headerlink" title="算法描述"></a>算法描述</h4><p><a href="https://en.wikipedia.org/wiki/Ford%E2%80%93Fulkerson_algorithm">Ford-Fulkerson方法(福特-富尔克森方法)</a>: 1956 年 L. R. Ford Jr 和 D. R. Fulkerson 在其发表的 <a href="http://www.cs.yale.edu/homes/lans/readings/routing/ford-max_flow-1956.pdf">论文</a> 中描述的基于 <strong>贪心思想</strong> 的求 <strong>有向图最大流</strong> 的算法。因为该算法未指定求增广路径的具体算法，所以通常将其称作 Ford-Fulkerson <strong>方法</strong> (Method) 而非 Ford-Fulkerson <strong>算法</strong> (Algorithm) 。若增广路径 <strong>以 $bfs$ 方式求出</strong> ，则为 <strong>Edmonds-Karp 算法</strong> 。此外也可以以 $dfs$ 方式求最短路径，我们之后会介绍 <strong>结合 $bfs$ 和 $dfs$ 求增广路的 Dinic 算法</strong> 。FF 首先设置要求解的目标，即源点 $s$ 到目标点 $t$ 的最大流，设为 $f$，初始值为 0，然后寻找 $s-t$ 路径 $p1$，$p1$ 上最小权边的边权即 $s$ 能沿 $p1$ 发往 $t$ 的最大流量 $c(p1)$。如我们在「最大流最小割定理及其证明」中所述，由于不适当的增广路选择会使得最大流量 $f$ 在求出前 $s$ 到 $t$ 就没有了增广路，因此 Ford-Fulkerson 方法要求每次求出一条增广路后，要在相反方向路径上添加 $c(p1)$，其作用是 $t$ 到 $s$ 在必要时能够发回原先 $s$ 发送到 $t$ 的流量。我们已经证明了该做法的正确性。当无法再在残留图中找到 $s-t$ 的增广路时所得到的 $f$ 即为原图 $s-t$ 最大流。</p><br /><h4 id="算法过程-13"><a href="#算法过程-13" class="headerlink" title="算法过程"></a>算法过程</h4><p>给定一张图 $G(V, E)$ ，源点为 $s$ ，汇点为 $t$ 。求 $G$ 中从 $s$ 到 $t$ 的最大流 $f$ 。</p><ol><li><p>设置一张残留网络 (残留图&#x2F;残差图&#x2F;残余图，<em>residual graph</em> ) $Gf$，$Gf$ 初始为 $G$。</p></li><li><p>考察 $Gf$ 中是否有从 $s$ 到 $t$ 的路径 $p$ ，使得 $p$ 上的每一条边 $(u,v) ∈ p$ ，都有 $c(u, v) &gt; 0$ 。$p$ 称作 <strong>增广路径 (Augmenting Path)</strong> 。若存在 $p$ ，则：<br>2.1 将 $p$ 中 <strong>最小边的权</strong>  $c$ 加入 $f$。<br>2.2  $p$ 的每条边减去该最小边的权 $c$。<br>2.3  $p$ 的反向路径上的每条边加上该最小边权 $c$。</p></li><li><p>在 $Gf$ 中反复寻找增广路径 $p$ 并执行 2 中的操作直到 $Gf$ 中找不到 $p$，算法停止。此时得到的 $f$ 即为 $s$ 到 $t$ 的最大流。</p></li></ol><p>※ 虽然根据 wiki 的说法 Ford-Fulkerson 未指定求增广路的具体方式，但若以 $dfs$ 方式求增广路，通常也称作 Ford-Fulkerson 。</p><br /><h4 id="算法正确性证明"><a href="#算法正确性证明" class="headerlink" title="算法正确性证明"></a>算法正确性证明</h4><p>请参考「最大流最小割定理」。</p><br /><h4 id="两种坏情形"><a href="#两种坏情形" class="headerlink" title="两种坏情形"></a>两种坏情形</h4><p><strong>小边权增广路径情形</strong></p><p>如下图，寻找从 $A$ 到 $B$ 的增广路径时，若选取 $A&gt;B&gt;C&gt;D$ 后，再选取 $A&gt;C&gt;B&gt;D$ ( $C&gt;B$ 由反向边操作得到)，如此反复选取。由于 $B,C$ 之间的小权边限制了流的大小，需经历 2000 次增广才能结束算法，而选取 $A&gt;B&gt;D$，然后选取 $A&gt;C&gt;D$ 则只需要两次。针对如何避免选取含有小边权的增广路，有以下两种做法。</p><ul><li><p>做法1:  <strong>总是选取流最大的增广路径</strong> 。显然能够避免小权边引起的多次增广路选取。</p></li><li><p>做法2:  <strong>总是选取最短的增广路径</strong> 。较短的增广路降低了路径上出现小权边的概率。</p></li></ul><p><img src="https://pic.leetcode-cn.com/1655468292-XDNzCD-image.png" alt="image.png"></p><p>以 $bfs$ 方式应用无权单源最短路径方法实现做法 2 即为 Edmonds-Karp 算法。</p><br /><p><strong>算法无法终止的情形</strong></p><p>算法能够结束的隐含前提是 <strong>每次找到的增广路至少使 $s$ 到 $t$ 的发送流增加 1 个单位 (例如整数 1)</strong> ，只要最大流是固定的，经过有限次操作后总能发送到最大流。如果边权存在 <strong>无理数</strong> ，则算法可能无法结束。以下举例说明 (该例来自 <a href="https://en.wikipedia.org/wiki/Ford%E2%80%93Fulkerson_algorithm">Wiki</a> )。</p><p>如下图的流量网络，$e1 &#x3D; (b, a), e2 &#x3D; (d, c), e3 &#x3D; (b, c)$ ， $|e1| &#x3D; |e3| &#x3D; 1$，$|e2| &#x3D; r &#x3D; (√5 - 1) &#x2F; 2$ 。其他边的容量为 $M (M &gt;&#x3D; 2)$ ，且 $r^2 &#x3D; 1 - r$ ， $r^3 &#x3D; r - r^2$ ,  $r^4 &#x3D; r^2 - r^3$ …。有路径 $p0 &#x3D; s &gt; b &gt; c &gt; t$ ，$p1 &#x3D; s &gt; d &gt; c &gt; b &gt; a &gt; t$ ， $p2 &#x3D; s &gt; b &gt; c &gt; d &gt; t$ ，$p3 &#x3D; s &gt; a &gt; b &gt; c &gt; t$ 。若按路径 $p0, p1, p2, p1, p3, p1, p2, p1, p3, p1, p2, p1, p3…$ 的顺序增广，则算法无法结束。</p><p>观察下表经过上述顺序一次循环后的结果，步骤 1 和步骤 5 时 $e1, e2, e3$ 剩余容量为 $r^n, r^{n+1}, 0$ 的形式。发送流为 $1+2(r^1+r^2)$ 。经过无限次完整的循环，$e1, e2, e3$ 剩余容量都会是 $r^n, r^{n+1}, 0$ 的形式，而发送流为 $1+2∑r^i$   ( $r$ 是从 1 到正无穷的整数)。根据等比数列求和公式有：</p><p>$$1+2∑r^i   &#x3D; 1 + 2*r&#x2F;(1-r)$$</p><p>将 $r &#x3D; 1 - r^2 &#x3D; (1+r)*(1-r)$ 代入上式分子中的 $r$ ，得到 $3+2r$ ，即发送流会向 $2+√5$ 趋近，但从原图可以看出最大流为 $2M + 1 &gt; 5 &gt; 2+√5$ 。</p><table><thead><tr><th>步骤</th><th>增广路</th><th>发送流</th><th>e1剩余</th><th>e2剩余</th><th>e3剩余</th></tr></thead><tbody><tr><td>0</td><td></td><td></td><td>$r^0 &#x3D; 1$</td><td>$r^1$</td><td>1</td></tr><tr><td>1</td><td>$p0$</td><td>1</td><td>$r^0$</td><td>$r^1$</td><td>0</td></tr><tr><td>2</td><td>$p1$</td><td>$r$</td><td>$r^2$</td><td>0</td><td>$r^1$</td></tr><tr><td>3</td><td>$p2$</td><td>$r$</td><td>$r^2$</td><td>$r^1$</td><td>0</td></tr><tr><td>4</td><td>$p1$</td><td>$r^2$</td><td>0</td><td>$r^3$</td><td>$r^2$</td></tr><tr><td>5</td><td>$p3$</td><td>$r^2$</td><td>$r^2$</td><td>$r^3$</td><td>0</td></tr></tbody></table><p><img src="https://pic.leetcode-cn.com/1655468320-vxRPFt-image.png" alt="image.png"></p><br /><h4 id="时空复杂度-16"><a href="#时空复杂度-16" class="headerlink" title="时空复杂度"></a>时空复杂度</h4><p>时间复杂度：$O(|E|*f)$ 。</p><p>设最大流为 $f$ ，算法过程为穷尽增广路径的过程，对于任意一条增广路，都可以保证在 $O(|E|)$ 时间内找到 (例如以 $bfs&#x2F;dfs$ 方式寻找，为 $O(|V|+|E|)$，简略为 $O(|E|)$  )，而每找到一条增广路径，至少增加 1  个单位的流量 (不考虑边权为无理数的情况，前面已说过，该情况可能会导致算法无法终止)，故总的时间复杂度为 $O(|E|*f)$ 。此时间复杂度与最大流的大小正相关，当 $f$ 较大时会导致较高的时间复杂度。若以 $bfs$ 算法寻找增广路，即 Edmonds-Karp 算法，时间复杂度为 $O(|V||E|^2)$ 。若以 $bfs$ 和 $dfs$ 相结合的 Dinic  算法寻找增广路，则时间复杂度进一步降为 $O(|V|^2|E|)$ 。</p><p>空间复杂度：依赖于存图及求最短路径的具体方法，采用邻接表存图，则存图空间为 $O(|V|+|E|)$ ，采用邻接矩阵为 $O(|V|^2)$ 。若以 $bfs$ 求最短路径，即 Edmonds-Karp 算法，队列的长度导致的空间复杂度为 $O(|V|)$ 。若以 $dfs$ 求最短路径，递归栈导致的空间复杂度为 $O(|V|)$ 。总体来说取决于存图方式。</p><br /><h4 id="代码-13"><a href="#代码-13" class="headerlink" title="代码"></a>代码</h4><p>我们采用 $dfs$ 方式找增广路，并将其看作 Ford-Fulkerson 「算法」。现给出 FF 「算法」解决 P3376 【模板】网络最大流 (请自行搜索) 一题的代码（#9, #10 测试例超时，其他通过）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Ford-Fulkerson</span></span><br><span class="line"><span class="keyword">package</span> com.yukiyama.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FF</span> &#123;</span><br><span class="line">    <span class="type">boolean</span>[] visited;</span><br><span class="line">    <span class="type">int</span>[] ends, heads, nexts, weights, preEdges, pre, saturatedWeights;</span><br><span class="line">    <span class="type">int</span> edgeNum;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">cin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cin.nextInt(), m = cin.nextInt(), s = cin.nextInt() - <span class="number">1</span>, t = cin.nextInt() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">FF</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FF</span>();</span><br><span class="line">        demo.visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">        demo.ends = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span> * m + <span class="number">2</span>];</span><br><span class="line">        demo.nexts = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span> * m + <span class="number">2</span>];</span><br><span class="line">        demo.weights = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span> * m + <span class="number">2</span>];</span><br><span class="line">        demo.preEdges = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        demo.heads = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        demo.pre = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        demo.saturatedWeights = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        demo.edgeNum = <span class="number">1</span>; <span class="comment">// 初始为1，使得第一条边的编号为2，二进制为 10，第二条边(第一条边的反向边)编号为3，二进制为11，方便取异或</span></span><br><span class="line">        demo.init(m, cin); <span class="comment">// 建图</span></span><br><span class="line">        cin.close();</span><br><span class="line">        System.out.println(demo.ek(s, t)); <span class="comment">// 求最大流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 求 s-t 最大流</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">ek</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == t) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 特判</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>, incFlow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((incFlow = dfs(s, t, Integer.MAX_VALUE)) &gt; <span class="number">0</span>) &#123; <span class="comment">// 不断增广</span></span><br><span class="line">            max += incFlow; <span class="comment">// 将每次增广路带来的流量增加到maxFlow上</span></span><br><span class="line">            Arrays.fill(visited, <span class="literal">false</span>); <span class="comment">// 重置 visited</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 链式向前星建图</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(<span class="type">int</span> m, Scanner cin)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> cin.nextInt() - <span class="number">1</span>, v = cin.nextInt() - <span class="number">1</span>, weight = cin.nextInt();</span><br><span class="line">            ++edgeNum;</span><br><span class="line">            ends[edgeNum] = v;</span><br><span class="line">            weights[edgeNum] = weight;</span><br><span class="line">            nexts[edgeNum] = heads[u]; </span><br><span class="line">            heads[u] = edgeNum;</span><br><span class="line">            ++edgeNum;</span><br><span class="line">            ends[edgeNum] = u;</span><br><span class="line">            weights[edgeNum] = <span class="number">0</span>;</span><br><span class="line">            nexts[edgeNum] = heads[v]; </span><br><span class="line">            heads[v] = edgeNum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// dfs 增广并实时地发送 &amp; 发回流</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> t, <span class="type">long</span> incFlow)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(u == t) <span class="keyword">return</span> incFlow;</span><br><span class="line">        visited[u] = <span class="literal">true</span>; <span class="comment">// 立即置为已访问</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">edgeNo</span> <span class="operator">=</span> heads[u]; edgeNo != <span class="number">0</span>; edgeNo = nexts[edgeNo]) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> ends[edgeNo], weight = weights[edgeNo];</span><br><span class="line">            <span class="keyword">if</span>(visited[v] || weight == <span class="number">0</span>) <span class="keyword">continue</span>; <span class="comment">// 跳过已访问或边权为0的情况</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">saturatedWeight</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>((saturatedWeight = dfs(v, t, Math.min(incFlow, weight))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                weights[edgeNo] -= saturatedWeight; <span class="comment">// 增广路发送流</span></span><br><span class="line">                weights[edgeNo ^ <span class="number">1</span>] += saturatedWeight; <span class="comment">// 反向增广路发回流</span></span><br><span class="line">                <span class="keyword">return</span> saturatedWeight;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h3 id="Edmonds-Karp"><a href="#Edmonds-Karp" class="headerlink" title="Edmonds-Karp"></a>Edmonds-Karp</h3><h4 id="算法描述-13"><a href="#算法描述-13" class="headerlink" title="算法描述"></a>算法描述</h4><p><a href="https://en.wikipedia.org/wiki/Edmonds%E2%80%93Karp_algorithm">Edmonds-Karp算法 (埃德蒙兹-卡普算法)</a>: 以 $bfs$ 方式 (无权最短路) 寻找增广路径实现 Ford-Fulkerson 方法即为 Edmonds-Karp 算法。每找到一条增广路并确定该路径上的最小边权 (该路径最大可发送流) 后，将此边权计入最大流中，并在此路径上对 $s-t$ 方向的边减去该权值， $t-s$ 方向上加上该权值。当 BFS 无法再找到增广路时算法结束，得到 $s$ 到 $t$ 的最大流。</p><br /><h4 id="算法过程-14"><a href="#算法过程-14" class="headerlink" title="算法过程"></a>算法过程</h4><p>给定一张图 $G(V, E)$ ，源点为 $s$ ，汇点为 $t$ 。求 $G$ 中从 $s$ 到 $t$ 的最大流 $f$ 。</p><ol><li><p>设置一张残留网络 (残留图&#x2F;残差图&#x2F;残余图，<em>residual graph</em> ) $Gf$，$Gf$ 初始为 $G$。</p></li><li><p><strong>以 $bfs$ 方式</strong> 考察 $Gf$ 中是否有从 $s$ 到 $t$ 的路径 $p$ ，使得 $p$ 上的每一条边 $(u,v) ∈ p$ ，都有 $c(u, v) &gt; 0$ 。$p$ 称作 <strong>增广路径 (Augmenting Path)</strong> 。若存在 $p$ ，则：<br>2.1 将 $p$ 中 <strong>最小边的权</strong>  $c$ 加入 $f$。<br>2.2  $p$ 的每条边减去该最小边的权 $c$。<br>2.3  $p$ 的反向路径上的每条边加上该最小边权 $c$。</p></li><li><p>在 $Gf$ 中反复寻找增广路径 $p$ 并执行 2 中的操作直到 $Gf$ 中找不到 $p$，算法停止。此时得到的 $f$ 即为 $s$ 到 $t$ 的最大流。</p></li></ol><br /><h4 id="时空复杂度-17"><a href="#时空复杂度-17" class="headerlink" title="时空复杂度"></a>时空复杂度</h4><p>以下证明 EK 算法的时间复杂度为：$O(|V||E|^2)$</p><blockquote><p>本证明参考了<a href="http://pisces.ck.tp.edu.tw/~peng/index.php?action=showfile&file=f6cdf7ef750d7dc79c7d599b942acbaaee86a2e3e">证明1</a>、<a href="https://brilliant.org/wiki/edmonds-karp-algorithm/">证明2</a>。</p></blockquote><br /><h5 id="1-一次BFS增广"><a href="#1-一次BFS增广" class="headerlink" title="1. 一次BFS增广"></a>1. 一次BFS增广</h5><p>每次 $bfs$ 增广，在增广路上的未饱和边会多出一条反向边，原图的单向边添加反向边后，就具有双向边 (两条) ，但饱和边仍是一条 (反向) ，因此增广操作导致的边数增长不会使总边数超过原来的 2 倍，即算法的任意时刻总边数 $&lt; 2|E|$。因此一次 $bfs$ 的时间复杂为 $O(2|E|)$，即 $O(|E|)$。</p><br /><h5 id="2-BFS增广次数"><a href="#2-BFS增广次数" class="headerlink" title="2. BFS增广次数"></a>2. BFS增广次数</h5><h6 id="2-1-增广路长度非递减"><a href="#2-1-增广路长度非递减" class="headerlink" title="2.1 增广路长度非递减"></a>2.1 增广路长度非递减</h6><p>即证明算法过程中的 $s$ 到 $t$ 的 BFS 增广操作，即正向边删除和反向边增加的操作，不会导致源点 $s$ 到任意一点 $v$ 的最短路径距离减少。残留图 $G_f$ 经过一次 BFS 增广变为 $G_{f’}$ 后，对任意顶点 $v$ ，源点 $s$ 到 $v$ 的最短路径长度 <strong>非递减</strong>，即有 $d’(s, v) ≥ d(s, v)$。以下利用反证法证明，并在证明中解释为何<strong>只能证明非递减而无法证明严格递增</strong>，即不是 $d’(s, v) &gt; d(s, v)$。</p><ol><li><p>假设某一次 $s - t$ 增广后，使得某些顶点到源点 $s$ 的最短路径距离相比增广前变小了，且这其中距离源点 $s$ 最近者为 $v$。则根据该假设有</p><p>(1)    $d’(s, v) &lt; d(s, v)$ </p></li><li><p>令 $u$ 为 $G_{f’}$ 中 $v$ 的靠近源点 $s$ 的前一个顶点，则有</p><p>(2)    $d’(s, u) + 1&#x3D; d’(s, v)$ </p><p>如 2.1.1 所述，$v$ 是我们有意选择的在 $G_{f’}$ 中最短距离相比在 $G_f$ 中变小的且距离 $s$ 最近的顶点，$u$ 比 $v$ 更靠近 $s$，但在 $G_{f’}$ 中相比在 $G_f$ 中距离 $s$ 的最短路径未变小，即有</p><p>(3)    $d(s, u) ≤ d’(s, u)$ </p></li><li><p>假设 $(u, v) ∈ E_f$，已知 $s$ 到 $v$ 的最短路径距离为 $d(s, v)$，则有</p><p>(4)    $d(s, u) + 1 &#x3D; d(s, v)$</p><p>结合(1)、(2)、(3)有 </p><p>$d(s, u) ≤ d’(s, u) → d(s, u) + 1 ≤ d’(s, u)+ 1 &#x3D; d’(s, v)  &lt; d(s, v)$，即</p><p>(5)    $d(s, u) + 1 &lt;  d(s, v)$ </p><p>(4) 是由 2.1.3 的假设得到的，与由 (1), (2), (3) 得到的 (5) 矛盾，故在 2.1.1 假设成立的前提下，2.1.3 的假设 $(u, v) ∈ E_f$ 不成立，即 $(u, v) ∉ E_f$。同时我们还能看到，如果一开始证明的是 $d’(s, v) &gt; d(s, v)$，那么就要反证 $d’(s, v) ≤ d(s, v)$ (对应式(1))，经过同样的过程当前的式 (5) 会变为 $d(s, u) + 1 ≤  d(s, v)$，将推导不出与 (4) 式的矛盾（因为都有一个等号）。</p></li><li><p>由上述知 $(u, v) ∉ E_f$，但如 2.1.2 所述，$(u, v) ∈ E_{f’}$ ，故在 $G_f$ 上的增广必定经过了 $(v, u)$，且此边饱和，导致在 $G_{f’}$ 中产生了反向边 $(u, v)$。于是可知在 $G_f$ 中有</p><p>(6)    $d(s, u) &#x3D; d(s, v) + 1$</p></li></ol><p>(6) 与 (5) 矛盾，于是最初 2.1.1 的假设不成立，即不存在这样的顶点 $v$，也即增广操作使得源点到任意一点 $v$ 的长度 <strong>非递减</strong>， <strong>故EK算法寻找的增广路长度非递减</strong>。</p><br /><h6 id="2-2-增广次数"><a href="#2-2-增广次数" class="headerlink" title="2.2 增广次数"></a>2.2 增广次数</h6><ol><li><p>假设某次 $G_f$ 的增广中 $(u, v)$ 为饱和边，增广后 $(u, v) ∉ E_{f’}$，$(v, u) ∈ E_{f’}$。之后 $(u, v)$ 要再次出现的前提是 $(v, u)$ 在增广路上。在 $G_f$ 中  $(u, v)$ 第一次成为饱和边时有</p><p>(7)    $d(s, v) &#x3D; d(s, u) + 1$</p></li><li><p>若 $(u, v)$ 第二次成为饱和边，可知在此前的 $G_{f’}$ 中 $(v, u)$ 中在增广路上，在 $G_{f’}$ 的这次增广中有</p><p>(8)    $d’(s, u) &#x3D; d’(s, v) + 1$</p></li><li><p>由 2.1 的结论，$s$ 到任意顶点的最短路径非递减，即必有 $d’(s, v)  ≥ d(s, v)$ ，结合 (7) 和 (8)，有</p><p>$d’(s, u) &#x3D; d’(s, v) + 1 ≥ d(s, v) + 1 &#x3D; d(s, u)+ 2$，即</p><p>(9)    $d’(s, u)   ≥ d(s, u) + 2$</p></li></ol><p>也就是说，$(u, v)$ 第二次成为饱和边时 $s$ 到 $u$ 的最短距离至少比前一次成为饱和边时大 2。而 $s$ 到任意顶点的距离最多不超过$|V| - 1$，故 $(u, v)$ 可以成为饱和边的次数最多为 $(|V| - 1) &#x2F; 2$。每次增广至少有一条边成为饱和边，根据 2.1 中的说明，EK算法过程中边数 $&lt; 2|E|$，故考虑 <strong>所有边的总的增广次数必小于</strong> $2|E|*(|V| - 1)&#x2F;2$，即 **增广次数复杂度为 $O(|V||E|)$**。</p><br /><p><strong>综上，EK 算法复杂度为 $O(|V||E|^2)$。</strong></p><p>证明过程中 <strong>BFS增广使得增广路长度非递减</strong> 的结论是关键，网上有的文章声称 BFS 寻找增广路的操作使得增广路长度递增，但我们已经在 2.1.3 的叙述中指出这是不对的。根据 2.1 的证明，只能得到 <strong>非递减</strong> 的结果，但这一结论在 2.2 中足以证明任意边第二次成为饱和边时其最短路径长至少增加2，由此得到BFS次数的上界。</p><p>空间复杂度：存图空间为 $O(|V|+|E|)$ ，队列空间为 $O(|V|)$ 。总体时间复杂度为 $O(|V|+|E|)$ 。</p><br /><h4 id="代码-14"><a href="#代码-14" class="headerlink" title="代码"></a>代码</h4><p>现给出 EK 算法解决 P3376 【模板】网络最大流 一题的代码（通过）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// edmonds-karp</span></span><br><span class="line"><span class="keyword">package</span> com.yukiyama.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EK</span> &#123;</span><br><span class="line">    <span class="type">boolean</span>[] visited;</span><br><span class="line">    <span class="type">int</span>[] ends, heads, nexts, weights, preEdges, pre, saturatedWeights;</span><br><span class="line">    <span class="type">int</span> edgeNum;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">cin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cin.nextInt(), m = cin.nextInt(), s = cin.nextInt() - <span class="number">1</span>, t = cin.nextInt() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">EK</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EK</span>();</span><br><span class="line">        demo.visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">        demo.ends = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span> * m + <span class="number">2</span>];</span><br><span class="line">        demo.nexts = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span> * m + <span class="number">2</span>];</span><br><span class="line">        demo.weights = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span> * m + <span class="number">2</span>];</span><br><span class="line">        demo.preEdges = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        demo.heads = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        demo.pre = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        demo.saturatedWeights = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        demo.edgeNum = <span class="number">1</span>; <span class="comment">// 初始为1，使得第一条边的编号为2，二进制为 10，第二条边(第一条边的反向边)编号为3，二进制为11，方便取异或</span></span><br><span class="line">        demo.init(m, cin); <span class="comment">// 建图</span></span><br><span class="line">        cin.close();</span><br><span class="line">        System.out.println(demo.ek(s, t)); <span class="comment">// 求最大流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 求 s-t 最大流</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">ek</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(bfs(s, t)) &#123; <span class="comment">// 不断增广</span></span><br><span class="line">            max += update(s, t); <span class="comment">// 将每次增广路带来的流量增加到maxFlow上</span></span><br><span class="line">            Arrays.fill(visited, <span class="literal">false</span>); <span class="comment">// 重置 visited</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 链式向前星建图</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(<span class="type">int</span> m, Scanner cin)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> cin.nextInt() - <span class="number">1</span>, v = cin.nextInt() - <span class="number">1</span>, weight = cin.nextInt();</span><br><span class="line">            ++edgeNum;</span><br><span class="line">            ends[edgeNum] = v;</span><br><span class="line">            weights[edgeNum] = weight;</span><br><span class="line">            nexts[edgeNum] = heads[u]; </span><br><span class="line">            heads[u] = edgeNum;</span><br><span class="line">            ++edgeNum;</span><br><span class="line">            ends[edgeNum] = u;</span><br><span class="line">            weights[edgeNum] = <span class="number">0</span>;</span><br><span class="line">            nexts[edgeNum] = heads[v]; </span><br><span class="line">            heads[v] = edgeNum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// bfs 增广</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">bfs</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == t) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 特判</span></span><br><span class="line">        Queue&lt;Integer&gt; q = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        q.add(s); <span class="comment">// 起始顶点入队</span></span><br><span class="line">        visited[s] = <span class="literal">true</span>; <span class="comment">// 立即置为已访问</span></span><br><span class="line">        saturatedWeights[s] = Integer.MAX_VALUE; <span class="comment">// 增广路径到达 s 为止的饱和边权置为INF</span></span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> q.remove();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">edgeNo</span> <span class="operator">=</span> heads[u]; edgeNo != <span class="number">0</span>; edgeNo = nexts[edgeNo]) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> ends[edgeNo], weight = weights[edgeNo];</span><br><span class="line">                <span class="keyword">if</span>(visited[v] || weight == <span class="number">0</span>) <span class="keyword">continue</span>; <span class="comment">// 跳过已访问或边权为0的情况</span></span><br><span class="line">                saturatedWeights[v] = Math.min(saturatedWeights[u], weight); <span class="comment">// 记录到 v 为止的饱和边权</span></span><br><span class="line">                q.add(v); <span class="comment">// v入队</span></span><br><span class="line">                visited[v] = <span class="literal">true</span>; <span class="comment">// 立即置为已访问</span></span><br><span class="line">                preEdges[v] = edgeNo; <span class="comment">// 记录边下标</span></span><br><span class="line">                pre[v] = u; <span class="comment">// 记录前驱</span></span><br><span class="line">                <span class="keyword">if</span>(v == t) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 找到增广路</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 发送 &amp; 发回流</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> t;</span><br><span class="line">        <span class="keyword">while</span>(cur != s) &#123; </span><br><span class="line">            <span class="type">int</span> <span class="variable">edge</span> <span class="operator">=</span> preEdges[cur];</span><br><span class="line">            weights[edge] -= saturatedWeights[t]; <span class="comment">// 增广路发送流</span></span><br><span class="line">            weights[edge ^ <span class="number">1</span>] += saturatedWeights[t]; <span class="comment">// 反向增广路发回流</span></span><br><span class="line">            cur = pre[cur];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> saturatedWeights[t];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h3 id="Dinic-Dinitz"><a href="#Dinic-Dinitz" class="headerlink" title="Dinic (Dinitz)"></a>Dinic (Dinitz)</h3><h4 id="算法描述-14"><a href="#算法描述-14" class="headerlink" title="算法描述"></a>算法描述</h4><p><a href="https://en.wikipedia.org/wiki/Dinic%27s_algorithm">Dinic算法 (迪尼克算法)</a>：EK 算法以 $bfs$ 方式实现 FF 方法中的增广操作，在 Dinic 算法中，采用 $bfs$ 与 $dfs$ 结合的方式增广。首先引进 <strong>高度标号 (层次标号)</strong> 和 <strong>分层图</strong> 的概念。以 $bfs$ 算法从 $s$ 到 $t$ ，标记 $s$ 为第 1 层，$s$ 的邻接顶点为第 2 层，以此类推 $t$ 为最后一层。执行一次 $bfs$，赋予每个顶点高度标号信息，此时的图称作分层图。在此分层图内以 $dfs$ 方式反复寻找增广路并执行增广操作 (找到饱和边，发送和发回流)，累计发送流。完成当前分层图的所有增广操作称作 <strong>一个阶段</strong> ，一个阶段的发送流总和为此分层图的 <strong>阻塞流</strong> 。一个阶段结束后，将此阶段阻塞流累计到最大流中，接着重置高度标号信息，再次执行 $bfs$ 得到新的分层图并重复 $dfs$ 的增广操作，直到无法分层时说明 $s$ 到 $t$ 已无增广路，算法结束，此时得到的阻塞流总和即为 $s$ 到 $t$ 的最大流。</p><p>高度标号的作用：在以 $dfs$ 增广时，每次从顶点 $u$ 到其邻接顶点 $v$ 的路径增长，都要考察 $v$ 的的高度是否比 $u$ 的高度大 1，以此来保证路径总是能 <strong>按步增长到最后一层</strong> 的 $t$ (在有增广路的前提下)。</p><br /><h4 id="算法过程-15"><a href="#算法过程-15" class="headerlink" title="算法过程"></a>算法过程</h4><p>给定一张图 $G(V, E)$ ，源点为 $s$ ，汇点为 $t$ 。求 $G$ 中从 $s$ 到 $t$ 的最大流 $f$ 。</p><ol><li>设置一张残留网络 (残留图&#x2F;残差图&#x2F;残余图) $G_f$ ，$G_f$ 初始为 $G$ 。</li><li>调用 $bfs$ 方法，赋予 $G_f$ 中所有顶点以高度标号，建立当前分层图。注意在赋予高度时会先判断是否已赋过值，若有则跳过，因此顶点高度不会因为它处于多个层次而被较高的高度值覆盖，即一个顶点的高度是是它离源点最近的高度。此方法返回布尔值，有分层图 (即有增广路) 时返回 $true$ ，否则返回 $false$ 。</li><li>求增广路发送流。以 $dfs$ 方法搜索 $s$ 到 $t$ 的增广路 $p$ ，并实时地发送 &#x2F; 发回流，返回值为本次增广路发送流 (饱和边权 $c$)。在方法中比较当前边与上一条边的边权，取较小者，并将此取值作为递归 $dfs$ 方法的入参 (具体看代码)。若存在 $p$ ，也即递归调用到基本情形 (遇到 $t$ )，以当前边权减去 $c$ ，当前边的反向边权加上 $c$ ，然后返回 $c$ 。</li><li>求阻塞流。反复求上述增广路发送流，并累积到当前分层图阻塞流中。在步骤 3 中，当前分层图完成所有增广由于已无增广路，不会递进到基本情形 (不会遇到 $t$ )，返回 0 且层层返回 0，于是发送流不大于 0，此时即可返回当前分层图的阻塞流。</li><li><strong>累计分层图阻塞流，清空所有顶点的高度标号信息</strong> ，再次调用 $bfs$ 方法建立当前分层图，重复 2、3、 4，直到建立分层图的 $bfs$ 方法返回 $false$，表明当前图无法分层，即 $s$ 到 $t$ 无增广路，算法结束。此时 $s$ 到 $t$ 的最大流。</li></ol><br /><h4 id="实例分析-1"><a href="#实例分析-1" class="headerlink" title="实例分析"></a>实例分析</h4><p>以下图为例，增广过程如下：</p><p><img src="https://pic.leetcode-cn.com/1655469220-NCwrkb-image.png" alt="image.png"></p><p>第一次：$s&gt;a&gt;c&gt;t,$  找到增广路后 $return$，得到饱和边权 ，修改当前边正向和反向边权后 $return$，再次修改当前边的正向和反向边权后 $return$ (层层返回并修改边权)，$t&gt;c&gt;a&gt;s$ 后得到本次增广路发送流为 2 。整体的顶点访问顺序为 $s&gt;a&gt;c&gt;t&gt;c&gt;a&gt;s$ 。</p><p>第二次：$s&gt;a&gt;c$ ，发现 $(c, t)$ 边权为 0，不满足邻边边权要大于 0 的条件，找 $a$ 的下一个满足层号关系的邻接顶点 $d$ ，然后 $d&gt;t$ ，同上，找到增广路后在$return$ 过程中修改正反向边权，$t&gt;d&gt;a&gt;s$ 后得到本次增广路发送流为 1 。整体的顶点访问顺序为 $s&gt;a&gt;c&gt;d&gt;t&gt;d&gt;a&gt;s$ 。</p><p>第三次：从 $s$ 开始，发现 $(s, a)$ 边权为 0，不满足邻边边权要大于 0 的条件，找 $s$ 的下一个满足层号关系的邻接顶点 $b$ ，然后 $b&gt;d&gt;t$ ，同上，找到增广路后在 $return$ 过程中修改正反向边权，$t&gt;d&gt;b&gt;s$ 后得到本次增广路发送流为 $2$ 。整体的顶点访问顺序为 $s&gt;b&gt;d&gt;t&gt;d&gt;b&gt;s$ 。</p><p>第四次：从 $s$ 开始，$for$ 循环遍历所有邻接顶点均不满足邻边边权要大于 0 的条件，返回 0 ，得到最终结果当前分层图阻塞流 5。</p><br /><h4 id="时空复杂度-18"><a href="#时空复杂度-18" class="headerlink" title="时空复杂度"></a>时空复杂度</h4><p>以下证明 Dinic 算法时间复杂度为：$O(|V|^2|E|)$</p><blockquote><p> 如下证明参考了<a href="https://courses.cs.duke.edu/fall19/compsci638/fall19_notes/lecture3.pdf">COMPSCI 638: Graph Algorithms, Lecture3</a>。</p></blockquote><h5 id="1-BFS建立分层图"><a href="#1-BFS建立分层图" class="headerlink" title="1. BFS建立分层图"></a>1. BFS建立分层图</h5><p>时间复杂度为 $O(|E|)$ ，可参考无权最短路径复杂度分析，略。</p><h5 id="2-一次DFS增广"><a href="#2-一次DFS增广" class="headerlink" title="2. 一次DFS增广"></a>2. 一次DFS增广</h5><p>在分层图中，由于高度标号加一的判断条件限制， $dfs$ 只能沿着高度递增的方向从 $s$ 到 $t$ 推进，因此单次 $dfs$ 推进次数最多不超过 $|V|-1$ 次，时间复杂度为 $O(|V|)$。</p><h5 id="3-一个阶段中DFS增广次数"><a href="#3-一个阶段中DFS增广次数" class="headerlink" title="3. 一个阶段中DFS增广次数"></a>3. 一个阶段中DFS增广次数</h5><p>在分层图中，每次 $dfs$ 增广的结果使得一条高度递增方向上的饱和边 $(u, v)$ 消失，此边的反向边 $(v, u)$ 增加。如前述，<strong>增广路只能沿着高度递增的方向</strong>，而同一阶段内(同一张分层图中)反向边是沿着高度递减方向增加的。$(u, v)$ 消失后再次出现的条件是 $(v, u)$ 为此后某次增广路上的饱和边。<strong>再次强调</strong>，在 <strong>同一阶段内</strong> (同一张分层图中)，$(v, u)$方向是<strong>高度递减</strong>的，不可能出现在增广路上，因此一条高度递增边 $(u, v)$ 被删除后不会再次出现。一次增广至少令一条高度递增边饱和并删除，高度递增边数量不大于$|E|$，于是 **一个阶段内 $dfs$ 的次数最多为 $|E|$，即 $O(|E|)$<strong>。结合 2 可知，</strong>一个阶段的总复杂度为单次 $dfs$ 的复杂度与 $dfs$ 次数的乘积，即 $O(|V||E|)$**。</p><h5 id="4-阶段数-分层图建立次数"><a href="#4-阶段数-分层图建立次数" class="headerlink" title="4. 阶段数 (分层图建立次数)"></a>4. 阶段数 (分层图建立次数)</h5><p><strong>此证明是难点。</strong> 如前述，在层高递增条件的限制下，$s - t$ 最短路径长度即 $t$ 的层高，因此最短路径最大不超过 $|V| - 1$。如果能证明每次分层图使得 $s - t$ 最短路径长 <strong>「严格」递增</strong> ，则立即推出阶段数(分层图建立次数)的上限为 $|V|$，复杂度为 $O(|V|)$。最短路径长严格递增的证明如下。</p><p>令相邻的两次分层图为 $G_f$  和 $G_{f’}$ ，以 $d(u, v)$ 和 $d’(u, v)$ 分别表示$G_f$  和 $G_{f’}$ 中的 $u$ 到 $v$ 的最短距离。</p><ol><li><p>由 <a href="https://leetcode-cn.com/circle/discuss/tN3sZc/">Edmonds-Karp算法复杂度证明</a> 已知 (这一点很重要)，删正向边加反向边的操作，使得<strong>源点 $s$ 到任意一点 $u$ 的距离是非递减</strong>的，即 <strong>必有</strong> $d’(s, u) ≥ d(s, u)$。对证明过程稍加改造很容易得到一个对汇点 $t$ 来说类似的结论，即删正向边加反向边的操作，使得任意一点 $u$ 到汇点 $t$ 的距离是非递减的，即 <strong>必有</strong> $d’(u, t) ≥ d(u, t)$。</p><p>(1)    $d’(s, u) ≥ d(s, u)$</p><p>(2)    $d’(u, t) ≥ d(u, t)$</p></li></ol><p>对于 $s - t$ 来说有 $d’(s, t) ≥ d(s, t)$。接下来的证明目标是<strong>拿掉该不等式中的等号</strong>，证明 $G_{f’}$ 相比 $G_f$，严格地有 $d’(s, t) &gt; d(s, t)$。可用<strong>反证法证明不可能取等号</strong>。</p><ol start="2"><li><p><strong>假设 $d’(s, t) ≥ d(s, t)$ 可以取到等号</strong>。<br>若$G_{f’}$ 有一条 $s$ 到 $t$ 的最短路径 $f’$，则一定存在边 $(x, y) ∈ E_{f’}$，是 $G_f$ 某条增广路饱和边的反向边。因为如果 $E_{f’}$ 都是 $G_f$ 中存在的边，由于 $d’(s, t) &#x3D; d(s, t)$，这样的 $f’$ 路径在 $G_f$ 中就<strong>一定</strong>已经被找到了。因此在 $G_f$ 中有 $(y, x) ∈ E_f$ ，于是有</p><p>(3)    $d(s, x) &#x3D; d(s, y) + 1$</p></li></ol><p><img src="https://pic.leetcode-cn.com/1655469138-CjXTPz-image.png" alt="image.png"></p><ol start="3"><li><p>由 (1) 和 (2) 易知</p><p>(4)    $d’(s, x) ≥ d(s, x)$  </p><p>(5)    $d’(y, t) ≥ d(y, t)$</p></li><li><p>$f’$ 路径长可写成 $d’(s, t) &#x3D; d’(s, x) + 1 + d’(y, t)$ ，应用 (4) 和 (5) 得到</p><p>$d’(s, t) &#x3D; d’(s, x) + 1 + d’(y, t) ≥ d(s, x) + 1 + d(y, t)$ </p><p>又由 (3) 得到</p><p>$d’(s, t) &#x3D; d’(s, x) + 1 + d’(y, t) ≥ d(s, x) + 1 + d(y, t) &#x3D; d(s, y) + d(y, t) + 2$</p><p>即</p><p>(6)    $d’(s, t) ≥ d(s, t) + 2$</p></li></ol><p>由此，$d’(s, t) &#x3D; d(s, t)$ 的假设不成立，但我们知道 $d’(s, t) ≥ d(s, t)$ ，因此有 $d’(s, t) &gt; d(s, t)$ ，也即证明了 <strong>Dinic 算法中下一分层图的最短路径长度与前一分层图相比严格递增</strong>。</p><br /><p>综上，总时间复杂度为每个阶段建立分层图的复杂度 $O(|E|)$ 与在该分层图内执行的总 $dfs$ 复杂度 $O(|V||E|)$ 之和乘以阶段数 $O(|V|)$，为 $O((|E|+|V||E|)*|V|)$，即 $O(|V|^2|E|)$。</p><br /><p>空间复杂度：采用邻接表存图，则存图空间为 $O(|V|+|E|)$ ，采用邻接矩阵为 $O(|V|^2)$ 。 $bfs$ 中的队列为 $O(|V|)$ ， $dfs$ 中的递归栈为 $O(|V|)$ 。总体来说取决于存图方式。</p><br /><h4 id="代码-15"><a href="#代码-15" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TODO</span></span><br></pre></td></tr></table></figure><br /><h2 id="实战应用"><a href="#实战应用" class="headerlink" title="实战应用"></a>实战应用</h2><p>给出以下图论相关题目及作者写的题解，供读者在阅读本文后自练自查。</p><p>※ 不断更新中。</p><table><thead><tr><th>题目</th><th>难度</th><th>题解</th></tr></thead><tbody><tr><td><a href="https://leetcode.cn/problems/number-of-connected-components-in-an-undirected-graph/">323. 无向图中连通分量的数目</a></td><td>中等</td><td><a href="https://leetcode.cn/problems/number-of-connected-components-in-an-undirected-graph/solution/by-yukiyama-y5l4/">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/number-of-provinces/">547.省份数量</a></td><td>中等</td><td><a href="https://leetcode.cn/problems/number-of-provinces/solution/by-yukiyama-mh7f/">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/number-of-islands/">200.岛屿数量</a></td><td>中等</td><td><a href="https://leetcode.cn/problems/number-of-islands/solution/by-yukiyama-jkd6/">题解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/max-area-of-island/">695. 岛屿的最大面积</a></td><td>中等</td><td><a href="https://leetcode.cn/problems/max-area-of-island/solution/by-yukiyama-0mrt/">题解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/is-graph-bipartite/">785. 判断二分图</a></td><td>中等</td><td><a href="https://leetcode.cn/problems/is-graph-bipartite/solution/by-yukiyama-yoc0/">题解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/redundant-connection/">684. 冗余连接</a></td><td>中等</td><td><a href="https://leetcode.cn/problems/redundant-connection/solution/-by-yukiyama-mlqi/">题解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/path-with-minimum-effort/">1631. 最小体力消耗路径</a></td><td>中等</td><td><a href="https://leetcode.cn/problems/path-with-minimum-effort/solution/yukiyama-by-yukiyama-qboz/">题解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/longest-increasing-path-in-a-matrix/">329. 矩阵中的最长递增路径</a></td><td>困难</td><td><a href="https://leetcode.cn/problems/longest-increasing-path-in-a-matrix/solution/by-yukiyama-d7bv/">题解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/course-schedule/">207. 课程表</a></td><td>中等</td><td><a href="https://leetcode.cn/problems/course-schedule/solution/yukiyama-by-yukiyama-lbz3/">题解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/course-schedule-ii/">210. 课程表 II</a></td><td>中等</td><td><a href="https://leetcode.cn/problems/course-schedule-ii/solution/-by-yukiyama-9scu/">题解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/alien-dictionary/">269. 火星词典</a></td><td>困难</td><td><a href="https://leetcode.cn/problems/alien-dictionary/solution/by-yukiyama-2cam/">题解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/sequence-reconstruction/">444. 序列重建</a></td><td>中等</td><td><a href="https://leetcode.cn/problems/sequence-reconstruction/solution/by-yukiyama-a371/">题解</a></td></tr><tr><td>814.无向图中的最短路径 (其他平台题目)</td><td>中等</td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/network-delay-time/">743. 网络延迟时间</a></td><td>中等</td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/">1334. 阈值距离内邻居最少的城市</a></td><td>中等</td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/connecting-cities-with-minimum-cost/">1135. 最低成本联通所有城市</a></td><td>中等</td><td></td></tr></tbody></table><table><thead><tr><th>题目</th><th>UF</th><th>BFS&#x2F;DFS</th><th>Topo</th><th>SP</th><th>MST</th><th>MF</th></tr></thead><tbody><tr><td><a href="https://leetcode.cn/problems/number-of-connected-components-in-an-undirected-graph/">323</a></td><td>〇</td><td>〇</td><td></td><td></td><td></td><td></td></tr><tr><td><a href="https://leetcode-cn.com/problems/number-of-provinces/">547</a></td><td>〇</td><td>〇</td><td></td><td></td><td></td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/number-of-islands/">200</a></td><td>〇</td><td>〇</td><td></td><td></td><td></td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/max-area-of-island/">695</a></td><td>〇</td><td>〇</td><td></td><td></td><td></td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/is-graph-bipartite/">785</a></td><td>〇</td><td>〇</td><td></td><td></td><td></td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/redundant-connection/">684</a></td><td>〇</td><td>〇</td><td></td><td></td><td></td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/path-with-minimum-effort/">1631</a></td><td>〇</td><td>〇</td><td></td><td>〇</td><td></td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/longest-increasing-path-in-a-matrix/">329</a></td><td></td><td>〇</td><td>〇</td><td></td><td></td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/course-schedule/">207</a></td><td></td><td>〇</td><td>〇</td><td></td><td></td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/course-schedule-ii/">210</a></td><td></td><td>〇</td><td>〇</td><td></td><td></td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/alien-dictionary/">269</a></td><td></td><td>〇</td><td>〇</td><td></td><td></td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/sequence-reconstruction/">444</a></td><td></td><td>〇</td><td>〇</td><td></td><td></td><td></td></tr><tr><td>814</td><td></td><td></td><td></td><td>〇</td><td></td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/network-delay-time/">743</a></td><td></td><td></td><td></td><td>〇</td><td></td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/">1334</a></td><td></td><td></td><td></td><td>〇</td><td></td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/connecting-cities-with-minimum-cost/">1135</a></td><td></td><td></td><td></td><td></td><td>〇</td><td></td></tr></tbody></table><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">UF: Union-Find 并查集</span><br><span class="line">FS: DFS &amp; BFS 深搜和广搜</span><br><span class="line">Topo: Topological Sort 拓扑排序</span><br><span class="line">SP: Shortest Path 最短路</span><br><span class="line">MST: Minimum Spanning Tree 最小生成树</span><br><span class="line">MF: Maximum Flow 最大流</span><br><span class="line"></span><br><span class="line">标记 〇 表示该题与该算法相关。</span><br></pre></td></tr></table></figure><br /><hr><p>【更新日志】</p><p>[2022-07-17]</p><ul><li>大幅修改了「最大流最小割定理」中的「证明 $k&#x3D;m$」小节的内容，修正了前一天发现的证明过程中的错误 (结论正确，过程有误)。虽然作者认为修正后的证明是正确的，但如果读者仍觉得有问题，还请评论或私信联系。</li></ul><p>[2022-07-16]</p><ul><li>在「最大流最小割定理」一节的「最小割的大小」小节中，原文称「现在我们来指出一个 $l &#x3D; 4$ 的割 …. …. 就得到了原图的一个大小为 4 的 $s-t$ 割」。根据原文的描述，似乎无法指出大小为 4 的割。这个部分有待更正，目前还在思考。。。暂时先以删除线划去，并注明证明暂不成立。</li><li>在「Edmonds-Karp」-「时间复杂度」-「2.2 增广次数」中，原文称「…之后 $(u, v)$ 要再次出现的前提是 $(v, u)$ 为饱和边…」，这是错误的。正确表述是「…之后 $(u, v)$ 要再次出现的前提是 $(v, u)$ 为 <strong>增广路上的边</strong> …」，后续论证仍然成立。</li><li>上述两点均由 <a href="/u/migeater/">@migeater</a> 指出，非常感谢！🙏</li></ul><p>[2022-07-01]</p><ul><li>在「链式向前星」中增加图示及若干补充描述。</li></ul><p>[2022-06-20]</p><ul><li>新增「网络流」一节。</li></ul><p>[2022-06-19]</p><ul><li>在「图的表示」一节中新增「链式向前星」小节，并在后续代码中给出此存图方式的代码实例。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法与数据结构 </tag>
            
            <tag> 图论算法 </tag>
            
            <tag> 最短路径 </tag>
            
            <tag> 最大流 </tag>
            
            <tag> 最小生成树 </tag>
            
            <tag> bfs </tag>
            
            <tag> dfs </tag>
            
            <tag> 拓扑排序 </tag>
            
            <tag> Dijkstra </tag>
            
            <tag> Beallman-Ford </tag>
            
            <tag> SPFA </tag>
            
            <tag> Floyd-Warshall </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并查集从入门到出门</title>
      <link href="/2022/06/10/%E5%B9%B6%E6%9F%A5%E9%9B%86%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%87%BA%E9%97%A8/"/>
      <url>/2022/06/10/%E5%B9%B6%E6%9F%A5%E9%9B%86%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%87%BA%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="今天，就由你来发明并查集"><a href="#今天，就由你来发明并查集" class="headerlink" title="今天，就由你来发明并查集"></a>今天，就由你来发明并查集</h1><blockquote><ul><li><p>可在作者的 <a href="https://github.com/iyukiyama/leetcode-posts">github仓库</a> 中获取本文和其他文章的 markdown 源文件及相关代码。</p></li><li><p>欢迎评论或仓库 PR 指出文章错漏或与我讨论相关问题，我将长期维护所有文章。</p></li><li><p>所有文章均用 Typora 完成写作，可使用 Typora 打开文章 md 文件，以获得最佳阅读体验。</p></li></ul></blockquote><p>⚠️ ⚠️ ⚠️ <strong>本文较长，正文一万两千字 (不含题解) ，尝试展现如何从零开始发明并查集。</strong></p><p>❗️ <strong>【NEW】</strong> ❗️</p><ul><li>9-15:  <a href="https://leetcode.cn/circle/discuss/SwgIJV/">红黑树从入门到看开</a></li></ul><hr><blockquote><p>$keywords$ :</p><p>从零发明并查集 &#x2F; 连通分量 &#x2F; 查询与合并 &#x2F; 按大小求并 &#x2F; 按秩(高度)求并 &#x2F; 路径压缩 &#x2F; 负数技巧 &#x2F; 反阿克曼函数</p></blockquote><p>前几天 (20220509) 在讨论区发了篇文章 <a href="https://leetcode.cn/circle/discuss/ooxfo8/">二分查找从入门到入睡</a> ，得到了蛮不错的反馈，这让我感觉到基础知识的总结和分享很有价值。从前一篇文章的点赞和一些评论中我还发现，虽然我们在力扣上总能看到一些知名 ID 的题解题评，<strong>但像我这样的小白用户才是大多数</strong> ，因此我想尝试多分享一些主要面向小白的，我用心总结过的（也许是微不足道的）心得，于是有了这篇文章。</p><p>并查集以简单高效著称，理解起来并没有太大的难度，但如果只是 <strong>「输入式」</strong> 地学习，初学时总会觉得不够透彻，尤其是 <strong>「路径压缩」</strong> ，以及 <strong>「秩」</strong> 的准确内涵。就好比你知道怎么写 $Dijkstra$ ，但你没有推导过一遍 <a href="https://leetcode.cn/circle/discuss/jJQn7V/">该算法的正确性</a> ，你做起题来就总是不踏实。所以本文尝试以 <strong>「启发式」</strong> 的方式讲解，让初学者真正地从思考一个具体的问题开始，从无到有逐步创造一种数据结构解决之（当然并不是真的从零开始，你得知道链表、树、递归等基础知识）。原本你跟着一般教材，比如我手边的 Weiss 那本 <a href="https://awesome-programming-books.github.io/algorithms/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9AJava%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0.pdf">数据结构与算法分析：Java语言描述</a> ，可能需要消化个一两天才能对并查集有掌控感，但我希望通过这篇文章把这个时间压缩到一两个小时之内（毕竟是你在全程发明并查集😄）。对于已经熟悉并查集，甚至是用并查集解决过不少问题的人，这篇文章可能也有一些看点。比如对于如下问题，如果你对自己的答案还有些犹疑的话，可以看看本文。</p><blockquote><p>问题1: 为什么带路径压缩的并查集中基于高度的求并称作「按秩求并」而非「按高度求并」？可否给出严谨的说明？<br>问题2: 求并时比较大小或比较秩，总是通过两棵树的根的大小或秩比较，而且一次只比较两个根，随着合并的进行，根逐渐变少，大小数组或秩数组的大部分空间似乎没用到，你能优化这部分空间吗？</p></blockquote><p>正文部分将从基本概念入手，呈现并查集的基本样貌，包括其适用的 <strong>问题特征</strong> ，<strong>「查询」</strong> 和 <strong>「合并」</strong> 是怎么想到的，如何从「简单查询」和「简单求并」得到的基本并查集中看到优化方向，并实现一个优化后的查询，即 <strong>「带路径压缩的查询」</strong> ，以及两个优化后的求并，即 <strong>「按大小求并」</strong> 和 <strong>「按秩 (高度) 求并」</strong> 。我还会准确地指出 <strong>「秩」的内涵</strong> 以回答上述「问题1」，并在文章末尾介绍一种 <strong>无需大小或秩数组空间的技巧</strong> 以回答上述「问题2」。最后会在「实战应用」中给出十几道题目的并查集解法，以便读者自查。</p><br /><p><strong>本文标题</strong> 意在表达作者的一种希望，即期待对并查集不太熟悉的你，在看完本文后能够 <strong>完全掌握</strong> 这一数据结构，且能够快速做完相关题目，<strong>出门</strong> 享受这个暮春（写于2022年暮春）。本文曾发布在个人知乎专栏中，也授权一位朋友发表在他自己的公众号上过。但我从读者的角度，以所谓 <strong>「独立发明」并查集</strong> 的视角出发，用一种全新的「冷幽默」写作风格（自封的），几乎重写了一遍。</p><p><strong>为了说得更透彻，文章依旧是话痨风。文中若有疏漏之处，还希望大家不吝赐教，你所指出的文章中的任何错误我都会及时更正。下面我们开始发明并查集的旅程。</strong></p><hr><p>yuki的其他文章如下，欢迎阅读指正！</p><blockquote><p>如下所有文章同时也在我的 github <a href="https://github.com/iyukiyama/leetcode-posts">仓库</a> 中维护。</p></blockquote><table><thead><tr><th>文章</th><th>[发布时间] 字数&#x2F;览&#x2F;藏&#x2F;赞 (~2022-10-20)</th></tr></thead><tbody><tr><td><a href="https://leetcode.cn/circle/discuss/eBo9UB/">十大排序从入门到入赘</a>  🔥🔥🔥</td><td>[20220516]  2.5万字&#x2F;64.8k览&#x2F;3.7k藏&#x2F;937赞</td></tr><tr><td><a href="https://leetcode.cn/circle/discuss/ooxfo8/">二分查找从入门到入睡</a> 🔥🔥🔥</td><td>[20220509]  2.3万字&#x2F;38.4k览&#x2F;2.1k藏&#x2F;503赞</td></tr><tr><td><a href="https://leetcode.cn/circle/discuss/qmjuMW/">并查集从入门到出门</a> 🔥🔥</td><td>[20220514]  1.2万字&#x2F;17.9k览&#x2F;1.0k藏&#x2F;321赞</td></tr><tr><td><a href="https://leetcode.cn/circle/discuss/FyPTTM/">图论算法从入门到放下</a> 🔥🔥</td><td>[20220617]  5.6万字&#x2F;19.9k览&#x2F;1.3k藏&#x2F;365赞</td></tr><tr><td>树ADT系列 (预计13篇)</td><td>系列文章，连载中</td></tr><tr><td>3. <a href="https://leetcode.cn/circle/discuss/wPzlSb/">二叉查找树</a></td><td>[20220801]  5千字</td></tr><tr><td>4. <a href="https://leetcode.cn/circle/discuss/zbwD3p/">AVL树</a></td><td>[20220817]  5千字</td></tr><tr><td>5. <a href="https://leetcode.cn/circle/discuss/BCK17f/">splay树</a></td><td>[20220817]  5千字</td></tr><tr><td>6. <a href="https://leetcode.cn/circle/discuss/SwgIJV/">红黑树从入门到看开</a> 🔥🤯🤯🤯</td><td>[20220915]  3万字&#x2F;5.3k览&#x2F;269藏&#x2F;72赞</td></tr><tr><td>10. <a href="https://leetcode.cn/circle/discuss/qGREiN/">树状数组从入门到下车</a> 🔥🤯</td><td>[20220722]  1.4万字&#x2F;5.8k览&#x2F;196藏&#x2F;72赞</td></tr><tr><td>11. <a href="https://leetcode.cn/circle/discuss/H4aMOn/">线段树从入门到急停</a> 🔥🤯</td><td>[20220726]  2.5万字&#x2F;8.7k览&#x2F;481藏&#x2F;138赞</td></tr><tr><td><a href="https://leetcode.cn/circle/discuss/GV0JrV/">图论相关证明系列</a></td><td>系列文章</td></tr><tr><td>1. <a href="https://leetcode.cn/circle/discuss/jJQn7V/">Dijkstra正确性证明</a> 🤯</td><td>[20220531]</td></tr><tr><td>2. <a href="https://leetcode.cn/circle/discuss/VVEc8f/">Prim正确性证明</a> 🤯</td><td>[20220919]</td></tr><tr><td>3. <a href="https://leetcode.cn/circle/discuss/xeEwYl/">Bellman-Ford及SPFA正确性证明</a></td><td>[20220602]</td></tr><tr><td>4. <a href="https://leetcode.cn/circle/discuss/Nbzix4/">Floyd正确性证明</a></td><td>[20220602]</td></tr><tr><td>5. <a href="https://leetcode.cn/circle/discuss/tMIy36/">最大流最小割定理证明</a> 🤯🤯</td><td>[20220719]</td></tr><tr><td>6. <a href="https://leetcode.cn/circle/discuss/tN3sZc/">Edmonds-Karp复杂度证明</a> 🤯🤯</td><td>[20220515]</td></tr><tr><td>7. <a href="https://leetcode.cn/circle/discuss/T9Xa1R/">Dinic复杂度证明</a> 🤯🤯</td><td>[20220531]</td></tr></tbody></table><hr><p>[2022-07-31]</p><ul><li>更正了「应用负数技巧」的并查集类的「按秩求并」方法的一处逻辑错误。该错误由 <a href="/u/you-lan-r4/">@you-lan-r4</a> (幽蓝) 发现并指出，感谢 🙏 。</li><li>修改了若干词句。</li></ul><hr><p>[TOC]</p><hr><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>我们以一个直观的问题引入并查集 (不相交集) 的概念。</p><p>※ 并查集: Union-Find Set ，不相交集: Disjoint Set。</p><blockquote><p><strong>亲戚问题：</strong> 有一群人，他们属于不同家族，同一个家族里的人互为亲戚，不同家族的人不是亲戚。已知每个人都知道自己与其他人是否有亲戚关系，求问有几个家族。</p></blockquote><p>亲戚问题代表着一大类能用并查集解决的所谓确定「<a href="https://en.wikipedia.org/wiki/Connected_component">连通分量</a>」的问题，可以将上述问题图示化如下，不同颜色的集合代表不同家族，集合内的人 (元素) 互为亲戚。从图论的角度来说，同一个集合内的元素是相互「连通」的，那么一个集合就是一个「连通分量」。用集合的语言来说，问题涉及的元素可划归到互相 <strong>没有交集</strong> 的集合，因此也称这样的结构为 <strong>「不相交集」</strong> 。</p><p><img src="https://pic.leetcode-cn.com/1652515794-TUjgDZ-image.png" alt="image.png"></p><p>于是我们可以这样概括性地描述并查集：</p><blockquote><p>并查集 (不相交集) 是一种描述不相交集合的数据结构，即若一个问题涉及多个元素，它们可划归到不同集合，同属一个集合内的元素等价（即可用任意一个元素作为代表，比如上述的互为亲戚即互相等价），不同集合内的元素不等价。</p></blockquote><p>这基本上就是对并查集的完整描述了，十分简单。问题涉及的元素初始时总是自己构成一个单元素集合，求解问题需要通过合并操作将等价元素归入一个集合中。为了能够合并等价元素，我们必须查询希望合并的对象元素属于哪个集合，以决定是否要执行合并。因此 <strong>主要操作就是「查询」与「合并」</strong>  (注意，此刻我们当然还不知道如何查询如何求并，但并不妨碍我们看出这两个操作的必要性) 。</p><p>「不相交」描述的是问题元素构成集合之后各个集合不相交的状态，「并查」描述的是处理问题时的操作。后文中两种称呼都会出现。</p><p>上面的亲戚问题只用于引入并查集的概念，而本文剩下的内容，会以 <a href="https://leetcode-cn.com/problems/number-of-provinces/">547: 省份数量</a> 问题为研究对象，一步步 <strong>发明并查集</strong> 以解决该问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LeetCode 547. 省份数量</span><br><span class="line">有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。</span><br><span class="line">省份是一组直接或间接相连的城市，组内不含其他没有相连的城市。</span><br><span class="line">给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] = 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] = 0 表示二者不直接相连。</span><br><span class="line">返回矩阵中 省份 的数量。</span><br><span class="line">示例1:</span><br><span class="line">输入：isConnected = [[1,1,0],[1,1,0],[0,0,1]]</span><br><span class="line">输出：2</span><br><span class="line">示例2</span><br><span class="line">输入：isConnected = [[1,0,0],[0,1,0],[0,0,1]]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p>不难看出这是一个典型的并查集问题。如果我们能够通过矩阵信息将同一省份的城市都加入到同一个集合，最终有多少个省份就会有多少个不相交集合。</p><p>从现在开始，行文视角换成正在读本文的你。对于上述问题，你在草稿纸上稍作勾画，写下了如下处理过程 (draft版)：</p><ol><li><p>初始时，每个城市是否与其他城市同属一省是未知的，此时每个城市构成单元素集合。</p></li><li><p>为了知道哪些城市同属一省，需要遍历矩阵，若 $(i, j)$ 为 1，说明 $i, j$ 两个城市同属一省，可以合并在一起，得到一个 2 元素集合。在集合扩大的过程中，需要找到一个代表，以便多元素集合之间的合并。即当询问 $i$ 与 $j$ 是否应当合并时，需先确定 $i$ 和 $j$ 各自的代表，若相同，那么她们在之前就已经通过其他城市合并在一起了，若不同，则合并之，即向其中一个城市宣告它的代表，使她可以知道自己属于哪个省。现在，「查询」与「合并」变得更具体了。</p></li><li><p>对未确定归属的城市进行上述的查询合并操作，当结束矩阵遍历时，所有城市就都知道了自己的代表。此时再遍历一遍所有城市，「查询」她们的代表，有多少个不同的代表，就有多少个不同的省份，于是问题得到解决。</p></li></ol><p>通过上述对处理过程的思考，你发现 <strong>「代表」</strong> 在这一过程中至关重要，且所谓「同属一省的城市 (形成了集合) 」并不是静态的将这些城市放在了一起（放到表中或者其他什么静态的数据结构中），而是 <strong>动态地</strong> 查询它们的代表才知道的。一个迫切要解决的问题就是如何保存及表示「代表」。再回顾一遍查询操作，假设集合中的某个元素 (省会城市) $x$ 为该集合的代表，查询城市 $y$ 是否属于 $x$ 所在的省时，虽然不能直接得知这一信息，但 $y$ 可能知道自己与其他城市是否在同一省，而这个其他城市又知道自己与 $x$ 在同一省，或者经过「若干跳」来追溯到 $x$ ，那么你就能够知道 $y$ 与 $x$ 为同一省。这种向着一个方向串联的关系使你立刻想到以 <strong>(单向) 链表</strong> 来实现 (这是你的独创，虽然后面你会知道用树的概念更合适，但谁让你现在还 <strong>一无所知</strong> 呢)。于是你将每个城市想象成单向链表中的一个结点，以尾节点 (省会城市) 作为代表，每个元素 (城市) 指向它的后继 (通过矩阵中的 1 得知) ，连续地向 $next$ 查询，一定能查询到尾结点。查询两个节点元素的尾结点是否相同，即可知道他们是否属于同一集合。你有了「查询」的感觉，并且当你思考「合并」操作时，也隐隐感觉到也许可以通过改变链表指针来实现，但你还不确定。</p><p>总之，你勾勒出了并查集处理问题的主要过程为： <strong>初始化 (单元素集合) 、合并和查询</strong> 。不待稍歇，你即刻拍马上路。</p><br /><h2 id="处理过程"><a href="#处理过程" class="headerlink" title="处理过程"></a>处理过程</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a><strong>初始化</strong></h3><p>你首先尝试完成 <strong>初始化</strong> 。虽然前面你有了链表的方案，但你更希望从最简单的 (实际上也是最常用的) 的数据形式入手，如果也能实现那当然更好。于是你采用了 0 到 $n - 1$ 的整数代表问题涉及的 $n$ 个元素，并以 <strong>数组</strong> 储存之。自然地，下标即代表元素，值为与该元素有 <strong>「等价」</strong> 关系的元素，效果上等于你之前链表想法中结点的 $next$ 指针 (引用) ，看起来能行。在亲戚关系中该等价关系为是否互为亲戚，在省份问题中等价关系为是否同属一省。对于省份问题，你创建了一个 $capital[]$ 数组 ( $capital$ 即省会，虽然对于城市 $i$， $capital[i]$ 是与 $i$ 在矩阵中有「联系」的城市， 不一定是省会，但你想不到更好的数组名，<strong>变量命名是你一生的课题</strong> ，暂时就这样吧)， $capital$ 大小为输入矩阵的一维长度，即城市数量。初始时，每个元素只知道 <strong>自己与自己「等价」</strong> ，因此创建这个数组后，遍历并使得 $capital[i] &#x3D; i$ 。这样初始化就完成了，看起来十分 OK👌。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="type">int</span>[] capital = <span class="keyword">new</span> <span class="title class_">int</span>[isConnected.length];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; isConnected.length; i++) &#123;</span><br><span class="line">    capital[i] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写代码解题时，初始化过程可以在主方法中完成，也可以在并查集类 $UnionFind$ 的构造器中完成。你选择在构造器中完成初始化，并写下如下代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="comment">// 在主方法(findCycleNum)中new UnionFind</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findCircleNum</span><span class="params">(<span class="type">int</span>[][] isConnected)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> isConnected.length;</span><br><span class="line">        <span class="type">UnionFind</span> <span class="variable">uf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnionFind</span>(isConnected); <span class="comment">// 通过构造器完成初始化</span></span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 求解过程 ???</span></span><br><span class="line">  </span><br><span class="line">        <span class="keyword">return</span> ???;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UnionFind类，只写我们当前知道的。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] capital;</span><br><span class="line">    <span class="comment">// 其他字段???</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UnionFind</span><span class="params">(<span class="type">int</span>[][] isConnected)</span>&#123; <span class="comment">// 构造方法</span></span><br><span class="line">        <span class="built_in">this</span>.capital = <span class="keyword">new</span> <span class="title class_">int</span>[isConnected.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; isConnected.length; i++)&#123; </span><br><span class="line">            capital[i] = i;</span><br><span class="line">            <span class="comment">// 其他字段的初始化???</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着你写了个输入矩阵，一共有 6 个城市 ${0, 1, 2, 3, 4, 5}$ ，<code>isConnected[i][j] = 1</code> 表示 $i$ 与 $j$ 为同一省。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 输入矩阵M</span><br><span class="line">&#123;</span><br><span class="line">&#123;1, 0, 0, 0, 1, 0&#125;, // 0-0, 0-4</span><br><span class="line">&#123;0, 1, 0, 0, 0, 1&#125;, // 1-1, 1-5</span><br><span class="line">&#123;0, 0, 1, 1, 0, 1&#125;, // 2-2, 2-3, 2-5</span><br><span class="line">&#123;0, 0, 1, 1, 0, 0&#125;, // 3-2, 3-3</span><br><span class="line">&#123;1, 0, 0, 0, 1, 0&#125;, // 4-0, 4-4</span><br><span class="line">&#123;0, 1, 1, 0, 0, 1&#125;, // 5-1, 5-2, 5-5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化后得到如下 5 个单元素集合。</p><p><img src="https://pic.leetcode-cn.com/1652516047-sitcTa-image.png" alt="image.png"></p><br /><h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a><strong>合并</strong></h3><p>你现在开始尝试实现 <strong>合并方法 ($union$)</strong> 。在你设计的处理过程中已经写到，合并的依据是查询，你先假设自己已经实现了「查询」方法 $find(x)$ ，该方法返回 $x$ 的当前代表。合并 $x$ 和 $y$ 的前提是 <code>find(x) != find(y)</code> ，因为若 <code>find(x) == find(y)</code> ，说明二者已经在同一集合中了（同一省）。具体做法如下，对于 $x$，$y$ 两个城市，若 <code>find(x) != find(y)</code> ，就令 <code>capital[find(y)] = find(x)</code> ，当然也可以是 <code>capital[find(x)] = find(y)</code> ，选用其中一种即可。你一开始可能想要写成 <code>capital[x] = y</code>，但马上发现这么写只能表示 $y$ 是 $x$ 的代表，而你的目的是用 $y$ 目前的代表 ( $find(y)$ 的返回值) 来作为 $x$ 的代表 ( $find(x)$ 的返回值) 的代表，这样才能使得 $x$ 目前的集合 <strong>整体并入</strong> $y$ 所在的集合。</p><p>到这你停顿了一下，又强调着提醒了一下自己，这里的「合并」并非真的把元素「静态地」装到了一个什么数据结构中，而是要通过 $find$ 才知道某个元素属于哪个集合，所以「合并 $x$ 与 $y$ 」就是「把 $y$ 所在集合合并到 $x$ 所在集合中」，也就是 <strong>「使 $y$ 所在树的根指向 $x$ 所在树的根」</strong> ，这样以后查询原 $y$ 所在集合的任意元素，指向原根后，会继续指向 $x$ 所在集合的根，也就知道此时这些元素已经合并到 $x$ 所在集合中了（在实现查询方法后你会有更深的体会）。合并方法就这么实现好了，并不复杂，你的信心开始上涌。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// union方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(find(x) != find(y))&#123;</span><br><span class="line">        capital[find(y)] = find(x); <span class="comment">// 令 x 的代表作为 y 的代表的代表</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在main方法中遍历矩阵，调用union执行合并的过程的写法如下：</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(isConnected[i][j] == <span class="number">1</span>) uf.union(i, j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是主方法扩充为如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="comment">// 在主方法(findCycleNum)中new UnionFind</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findCircleNum</span><span class="params">(<span class="type">int</span>[][] isConnected)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> isConnected.length;</span><br><span class="line">        <span class="type">UnionFind</span> <span class="variable">uf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnionFind</span>(isConnected); <span class="comment">// 通过构造器完成初始化</span></span><br><span class="line">        <span class="comment">// 两个for，遍历矩阵完成合并</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(isConnected[i][j] == <span class="number">1</span>) uf.union(i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ???; <span class="comment">// 完成合并后我们已经完成求解，但现在还不知道该返回什么</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在你想试试这个合并方法能不能有效处理输入矩阵，并看看会「合并」成何种状态。为方便，你把前面的输入矩阵 $isConnected$ 再一次写在这里。 遍历前三行，你画出了遍历到 $isConnected[2][3]$ 和 $isConnected[2][5]$ 的状态（建议动手画一下，加深理解）。可以看到，遍历前三行后，就已经得到了最终的两个不相交集，所以对于这个输入，一共有两个省。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 输入矩阵M</span><br><span class="line">&#123;</span><br><span class="line">&#123;1, 0, 0, 0, 1, 0&#125;, // 0-0, 0-4</span><br><span class="line">&#123;0, 1, 0, 0, 0, 1&#125;, // 1-1, 1-5</span><br><span class="line">&#123;0, 0, 1, 1, 0, 1&#125;, // 2-2, 2-3, 2-5</span><br><span class="line">&#123;0, 0, 1, 1, 0, 0&#125;, // 3-2, 3-3</span><br><span class="line">&#123;1, 0, 0, 0, 1, 0&#125;, // 4-0, 4-4</span><br><span class="line">&#123;0, 1, 1, 0, 0, 1&#125;, // 5-1, 5-2, 5-5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当你画出 $union$ 的过程后，自然地发现，数据的结构呈现出 <strong>「树」</strong> 的形态，原先的单向链表的「尾结点」为树的 <strong>「根」</strong> ，但与通常的树不同，这里的链接关系是从孩子结点指向父结点。现在，你非常自然地将并查集结构从一开始的「单向链表」转换成了「树」。</p><p>※ 作者按：我认为用树来理解不是特别重要，这个结构按链表理解完全没问题，一个「集合」也可以描述成一条或多条相交于尾结点的链表，「尾结点」等同于树中的「根」，后续出现的「树高」的概念也可以说是「最长链」的长度等等，只不过确实不如树的形象和树的语言描述来得方便。总之后续转换为树的语言来描述这里的「集合」）。</p><p><img src="https://pic.leetcode-cn.com/1652516076-TZtQcS-image.png" alt="image.png"></p><br /><h4 id="再谈合并语句"><a href="#再谈合并语句" class="headerlink" title="再谈合并语句"></a>再谈合并语句</h4><p>前面我们说到 $union(x,y)$ 是要将 $y$ (或 $x$ ) 所在树的根指向 $x$ (或 $y$ ) 所在树的根，因此要写成 <code>capital[find(y)] = find(x)</code> (或 <code>capital[find(x)] = find(y)</code> ) 。现在我们具体看看为什么 <code>capital[y] = x</code> 这样的写法为什么是错误的。如下所示的两个三元素集合，1 为 ${1,2,3}$ 的根，4 为  ${4,5,6}$ 的根。以 $capital[y] &#x3D; x$ 执行 $union(3, 5)$ ，那么两棵树会合并，合并后 $find(2)$ 和 $find(6)$ 查到的根分别是 1 和 4 ，所以当询问 2 和 6 是否在同一集合时会出错。读者朋友们可以把「小结」中的代码的 <code>capital[find(y)] = find(x)</code> 改成 <code>capital[y] = x</code> ，实际验证后会发现确实无法通过该题。</p><pre><code>    1          4         / \        / \  2   3  &lt;-  5   6    </code></pre><br /><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a><strong>查询</strong></h3><p>你现在开始尝试实现 <strong>查询方法 ( $find$ 方法)</strong> 。之前已经说过，若集合以单向链表（暂时还用链表的语言描述）的形式组织，尾结点为集合代表 (省会)。那么查询应该是一个递归的过程，熟悉链表写法的你立即写出如下 <strong>尾递归</strong> 代码。</p><p>※ 当然也可以用迭代来实现，这里采用递归方式实现，后续你会知道用递归而非迭代实现的好处。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果用链表组织集合，find可实现如下</span></span><br><span class="line"><span class="keyword">public</span> Node <span class="title function_">find</span><span class="params">(Node x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x.next == <span class="literal">null</span>) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> find(x.next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这相当理想，不过别忘了，虽然将集合想象成链表，但目前 $capital$ 是一个数组，要怎样沿着 $x$ 到找到它的代表元呢？如果做不到这一点你很可能要回到初始化推倒重来了。想到这里，你意识到要先思考此时该 <strong>如何找到代表元</strong> 。初始化单元素集合时，<code>capital[i] = i</code> ，如果此时合并 $i$ 和 $j$ ，令 <code>capital[find(j)] = find(i)</code> ，因为刚开始 <code>find(j) = j</code> ，<code>find(i) = i</code> ，所以这个合并其实就是 <code>capital[j] = i</code> ，并且要令此后 <code>find(j) = i</code> 。你发现，代表元的特点是 <code>find(i) = i</code> ，即自己指向自己，而非代表元 <code>find(j) = i</code>  ( $i$ 是 $j$ 的代表) 不具备这个特点。于是仿照前面链表的写法，你轻松写出如下 $find$ 方法。当 <code>capital[x] = x</code> 时，找到代表元，否则就找当前代表元的代表元，因为从 $x$ 到它的代表元，一定是串联在一条链上的，而对于尾结点 $t$ ，一定满足 <code>capital[t] = t</code> ，因此可以保证找到 $x$ 的代表元 $t$ 。可以看到，无论是 $union$ 还是 $find$ ，无论从理解上还是从实现上，都异常简单（这正是并查集的一大特色，短小精悍，以少量的代码完成高效的处理，你后续还会反复体会到这一点）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// find方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(capital[x] == x) <span class="keyword">return</span> x; <span class="comment">// 只有根节点满足capital[x] = x</span></span><br><span class="line">    <span class="keyword">return</span> find(capital[x]);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>至此你得到了<strong>基本的并查集实现</strong>，主要方法 $find$ 和 $union$ 都只有数行代码，十分简洁。你回顾了一下刚才的实现，写下如下概括性的总结。</p><ul><li><strong>初始化：</strong> 初始化代表下标 $i$ (城市 $i$ ) 的省会 ( $capital[i]$ ) 的 $capital$ 数组，一开始令 <code>capital[i] = i</code> 。</li><li><strong>合并：</strong> 以查询为基础，$union(x, y)$ 将 $y$ 当前的代表元「指向」 $x$ 当前的代表元。</li><li><strong>查询：</strong> 为尾递归方法，$find(x)$ 不断在链上沿着 $x$ 到它的代表元的方向前进，直到找到代表元(尾结点)。</li></ul><p>现在，你已经 <strong>「独立发明」</strong> 了基本并查集，写下如下代码，并验证了它确实能够解决省份问题，你感到一阵兴奋。</p><p>※ 最终的省份数量可以在合并完成后对所有元素执行一次 $find(x)$ ，统计不同结果的个数得到。更聪明的做法是设置一个 <code>unionCount = 0</code> ，表示合并的次数，在 $union$ 方法内添加一行代码，使得发生合并时 <code>unionCount++</code> 实现累计，最后元素总数减去合并次数即为不相交集数量，也即省份数量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="comment">// 在主方法(findCycleNum)中new UnionFind</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findCircleNum</span><span class="params">(<span class="type">int</span>[][] isConnected)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> isConnected.length;</span><br><span class="line">        <span class="type">UnionFind</span> <span class="variable">uf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnionFind</span>(isConnected); <span class="comment">// 通过构造器完成初始化</span></span><br><span class="line">        <span class="comment">// 两个for，遍历矩阵完成合并</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(isConnected[i][j] == <span class="number">1</span>) uf.union(i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n - uf.unionCount; <span class="comment">// 完成合并后我们已经完成求解，但现在还不知道该返回什么</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UnionFind类，只写我们当前知道的。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] capital;</span><br><span class="line">    <span class="type">int</span> <span class="variable">unionCount</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 合并次数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UnionFind</span><span class="params">(<span class="type">int</span>[][] isConnected)</span>&#123; <span class="comment">// 构造器</span></span><br><span class="line">        <span class="built_in">this</span>.capital = <span class="keyword">new</span> <span class="title class_">int</span>[isConnected.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; isConnected.length; i++)&#123; </span><br><span class="line">            capital[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// union方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(find(x) != find(y))&#123;</span><br><span class="line">            capital[find(y)] = find(x);</span><br><span class="line">            unionCount++; <span class="comment">// 实时统计合并次数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// find方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(capital[x] == x) <span class="keyword">return</span> x; <span class="comment">// 只有根节点满足capital[x] = x</span></span><br><span class="line">        <span class="keyword">return</span> find(capital[x]);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>治学十分严谨的你开始研究目前的实现，并思考这一基本实现是否存在什么问题，或者有什么可以优化的地方。你首先从数据规模上考虑，若元素较多时，你发现将得到一条很长的链，对头节点查询其代表元时，需要遍历整条链。例如上述 ${1, 2, 3, 5}$ 这个集合，如果还有 ${6}, {7}, {8}$ 这三个单结点元素，且令  ${1, 2, 3, 5}$ 连续地与它们合并，即执行 $union(6, 5), union(7, 5), union(8, 5)$ 之后，得到如下。</p><p>※ 对于本题，因为只需要遍历矩阵右上三角执行合并，因此 $union(x,y)$ 总有 $x &gt; y$ ， 上述 $union(6, 5), union(7, 5), union(8, 5)$ 实际上并不会执行，这么写只是为了引出后续内容而设置的假想情形。不过，在别的题目中，若 $union(x, y)$ 时， $x$ 总是一个单元素集合的话，是完全有可能出现链状树的。</p><p><img src="https://pic.leetcode-cn.com/1652516119-xkUCfu-image.png" alt="image.png"></p><p>你发现，简单直接的合并将导致较高的树，若再继续执行 $union(5, 9)$ ，首先进行的 $find(5)$ 将会依次向父节点方向查询 $1, 2, 6, 7, 8$ ，查询效率低下。设想，如果能将树的高度降低，例如除根节点外的所有节点直接挂在根节点下（ <strong>放射状</strong> ，或者也有人说是 <strong>菊花状</strong> ），那么 $find$ 的复杂度将为常数级，$union$ 也会因此变为常数级操作。基于这个思考，你将在下一节继续发明更好的求并方法，使得两棵树合并后得到的新树拥有更低的树高。</p><br /><p><strong>补充说明：寻找等价关系</strong></p><p>在省份数量问题中，矩阵已给出等价信息，使得我们可以直接遍历 $isConnected[i][j]$ ，根据其值是否为 1 来直接求并，但对于有的问题，开始时等价信息并不明显，需要先找到这样的等价关系，然后才能求并。例如 <a href="https://leetcode-cn.com/problems/longest-consecutive-sequence/">128: 最长连续序列</a> 问题，可以用并查集求解，但需要在开始时对 $i$ 和 $i+1$ 执行一次合并操作，这个「等价」是不太明显的。具体过程（代码）可参考后续内容。</p><br /><h2 id="求并优化"><a href="#求并优化" class="headerlink" title="求并优化"></a>求并优化</h2><p>以目前的实现求解省份数量问题，你已经发现，合并 $x$ 和 $y$ 所在树 (集合) 时，只是简单地将 $y$ 所在树的根指向 $x$ 所在树的根 $capital[find(y)] &#x3D; find(x)$ ，最坏的情况下将得到一棵链状的树，较高的树高将导致较高的查询 (及合并) 复杂度。你希望以某种策略使合并后得到树高较小的树。几乎不费思忖，你就得到了一个自然的想法：在合并时，不再默认将  $y$  所在树 (的根) 挂到 $x$ 所在树 (的根) 上，而是先 <strong>比较这两棵树的大小</strong> ，让较小的树挂到较大的树上，因为 <strong>较小的树的树高总是倾向于较低</strong> 。如果较小的那棵树低于较大的那棵树，合并后树高不变！你迫不及待继续码起来。</p><br /><h3 id="按大小求并"><a href="#按大小求并" class="headerlink" title="按大小求并"></a>按大小求并</h3><p>现在，你尝试实现这种 <strong>「按大小求并」</strong> 的做法。这很简单，只需要在合并前比较两棵树的大小即可，如下，「按大小求并」的 $union$ 方法对你来说就是「分分钟」（此时你已经有点膨胀了，不过作为并查集发明人，倒也不为过）。（为了从更广泛的意义上描述，此后不再特别强调「省份数量」问题，且把 $capital$ 数组改为更一般的 $parent$ 数组，表示父结点。）</p><p>※ 用 $parent$ 而不是 $father$ ，就像说孩子结点而不是儿子结点，用 $child$ 而不是 $son$ ，都是名称上的性别正义，不过中文语境中很少说“亲结点”，因此还是描述为父结点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Union方法：按大小求并</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">xRoot</span> <span class="operator">=</span> find(x), yRoot = find(y);</span><br><span class="line">    <span class="comment">// 根节点不同才求并</span></span><br><span class="line">    <span class="keyword">if</span>(xRoot != yRoot) &#123;</span><br><span class="line">        <span class="keyword">if</span>(size[yRoot] &lt;= size[xRoot])&#123; <span class="comment">// 当y所在树大小小于等于x所在树大小时</span></span><br><span class="line">            parent[yRoot] = xRoot; <span class="comment">// 将yRoot挂在xRoot上</span></span><br><span class="line">            size[xRoot] += size[yRoot]; <span class="comment">// 更新x所在树的大小</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parent[xRoot] = yRoot;</span><br><span class="line">            size[yRoot] += size[xRoot];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你新增了一个与 $parent$ 大小相同的 $size$ 数组，$size[i]$ 表示 $i$ 结点所在树的大小。$UnionFind$ 类中需要添加 $size$ 数组字段和相应的初始化内容（单结点集合的大小为 1）。如下代码在构造器中初始化树大小数组 $size []$ 。补充后如下，并且你稍微修改了构造器的入参，不是以矩阵为入参，而是以一维数组为入参， $parent$ 数组的初始化改为写在主方法中。因为你觉得这样有利于使 $UnionFind$ 类的写法统一且稳定，不必总是对不同问题进行调整。你对这一修改还算满意。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="type">int</span>[] parent = <span class="keyword">new</span> <span class="title class_">int</span>[isConnected.length];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; isConnected.length; i++) &#123;</span><br><span class="line">    parent[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">UnionFind</span> <span class="variable">uf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnionFind</span>(parent);</span><br><span class="line"></span><br><span class="line"><span class="comment">// UnionFind类(部分)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] parent, size; <span class="comment">// size保存树的大小</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UnionFind</span><span class="params">(<span class="type">int</span>[] parent)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.parent = parent;</span><br><span class="line">        <span class="built_in">this</span>.size = <span class="keyword">new</span> <span class="title class_">int</span>[parent.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; parent.length; i++) &#123;</span><br><span class="line">            <span class="built_in">this</span>.size[i] = <span class="number">1</span>; <span class="comment">// 初始时单节点树大小为1</span></span><br><span class="line">        &#125; <span class="comment">// 或者 Arrays.fill(size, 1);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按大小求并的方法就这样实现出来了。不过在欣赏这个实现之余，你难免会回想自己当初 <strong>为何出发</strong> ，起初你希望合并后的树拥有较低的树高，但是一棵大小较小的树完全有可能高于大小较大的树，比如链状树在结点较少时也很容易高于菊花树。那为何不直接按高度求并呢？而且按高度求并还有一个好处，新树的高度变化只发生在两棵树高度相等时，此时高度加 1 ，而按大小求并时，每次合并都要修改新树的大小。沿着这个想法，下一节你将继续发明 <strong>「按高度求并」</strong>。</p><br /><h3 id="按秩-高度-求并"><a href="#按秩-高度-求并" class="headerlink" title="按秩(高度)求并"></a>按秩(高度)求并</h3><p>不是「按高度求并」吗，怎么还有个 <strong>「秩 ( $rank$ ) 」</strong> ？现说明如下，但该说明的内容你只能在下一节发明「路径压缩」后才会理解，此处按下不表，你可以先将「秩 ( $rank$ )」暂时等同于「高度 ( $height$ ) 」。</p><blockquote><p>当并查集的查找方法不具有「带路径压缩」的效果时，本节所述方法就是严格的「按高度求并」。</p><p>当并查集应用了「带路径压缩」的查找方法时，$height$ 将不能表示严格的「树高」的概念，为严谨，需改称「按高度求并」为「按秩求并」。</p></blockquote><p>类似「按大小求并」的做法，你立即写出「按秩 (高度) 求并」的如下方法（初始化 $rank$ 数组写法与 $size$ 数组一致，此处省略。另外下面代码的写法有点不规范，括号内单行语句的情况你都省略了括号，不过你并不是很在意，心想规范个腿，我没写成一行算客气的了）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// union方法：按秩(高度)求并，先判断是否在同一集合</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">xRoot</span> <span class="operator">=</span> find(x), yRoot = find(y);</span><br><span class="line">    <span class="keyword">if</span>( xRoot != yRoot)&#123;</span><br><span class="line">        <span class="keyword">if</span>(rank[yRoot] &lt;= rank[xRoot]) parent[yRoot] = xRoot;</span><br><span class="line">        <span class="keyword">else</span> parent[xRoot] = yRoot;</span><br><span class="line">        <span class="keyword">if</span>(rank[xRoot] == rank[yRoot]) rank[xRoot]++; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你敏锐地发现还可以有一种去掉 <code>if(xRoot != yRoot)</code> 判断的写法。因为你发现即便 <code>xRoot == yRoot</code> ，根据 <code>rank[xRoot] == rank[yRoot]</code> ，将执行  <code>parent[yRoot] = xRoot</code> ，仍是根结点指向自己，并未改变什么。在不同集合元素求并操作较多时，这样做可以节省一点 <code>xRoot != yRoot</code> 判断的时间。当然，这并不重要，你只是想多展现一些不同的写法。你还注意到，采用这种写法后，在决定是否要增加秩 (树高) 时，要判断是否有 <code>xRoot != yRoot</code> 。即当两棵树秩 (高度) 相等且为不同集合时，新树的秩 (高度) 加 1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// union方法：按秩(高度)求并，不判断是否在同一集合</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">xRoot</span> <span class="operator">=</span> find(x), yRoot = find(y);</span><br><span class="line">    <span class="keyword">if</span>(rank[yRoot] &lt;= rank[xRoot]) parent[yRoot] = xRoot;</span><br><span class="line">    <span class="keyword">else</span> parent[xRoot] = yRoot;</span><br><span class="line">    <span class="keyword">if</span>(rank[xRoot] == rank[yRoot] &amp;&amp; xRoot != yRoot)&#123;</span><br><span class="line">        rank[xRoot]++; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>秩 (高度) 较小的树的秩 (高度) 无需更新，因为每次求一个元素所在集合的高度都会先找到该集合的树的根，秩 (高度) 较小的树在合并后其树根在新树中就不是树根了。这一点你当然了若于胸。</p><p>现在你回过头重新审视前述导致树高较高的基本合并方法，并尝试使用优化的「按秩 (高度) 合并」方法看看效果。对于 ${1, 2, 3, 5}$ 集合，连续地合并它与单节点集合 ${6}, {7}, {8}$ ，即执行 $union(6, 5), union(7, 5), union(8, 5)$ ，在应用按秩 (高度) 求并之后，得到如下。</p><p><img src="https://pic.leetcode-cn.com/1652516172-rTFJLD-image.png" alt="image.png"></p><p>效果十分理想。但结点 5 显得异常扎眼，如果能将节点 5 也直接连到根节点 2 下，将得到最完美的高度为 2 的树。这是否能做到呢？一番踌躇后，你发现在 $union$ 方法中无法做到这一点，因为 $union$ 的作用只是让一个树根指向另一个树根。那 $find$ 方法能实现吗？勤学好问的你继续逼问自己，并想到 $find(5)$ 从 5 沿着父结点方向走向根，看起来可以在这个过程中做些文章。于是，你再接再厉，在下一节中继续这一优化。如果实现该优化，将使得 5 到根结点 2 的路径缩短，因此你在这里提前把这个优化命名为 <strong>「路径压缩」</strong>，优化后的 $find$ 方法称作 <strong>「带路径压缩的查找」</strong>。</p><br /><h2 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h2><p>前面提到，在 $find(5)$ 时，如果能在查询过程中将 5 的父结点改为 2，就完成了「路径压缩」，熟悉递归的你立刻感觉到这很容易，只需在 $find$ 方法中修改一行代码，就可以让 $find$ 在查询根节点的同时执行这个「压缩」的操作。于是你写下如下代码，改动了 $return$ 语句，将递归的 $find[parent[x]]$ 赋值给 $parent[x]$ ，如下。略作推敲，你肯定该写法正确无误，可以让 <strong>当前查找的节点到根节点路径上所有的节点都指向根节点</strong> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// find方法：带路径压缩</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(parent[x] == x) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> parent[x] = find(parent[x]);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你继续审视前述按秩 (高度) 合并的扎眼的 5 ，在更新了「带路径压缩」的 $find$ 方法后，重新执行一次 $union$ 看下会发生什么。对 ${1, 2, 3, 5}$ 集合，连续地与单节点集合 ${6}, {7}, {8}$ 合并。首先执行 $union(6, 5)$ ，方法内会执行 $find(5)$ 来查找5的根结点，在带路径压缩的 $find$ 中，5 在寻找其所在树的根节点的过程中，<strong>实时地令其到根节点路径上的所有节点都指向了根节点</strong>，于是原路径被压缩，继续合并 ${7}$ 和 ${8}$ 之后你画出下图。</p><p><img src="https://pic.leetcode-cn.com/1652516194-NgIHxD-image.png" alt="image.png"></p><p>终于得到了一棵对于查询 (以及合并) 来说最完美的树，心情不错的你为防万一，又检查了一遍实现过程，并有一个 <strong>不大不小中发现</strong> 。5 指向 2 发生在 $union(6, 5)$ 时 (其内调用 $find(5)$ ) ， $find$ 方法不会修改树的高度，「压缩」前后 $rank[2]$ 保持不变，即 $rank[2] &#x3D; 3$ ，但经过 $find$ 的压缩，树的高度已经变为 2 了。这时你突然有所领悟，<strong>原来这就是称做「按秩求并」而非「按高度求并」原因</strong>。一声「なるほど」之后你快速写下如下总结（「好记忆不如烂笔头」是你小学三年级的座右铭，你还把这句话刻在了书桌右上角）：</p><blockquote><p>「按秩求并」而非「按高度求并」：</p><p>在应用带路径压缩的查询和按秩求并后，$rank[root]$ 记录的数字是树实际高度的一个上界，树的实际高度可能小于此值。</p></blockquote><p>对于「秩 ( $rank$ )」，你还有这样的思考: 按高度求并的优化原本是用「高度 ( $height$ )」来指导树的合并，但因为 <strong>「同时」</strong> 应用了 「路径压缩」 优化，导致程序记录的 $height$ 信息不再是严格定义下的「高度」，这就好像树高被 $find$ 给压缩了，但 $height$ 这个变量没察觉到这个变化，导致 $height$ 不再能表达「真实高度」。因此为了严谨，我们不能再使用 $height$ 这个单词 (这个概念) ，转而采用另一个词 (另一个概念) 来指代此时的「高度」。找啊找，发现 $rank$ 这个单词很合适。中文的「秩」是「$rank$」这个词的翻译，就是我们理解的「排名」那样，指一种「不精确的突出相对意味的大小」，Webster 词典对 $rank$ 的第一条释义为: <em>relative standing or position</em>。你当然也可以选择别的词来形容，比如 almost height, rough height 之类的，只不过都不如 $rank$ 更合适。</p><p>至此，你完成了一个中等偏大的成就：先是独立发明基本并查集，再通过观察树的形态发现优化方向，主动提出优化方案，并最终实现了两种求并优化（「按大小求并」和「按秩求并」）和一种查询优化（「带路径压缩的查询」）。你略感激动，但也没有四下声张，只是把尚未完稿的文章分享给了一个朋友，还顺手编辑了一张喵喵表情，「并查集，就这？就这？」。</p><p>※ Webster词典中给出的 「$rank$ (秩) 」 一词的释义。</p><p><img src="https://pic.leetcode-cn.com/1654406088-kLYvfW-image.png" alt="image.png"></p><br /><h2 id="类的实现代码"><a href="#类的实现代码" class="headerlink" title="类的实现代码"></a>类的实现代码</h2><p>现在你作为并查集发明人，继续总结如下内容。</p><p>通过上述对实际问题处理过程的讲解，我们已经给出了能够处理集合代表元查询及合并问题的并查集数据结构。在按大小或按秩求并时，需要保存大小或秩 (高度) 信息的数组。现给出如下包含 <strong>直接求并，按大小求并，按秩求并，直接查询，带路径压缩查询</strong> 等方法的实现。实际使用时只需按需选择一种求并和一种查询方法即可，<strong>按秩求并 + 带路径压缩查询</strong> 的组合在多数情况下因其效率更高而成为首选。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] parent, rank, size; <span class="comment">// 实际代码中，按秩求并和按大小求并选择其一</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UnionFind</span><span class="params">(<span class="type">int</span>[] parent)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.parent = parent;</span><br><span class="line">        <span class="built_in">this</span>.rank = <span class="keyword">new</span> <span class="title class_">int</span>[parent.length];</span><br><span class="line">        <span class="built_in">this</span>.size = <span class="keyword">new</span> <span class="title class_">int</span>[parent.length];</span><br><span class="line">        Arrays.fill(rank, <span class="number">1</span>); <span class="comment">// 实际代码中，按秩求并和按大小求并选择其一</span></span><br><span class="line">        Arrays.fill(size, <span class="number">1</span>); <span class="comment">// 实际代码中，按秩求并和按大小求并选择其一</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 直接查找</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findDirect</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(parent[x] == x) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">return</span> findDirect(parent[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 带路径压缩的查找</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(parent[x] == x) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">return</span> parent[x] = find(parent[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 直接求并</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unionDirect</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">xRoot</span> <span class="operator">=</span> find(x), yRoot = find(y);</span><br><span class="line">        <span class="keyword">if</span>(xRoot != yRoot)&#123;</span><br><span class="line">            parent[yRoot] = xRoot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 按大小求并</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unionBySize</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">xRoot</span> <span class="operator">=</span> find(x), yRoot = find(y);</span><br><span class="line">        <span class="keyword">if</span>(xRoot != yRoot) &#123; <span class="comment">// 根节点不同才求并</span></span><br><span class="line">            <span class="keyword">if</span>(size[yRoot] &lt;= size[xRoot])&#123;</span><br><span class="line">                parent[yRoot] = xRoot;</span><br><span class="line">                size[xRoot] += size[yRoot];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                parent[xRoot] = yRoot;</span><br><span class="line">                size[yRoot] += size[xRoot];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 按秩求并</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">xRoot</span> <span class="operator">=</span> find(x), yRoot = find(y);</span><br><span class="line">        <span class="keyword">if</span>( xRoot != yRoot)&#123;</span><br><span class="line">            <span class="keyword">if</span>(rank[yRoot] &lt;= rank[xRoot]) &#123;</span><br><span class="line">                parent[yRoot] = xRoot;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                parent[xRoot] = yRoot;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(rank[xRoot] == rank[yRoot]) &#123;</span><br><span class="line">                rank[xRoot]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><p><strong>无需大小&#x2F;秩数组空间的技巧</strong></p><p>你还在一本书上学到一种技巧，并搬运到了自己的教程上。如果元素的表示不涉及负数（通常如此）的话，可以用一个小技巧来节省大小或秩数组的开销。在以前的说明中，初始化集合时，我们令每一个元素的父节点指向自己，即 <code>parent[x] = x</code> ，表示这是根节点。本技巧以 <code>parent[x] &lt; 0</code> 表示根节点，初始时所有结点不再指向自己，而是置为 -1 ，即 <code>parent[i] = -1</code> 。这样的可行之处在于，$find(x)$ 会一直递归找到根，除了根的 $parent[root]$ 为负数，其他元素 $y$ 的 $parent[y]$ 都是真实存在的父结点的下标，下标自然是非负数。需要注意的是，因其为负数，在两棵树比较大小或秩(高度)时，值越小，则大小或秩 (高度) 越大。在按大小求并时， $size[root]$ 的更新方法不变，但在按秩 (高度) 求并时，新树高度增高 1 时需令 <code>rank[root]--</code> 。</p><p>应用此技巧，给出如下完整实现。同样地，实际使用时只需按需选择一种求并和一种查询方法即可。</p><p>※ 此技巧学习自Weiss的 <a href="https://awesome-programming-books.github.io/algorithms/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9AJava%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0.pdf">数据结构与算法分析：Java语言描述</a> 。另外，在不用负数技巧的版本中，由于根节点相同不影响结果，考虑到在不同集合元素求并操作较多时，在 $union$ 方法中可以省去 <code>xRoot != yRoot</code> 的判断。这个版本中，必须要执行 <code>xRoot != yRoot</code> 的判断，否则当两个同集合元素比较时，将使得 <code>parent[xRoot] = xRoot</code> ，也即原为一个负数的 <code>parent[xRoot]</code> 的值变成了一个非负数 ( $xRoot$ ) ，将导致程序错误。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 应用负数技巧的并查集</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind2</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] parent;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UnionFind2</span><span class="params">(<span class="type">int</span>[] parent)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 直接查找</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findDirect</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(parent[x] &lt; <span class="number">0</span>) <span class="keyword">return</span> x; <span class="comment">// 只有代表元满足 parent[x] &lt; 0</span></span><br><span class="line">        <span class="keyword">return</span> findDirect(parent[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 带路径压缩的查找</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(parent[x] &lt; <span class="number">0</span>) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">return</span> parent[x] = find(parent[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 直接求并</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unionDirect</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">xRoot</span> <span class="operator">=</span> find(x), yRoot = find(y);</span><br><span class="line">        <span class="keyword">if</span>(xRoot != yRoot)&#123;</span><br><span class="line">            parent[yRoot] = xRoot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 按大小求并</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unionBySize</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">xRoot</span> <span class="operator">=</span> find(x), yRoot = find(y);</span><br><span class="line">        <span class="keyword">if</span>(xRoot != yRoot) &#123; <span class="comment">// 根节点不同才求并</span></span><br><span class="line">            <span class="keyword">if</span>(parent[xRoot] &lt;= parent[yRoot])&#123; <span class="comment">// 负数比较，较小者树较大，xRoot所在树更大(或相等)</span></span><br><span class="line">                parent[xRoot] += parent[yRoot]; <span class="comment">// 更新树的大小</span></span><br><span class="line">                parent[yRoot] = xRoot;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                parent[yRoot] += parent[xRoot];</span><br><span class="line">                parent[xRoot] = yRoot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 按秩求并</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">xRoot</span> <span class="operator">=</span> find(x), yRoot = find(y);</span><br><span class="line">        <span class="keyword">if</span>(xRoot != yRoot) &#123;</span><br><span class="line">            <span class="keyword">if</span>(parent[xRoot] &lt; parent[yRoot])&#123; <span class="comment">// xRoot所在树秩更大，yRoot挂到xRoot之下</span></span><br><span class="line">                parent[yRoot] = xRoot;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(parent[xRoot] &gt; parent[yRoot])&#123; <span class="comment">// yRoot所在树秩更大，xRoot挂到yRoot之下</span></span><br><span class="line">                parent[xRoot] = yRoot;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123; <span class="comment">// 秩等大，yRoot挂到xRoot之下</span></span><br><span class="line">                parent[xRoot]--; <span class="comment">// xRoot所在树秩加1 (负数，实际减1)</span></span><br><span class="line">                parent[yRoot] = xRoot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>这个部分你终于感到力有不逮，严格的 <a href="https://oi-wiki.org/ds/dsu-complexity/">复杂度证明</a> 你看了八遍，最终选择放弃，暂时只能写下如下内容（但你在行文中假装自己知道什么是 <a href="https://en.wikipedia.org/wiki/Ackermann_function">反阿克曼函数</a> ）。</p><p>时间复杂度：严格的分析很复杂，省略。带路径压缩的按秩求并的并查集，其查询与合并操作的时间复杂度均为 $O(α(n))$ ( $α(n)$ 表示增长十分缓慢的反阿克曼函数)，对于任何实际的问题的 $n$ ，$α(n)$ 不会超过 5 。因此可以认为此复杂度为 $O(1)$ 。初始化 $parent[] &#x2F; size[] &#x2F; rank[]$  数组的时间复杂度为 $O(n)$ 。</p><p>空间复杂度：取决于 $parent[] &#x2F; size[] &#x2F; rank[]$ 数组所占空间，为 $O(n)$ 。</p><br /><h2 id="实战应用"><a href="#实战应用" class="headerlink" title="实战应用"></a>实战应用</h2><p>在「处理过程」中介绍了应用不相交集处理问题的通用过程，如下一些例题中我们将看到，对于不同的具体问题，各步骤的应用是灵活的。</p><ol><li><a href="https://leetcode-cn.com/problems/longest-consecutive-sequence/">128.最长连续数列</a>。只需在 $find()$ 时以路径压缩方式合并，除给定初始时的等价关系用到主动合并(直接求并)外，不再调用 $union$ 。</li><li><a href="https://leetcode-cn.com/problems/number-of-provinces/">547.省份数量</a>。等价关系在输入矩阵中是明显的，只需在 <code>isConnected[i][j] = 1</code> 时主动合并 $union(i, j)$ 即可，$find()$ 中可以不带合并 (路径压缩)，当然也可以带路径压缩以提高效率。</li><li><a href="https://leetcode-cn.com/problems/number-of-islands/">200.岛屿数量</a>。与省份数量问题的输入都是矩阵，但岛屿数量问题的初始时单节点元素是矩阵中的每一个 “1”，而省份数量问题是列(或行)中的每一个元素。</li><li><a href="https://leetcode.cn/problems/evaluate-division/">399. 除法求值</a> 和 <a href="https://leetcode.cn/problems/path-with-minimum-effort/">1631. 最小体力消耗路径</a> 的并查集解法需要一定的问题抽象能力。</li></ol><p>以下题目的并查集解法都十分经典，如果你能够想到应用并查集，应用本文介绍的内容，解题应当是轻松愉快的。也一并给出题解，供读者朋友们自练自查。</p><table><thead><tr><th>题目</th><th>难度</th><th>题解</th></tr></thead><tbody><tr><td><a href="https://leetcode.cn/problems/number-of-connected-components-in-an-undirected-graph/">323. 无向图中连通分量的数目</a></td><td>中等</td><td><a href="https://leetcode.cn/problems/number-of-connected-components-in-an-undirected-graph/solution/by-yukiyama-y5l4/">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/number-of-provinces/">547.省份数量</a></td><td>中等</td><td><a href="https://leetcode.cn/problems/number-of-provinces/solution/by-yukiyama-mh7f/">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/number-of-islands/">200.岛屿数量</a></td><td>中等</td><td><a href="https://leetcode.cn/problems/number-of-islands/solution/by-yukiyama-jkd6/">题解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/max-area-of-island/">695. 岛屿的最大面积</a></td><td>中等</td><td><a href="https://leetcode.cn/problems/max-area-of-island/solution/by-yukiyama-0mrt/">题解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/is-graph-bipartite/">785. 判断二分图</a></td><td>中等</td><td><a href="https://leetcode.cn/problems/is-graph-bipartite/solution/by-yukiyama-yoc0/">题解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/redundant-connection/">684. 冗余连接</a></td><td>中等</td><td><a href="https://leetcode.cn/problems/redundant-connection/solution/-by-yukiyama-mlqi/">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/longest-consecutive-sequence/">128.最长连续数列</a></td><td>中等</td><td><a href="https://leetcode.cn/problems/longest-consecutive-sequence/solution/by-yukiyama-e3th/">题解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/similar-string-groups/">839. 相似字符串组</a></td><td>困难</td><td><a href="https://leetcode.cn/problems/similar-string-groups/solution/by-yukiyama-j3dt/">题解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/evaluate-division/">399. 除法求值</a></td><td>中等</td><td><a href="https://leetcode.cn/problems/evaluate-division/solution/yukiyama-by-yukiyama-geql/">题解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/path-with-minimum-effort/">1631. 最小体力消耗路径</a></td><td>中等</td><td><a href="https://leetcode.cn/problems/path-with-minimum-effort/solution/yukiyama-by-yukiyama-qboz/">题解</a></td></tr><tr><td>&#x3D;&#x3D;&#x3D;&#x3D; 持续更新中 &#x3D;&#x3D;&#x3D;&#x3D;</td><td></td><td></td></tr></tbody></table><br /><p>🐮🐮🐮<br>牛啊，你竟然真的看到这里了。</p><hr><p><strong>文章更新日志</strong></p><p>[2022-06-11]</p><ul><li>「实战应用」中新增「<a href="https://leetcode.cn/problems/number-of-connected-components-in-an-undirected-graph/">323. 无向图中连通分量的数目</a>」的并查集题解。</li><li>优化文章可读性，新增若干补充说明。</li></ul><p>[2022-06-05]</p><ul><li>「实战应用」中新增「<a href="https://leetcode.cn/problems/path-with-minimum-effort/">1631. 最小体力消耗路径</a>」的并查集题解。</li><li>修改了「实战应用」的展现方式，不再在本帖中直接贴出题解，而以表格形式罗列，给出题解链接。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法与数据结构 </tag>
            
            <tag> 图论算法 </tag>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十大排序从入门到入赘</title>
      <link href="/2022/06/08/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E8%B5%98/"/>
      <url>/2022/06/08/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E8%B5%98/</url>
      
        <content type="html"><![CDATA[<h1 id="从今天起，与「排序」一刀两断"><a href="#从今天起，与「排序」一刀两断" class="headerlink" title="从今天起，与「排序」一刀两断"></a>从今天起，与「排序」一刀两断</h1><p><strong>感谢官方置顶推荐</strong> 🎉😄。</p><blockquote><ul><li><p>可在作者的 <a href="https://github.com/iyukiyama/leetcode-posts">github仓库</a> 中获取本文和其他文章的 markdown 源文件及相关代码。</p></li><li><p>欢迎评论或仓库 PR 指出文章错漏或与我讨论相关问题，我将长期维护所有文章。</p></li><li><p>所有文章均用 Typora 完成写作，可使用 Typora 打开文章 md 文件，以获得最佳阅读体验。</p></li></ul></blockquote><p>⚠️ ⚠️ ⚠️ <strong>本文巨长，全文两万五千余字，尝试彻底解析十大排序算法并给出相应实现。</strong></p><p>❗️ <strong>【NEW】</strong> ❗️</p><ul><li>9-15:  <a href="https://leetcode.cn/circle/discuss/SwgIJV/">红黑树从入门到看开</a></li></ul><hr><blockquote><p>$keywords$ :</p><p>三种元素交换方法 &#x2F; 排序稳定性分析 &#x2F; 排序复杂度分析 &#x2F; 冒泡排序 &#x2F; 选择排序 &#x2F; 插入排序 &#x2F; 希尔排序 &#x2F; shell增量 &#x2F; Hibbard增量 &#x2F; Knuth增量 &#x2F; 逆序数 &#x2F; 归并排序 &#x2F; 自顶向下 &#x2F; 自底向上 &#x2F; 原地与非原地 &#x2F; 手摇算法 (三重反转) &#x2F; 快速排序 &#x2F; 非递归与递归快速排序 &#x2F; 首位轴 &#x2F; 三数取中轴 &#x2F; 随机轴 &#x2F; 双轴快排 &#x2F; 堆排序 &#x2F; 堆化方法 &#x2F; 下滤方法 &#x2F; 计数排序 &#x2F; 稳定版计数排序 &#x2F; 非稳定版计数排序 &#x2F; 基数排序 &#x2F; 基于计数排序的基数排序 &#x2F; 不基于计数排序的基数排序 &#x2F; 桶排序 &#x2F; 决策树</p></blockquote><p>前几天在讨论区上发布的二分查找和并查集文章反馈良好，这让我进一步相信基础知识的总结和分享确实很有一部分受众，于是趁热打铁，<del>连夜</del>推出本文。我(几乎)可以肯定，你在别处(基本上)看不到比本文更深入更广泛地网罗「十大排序」方方面面的文章，如果有，我就把这句话划掉。</p><p>「排序」十分基础，但内容庞杂，网上做全面介绍的资料不可谓不多，但我所看过的材料，总是在这一处或那一处上有所遗憾。比如复杂度缺少证明，比如优化版本未给出，比如缺少便于理解的图示，或者干脆就是到处复制粘贴错误百出的公众号引流文等等等等。<strong>因此上作者试图（企图）在「面试」这一层面上，彻底对排序做一个了断</strong>，使得面试官(几乎)不可能问得比本文内容更深更广（如果你是面试官，我劝你别看，我看你别劝👊😅）。</p><p>本文设想的读者应当是初学排序的同学，以及想对「排序」做一点查漏补缺工作的朋友，比如你突然想不起「双轴快排」该如何实现（对你竟然想要徒手实现双轴快排，我起立致敬🫡），或者「计数排序」稳不稳定，又或者「自底向上归并」该怎么写，你都可以在文中找到相应的答案。不过即便你就是纳闷，“不就是「排序」吗，自己随便看看不就好了，有什么好说的，还搞得这么煞有介事”，也十分欢迎你给出一些指导意见。</p><p>本文标题意在表达作者的一种希望，即看完本文，读者觉得确实有些帮助，甚或令七尺男儿拍案，以至于 <strong>「想嫁」</strong> 的心都有了，那就算对得起作者案头那把 <strong>键帽斑驳的双飞燕键盘</strong> 了。</p><p>发文的本心首要是<strong>向大家学习</strong>，其次是分享(一点微不足道)的心得。仍旧希望大家<strong>不吝赐教</strong>，你所指出的每一个错误，我都会 <strong>立即更正</strong> 。</p><p>本文主要内容（特色）如下：</p><ul><li><p><strong>内容 (应该还算) 全面。</strong> 具体如下。</p><ul><li><p>给出 $swap$ 的三种实现。</p></li><li><p>给出十大排序中后面贴出的思维图所列的所有实现。</p></li><li><p>所有代码均经过验证，注释关键语句，力求所见即所得，贴到IDE上就能跑。</p></li><li><p>给出十大排序的所有稳定性和时空复杂度结论和分析证明。</p></li><li><p>在「希尔排序」中讨论了逆序数。</p></li><li><p>在「归并排序」中分析了 自顶向下&#x2F;自底向上&#x2F;原地&#x2F;非原地 各情形排序过程，并给出各自的实现代码。</p></li><li><p>在「归并排序」中讨论了「手摇算法」。</p></li><li><p>在「快速排序」中讨论了三种基于不同轴选择的单轴快排（首位轴&#x2F;随机轴&#x2F;三数取中轴）并给出相应实现代码。分析给出了利用栈实现的迭代方式的快排。给出并逐行分析了「双轴快排」的代码。</p></li><li><p>讨论了「计数排序」的稳定性。</p></li><li><p>分别给出了基于计数排序和不基于计数排序的「基数排序」实现。</p></li><li><p>从「决策树」角度分析并证明了基于「比较」的排序时间复杂度下界为$O(nlogn)$。</p></li><li><p>贴出「Stiring公式」的详细证明文章链接。</p></li></ul></li><li><p><strong>叙述 (应该还算) 准确。</strong> 本文力求言必有据，所有性质，包括各类排序的稳定性，时空复杂度等关键信息，或给出例子，或给出图示，或严格证明，总之尽力拒绝模糊。</p></li><li><p><strong>制作 (应该还算) 精良。</strong> 公式一概以 $\LaTeX$ 编辑。有多处方便记忆的汇总表格。有大量图示，动图静图，有助于理解之处尽附详图。</p></li></ul><hr><p>yuki的其他文章如下，欢迎阅读指正！</p><blockquote><p>如下所有文章同时也在我的 github <a href="https://github.com/iyukiyama/leetcode-posts">仓库</a> 中维护。</p></blockquote><table><thead><tr><th>文章</th><th>[发布时间] 字数&#x2F;览&#x2F;藏&#x2F;赞 (~2022-10-20)</th></tr></thead><tbody><tr><td><a href="https://leetcode.cn/circle/discuss/eBo9UB/">十大排序从入门到入赘</a>  🔥🔥🔥</td><td>[20220516]  2.5万字&#x2F;64.8k览&#x2F;3.7k藏&#x2F;937赞</td></tr><tr><td><a href="https://leetcode.cn/circle/discuss/ooxfo8/">二分查找从入门到入睡</a> 🔥🔥🔥</td><td>[20220509]  2.3万字&#x2F;38.4k览&#x2F;2.1k藏&#x2F;503赞</td></tr><tr><td><a href="https://leetcode.cn/circle/discuss/qmjuMW/">并查集从入门到出门</a> 🔥🔥</td><td>[20220514]  1.2万字&#x2F;17.9k览&#x2F;1.0k藏&#x2F;321赞</td></tr><tr><td><a href="https://leetcode.cn/circle/discuss/FyPTTM/">图论算法从入门到放下</a> 🔥🔥</td><td>[20220617]  5.6万字&#x2F;19.9k览&#x2F;1.3k藏&#x2F;365赞</td></tr><tr><td>树ADT系列 (预计13篇)</td><td>系列文章，连载中</td></tr><tr><td>3. <a href="https://leetcode.cn/circle/discuss/wPzlSb/">二叉查找树</a></td><td>[20220801]  5千字</td></tr><tr><td>4. <a href="https://leetcode.cn/circle/discuss/zbwD3p/">AVL树</a></td><td>[20220817]  5千字</td></tr><tr><td>5. <a href="https://leetcode.cn/circle/discuss/BCK17f/">splay树</a></td><td>[20220817]  5千字</td></tr><tr><td>6. <a href="https://leetcode.cn/circle/discuss/SwgIJV/">红黑树从入门到看开</a> 🔥🤯🤯🤯</td><td>[20220915]  3万字&#x2F;5.3k览&#x2F;269藏&#x2F;72赞</td></tr><tr><td>10. <a href="https://leetcode.cn/circle/discuss/qGREiN/">树状数组从入门到下车</a> 🔥🤯</td><td>[20220722]  1.4万字&#x2F;5.8k览&#x2F;196藏&#x2F;72赞</td></tr><tr><td>11. <a href="https://leetcode.cn/circle/discuss/H4aMOn/">线段树从入门到急停</a> 🔥🤯</td><td>[20220726]  2.5万字&#x2F;8.7k览&#x2F;481藏&#x2F;138赞</td></tr><tr><td><a href="https://leetcode.cn/circle/discuss/GV0JrV/">图论相关证明系列</a></td><td>系列文章</td></tr><tr><td>1. <a href="https://leetcode.cn/circle/discuss/jJQn7V/">Dijkstra正确性证明</a> 🤯</td><td>[20220531]</td></tr><tr><td>2. <a href="https://leetcode.cn/circle/discuss/VVEc8f/">Prim正确性证明</a> 🤯</td><td>[20220919]</td></tr><tr><td>3. <a href="https://leetcode.cn/circle/discuss/xeEwYl/">Bellman-Ford及SPFA正确性证明</a></td><td>[20220602]</td></tr><tr><td>4. <a href="https://leetcode.cn/circle/discuss/Nbzix4/">Floyd正确性证明</a></td><td>[20220602]</td></tr><tr><td>5. <a href="https://leetcode.cn/circle/discuss/tMIy36/">最大流最小割定理证明</a> 🤯🤯</td><td>[20220719]</td></tr><tr><td>6. <a href="https://leetcode.cn/circle/discuss/tN3sZc/">Edmonds-Karp复杂度证明</a> 🤯🤯</td><td>[20220515]</td></tr><tr><td>7. <a href="https://leetcode.cn/circle/discuss/T9Xa1R/">Dinic复杂度证明</a> 🤯🤯</td><td>[20220531]</td></tr></tbody></table><hr><p>[2022-10-19]</p><ul><li>根据 <a href="/u/strange-antonellipd4/">@strange-antonellipd4</a> (God Man) 的建议，新增了基于 Sedgewick 增量的希尔排序实现。</li></ul><p>[2022-07-28]</p><ul><li>根据 <a href="/u/welliem/">@welliem</a> (welliem) 的提醒，改进「计数排序」$countArr$ 变形部分的代码，相比原实现更快。感谢 welliem 🙏</li></ul><p>[2022-07-19]</p><ul><li>更正了关于基数排序稳定性的说法，更正前文章声称基数排序稳定性取决于计数排序的稳定性，这句话是错误的。因为在基数排序中，对每一位的排序，无论采用计数排序还是非计数排序，该排序都必须稳定，否则所有位排完后，排序可能错误。详情请看「基数排序」-「算法描述」中的相关说明。该错误由 <a href="/u/vclip/">@vclip</a> (白) 发现，感谢白总！🙏</li></ul><hr><h2 id="十大排序分类"><a href="#十大排序分类" class="headerlink" title="十大排序分类"></a>十大排序分类</h2><p><img src="https://pic.leetcode-cn.com/1652691519-SVKUkM-image.png" alt="image.png"></p><br /><h2 id="复杂度和稳定性一览"><a href="#复杂度和稳定性一览" class="headerlink" title="复杂度和稳定性一览"></a>复杂度和稳定性一览</h2><p><strong>稳定性：</strong> </p><p>所谓排序的稳定性，指的是对于存在相等元素的序列，排序后，原相等元素在排序结果中的 <strong>相对位置相比原输入序列不变</strong> 。例如 $nums&#x3D;{3,1,2_1,2_2}$  ，数字 $2$ 出现了两次，下标表示他们出现的次序，若排序方法将 $nums$ 排成了 ${1,2_2,2_1,3}$ ，虽然排序结果正确，但改变了两个 $2$ 的相对位置。只有排序为  ${1,2_1,2_2,3}$ 我们才说该排序是稳定的。</p><p>如果排序对象只是数值，那么是否稳定没有区别。但若是对引用类型进行排序，排序依据是该类型中的某个可比较的数值字段，那么我们可能会希望该字段相同，但其他字段不同的元素相对位置相比原输入保持不变，这时候就需要稳定排序。</p><table><thead><tr><th>排序算法</th><th>平均时间</th><th>最好时间</th><th>最坏时间</th><th>空间</th><th>稳定性*</th></tr></thead><tbody><tr><td>冒泡</td><td>$O(n^2)$</td><td>$O(n)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td>稳定</td></tr><tr><td>选择</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td>不稳定</td></tr><tr><td>插入</td><td>$O(n^2)$</td><td>$O(n)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td>稳定</td></tr><tr><td>希尔</td><td>$O(nlogn)$ ~ $O(n^2)$</td><td>$O(nlogn)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td>不稳定</td></tr><tr><td>希尔</td><td>$O(nlog_3n)$ ~ $O(n^\frac{3}{2})$</td><td>$O(nlog_3n)$</td><td>$O(n^\frac{3}{2})$</td><td>$O(1)$</td><td>不稳定</td></tr><tr><td>归并</td><td>$O(nlogn)$</td><td>$O(nlogn)$</td><td>$O(nlogn)$</td><td>$O(n)$</td><td>稳定</td></tr><tr><td>快速</td><td>$O(nlogn)$</td><td>$O(nlogn)$</td><td>$O(n^2)$</td><td>$O(logn)$</td><td>不稳定</td></tr><tr><td>堆</td><td>$O(nlogn)$</td><td>$O(nlogn)$</td><td>$O(nlogn)$</td><td>$O(1)$</td><td>不稳定</td></tr><tr><td>计数</td><td>$O(n + k)$</td><td>$O(n + k)$</td><td>$O(n + k)$</td><td>$O(n + k)$</td><td>稳定</td></tr><tr><td>基数</td><td>$O(d(n + k))$*k为常数$O(dn)$</td><td>$O(d(n + k))$*同前</td><td>$O(d(n + k))$*同前</td><td>$O(n + k)$</td><td>稳定</td></tr><tr><td>桶</td><td>$O(n)$</td><td>$O(n)$</td><td>$O(n^2)$ or $O(nlogn)$</td><td>$O(n)$</td><td>稳定</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">下列说明在正文相应章节均有更详细的描述。</span><br><span class="line"></span><br><span class="line">※1冒泡: 输入数组已排序时最好。</span><br><span class="line">※2选择: 时间复杂度与输入数组特点无关。</span><br><span class="line">※3插入: 输入数组已排序时最好。</span><br><span class="line">※4希尔: 复杂度取决于增量序列，两行分别为希尔增量，</span><br><span class="line">    和Knuth增量的希尔排序。输入数组已排序时最好。</span><br><span class="line">※5归并: 所列复杂度为「自顶向下非原地」版本。</span><br><span class="line">    自顶向下/自底向上，非原地/原地的时间空间复杂度见该归并排序一节。</span><br><span class="line">※6快速: 当输入数组有序，且总是选取第一个元素为主轴时，</span><br><span class="line">    时间复杂度退化为O(n^2)。空间开销为递归深度。</span><br><span class="line">※7堆: 原地堆排序空间复杂度为O(1)。输入数组所有数字相等时，</span><br><span class="line">    时间复杂度为O(n)。</span><br><span class="line">※8计数: k是计数数组大小。应用稳定性优化则稳定，否则不稳定。</span><br><span class="line">    朴素版本空间复杂度为O(k)，稳定性优化版本空间复杂度为O(n + k)。</span><br><span class="line">※9基数: d是最大数位数，k是计数数组大小，处理负数时k=19。</span><br><span class="line">※10桶: 稳定性取决于桶内排序是否稳定。空间取决于桶使用数组还是容器，</span><br><span class="line">    若采用数组为O(kn)，容器则为O(n)。所有元素放入同一个桶时复杂度最大。</span><br><span class="line">    最坏时间复杂度取决于采用哪种桶内排序算法。</span><br><span class="line"></span><br><span class="line">稳定性: 存在稳定和非稳定版本时，视作「稳定」。</span><br></pre></td></tr></table></figure><br /><h2 id="三种交换方法"><a href="#三种交换方法" class="headerlink" title="三种交换方法"></a>三种交换方法</h2><p>对于冒泡、选择、插入等采用比较和交换元素的排序方法，由于经常执行交换操作，通常将交换动作写为 $swap$ 方法，需要交换时调用。最常见 $swap$ 写法有如下三种：</p><ol><li>方法一: 利用一个临时数 $tmp$ 来交换 $arr[i]$ ，$arr[j]$ 。</li><li>方法二: 利用 $arr[i]$ 和和 $arr[j]$ 的加减运算避免临时数 $tmp$ 的开销，但由于涉及到加减法可能导致数字 <strong>「提前溢出」</strong> 。</li><li>方法三: 利用位运算中的 <strong>异或</strong> 运算，能够避免 $tmp$ 的开销且不会导致数字溢出。</li></ol><p>需要特别注意的是， <strong>「方法二」和「方法三」要避免  $i &#x3D; j$  ，若  $i &#x3D; j$ ，执行 $swap$ 后将导致该数字变为 0</strong>。实际上自我交换总是不必要的，因此应当保证 $swap$ 被调用时 $i !&#x3D; j$，这样就无需 $if$ 语句了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一: 利用临时数tmp</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法二: 利用加减运算</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swapCal</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(i == j) <span class="keyword">return</span>; <span class="comment">// 若无法保证swapCal被调用时满足 i != j，则需有此句，否则i == j时此数将变为0</span></span><br><span class="line">    arr[i] = arr[i] + arr[j]; <span class="comment">// a = a + b</span></span><br><span class="line">    arr[j] = arr[i] - arr[j]; <span class="comment">// b = a - b</span></span><br><span class="line">    arr[i] = arr[i] - arr[j]; <span class="comment">// a = a - b</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法三: 利用异或运算</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swapXOR</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(i == j) <span class="keyword">return</span>; <span class="comment">// 若无法保证swapXOR被调用时满足 i != j，则需有此句，否则i == j时此数将变为0</span></span><br><span class="line">    arr[i] = arr[i] ^ arr[j]; <span class="comment">// a = a ^ b，也可写成 arr[i] ^= arr[j];</span></span><br><span class="line">    arr[j] = arr[i] ^ arr[j]; <span class="comment">// b = (a ^ b) ^ b = a ^ (b ^ b) = a ^ 0 = a， 也可写成 arr[j] ^= arr[i];</span></span><br><span class="line">    arr[i] = arr[i] ^ arr[j]; <span class="comment">// a = (a ^ b) ^ a = (a ^ a) ^ b = 0 ^ b = b， 也可写成 arr[i] ^= arr[j];</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><p>对于要排序的数组，从第一位开始从前往后比较相邻两个数字，若前者大，则交换两数字位置，然后比较位向右移动一位。也就是比较 $arr[0]$ 和 $arr[1]$ ，若 $arr[0] &gt; arr[1]$ ，交换 $arr[0]$ 和 $arr[1]$ 。接着比较位移动一位，比较 $arr[1]$ 和 $arr[2]$ ，直到比较到 $arr[n - 2]和$ $arr[n - 1] (n &#x3D; arr.length)$ 。第1轮从前到后的比较将使得最大的数字 <strong>冒泡</strong> 到最后，此时可以说一个数字已经被排序。每一轮的比较将使得当前未排序数字中的最大者被排序，未排序数字总数减 1。第 $arr.length - 1$ 轮结束后排序完成。</p><p>如下<a href="https://tva1.sinaimg.cn/large/008i3skNgy1gze7lbis8sg309k059jxz.gif">动图</a>展示了 ${4,6,2,1,7,9,5,8,3}$ 的冒泡排序过程（未应用优化）。</p><p><img src="https://pic.leetcode-cn.com/1652691998-pJaTQD-bubble.gif" alt="bubble.gif"></p><p><strong>稳定性：稳定。</strong></p><p>冒泡排序始终只交换相邻元素，比较对象大小相等时不交换，相对位置不变，故稳定。</p><br /><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p><strong>提前结束优化</strong></p><p>当某一轮比较均未发生交换，说明排序已完成，可设置一个布尔值记录一轮排序是否有发生交换，若无则提前退出循环结束程序。</p><p><strong>冒泡界优化</strong></p><p>记录前一轮交换的最终位置，说明该位置之后的元素为已排序状态，下一轮的交换只需执行到该处。</p><br /><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：两层 $for$ 循环，第 1 轮比较 $n - 1$ 次 $(n &#x3D; arr.length)$ ，最后一轮比较 1 次。总比较次数为 $n*(n - 1) &#x2F; 2$ 次，时间复杂度为 $O(n^2)$。当输入数组为已排序状态时，在应用提前结束优化的情况下，只需一轮比较，此时为最佳时间复杂度 $O(n)$。</p><p>空间复杂度：算法中只有常数项变量，$O(1)$。</p><br /><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>无优化的基本冒泡排序代码此处不列出。</p><br /><h4 id="提前结束优化"><a href="#提前结束优化" class="headerlink" title="提前结束优化"></a>提前结束优化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] bubbleSort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="comment">// n - 1轮次执行，当前 n - 1 个元素排好后，最后一个元素无需执行，故i &lt; arr.length - 1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 本轮执行是否有交换的标志，若无则false，若有则true</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">swapped</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 每轮循环，通过依次向右比较两个数，将本轮循环中最大的数放到最右</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; arr.length - i; j++) &#123;</span><br><span class="line">            <span class="comment">// 若左大于右则交换，并将swapped置为true</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j - <span class="number">1</span>] &gt; arr[j]) &#123;</span><br><span class="line">                swap(arr, j - <span class="number">1</span>, j);</span><br><span class="line">                swapped = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若无交换，表示当前数组已完全排序，退出大循环</span></span><br><span class="line">        <span class="keyword">if</span> (!swapped) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h4 id="提前结束-冒泡界优化"><a href="#提前结束-冒泡界优化" class="headerlink" title="提前结束+冒泡界优化"></a>提前结束+冒泡界优化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] bubbleSort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">swapped</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">lastSwappedIdx</span> <span class="operator">=</span> arr.length - <span class="number">1</span> ;</span><br><span class="line">    <span class="type">int</span> <span class="variable">swappedIdx</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// lastSwappedIdx表示前一轮交换的最终位置，即下标为lastSwappedIdx是未排序部分中的最后一个数的下标，</span></span><br><span class="line">    <span class="comment">// 因此for中的界是i &lt; lastSwappedIdx而不需要写成i &lt;= lastSwappedIdx</span></span><br><span class="line">    <span class="keyword">while</span> (swapped) &#123; <span class="comment">// 当swapped = false时，排序完成</span></span><br><span class="line">        <span class="comment">// 本轮执行是否有交换的标志，若无则true，若有则false</span></span><br><span class="line">        swapped = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 每轮循环，通过依次向右比较两个数，将本轮循环中最大的数放到最右</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; lastSwappedIdx; i++) &#123;</span><br><span class="line">            <span class="comment">// 若左大于右则交换，并将swapped置为true</span></span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; arr[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                swap(arr, i, i + <span class="number">1</span>);</span><br><span class="line">                swapped = <span class="literal">true</span>;</span><br><span class="line">                swappedIdx = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        lastSwappedIdx = swappedIdx;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h3><p>对于要排序的数组，设置一个 $minIdx$ 记录最小数字下标。先假设第 1 个数字最小，此时 <code>minIdx = 0</code> ，将 $arr[minIdx]$ 与后续数字逐一比较，当遇到更小的数字时，使 $minIdx$ 等于该数字下标，第1轮比较将找出此时数组中最小的数字。找到后将 $minIdx$ 下标的数字与第 1 个数字交换，此时称一个数字已被排序。然后开始第2轮比较，令 <code>minIdx = 1</code>，重复上述过程。每一轮的比较将使得当前未排序数字中的最小者被排序，未排序数字总数减 1。第 $arr.length - 1$ 轮结束后排序完成。</p><p>如下<a href="https://tva1.sinaimg.cn/large/008i3skNgy1gze7srslbag309k059125.gif">动图</a>展示了 ${4,6,2,1,7,9,5,8,3}$ 的选择排序过程（单元选择）。</p><p><img src="https://pic.leetcode-cn.com/1652692082-UXzLDc-select.gif" alt="select.gif"></p><p>微优化：在交换前判断 $minIdx$ 是否有变化，若无变化则无需交换。当数组大致有序时，能够减少无效交换带来的开销。</p><p><strong>稳定性：不稳定。</strong></p><p>存在跨越交换。找到本轮次最小值之后，将其与本轮起始数字交换，此时若中间有与起始元素同值的元素，将打破稳定性。</p><p>例:　7 7 2 。第一轮交换第一个 7 和 2，则两个 7 位置关系改变。</p><br /><h3 id="双元选择优化"><a href="#双元选择优化" class="headerlink" title="双元选择优化"></a>双元选择优化</h3><p>在遍历寻找最小值下标 $minIdx$ 时，可以同时寻找最大值下标 $maxIdx$ ，这样就可以一轮遍历确定两个元素的位置，遍历次数减少一半，但每轮次的操作变多，因此该优化 <strong>只能少量提升选择排序的速度</strong> (复杂度介于单元选择排序复杂度及其一半之间，只有系数上的区别)。</p><br /><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：两层 $for$ 循环，第1轮比较 $n - 1$ 次 ( <code>n = arr.length</code> ) ，最后一轮比较 1 次。总比较次数为 $n*(n - 1) &#x2F; 2$ 次，时间复杂度为 $O(n^2)$。 双元选择优化版本也是 $O(n^2)$。</p><p>冒泡排序和选择排序的比较次数均为 $O(n^2)$，但选择排序的交换次数是 $O(n)$，而冒泡排序的平均交换次数仍然是二次的。</p><p>空间复杂度：算法中只有常数项变量，$O(1)$。</p><br /><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><h4 id="单元选择排序"><a href="#单元选择排序" class="headerlink" title="单元选择排序"></a>单元选择排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] selectSort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="comment">// n - 1 轮次执行,当前 n - 1 个元素排好后，最后一个元素无需执行，故 i &lt; arr.length - 1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minIdx</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="comment">// 找到本轮执行中最小的元素，将最小值下标赋值给min</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIdx])  minIdx = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若本轮第一个数字不是最小值，则交换位置</span></span><br><span class="line">        <span class="keyword">if</span> (minIdx != i) swap(arr, i, minIdx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h4 id="双元选择排序"><a href="#双元选择排序" class="headerlink" title="双元选择排序"></a>双元选择排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] selectSortDouble(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">    <span class="comment">// 每轮确定两个数字，因此界也会动态变化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - <span class="number">1</span> - i; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minIdx</span> <span class="operator">=</span> i, maxIdx = i;</span><br><span class="line">        <span class="comment">// 找到本轮执行中最小和最大的元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; n - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIdx]) minIdx = j;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &gt; arr[maxIdx]) maxIdx = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若本轮最大值等于最小值，说明未排序部分所有元素相等，无需再排序</span></span><br><span class="line">        <span class="keyword">if</span>(minIdx == maxIdx) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 若本轮第一个数字不是最小值，则交换位置（将最小值与本轮第一个数字交换位置）</span></span><br><span class="line">        <span class="keyword">if</span> (minIdx != i) swap(arr, i, minIdx);</span><br><span class="line">        <span class="comment">// 在交换i和minIdx时，有可能出现i即maxIdx的情况，此时需要修改maxIdx为minIdx</span></span><br><span class="line">        <span class="keyword">if</span>(maxIdx == i) maxIdx = minIdx;</span><br><span class="line">        <span class="comment">// 若本轮最后一个数字不是最大值，则交换位置（将最大值与本轮最后一个数字交换位置）</span></span><br><span class="line">        <span class="keyword">if</span> (maxIdx != n - <span class="number">1</span> - i) swap(arr, n - <span class="number">1</span> - i, maxIdx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="算法描述-2"><a href="#算法描述-2" class="headerlink" title="算法描述"></a>算法描述</h3><p>对于待排序数组，从第 2 个元素开始 (称作插入对象元素) ，比较它与之前的元素 (称作比较对象元素) ，当插入对象元素小于比较对象元素时，继续往前比较，直到不小于(≥)比较对象，此时将插入对象元素插入到该次比较对象元素之后。重复这个插入过程直到最后一个元素作为插入对象元素完成插入操作。</p><p>如下 <a href="https://tva1.sinaimg.cn/large/008i3skNgy1gze7ygeszkg309k0amai1.gif">动图</a> 展示了 ${4,6,2,1,7,9,5,8,3}$ 的简单插入排序过程。</p><p><img src="https://pic.leetcode-cn.com/1652692170-fPOTLH-insert.gif" alt="insert.gif"></p><p><strong>稳定性：简单插入和折半插入(二分插入)排序是稳定的。</strong></p><p>对于大小相同的两个数字，简单插入和折半插入均使得后来的数字靠右放置 （因为条件是 <code>≥</code> ），因此不会改变其相对位置。</p><br /><h3 id="折半插入优化"><a href="#折半插入优化" class="headerlink" title="折半插入优化"></a>折半插入优化</h3><p>注意到插入排序的每一轮向前插入都使得该元素在完成插入后，<strong>从第一个元素到该元素是排序状态</strong>（指这部分的相对排序状态，在它们中间后续可能还会插入其他数字），利用这一点，对一个新的插入对象向前执行折半插入，能够显著减少比较的次数。另一种优化是增量递减插入排序，也叫希尔排序，将在希尔排序章节中介绍。</p><p>折半插入的关键在于找到插入位置，折半过程代码如下。这实际上是二分查找「模版一」中的「小于等于」情形。如果你尚不能熟练且准确地写出如下代码，这可能是因为对二分查找写法不熟悉，推荐阅读我写的这篇文章: <a href="https://leetcode.cn/circle/discuss/ooxfo8/">二分查找从入门到入睡</a>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">center</span> <span class="operator">=</span> low + (high - low) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (arr[center] &lt;= target) low = center + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> high = center - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h3 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：两层 $for$ 循环，外层总轮次为 $n - 1$ 轮 ( <code>n = arr.length</code> ) ，当原数组逆序时，移动次数为 $n*(n - 1) &#x2F; 2$ 次，最坏时间复杂度为 $O(n^2)$，平均时间复杂度同为 $O(n^2)$。当原数组已基本有序时，接近线性复杂度 $O(n)$。例如原数组已完全排序，则算法只需比较 n - 1 次。</p><p>※ 折半插入总的查找(比较)次数虽为 $O(nlogn)$，但平均移动 (每轮移动一半的数字) 次数仍是 $O(n^2)$。</p><p>空间复杂度：算法中只有常数项变量，$O(1)$。</p><br /><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><h4 id="简单插入排序"><a href="#简单插入排序" class="headerlink" title="简单插入排序"></a>简单插入排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] insertSort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123; <span class="comment">// N-1轮次执行</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> arr[i], j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(target &lt; arr[j]) arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j + <span class="number">1</span>] = target; <span class="comment">// 若发生移动，此时的插入对象数字≥j位置的数字，故插入位置为j + 1，若未移动也成立，无需判断</span></span><br><span class="line">        <span class="comment">// if(j != i - 1) arr[j + 1] = target; // 也可以用这种写法，表示发生移动才插入，否则不必插入(赋值)，但不判断效率更高</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h4 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] insertSortBinary(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="comment">// n - 1 轮次执行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 若当前插入对象大于等于前一个对象，无需插入</span></span><br><span class="line">        <span class="keyword">if</span> (arr[i - <span class="number">1</span>] &lt;= arr[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        <span class="comment">// 折半查找 (二分查找「模版一」)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>, high = i - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// while结束后，target要插入的位置为low或high + 1 (low = high + 1)</span></span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">center</span> <span class="operator">=</span> low + (high - low) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (arr[center] &lt;= target) low = center + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> high = center - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &gt; low; j--) &#123; <span class="comment">// 移动</span></span><br><span class="line">            arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        arr[low] = target; <span class="comment">// 插入</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><h3 id="算法描述-3"><a href="#算法描述-3" class="headerlink" title="算法描述"></a>算法描述</h3><p><a href="https://en.wikipedia.org/wiki/Shellsort">希尔排序</a> 是<strong>简单插入排序的改进</strong>，它基于以下事实。</p><ol><li><p>简单插入排序对<strong>排序程度较高的序列</strong>有较高的效率。假设初始序列已完全排序，则每一轮均只需比较一次，将得到 $O(n)$ 的线性复杂度，冒泡排序和选择排序做不到这一点，均仍需 $O(n^2)$ 次比较(冒泡排序在应用提前结束优化后可以做到)。</p></li><li><p>简单插入排序每次比较最多将数字移动一位，效率较低。</p></li></ol><p>Donald Shell 在 1959 年发表的 <a href="http://penguin.ewu.edu/cscd300/Topic/AdvSorting/p30-shell.pdf">论文</a> 中，针对第二点，提出如下方法。对原待排序列中相隔 $gap$ 的数字执行简单插入排序，然后缩小 $gap$，对新的 $gap$ 间隔的数字再次执行简单插入排序。以一种规则减少 $gap$ 的大小，当 $gap$ 为 1 时即简单插入排序，因此希尔排序也称作 <strong>增量递减排序</strong>。希尔在论文中提出的增量序列生成式为 $n &#x2F; 2^k$，<code>k = 1, 2, 3, ...</code> ，例如 <code>n = 11</code>，则增量序列为 ${1,2,5}$ 。在讨论希尔排序时，可将其称为 <strong>Shell增量</strong>，另有更优的 <strong>Hibbard增量</strong>、<strong>Knuth增量</strong>、<strong>Sedgewick增量</strong> 等。</p><p>程序开始时 $gap$ 较大，待排元素较少，因此排序速度较快。当 $gap$ 较小时，基于第一点，此时待排序列已大致有序，排序效率接近线性复杂度。因此能够期待希尔排序复杂度将优于 $O(n^2)$。详细见「复杂度分析」。</p><p><strong>稳定性：不稳定。</strong></p><p><code>gap &gt; 1</code> 时，跨越 $gap$ 的插入可能会改变两个相同值元素的位置关系。例如 ${0, 1, 4, 3, 3, 5, 6}$ ，当 <code>gap = 2</code> 时，对 ${0, 4, 3, 6}$ 简单插入排序后得到 ${0, 1, 3, 3, 4, 5, 6}$ ，原数组中的两个 3 的位置互换了。</p><br /><h3 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：希尔排序的时间复杂度与增量序列的选择有关。<strong>最优复杂度增量序列尚未明确</strong>。</p><p><strong>Shell增量</strong> (Shell, 1959): $n &#x2F; 2^k$，最坏时间复杂度 $Θ(n^2)$。</p><p><strong>Hibbard增量</strong> (Hibbard, 1963)：${1, 3, 7, 15,…}$ ，即 $2^k - 1,k &#x3D; 1, 2, 3, …$ ， 最坏时间复杂度 $Θ(n^\frac{3}{2})$。</p><p><strong>Knuth增量</strong> (Knuth, 1971)：${1, 4, 13, 40,…}$ ，即 $(3^k - 1) &#x2F; 2，k &#x3D; 1, 2, 3, …$ ，最坏时间复杂度 $Θ(n^\frac{3}{2})$。</p><p><strong>Sedgewick增量</strong> (Sedgewick, 1982): ${1, 8, 23, 77, 281… }$ ，即 $4^k + 3*2^{k-1} + 1$ (最小增量 1 直接给出)，$k &#x3D; 1,2,3,…$ ，最坏时间复杂度 $Θ(n^\frac{4}{3})$。</p><p>平均 &#x2F; 最坏复杂度的证明需要借助数论和组合数学，略 (我不会)。</p><p>当输入数组已排序时，达到最好时间复杂度。</p><p>空间复杂度：算法中只有常数项变量，$O(1)$ 。</p><br /><h3 id="逆序数"><a href="#逆序数" class="headerlink" title="逆序数"></a><strong>逆序数</strong></h3><p>希尔排序是较早出现的 <strong>突破二次复杂度</strong> 的排序算法，下面从 <strong>逆序数</strong> 的角度来直观地证明为何希尔排序能够突破二次复杂度。</p><p>在一个排列中，如果任意一对数的前后位置与大小顺序相反，即前面的数大于后面的数，那么它们就称为一个 <strong>逆序</strong>，一个排列中逆序的总数就称为这个排列的 <strong>逆序数</strong>。排序的过程就是不断减少逆序数 <strong>直到逆序数为 0</strong> 的过程。</p><p>回顾冒泡排序和简单插入排序，算法的每一次交换，都只交换相邻元素（简单插入排序中元素每次右移也看作交换），因此每次交换只能减少一个逆序。冒泡排序和简单插入排序的元素平均交换次数均为 $O(n^2)$， 也即逆序数 (或逆序数减少次数) 为 $O(n^2)$。 如果能跨越多个数字进行交换，则可能一次减少多个逆序。在选择排序中，每轮选到最小元素后的交换即是跨越多个元素的，交换次数 (减少逆序数的操作) 为 $O(n)$，要少于冒泡和简单插入排序，只是因为比较次数仍是 $O(n^2)$， 所以整体复杂度为 $O(n^2)$。</p><p>现在来分析跨越多个元素的交换如何减少逆序数，假设 $arr[i]&gt;arr[j],i&lt;j$。对于任意的 $arr[k] (i &lt; k &lt; j)$：</p><ol><li><p>若 $arr[k] &lt; arr[j]$ ，交换 $arr[i] 和 $arr[j] 后，三者的逆序数从 2 变为 1。</p></li><li><p>若 $arr[k] &gt; arr[i]$ ，交换 $arr[i] 和 $arr[j] 后，三者的逆序数从 2 变为 1。</p></li><li><p>若 $arr[i] &gt; arr[k] &gt; arr[j]$，交换 $arr[i]$ 和 $arr[j]$ 后，三者的逆序数从 3 变为 0 。</p></li></ol><p>$arr[k] &#x3D; arr[i]$ 或 $arr[k] &#x3D; arr[j]$ 的情况一样，都使得三者逆序数从 2 变为 1 ，下图省略。</p><p><img src="https://pic.leetcode-cn.com/1652692231-bmfUsM-image.png" alt="image.png"></p><p>对 $arr[i]$ 和 $arr[j]$ 的逆序消除，使得逆序 <strong>至少</strong> 减少一次，并 <strong>有机会减少大于一次的逆序</strong> (情况3)，因此能够以比 $n^2$ 低阶的次数消除所有逆序。</p><p>实际上归并排序，快速排序，堆排序均实现了 <strong>长距离交换元素</strong>，使得复杂度优于 **O(n^2)**。</p><br /><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><p>从下列实现可看出，不同增量的代码仅 $gap$ 初始化和增量递减上有差异，此差异反映了各自不同的增量。</p><br /><h4 id="Shell增量"><a href="#Shell增量" class="headerlink" title="Shell增量"></a>Shell增量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 希尔排序：采用Shell增量 N / 2^k</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] shellSortShell(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> n / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123; <span class="comment">// gap 初始为 n/2，缩小gap直到1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>; start &lt; gap; start++) &#123; <span class="comment">// 步长增量是gap，当前增量下需要对gap组序列进行简单插入排序</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start + gap; i &lt; n; i += gap) &#123; <span class="comment">// 此for及下一个for对当前增量序列执行简单插入排序</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> arr[i], j = i - gap;</span><br><span class="line">                <span class="keyword">for</span> (; j &gt;= <span class="number">0</span>; j -= gap) &#123; </span><br><span class="line">                     <span class="keyword">if</span> (target &lt; arr[j]) &#123;</span><br><span class="line">                         arr[j + gap] = arr[j];</span><br><span class="line">                     &#125; <span class="keyword">else</span> <span class="keyword">break</span>; </span><br><span class="line">                &#125;                 </span><br><span class="line">                <span class="keyword">if</span> (j != i - gap) arr[j + gap] = target;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del><strong>尤其需要注意的是</strong>，网上有大量<strong>错误的「Shell增量」希尔排序写法</strong>写成如下形式，gap直接从 n &#x2F; 2开始，虽然gap减小到1时变成简单插入排序，可以得到正确结果，但增量序列并不一定满足「Shell增量」的定义，实际上只有当n为2的整数次幂时才满足。</del> 删除内容为作者早先的错误认识，实际上 $Shell$ 增量并未要求增量序列必须为 ${1,2,4,8,16,…}$ ，而是无论 $n$ 等于多少，都直接从 $n &#x2F; 2$ 开始，不断除 2 直到 <code>gap = 1</code>。详情可参考 Donald Shell 原论文 <a href="https://dl.acm.org/doi/pdf/10.1145/368370.368387">A High-Speed Sorting Procedure</a>。原论文TABLE 1给出了长度为 11 的序列 ${3, 11, 6, 4, 9, 5, 7,8,10, 2, 1}$，首个 $gap$ 为 <code>gap = 11 / 2 = 5</code>，接着是 <code>gap = 2</code> ，<code>gap = 1</code>。</p><br /><h4 id="Hibbard增量"><a href="#Hibbard增量" class="headerlink" title="Hibbard增量"></a>Hibbard增量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 希尔排序： 采用Hibbard增量 &#123;1, 3, 7, 15,...&#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] shellSortHibbard(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length, gap = <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">while</span> (gap &lt; n / <span class="number">2</span>) gap = gap * <span class="number">2</span> + <span class="number">1</span>; <span class="comment">// 初始化gap (Hibbard增量序列)</span></span><br><span class="line">    <span class="keyword">for</span> (; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123; <span class="comment">// 缩小gap直到1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>; start &lt; gap; start++) &#123; <span class="comment">// 步长增量是gap，当前增量下需要对gap组序列进行简单插入排序</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start + gap; i &lt; arr.length; i += gap) &#123; <span class="comment">// 此for及下一个for对当前增量序列执行简单插入排序</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> arr[i], j = i - gap;</span><br><span class="line">                <span class="keyword">for</span> (; j &gt;= <span class="number">0</span>; j -= gap) &#123; </span><br><span class="line">                     <span class="keyword">if</span> (target &lt; arr[j]) &#123;</span><br><span class="line">                         arr[j + gap] = arr[j];</span><br><span class="line">                     &#125; <span class="keyword">else</span> <span class="keyword">break</span>; </span><br><span class="line">                &#125;                 </span><br><span class="line">                <span class="keyword">if</span> (j != i - gap) arr[j + gap] = target;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h4 id="Knuth增量"><a href="#Knuth增量" class="headerlink" title="Knuth增量"></a>Knuth增量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 希尔排序： 采用Knuth增量 &#123;1, 4, 13, 40,...&#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] shellSortKnuth(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length, gap = <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">while</span> (gap &lt; n / <span class="number">3</span>) gap = gap * <span class="number">3</span> + <span class="number">1</span>; <span class="comment">// 初始化gap (Knuth增量序列)</span></span><br><span class="line">    <span class="keyword">for</span> (; gap &gt; <span class="number">0</span>; gap /= <span class="number">3</span>) &#123; <span class="comment">// 缩小gap直到1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>; start &lt; gap; start++) &#123; <span class="comment">// 步长增量是gap，当前增量下需要对gap组序列进行简单插入排序</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start + gap; i &lt; arr.length; i += gap) &#123; <span class="comment">// 此for及下一个for对当前增量序列执行简单插入排序</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> arr[i], j = i - gap;</span><br><span class="line">                <span class="keyword">for</span> (; j &gt;= <span class="number">0</span>; j -= gap) &#123; </span><br><span class="line">                     <span class="keyword">if</span> (target &lt; arr[j]) &#123;</span><br><span class="line">                         arr[j + gap] = arr[j];</span><br><span class="line">                     &#125; <span class="keyword">else</span> <span class="keyword">break</span>; </span><br><span class="line">                &#125;                 </span><br><span class="line">                <span class="keyword">if</span> (j != i - gap) arr[j + gap] = target;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h4 id="Sedgewick增量"><a href="#Sedgewick增量" class="headerlink" title="Sedgewick增量"></a>Sedgewick增量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] shellSortSedgewick(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length, gap = <span class="number">1</span>;</span><br><span class="line">    List&lt;Integer&gt; gaps = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    gaps.add(gap);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; gap &lt; n; k++)&#123; <span class="comment">// 计算增量序列</span></span><br><span class="line">        gap = (<span class="type">int</span>) (Math.pow(<span class="number">4</span>, k) + <span class="number">3</span> * Math.pow(<span class="number">2</span>, k - <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">        gaps.add(gap);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> gaps.size() - <span class="number">1</span>; idx &gt;= <span class="number">0</span>; --idx) &#123; <span class="comment">// 缩小 gap 直到 1</span></span><br><span class="line">        gap = gaps.get(idx);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>; start &lt; gap; start++) &#123; <span class="comment">// 步长增量是 gap ，当前增量下需要对 gap 组序列进行简单插入排序</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start + gap; i &lt; n; i += gap) &#123; <span class="comment">// 此 for 及下一个 for 对当前增量序列执行简单插入排序</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> arr[i], j = i - gap;</span><br><span class="line">                <span class="keyword">for</span> (; j &gt;= <span class="number">0</span>; j -= gap) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (target &lt; arr[j]) &#123;</span><br><span class="line">                        arr[j + gap] = arr[j];</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j != i - gap) arr[j + gap] = target;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="算法描述-4"><a href="#算法描述-4" class="headerlink" title="算法描述"></a>算法描述</h3><p>归并排序是 <strong>分治思想</strong> 的应用，即将原待排数组 <strong>递归或迭代</strong> 地分为左右两半，直到数组长度为 1，然后合并 ($merge$) 左右数组，在合并中完成排序。详细过程需结合代码理解，如下 <a href="https://tva1.sinaimg.cn/large/008i3skNgy1gymsfclus3g309w0aq1b4.gif">动图</a> 展示了 ${4,6,2,1,7,9,5,8,3}$ 的归并排序过程（自顶向下非原地）。合并过程采用 <strong>非原地</strong> 合并方法，即依次比较两部分已排序数组，将比较结果依次写入 <strong>新空间</strong> 中。后续会介绍一种称作 <strong>原地(in-place)</strong> 归并排序的改进，使得空间复杂度达到 <strong>常数级</strong> (自底向上时，$O(1)$)。</p><p><img src="https://pic.leetcode-cn.com/1652692297-eViXmh-merge.gif" alt="merge.gif"></p><p>如下树状图中的橙色线表示递归的轨迹（自顶向下递归归并排序）。</p><p><img src="https://pic.leetcode-cn.com/1652692317-RPkNWF-image.png" alt="image.png"></p><p><strong>稳定性：稳定。</strong></p><p>合并时的此判断中的等号 <code>if(left[l_next] &lt;= right[r_next])</code>，保证了出现相等元素时，居左的元素总会被放在左侧，即排序是稳定的。</p><br /><h3 id="自顶向下和自底向上"><a href="#自顶向下和自底向上" class="headerlink" title="自顶向下和自底向上"></a>自顶向下和自底向上</h3><p>可以通过 <strong>自顶向下 (top-down)</strong> 或 <strong>自底向上 (bottom-up)</strong> 的方式实现归并排序。</p><p>自顶向下 (top-down)：从输入数组出发，不断二分该数组，直到数组长度为1，再执行合并。适合用 <strong>递归</strong> 实现。</p><p>自底向上 (bottom-up)：从输入数组的单个元素出发，一一合并，二二合并，四四合并直到数组有序。适合用 <strong>迭代</strong> 实现。</p><p>后续给出 自顶向下原地 &#x2F; 自顶向下非原地 &#x2F; 自底向上原地 &#x2F; 自底向上非原地 四种代码实现。</p><br /><h3 id="原地归并"><a href="#原地归并" class="headerlink" title="原地归并"></a>原地归并</h3><p>前述归并排序，每一次合并都是将两部分待合并数组的比较结果写入一个与 $arr$ 等大小的临时数组 $tmpArr$ 中，写入后再将 $tmpArr$ 中的合并结果写回到 $arr$ 中。于是 $tmpArr$ 的空间开销即为该实现的空间复杂度，为 $O(n)$。实际上，通过一种 <strong>原地旋转交换</strong> 的方法（俗称手摇算法&#x2F;内存反转算法&#x2F;三重反转算法，英文社区一般称为 <a href="https://en.wikipedia.org/wiki/Block_swap_algorithms">block swap algorithm</a>），则只需要 $O(1)$ 的辅助空间（由于递归空间为 $O(logn)$，其总的空间复杂度仍为 $O(logn)$）。以下介绍旋转交换的实现方法。</p><p>以 456123 为例，欲将 456 和 123 交换位置转换为 123456，只需要执行三次旋转即可：</p><ol><li>旋转 456，得到 654</li><li>旋转 123，得到 321</li><li>旋转 654321 得到 123456</li></ol><p>应用上述「手摇算法」对两个排序序列的「原地归并」过程如下。</p><ol><li><p>记左数组第一个数下标为 $i$ ，记右数组第一个数下标为 $j$ 。</p></li><li><p>找到左数组中第一个 <strong>大于</strong> 右数组第一个数字的数，记其下标为 $i$ 。</p></li><li><p>以 $index$ 暂存右数组第一个元素的下标 $index &#x3D; j$ 。</p></li><li><p>找到右数组中第一个 <strong>大于等于</strong> $arr[i]$ 的数，记其下标为 $j$ 。此时必有 $[i, index - 1]$ 下标范围序列大于 $[index, j - 1]$ 下标范围序列。</p></li><li><p>通过三次翻转交换 $[i, index-1]$ 和 $[index, j - 1]$ 序列 (指下标范围)，即依次翻转 $[i, index-1]$ ，翻转 $[index, j - 1]$ ，翻转 $[i, j - 1]$ 。</p></li><li><p>重复上述过程直到不满足 <code>(i &lt; j &amp;&amp; j &lt;= rightEnd)</code></p></li></ol><p>※ 第4步如果找「大于」而不是「大于等于」，对于数字数组排序，结果正确，但将 <strong>破坏稳定性</strong>。建议动手画一下。</p><p>以 ${1, 2, 4, 6, 7}$ 与 ${3, 5, 8, 9}$  两个已排序序列的合并为例，观察借助手摇算法实现原地归并的过程。</p><ol><li>在 ${1, 2, 4, 6, 7}$ 中找到第一个大于 3 的数 4 ，其下标为 2 ，$i &#x3D; 2$。$index &#x3D; j &#x3D; 5$。在 ${3, 5, 8, 9}$ 中找到第一个大于 $arr[i] &#x3D; arr[2] &#x3D; 4$ 的数 5，其下标为 6，$j &#x3D; 6$  。</li><li>如上操作使得 $[0, i - 1]$ 必是最小序列，$[index, j - 1]$ 必小于 $arr[i]$ 。因此交换 $[i, index - 1]$ 和 $[index, j - 1]$（采用三次旋转完成交换），使得这部分序列在整个数组中有序。</li><li>交换后，继续执行上述过程，直到不满足该条件 ：<code>i &lt; j &amp;&amp; j &lt;= rightEnd</code>。</li></ol><p><img src="https://pic.leetcode-cn.com/1652692350-OvThvJ-image.png" alt="image.png"></p><br /><h3 id="复杂度分析-4"><a href="#复杂度分析-4" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><h4 id="自顶向下非原地"><a href="#自顶向下非原地" class="headerlink" title="自顶向下非原地"></a>自顶向下非原地</h4><p><strong>时间复杂度</strong></p><p>每次减半后的左右两半对应元素的对比 ( <code>if(left[l_next] &lt;= right[r_next])</code> ) 和赋值 ( <code>resArr[res_next++] = ??? </code> ) 总是必须的，也即在每一层递归中(这里的一层指的是 <strong>递归树</strong> 中的层)，比较和赋值的时间复杂度都是 $O(n)$，数组规模减半次数为 $logn$，即递归深度为 $logn$，也即总共需要 $logn$ 次 $O(n)$ 的比较和赋值，时间复杂度为 $O(nlogn)$。</p><p>也可以这样求解。当 $n &#x3D; 1$ 时，排序只需常数时间，可以记为 1。$n$ 个元素的归并排序时间由 $n&#x2F;2$ 个元素的归并排序的两倍，再加上将两个 $n&#x2F;2$ 大小的已排序数比较及合并的耗时得到。得到如下两个式子(第2个式子加号右边的 $n$ 表示比较及合并的时间)。</p><p>$$<br>\begin{aligned}<br>T(1)&amp;&#x3D;1 \<br>T(n)&amp;&#x3D;2 T(n &#x2F; 2)+n<br>\end{aligned}<br>$$</p><p>对第二个式子，左右两边除以n，得到</p><p>$$<br>\frac{T(n)}{n}&#x3D;\frac{T(n &#x2F; 2)}{n &#x2F; 2}+1<br>$$</p><p>可以不断地将括号内的n除以2(假设n为2的多次幂)，从 $T(n) &#x2F; n$ 写到 $T(1)$ ，得到</p><p>$$<br>\begin{aligned}<br>\frac{T(n)}{n} &amp;&#x3D;\frac{T(n &#x2F; 2)}{n &#x2F; 2}+1 \<br>\frac{T(n &#x2F; 2)}{n &#x2F; 2} &amp;&#x3D;\frac{T(n &#x2F; 4)}{n &#x2F; 4}+1 \<br>\frac{T(n &#x2F; 4)}{n &#x2F; 4} &amp;&#x3D;\frac{T(n &#x2F; 8)}{n &#x2F; 8}+1 \<br>&amp; \cdots  \<br>\frac{T(2)}{2} &amp;&#x3D;\frac{T(1)}{1}+1<br>\end{aligned}<br>$$</p><p>将上述所有式子相加后得到如下，故复杂度为 $O(nlogn)$。</p><p>$$<br>\begin{gathered}<br>\frac{T(n)}{n}&#x3D;\frac{T(1)}{1}+\log n \<br>T(n)&#x3D;n+n \log n<br>\end{gathered}<br>$$</p><p><strong>空间复杂度</strong></p><p>递归深度为 $logn$，递归过程中需要一个长度为 $n$ 的临时数组保存中间结果，空间复杂度为 $O(n)$。</p><br /><h4 id="自顶向下原地"><a href="#自顶向下原地" class="headerlink" title="自顶向下原地"></a>自顶向下原地</h4><p><strong>时间复杂度</strong></p><p>该方式的时间复杂度计算参考了<a href="https://blog.csdn.net/weixin_45502929/article/details/110914032">此篇文章</a>。</p><p>当序列为 <strong>链表</strong> 时，手摇算法只需做如下指针调整即可（只做示意，非实际代码）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">双向链表时：</span><br><span class="line">tmp = index.prev </span><br><span class="line">index.prev = i.prev</span><br><span class="line">i.prev = j.prev</span><br><span class="line">j.prev = tmp</span><br><span class="line"></span><br><span class="line">单向链表时：</span><br><span class="line">(i-1).next = index</span><br><span class="line">(index-1).next = j</span><br><span class="line">(j-1).next = i</span><br></pre></td></tr></table></figure><p><img src="https://pic.leetcode-cn.com/1652692690-NszjAD-image.png" alt="image.png"></p><p>对于长度为 $n$ 的序列，手摇算法操作元素个数至多不超过 $n&#x2F;2$ 个，容易得到下述递推式。</p><p>$$<br>T(n)&#x3D;c \cdot \frac{n}{2}+2 T\left(\frac{n}{2}\right)<br>$$</p><p>由前述计算方法可复杂度为 $O(nlogn)$。</p><p>当序列为<strong>数组</strong>时，以 {1,3,5,7,…k} 和 {2,4,6,8,…,n} 的手摇合并为例，对于长度为 n 的序列，一次手摇算法需要对一半规模（非严格的一半）的元素进行翻转（翻转两次）。例如第一次手摇，需翻转{3, …, k}和{2}（ {2} 只有一个元素，实际不翻转）得到 {k, …, 3} 和 {2} ，然后再翻转 {k, …, 3, 2} 得到 {2, 3, …, k}。下一次手摇对象是{5, …, k}和{4}，翻转元素个数相比上一次减少一个，可知完成 {1,3,5,7,…k} 和 {2,4,6,8,…,n} 的手摇合并所需要的对元素的翻转次数是 $c*n^2$ (等差数列求和，c是一常数)，于是有下列递推式。</p><p>$$<br>T(n)&#x3D;c n^{2}+2 T\left(\frac{n}{2}\right)<br>$$</p><p>仍沿用前述方法计算</p><p>$$<br>\begin{gathered}<br>\frac{T(n)}{n}&#x3D;\frac{T(n &#x2F; 2)}{n &#x2F; 2}+c n \<br>\frac{T(n &#x2F; 2)}{n &#x2F; 2}&#x3D;\frac{T(n &#x2F; 4)}{n &#x2F; 4}+c \frac{n}{2} \<br>\frac{T(n &#x2F; 4)}{n &#x2F; 4}&#x3D;\frac{T(n &#x2F; 8)}{n &#x2F; 8}+c \frac{n}{4} \<br>\cdots \<br>\frac{T(2)}{2}&#x3D;\frac{T(1)}{1}+c \frac{n}{2^{k-1}}<br>\end{gathered}<br>$$</p><p>其中 $k &#x3D; logn$，由等比数列求和公式得到</p><p>$$<br>\begin{aligned}<br>&amp;\frac{T(n)}{n}&#x3D;c \frac{n\left(1-\left(\frac{1}{2}\right)^{k}\right)}{1-\frac{1}{2}}+1 \<br>&amp;T(n)&#x3D;2 c n^{2}-2 c n\left(\frac{1}{2}\right)^{k}+n<br>\end{aligned}<br>$$</p><p>故复杂度为 $O(n^2)$。</p><p>上述复杂度为 <strong>最坏及平均情形</strong>， <strong>最好情形是输入数组已排序</strong>，则无需手摇，但序列长度为 n 时需要的比较判断次数是 n，于是最好情形的递推式如下，复杂度为 $O(nlogn)$。</p><p>$$<br>T(n)&#x3D;2 T(n &#x2F; 2)+n<br>$$</p><p><strong>空间复杂度</strong></p><p>递归深度为 $logn$，手摇算法仅需 $O(1)$ 的辅助空间，综合来看空间复杂度为 $O(logn)$。</p><br /><h4 id="自底向上非原地-amp-自底向上原地"><a href="#自底向上非原地-amp-自底向上原地" class="headerlink" title="自底向上非原地 &amp; 自底向上原地"></a>自底向上非原地 &amp; 自底向上原地</h4><p><strong>时间复杂度</strong></p><p>同自顶向下非原地&#x2F;原地的分析类似，只是程序运行过程从递归变为了迭代。</p><p><strong>空间复杂度</strong></p><p>自底向上非原地归并：迭代过程中需要一个长度为 n 的临时数组保存中间结果，空间复杂度为 $O(n)$。</p><p>自底向上原地归并：手摇算法仅需 $O(1)$ 的辅助空间，其他空间开销均为常数级，空间复杂度为 $O(1)$。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>四种归并排序的时空复杂度总结如下（待排序序列是数组形式，不考虑链表形式）。</p><table><thead><tr><th>归并排序</th><th>平均时间</th><th>最好时间</th><th>最坏时间</th><th>空间</th><th>稳定性</th><th>备注</th></tr></thead><tbody><tr><td>自顶向下非原地</td><td>$O(nlogn)$</td><td>$O(nlogn)$</td><td>$O(nlogn)$</td><td>$O(n)$</td><td>稳定</td><td>递归深度 $O(logn)$，辅助空间为 $O(n)$</td></tr><tr><td>自顶向下原地</td><td>$O(n^2)$</td><td>$O(nlogn)$</td><td>$O(n^2)$</td><td>$O(logn)$</td><td>稳定</td><td>空间消耗为递归深度手摇交换仅需 $O(1)$ 空间最好时间在输入数组有序时取得</td></tr><tr><td>自底向上非原地</td><td>$O(nlogn)$</td><td>$O(nlogn)$</td><td>$O(nlogn)$</td><td>$O(n)$</td><td>稳定</td><td>无递归深度，辅助空间为 $O(n)$</td></tr><tr><td>自底向上原地</td><td>$O(n^2)$</td><td>$O(nlogn)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td>稳定</td><td>手摇交换仅需 $O(1)$ 空间</td></tr></tbody></table><p>根据上述分析，原地相比非原地，空间消耗较少，采用自底向上原地归并排序时空间复杂度为常数级 $O(1$)，但需要 $O(n^2)$ 的时间复杂度。是一种以时间换空间的做法，通常空间不为瓶颈时，应采用 <strong>效率更高的非原地归并排序。</strong></p><br /><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><h4 id="自顶向下非原地归并"><a href="#自顶向下非原地归并" class="headerlink" title="自顶向下非原地归并"></a>自顶向下非原地归并</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] mergeSort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="type">int</span>[] tmpArr = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line">    mergeSort(arr, tmpArr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span>[] tmpArr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">center</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        mergeSort(arr, tmpArr, left, center);</span><br><span class="line">        mergeSort(arr, tmpArr, center + <span class="number">1</span>, right);</span><br><span class="line">        merge(arr, tmpArr, left, center, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非原地合并方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span>[] tmpArr, <span class="type">int</span> leftPos, <span class="type">int</span> leftEnd, <span class="type">int</span> rightEnd)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">rightPos</span> <span class="operator">=</span> leftEnd + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">startIdx</span> <span class="operator">=</span> leftPos;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tmpPos</span> <span class="operator">=</span> leftPos;</span><br><span class="line">    <span class="keyword">while</span> (leftPos &lt;= leftEnd &amp;&amp; rightPos &lt;= rightEnd) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[leftPos] &lt;= arr[rightPos]) &#123;</span><br><span class="line">            tmpArr[tmpPos++] = arr[leftPos++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tmpArr[tmpPos++] = arr[rightPos++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 比较完成后若左数组还有剩余，则将其添加到tmpArr剩余空间</span></span><br><span class="line">    <span class="keyword">while</span> (leftPos &lt;= leftEnd) &#123;</span><br><span class="line">        tmpArr[tmpPos++] = arr[leftPos++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 比较完成后若右数组还有剩余，则将其添加到tmpArr剩余空间</span></span><br><span class="line">    <span class="keyword">while</span> (rightPos &lt;= rightEnd) &#123;</span><br><span class="line">        tmpArr[tmpPos++] = arr[rightPos++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 容易遗漏的步骤，将tmpArr拷回arr中</span></span><br><span class="line">    <span class="comment">// 从小区间排序到大区间排序，大区间包含原来的小区间，需要从arr再对应比较排序到tmpArr中，</span></span><br><span class="line">    <span class="comment">// 所以arr也需要动态更新为排序状态，即随时将tmpArr拷回到arr中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIdx; i &lt;= rightEnd; i++) &#123;</span><br><span class="line">        arr[i] = tmpArr[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h4 id="自顶向下原地归并"><a href="#自顶向下原地归并" class="headerlink" title="自顶向下原地归并"></a>自顶向下原地归并</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] mergeSort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    mergeSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">center</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        mergeSort(arr, left, center);</span><br><span class="line">        mergeSort(arr, center + <span class="number">1</span>, right);</span><br><span class="line">        merge(arr, left, center, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原地归并（手摇算法）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> leftPos, <span class="type">int</span> leftEnd, <span class="type">int</span> rightEnd)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> leftPos, j = leftEnd + <span class="number">1</span>; <span class="comment">// #1</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt; j &amp;&amp; j &lt;= rightEnd) &#123;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; arr[i] &lt;= arr[j]) i++; <span class="comment">// #2</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> j; <span class="comment">// #3</span></span><br><span class="line">        <span class="keyword">while</span>(j &lt;= rightEnd &amp;&amp; arr[j] &lt; arr[i]) j++; <span class="comment">// #4 注意是 arr[j] &lt; arr[i]，即找到j使得arr[j] 为第一个大于等于 arr[i]值</span></span><br><span class="line">        exchange(arr, i, index - <span class="number">1</span>, j - <span class="number">1</span>); <span class="comment">// #5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 三次翻转实现交换</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">exchange</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> leftEnd, <span class="type">int</span> rightEnd)</span> &#123;</span><br><span class="line">    reverse(arr, left, leftEnd);</span><br><span class="line">    reverse(arr, leftEnd + <span class="number">1</span>, rightEnd);</span><br><span class="line">    reverse(arr, left, rightEnd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(start &lt; end) &#123;</span><br><span class="line">        swap(arr, start, end);</span><br><span class="line">        start++;</span><br><span class="line">        end--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h4 id="自底向上非原地归并"><a href="#自底向上非原地归并" class="headerlink" title="自底向上非原地归并"></a>自底向上非原地归并</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] mergeSortBU(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="type">int</span>[] tmpArr = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line">    <span class="comment">// 间隔，注意不能写成gap &lt; arr.length / 2 + 1，此种写法只适用于元素个数为2的n次幂时</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> <span class="number">1</span>; gap &lt; arr.length; gap *= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 基本分区合并(随着间隔的成倍增长，一一合并，二二合并，四四合并...)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>; left &lt; arr.length - gap; left += <span class="number">2</span> * gap) &#123;</span><br><span class="line">            <span class="comment">// 调用非原地合并方法。leftEnd = left+gap-1; rightEnd = left+2*gap-1;</span></span><br><span class="line">            merge(arr, tmpArr, left, left + gap - <span class="number">1</span>, Math.min(left + <span class="number">2</span> * gap - <span class="number">1</span>, arr.length - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>nums</th><th>gap &#x3D; 3时的合并过程</th></tr></thead><tbody><tr><td>1,3,5,2,4,6,7,9,11</td><td>left &#x3D; 0, [1,3,5] 与 [2,4,6]合并<br />left &#x3D; 6 不满足 6 &lt; 9 - 3，最后一个「左段」[7,9,11]无需合并</td></tr><tr><td>1,3,5,2,4,6,7,9,11,8,10,12</td><td>left &#x3D; 0, [1,3,5] 与 [2,4,6]合并<br />left &#x3D; 6, [7,9,11] 与 [8,10,12]合并<br />left &#x3D; 12 不满足 12 &lt; 12 - 3</td></tr><tr><td>1,3,5,2,4,6,7,9,11,8</td><td>left &#x3D; 0, [1,3,5] 与 [2,4,6]合并<br />left &#x3D; 6, [7,9,11] 与 [8]合并<br />left &#x3D; 12 不满足 12 &lt; 10 - 3</td></tr></tbody></table><br /><h4 id="自底向上原地归并"><a href="#自底向上原地归并" class="headerlink" title="自底向上原地归并"></a>自底向上原地归并</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] mergeSortBUInPlace(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="comment">// 间隔，注意不能写成gap &lt; arr.length / 2 + 1，此种写法只适用于元素个数为2的n次幂时</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> <span class="number">1</span>; gap &lt; arr.length; gap *= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 基本分区合并(随着间隔的成倍增长，一一合并，二二合并，四四合并...)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>; left &lt; arr.length - gap; left += <span class="number">2</span> * gap) &#123;</span><br><span class="line">            <span class="comment">// 调用原地合并方法。leftEnd = left+gap-1; rightEnd = left+2*gap-1;</span></span><br><span class="line">            merge(arr, left, left + gap - <span class="number">1</span>, Math.min(left + <span class="number">2</span> * gap - <span class="number">1</span>, arr.length - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="算法描述-5"><a href="#算法描述-5" class="headerlink" title="算法描述"></a>算法描述</h3><p>与归并排序一样，快速排序也是一种利用 <strong>分治思想</strong> 的排序方法，确定 <strong>主轴及分区</strong> 是快速排序的核心操作。首先在数组中确定一个主轴元素(下标记为 $pivot$ )，然后将数组分为两部分，小于主轴的放在（确定最终位置的）主轴左侧，大于等于主轴的放在主轴右侧。递归地对主轴左右两侧数组执行这个过程，每次递归都传入待排序数组 $arr$ 和本次要处理的部分的左右界，只处理这个范围内的序列。当所有递归都到达基准情形时，排序完成。因为是原地交换，递归过程中 $arr$ 总是在动态排序，递归过程无需返回，为尾递归形式。</p><p>详细过程需结合代码理解，如下<a href="https://tva1.sinaimg.cn/large/008i3skNly1gynuubbcdpg306q03gdl9.gif">动图</a>展示了 ${4,6,2,1,7,9,5,8,3}$ 的快速排序过程（以起始元素为主轴）。</p><p><img src="https://pic.leetcode-cn.com/1652692926-vUyVEI-quick.gif" alt="quick.gif"></p><p><strong>主轴的选择</strong></p><ol><li><p><strong>主轴为起始元素</strong> ( $quickSortSimple$ )。每次选取当前数组第一个元素作为主轴。</p><ul><li><p>优点：实现简单。</p></li><li><p>缺点：若输入是较为有序的数组，$pivot$ 总是不能均匀地分割数组。若输入数组本身有序，**复杂度退化到 $O(n^2)$**。</p></li></ul></li><li><p><strong>主轴为随机下标元素</strong> ( $quickSortRandom$ )。每次随机选取当前数组的下标，将该下标元素作为主轴。</p><ul><li><p>优点：避免了主轴为起始元素时对于基本有序的输入，因不能均匀分割数组导致复杂度退化的情况。</p></li><li><p>缺点：随机数的选取本身消耗一定的性能。</p></li></ul></li><li><p><strong>主轴为左中右三数大小居中者</strong> ( $quickSortMedian3$ )。每次比较当前数组起始、中间和末尾三个元素的大小，选择大小居中者为主轴。</p></li></ol><ul><li><p>优点：实现相对简单，且有效避免简单快排中的 <strong>劣质分割</strong>。</p></li><li><p>缺点：三数取中方法消耗一定性能。</p></li></ul><p>快速排序也可以与其他排序相结合，例如当元素较少时使用简单插入排序能够获得更高的排序效率，实际上这就是 JDK 的做法，这里不展开介绍。</p><br /><p><strong>分区方法(partition)</strong></p><p>快速排序中的 <strong>核心方法为 $partition$<strong>。 $partition$方法执行后，</strong>要实现主轴左边元素均小于主轴，主轴右边元素均大等于主轴元素</strong>。</p><p>选定一个数作为主轴后（无论是上述哪种方法选取主轴元素， <strong>都将选定的主轴置于当前数组的起始位置</strong> ），设置一个 $index (index &#x3D; pivot + 1)$ 动态更新最终的主轴下标。从左到右将主轴后的所有元素依次与主轴元素比较，若小于主轴则将该数字与下标为 $index$ 的数字交换，$index$ 右移一位，使得 <strong>$index$ 的前一位总是当前最后一个小于主轴的元素</strong>。遍历比较结束后，交换下标为 $pivot$ 与 $index - 1$ 的数字，并将当前主轴的下标 $index - 1$ 返回。</p><br /><p><strong>稳定性：不稳定。</strong></p><p>$partition$ 中在确定了主轴位置后，将一开始设置的主轴元素与最后一个小于主轴的元素 $x$ 交换时，若中间有与 $x$ 同值的元素，则稳定性被破坏。</p><p>例：7 2 4 4 8 9</p><p>7 为主轴元素，$partition$ 过后交换 7 和第二个 4 ，则两个 4 的位置关系发生变化。</p><br /><h3 id="非递归快排"><a href="#非递归快排" class="headerlink" title="非递归快排"></a>非递归快排</h3><p>前述快排以递归形式写出，递归地确定 $[left, right]$ 区间的 $pivot$ 位置并对新的左区间 $[left, pivot - 1]$ 和右边区间 $[pivot + 1, right]$ 区间执行同样的过程。若要求不以递归形式实现快排，容易想到利用 <strong>栈保存区间左右界</strong>，每次 $partition$ 划分确定 $pivot$ 后将得到的 $pivot$ 左右两侧的区间的 $left,right$ 界压入栈中。过程如下：</p><ol><li><p>初始时区间左右界是 $0, arr.length -1$ ，将他们压入栈（按 $right, left$ 顺序入栈）。</p></li><li><p>以 $while$ 询问当前栈是否空，不空则弹出栈顶的一对界（依次为 $left，right$ ）。</p></li><li><p>若满足 $left &lt; right$ ，则对当前这对 $left,right$ 界的区间执行一次 $partition$ 方法，得到该区间的 $pivot$ 。</p></li><li><p>若满足 $left &lt; pivot$ ，则将 $pivot$ 左侧区间的左右界压入栈（按 $pivot - 1,left$ 顺序入栈）。并列地，若满足 $right &gt; pivot$ ，则将 $pivot$ 右侧区间的左右界压入栈（按 $right,pivot + 1$ 顺序入栈）</p></li><li><p>$while$ 结束时排序完成，返回此时的 $arr$ 。</p></li></ol><p>非递归快排代码实现后续给出，与递归快排一样，在 $partition$ 方法前加入如下两行实现主轴的随机选取；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">randomIndex</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(right - left) + left + <span class="number">1</span>; <span class="comment">// 在[left + 1, right]范围内的随机值</span></span><br><span class="line">swap(arr, left, randomIndex); <span class="comment">// arr[left]与它之后的某个数交换</span></span><br></pre></td></tr></table></figure><p>在 $partition$ 方法前加入如下一行实现主轴的三数取中选取。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">median3(arr, left, right);</span><br></pre></td></tr></table></figure><br /><h3 id="双轴快排"><a href="#双轴快排" class="headerlink" title="双轴快排"></a>双轴快排</h3><p><strong>双轴快排是单轴快排的改进</strong>，初次学习双轴快排需要仔细深入地理解各处细节，因此本小节将详细介绍其实现细节，展示确定双轴位置既区间划分的过程。</p><p>前述快排每次递归确定当前区间的主轴，并利用该主轴将当前区间划分为左右两个部分。双轴快排则以 <strong>两个轴</strong> $(pivot1, pivot2)$ 将当前区间划分为 <strong>三个子区间</strong>，双轴三区间的划分结果要满足如下。为方便叙述，将 $[left, pivot1)$ 称作区间1，$(pivot1, pivot2)$ 称作区间2， $(pivot2, right]$ 称作区间3，其中 $pivot1$ ，$pivot2$ 指的是最终位置，区间1，区间2，区间3均指划分后的最终区间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr[i] &lt; arr[pivot1],  i ∈ [left, pivot1) 区间1</span><br><span class="line">arr[pivot1] ≤ arr[i] ≤ arr[pivot2], i ∈ (pivot1, pivot2) 区间2</span><br><span class="line">arr[i] &gt; arr[pivot2], i ∈ (pivot2, right] 区间3</span><br></pre></td></tr></table></figure><p>对三个子区间执行同样的过程，直到无法划分时排序完成。算法主要过程和说明如下，结合后续代码实现的注释可准确把握各处细节。</p><ol><li><p>$dualPivotQuickSort$ 执行开始，首先以 <code>if(left &lt; right)</code> 为条件，只对大小大于等于 2 的区间执行双轴快排。</p></li><li><p>以如下语句 <strong>令左右两端元素中较小者居左</strong> ，后续以 $left$ 为初始 $pivot1$ (下标)，$right$ 为初始 $pivot2$ (下标)，保证 $pivot1$ 为左右两端元素中的较小者。</p><p>在程序后续内容中，$arr[left]$ 为 $pivot1$ 的值(左轴值)，$arr[right]$ 为 $pivot2$ 的值(右轴值)。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(arr[left] &gt; arr[right]) &#123;</span><br><span class="line">    swap(arr, left, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>设置 $index &#x3D; left + 1$ ，$lower &#x3D; left + 1$，$upper &#x3D; right - 1$ 。</p><p>$index$ 表示当前考察的元素下标。</p><p>$lower$ 是用于推进到 $pivot1$ 最终位置的动态向右扩展的下标（扩展区间1），在程序的任意时刻总有 $[left, lower)$ 的元素 <strong>确定在区间1中</strong> 。</p><p>$upper$ 是用于推进到 $pivot2$ 最终位置的动态向左扩展的下标（扩展区间3），在程序的任意时刻总有 $(upper, right]$ 的元素 <strong>确定在区间3中</strong> 。</p><p>当循环结束时 $lower–$ 和 $upper++$ 为最终的 $pivot1$ 和 $pivot2$ 的位置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">初始时lower == left + 1，表示区间1元素个数为1，</span><br><span class="line">因为lower以左(不含lower)才是确定在区间1中的元素。</span><br><span class="line">在遍历结束后以两个swap完成双轴归位时，</span><br><span class="line">最后一个确定在区间1的元素会与arr[left]交换。</span><br><span class="line">所以说我们一开始就知道left处的元素最终一定在区间1中，</span><br><span class="line">因此初始时令lower == left + 1。</span><br><span class="line">upper == right - 1的初始取值也是基于同样的原因。</span><br><span class="line">如果现在还无法很好地理解这一点，先将整个过程看完后再回过头来多推敲几次。</span><br></pre></td></tr></table></figure></li><li><p>从此处开始，代码行为是要遍历从 $left + 1$ 到 $right - 1$ 的所有元素，通过与 $arr[left]$ (左轴值) 和 $arr[right]$ (右轴值) 的比较，以及元素交换操作，将 <strong>每一个元素正确地置于区间1，区间2和区间3</strong> 中，与此同时，以 $lower$ 的动态右移和 $upper$ 的动态左移，不断扩展这三个区间。 <strong>通过 $index++$，从左到右依次遍历所有元素</strong>，当所有元素遍历完成，也就意味着所有元素都已归于其应属的区间。显然，这些操作应在一个 <strong>循环</strong> 之内，下面进入该循环。</p><ol><li><p>首先，循环的边界条件是 <code>while(index &lt;= upper)</code> 。虽然还未开始分析 $upper$ 的动态变化，但已经知道 $upper$ 以右 (不含 $upper$ ) 的元素是确定在区间3中的，$index$ 向右推进的时候不能超过 $upper$ ，因为下标为 $upper + 1$ 的元素是已确定在区间3中的 (但下标为 $upper$ 的元素尚未确定其归属)，所以是 $&lt;&#x3D;$。</p></li><li><p>以 <code>if(arr[index] &lt; arr[left])</code> 考察 $arr[index]$ 是否应在区间1，若满足则在区间1。这意味需要将该元素置于 $lower$ 左侧，且区间1需向右扩展1位，通过如下两行，交换 $arr[index]$ 和 $arr[lower]$ 后 $lower++$ 来完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">swap(arr, index, lower); </span><br><span class="line">lower++;</span><br></pre></td></tr></table></figure></li><li><p>类似地，以 <code>else if(arr[index] &gt; arr[right])</code> 考察 $arr[index]$ 是否应在区间3，若满足则在区间3。这意味着需要将该元素置于 $upper$ 右侧，且区间3需向左扩展1位。与上一步(4.2)不同的是，不能直接执行如下两行，即交换 $arr[index]$ 和 $arr[upper]$ 后 $upper–$ 。因为如果被交换的当前的 $arr[upper]$ 也是应当位于区间3中的元素，交换后，继续考察下一个元素，且因为考察界满足 i$ndex &lt;&#x3D; upper$ ，将导致该元素无法再被考察，也就无法将其正确地放入区间3中。而上一步并不存在该问题(因为与 $arr[index]$ 交换的 $arr[lower]$ 一定是属于区间2的元素)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">swap(arr, index, upper);</span><br><span class="line">upper--;</span><br></pre></td></tr></table></figure><p>因此，在执行上述两行之前，应该实现一种操作，使得与 $arr[index]$ 交换的 $arr[upper]$ 不是区间3中的元素。于是可以先从当前 $arr[upper]$ 往左考察是否有 $arr[upper] &gt; arr[right]$ ，若满足则表示 $arr[upper]$ 确定在区间3中，于是 $upper–$ 扩展区间3，直到不满足时表示此时 $arr[upper]$ 确定为不在区间3中的元素，于是才交换 $arr[index]$ 和 $arr[upper]$，然后 $upper–$ ，如下。需要注意的是 $while$ 中还有一个条件，即 $index &lt; upper$ ，因为区间3左扩不可使 $index &#x3D;&#x3D; upper$ ，否则之后的第二条 $upper–$ 将导致 $upper$ 为一个已经确定了区间归属的元素的位置（ $arr[index - 1]$ 为已考察过元素）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(arr[upper] &gt; arr[right] &amp;&amp; index &lt; upper) &#123;</span><br><span class="line">    upper--;</span><br><span class="line">&#125;</span><br><span class="line">swap(arr, index, upper);</span><br><span class="line">upper--;</span><br></pre></td></tr></table></figure><p>如上，交换 $arr[index]$ 和 $arr[upper]$ 后，此时的 $arr[index]$ 确定不在区间3中，但在区间1还是区间2中仍需明确，否则之后 $index++$ 跳过该元素后将可能导致该元素归属错误。于是再对其执行一次与4.2相同的步骤。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(arr[index] &lt; arr[left]) &#123;</span><br><span class="line">    swap(arr, index, lower);</span><br><span class="line">    lower++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述 $if$ 和 $elseif$ 完成了对一个属于区间1和区间3元素考察和处理，不满足 $if$ 且不满足 $elseif$ 的元素属于区间2，其已处于 $(lower, upper)$ 之间，无需移动。</p><p>前述操作完成了对 $arr[index]$ 的考察和处理（移动或不移动），于是 $index++$ ，考察下一个元素。</p></li></ol></li><li><p>当 <code>while(index &lt;= upper)</code> 结束时，所有元素考察处理完毕，此时最后一个确定在区间1的元素下标是 $lower–$ ，最后一个确定在区间3的元素下标是 $upper++$ 。如下，通过交换将初始轴归于其正确的位置。最后对三个子区间分别递归地执行双轴快排。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lower--;</span><br><span class="line">upper++;</span><br><span class="line">swap(arr, left, lower);</span><br><span class="line">swap(arr, upper, right);</span><br><span class="line">dualPivotQuickSort(arr, left, lower - <span class="number">1</span>); <span class="comment">// 区间1</span></span><br><span class="line">dualPivotQuickSort(arr, lower + <span class="number">1</span>, upper - <span class="number">1</span>); <span class="comment">// 区间2</span></span><br><span class="line">dualPivotQuickSort(arr, upper + <span class="number">1</span>, right); <span class="comment">// 区间3</span></span><br></pre></td></tr></table></figure></li></ol><p>下图展示了双轴快排对 ${29, 46, 21, 90, 14, 1, 68, 34, 55, 8}$ 的双轴位置确定也即区间划分的过程。浅蓝色表示未排序，绿色表示左轴值，深蓝色表示右轴值，黄色表示区间1，灰色表示区间2，橙色表示区间3。</p><p><img src="https://pic.leetcode-cn.com/1652692972-TbEiju-image.png" alt="image.png"></p><br /><h3 id="复杂度分析-5"><a href="#复杂度分析-5" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：平均 &#x2F; 最好为 $O(nlogn)$，最坏为 $O(n^2)$。</p><p>单轴快排每次 $partition$ 主轴均居中，则递归深度为 $i$ 的 $partition$ 有 $2^i$ 个， 这 $2^i$ 个 $partition$ 需要比较的次数是 (除去 $2^{i-1}$ 个主轴元素的元素个数) $n - 2^{i-1}$。给出如下复杂度估计。</p><p>$$<br>\begin{aligned}<br>T(n) &amp;&#x3D;\sum_{1}^{\log n}\left(n-2^{(i-1)}\right) \<br>&amp;&#x3D;n \log n-\left(1-2^{\operatorname{logn}}\right) &#x2F;(1-2) \<br>&amp;&#x3D;n \log n-n+1<br>\end{aligned}<br>$$</p><p>可知时间复杂度为 $O(nlogn)$。</p><p>也可通过如下递推式导出。</p><p>$$<br>T(n)&#x3D;2 T(n &#x2F; 2)+n<br>$$</p><p>严格来说等号右边应该为 $2T((n-1)&#x2F;2)+n$，因为确定轴之后轴元素不参与两分区划分，但并不影响结果的正确性，求解该递推式的方法在归并排序中已介绍过，最终同样得到时间复杂度为 $O(nlogn)$。</p><p>双轴快排递推式如下，用同样的方法可得到 $O(nlog_3n)$。对数的底数为3，相比单轴快排的底数2，双轴快排的复杂度更低，效率更高。</p><p>$$<br>T(n)&#x3D;3 T(n &#x2F; 3)+n<br>$$</p><p><strong>最坏情形</strong></p><p>对于单轴快排，当输入为已排序数组，且采用首位为主轴的方式，第 $i$ 次 $partition$ 后主轴左右两部分总是 $left &#x3D; null$ ，$right &#x3D; n - i,$  第 $i$ 次 $partition$ 需要比较 $n - i$ 次，共有 $n$ 次 $partition$ ，总比较次数 $O(n^2)$。类似于对已排序的数组做 <strong>选择排序</strong>。</p><p>左右两端取轴的双轴快排对于已排序数组，同样是 $O(n^2)$ 的最坏情形。</p><p>空间复杂度：递归形式的快排，取决于递归深度，为 $O(logn)$。非递归形式的快排，保存分区信息的栈深度与递归深度相同，空间复杂度也是 $O(logn)$。</p><p>不同于归并排序中需要借助一个临时数组保存每次合并的结果，快速排序以原地交换元素的形式，避免了 $O(n)$ 的数组开销。</p><br /><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><h4 id="递归快排"><a href="#递归快排" class="headerlink" title="递归快排"></a>递归快排</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 三数取中快排</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] quickSortMedian3(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    quickSortMedian3(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>); <span class="comment">// 后两个参数是下标值</span></span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">quickSortMedian3</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (left &lt; right) &#123; </span><br><span class="line">        <span class="comment">// 执行median3将左，中，右三数中值放到left位置上</span></span><br><span class="line">        median3(arr, left, right);</span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> partition(arr, left, right);</span><br><span class="line">        quickSortMedian3(arr, left, pivot - <span class="number">1</span>);</span><br><span class="line">        quickSortMedian3(arr, pivot + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将left, center, right下标三个数中，大小居中者放到left下标处</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">median3</span><span class="params">(<span class="type">int</span>[]arr, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> l + (r - l) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (arr[l] &gt; arr[c]) swap(arr, l, c); <span class="comment">// 左中，大者居中</span></span><br><span class="line">    <span class="keyword">if</span> (arr[c] &gt; arr[r]) swap(arr, c, r); <span class="comment">// 中右，大者居右，此时最大者居右</span></span><br><span class="line">    <span class="keyword">if</span> (arr[c] &gt; arr[l]) swap(arr, l, c); <span class="comment">// 左中，大者居左，此时中者居左</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 随机主轴快排</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] quickSortRandom(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    quickSortRandom(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">quickSortRandom</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="comment">// 取区间内随机下标，注意Random().nextInt(int x)方法的使用（含0不含x）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">randomIndex</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(right - left) + left + <span class="number">1</span>; <span class="comment">// 在[left + 1, right]范围内的随机值</span></span><br><span class="line">        <span class="comment">// 交换随机取得的下标元素与当前起始元素</span></span><br><span class="line">        swap(arr, left, randomIndex); <span class="comment">// arr[left]与它之后的某个数交换</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> partition(arr, left, right);</span><br><span class="line">        quickSortRandom(arr, left, pivot - <span class="number">1</span>);</span><br><span class="line">        quickSortRandom(arr, pivot + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 朴素快排(首位为主轴)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] quickSortSimple(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    quickSortSimple(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>); <span class="comment">// 后两个参数是下标值</span></span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">quickSortSimple</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="comment">// 若left == right，表示此时arr只有一个元素，即为基准情形，完成递归(准确说是完成递进)</span></span><br><span class="line">    <span class="comment">// (尾递归，“回归”过程中不做任何事情）</span></span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> partition(arr, left, right);</span><br><span class="line">        quickSortSimple(arr, left, pivot - <span class="number">1</span>);</span><br><span class="line">        quickSortSimple(arr, pivot + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//　partition方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> left, index = pivot + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 注意此时right是坐标，要执行到最后一个元素，所以是&lt;=</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index; i &lt;= right; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; arr[pivot]) &#123;</span><br><span class="line">            swap(arr, index, i);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后一个小于主轴元素的元素下标是index - 1</span></span><br><span class="line">    swap(arr, pivot, index - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> index - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h4 id="非递归快排-迭代快排"><a href="#非递归快排-迭代快排" class="headerlink" title="非递归快排 (迭代快排)"></a>非递归快排 (迭代快排)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] quickSortStack(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="comment">// 用于保存区间左右边界的栈，按right到left的顺序将初始区间界入栈</span></span><br><span class="line">    Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    stack.push(arr.length - <span class="number">1</span>);</span><br><span class="line">    stack.push(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 判断栈是否空，不空则弹出一对left，right界</span></span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> stack.pop(), right = stack.pop();</span><br><span class="line">        <span class="keyword">if</span>(left &lt; right) &#123; <span class="comment">// 执行partition的前提是left小于right</span></span><br><span class="line">            <span class="comment">// 对[left, right]区间执行partition方法，得到pivot</span></span><br><span class="line">              <span class="comment">// 加入后续两行实现随机轴快排</span></span><br><span class="line">            <span class="comment">// int randomIndex = new Random().nextInt(right - left) + left + 1; // 在[left + 1, right]范围内的随机值</span></span><br><span class="line">            <span class="comment">// swap(arr, left, randomIndex); // arr[left]与它之后的某个数交换</span></span><br><span class="line">              <span class="comment">// 加入下行实现三数取中快排</span></span><br><span class="line">            median3(arr, left, right);</span><br><span class="line">            <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> partition(arr, left, right);</span><br><span class="line">            <span class="comment">// 当前pivot的左区间存在则将该区间right，left界入栈</span></span><br><span class="line">            <span class="keyword">if</span>(pivot &gt; left) &#123;</span><br><span class="line">                stack.push(pivot - <span class="number">1</span>);</span><br><span class="line">                stack.push(left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当前pivot的右区间存在则将该区间right，left界入栈</span></span><br><span class="line">            <span class="keyword">if</span>(right &gt; pivot) &#123;</span><br><span class="line">                stack.push(right);</span><br><span class="line">                stack.push(pivot + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h4 id="双轴快排-1"><a href="#双轴快排-1" class="headerlink" title="双轴快排"></a>双轴快排</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] dualPivotQuickSort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    dualPivotQuickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>); <span class="comment">// 后两个参数是下标值</span></span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *     区间1               区间2                         区间3</span></span><br><span class="line"><span class="comment"> * +------------------------------------------------------------+</span></span><br><span class="line"><span class="comment"> * |  &lt; pivot1  | pivot1 &lt;= &amp;&amp; &lt;= pivot2  |    ?    | &gt; pivot2  |</span></span><br><span class="line"><span class="comment"> * +------------------------------------------------------------+</span></span><br><span class="line"><span class="comment"> *              ^                         ^         ^</span></span><br><span class="line"><span class="comment"> *              |                         |         |</span></span><br><span class="line"><span class="comment"> *            lower                     index      upper</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dualPivotQuickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(left &lt; right) &#123; <span class="comment">// 排序对象是right大于left的区间（即大小大于等于2的区间）</span></span><br><span class="line">        <span class="comment">// 令左右两端元素中较小者居左，以left为初始pivot1，right为初始pivot2</span></span><br><span class="line">        <span class="comment">// 即arr[left]为选定的左轴值，arr[right]为选定的右轴值</span></span><br><span class="line">        <span class="keyword">if</span>(arr[left] &gt; arr[right]) &#123;</span><br><span class="line">            swap(arr, left, right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> left + <span class="number">1</span>; <span class="comment">// 当前考察元素下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">lower</span> <span class="operator">=</span> left + <span class="number">1</span>; <span class="comment">// 用于推进到pivot1最终位置的动态下标，总有[left, lower)确定在区间1中</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">upper</span> <span class="operator">=</span> right - <span class="number">1</span>; <span class="comment">// 用于推进到pivot2最终位置的动态下标，总有(upper, right]确定在区间3中</span></span><br><span class="line">        <span class="comment">// [lower, index)确定在区间2中，[index, upper]为待考察区间。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// upper以右（不含upper）的元素都是确定在区间3的元素，所以考察元素的右界是upper</span></span><br><span class="line">        <span class="keyword">while</span>(index &lt;= upper) &#123;</span><br><span class="line">            <span class="comment">// 若arr[index] &lt; arr[left]，即arr[index]小于左轴值，则arr[index]位于区间1</span></span><br><span class="line">            <span class="keyword">if</span> (arr[index] &lt; arr[left]) &#123;</span><br><span class="line">                <span class="comment">// 交换arr[index]和arr[lower]，配合后一条lower++，保证arr[index]位于区间1</span></span><br><span class="line">                swap(arr, index, lower); </span><br><span class="line">                <span class="comment">// lower++，扩展区间1，lower位置向右一位靠近pivot1的最终位置</span></span><br><span class="line">                lower++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 若arr[index] &gt; arr[right]，即arr[index]大于右轴值，则arr[index]位于区间3</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(arr[index] &gt; arr[right]) &#123;</span><br><span class="line">                <span class="comment">// 先扩展区间3，使得如下while结束后upper以右（不含upper）的元素都位于区间3</span></span><br><span class="line">                <span class="comment">// 区间3左扩不可使index == upper，否则之后的第二条upper--将导致upper为一个已经确定了区间归属的元素的位置（即index - 1）</span></span><br><span class="line">                <span class="keyword">while</span>(arr[upper] &gt; arr[right] &amp;&amp; index &lt; upper) &#123;</span><br><span class="line">                    upper--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 交换arr[index]和arr[upper]，配合后一条upper--，保证arr[index]位于区间3</span></span><br><span class="line">                swap(arr, index, upper);</span><br><span class="line">                upper--;</span><br><span class="line">                <span class="comment">// 上述交换后，index上的数字已经改变，只知道此时arr[index] ≤ arr[right]，arr[index]有可能在区间1或区间2，</span></span><br><span class="line">                <span class="comment">// 若arr[index] &lt; arr[left]，即arr[index]小于左轴值，则arr[index]位于区间1</span></span><br><span class="line">                <span class="keyword">if</span>(arr[index] &lt; arr[left]) &#123;</span><br><span class="line">                    <span class="comment">// 交换arr[index]和arr[lower]，配合后一条lower++，保证arr[index]位于区间1</span></span><br><span class="line">                    swap(arr, index, lower);</span><br><span class="line">                    <span class="comment">// lower++，扩展区间1，lower位置向右一位靠近pivot1的最终位置</span></span><br><span class="line">                    lower++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            index++; <span class="comment">// 考察下一个数字</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// while(index &lt;= upper)结束后最后一个确定在区间1的元素的下标是lower--，</span></span><br><span class="line">        <span class="comment">// 最后一个确定在区间3的元素下标是upper++。</span></span><br><span class="line">        lower--;</span><br><span class="line">        upper++;</span><br><span class="line">        <span class="comment">// 双轴归位。此时的lower，upper即分别为最终pivot1(初始时为left)，最终pivot2(初始时为right)。</span></span><br><span class="line">        swap(arr, left, lower);</span><br><span class="line">        swap(arr, upper, right);</span><br><span class="line">        <span class="comment">// 对三个子区间分别执行双轴快排</span></span><br><span class="line">        dualPivotQuickSort(arr, left, lower - <span class="number">1</span>); <span class="comment">// 区间1</span></span><br><span class="line">        dualPivotQuickSort(arr, lower + <span class="number">1</span>, upper - <span class="number">1</span>); <span class="comment">// 区间2</span></span><br><span class="line">        dualPivotQuickSort(arr, upper + <span class="number">1</span>, right); <span class="comment">// 区间3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><h3 id="算法描述-6"><a href="#算法描述-6" class="headerlink" title="算法描述"></a>算法描述</h3><p>将输入数组建立为一个 <strong>大顶堆</strong>，之后反复取出堆顶并对剩余元素重建大顶堆，将依次取出的堆顶逆序排列，即可将原数组从小到大排列完成排序。</p><p>一个直接的想法是在原数组之外新建一个数组保存每次取得的堆顶，这样会有 $O(n)$ 的空间开销，可以用一种称作 **「原地堆排序」**的技巧避免此开销，具体做法如下。</p><ol><li><p>首先将原待排序数组$arr[]建立为一个大顶堆 (heapify堆化方法)。</p></li><li><p>交换堆顶和当前未排序部分中最末尾元素，则堆顶元素已排序（此时在数组最末尾）。</p></li><li><p>剩余元素中 <strong>只有当前堆顶</strong>（之前被交换的末尾元素）可能造成 <strong>堆失序</strong>，因此只需对堆顶调用一次调整堆序的下滤(siftDown)操作（操作范围为未排序部分），即可恢复未排序部分的堆序。</p></li><li><p>重复2，3直到所有元素已排序，返回$arr[]。</p></li></ol><p>上述通过交换堆顶与当前未排序部分末尾元素的做法，避免了额外的空间开销，即 <strong>原地堆排序</strong>，程序结束后返回的$arr[]为已排序状态。</p><p><strong>稳定性：不稳定。</strong></p><p>交换可能会破坏稳定性。例：输入数组 {1, 2, 2}，变灰表示已排序。可以看到红2和绿2的相对顺序相比输入已改变。</p><p><img src="https://pic.leetcode-cn.com/1652693077-zEkBlq-image.png" alt="image.png"></p><br /><h4 id="堆化方法-heapify"><a href="#堆化方法-heapify" class="headerlink" title="堆化方法 (heapify)"></a>堆化方法 (heapify)</h4><p>将原输入数组看作一棵 <a href="https://www.programiz.com/dsa/complete-binary-tree">完全二叉树(Complete Binary Tree)</a>。根节点下标为0，于是根据完全二叉树的结构性质，任意一个节点(下标为 i )的左子节点下标为 $2 * i + 1$，右子节点下标为 $2 * i + 2$，父节点下标为 $i &#x2F; 2$。 <strong>堆化过程即使得整棵树满足堆序性质</strong>，也即任意一个节点大于等于其子节点（大顶堆）。堆化操作总结为一句话就是：对最后一个非叶子节点到根节点，依次执行下滤操作(siftDown)。</p><p>从最后非一个叶子开始下滤的原因是此节点之后的节点均为叶子节点，叶子节点无子节点，故其本身已满足堆序性质，也就无下滤的必要（也无法下滤）。每一次下滤使得该节点及其之后的节点都满足堆序性质，直到根节点。</p><p>※ 最后一个非叶子节点（也即最后一个元素的父节点）下标为 $(n - 1) &#x2F; 2$，n为数组长度。</p><p>如下<a href="https://tva1.sinaimg.cn/large/008i3skNgy1gyopuk6qs7g30i603ntby.gif">动图</a>是将输入数组{4, 6, 2, 1, 7, 9, 5, 8, 3} (1为最后一个非叶子结点) 堆化成大顶堆{9, 8, 5, 6, 7, 2, 4, 1, 3}的过程。</p><p><img src="https://pic.leetcode-cn.com/1652693123-umfUhL-heapify.gif" alt="heapify.gif"></p><br /><h4 id="下滤方法-siftDown"><a href="#下滤方法-siftDown" class="headerlink" title="下滤方法(siftDown)"></a>下滤方法(siftDown)</h4><p><strong>下滤(siftDown)是堆排序的核心方法</strong>，在堆排序中用于在程序开始时 <strong>创建大顶堆</strong>，以及在每次排序堆顶时用于 <strong>恢复未排序部分的堆序</strong>。</p><p>该方法来源于删除堆顶元素操作，先介绍下滤在删除堆顶元素操作中的处理过程。如下<a href="https://tva1.sinaimg.cn/large/008i3skNgy1gyosplo6zzg30i603nwga.gif">动图</a>展示了删除大顶堆{9, 8, 5, 6, 7, 2, 4, 1, 3}堆顶元素9的过程（动图中出现的100表示堆顶，值为9）。</p><ol><li><p>删除堆顶，堆中元素减1，将当前最后一个元素3暂时置为堆顶。</p></li><li><p>可以看到，此时影响堆序的只有该堆顶元素3，于是交换其与左右子节点中的较大者。</p></li><li><p>对元素3重复操作2，直到3再无子节点，堆序恢复。</p></li></ol><p>恢复堆序的过程就是将影响堆序的元素不断向下层移动（并交换）的过程，因此形象地称之为下滤(siftDown)。</p><p>※ 注意，此处沿用JDK源码中下滤操作的方法名”siftDown”，<strong>sift为过滤之意</strong>，网上有的博客文章将其讹误成shift。</p><p><img src="https://pic.leetcode-cn.com/1652693170-JMfGtM-siftDown.gif" alt="siftDown.gif"></p><p>可以看到，对节点x的下滤操作的本质是恢复以x为根节点的树的堆序。因此在堆化操作中，只需要分别依次地对最后一个非叶子节点到根节点执行下滤操作，即可使整棵树满足堆序。在排序过程中，每次原地交换后（交换当前堆顶与当前未排序部分最后一个元素），只有新堆顶影响堆序，对其执行 <strong>一次</strong> 下滤操作（范围为未排序部分）即可使未排序部分重新满足堆序。</p><br /><h3 id="复杂度分析-6"><a href="#复杂度分析-6" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：原地堆排序的时间复杂度为 $O(nlogn)$。</p><p>建堆时间复杂度: $O(n)$，证明如下。</p><p>以完全二叉树为例，以根节点为第 1 层，共 h 层。第 k 层有 $2^{k-1}$ 个元素，该层每个元素至多下滤 $h - k$ 次。于是所有元素最大下滤次数总和为：</p><p>$$<br>S&#x3D;\sum_{k&#x3D;1}^{h-1} 2^{k-1}(h-k)<br>$$</p><p>$$<br>S&#x3D;h-1+2(h-2)+4(h-3)+\ldots+2^{h-2}<br>$$</p><p>$$<br>2S&#x3D;2(h-1)+4(h-2)+8(h-3)+\ldots+2^{h-1}<br>$$</p><p>下式2S减去上式S得到<br>$$<br>S&#x3D;-h+1+2+4+\ldots+2^{h-1}&#x3D;2^{h}-1-h<br>$$</p><p>已经知道，总元素数为 $n &#x3D; 2^h - 1$，因此 $S &#x3D; n - h$ 建堆时间复杂度为 $O(n)$。</p><p>原地交换至排序完成时间复杂度：$O(nlogn)$，证明如下。</p><p>当前堆顶通过交换完成排序时，其下滤次数取决于当前树高，设当前未排序元素个数为i，其下滤次数最多为层高减1（根节点为第1层），即 $logi$。每排序一次堆顶，待排序部分元素个数减1，于是从一个大顶堆开始完成排序所需时间取决于 n - 1 次堆顶下滤(下滤范围分别为n, n -1, n-2,…,2)次数总和最大值。</p><p>$$<br>\sum_{i&#x3D;2}^{n} \log i<br>$$</p><p>由<a href="https://en.wikipedia.org/wiki/Stirling%27s_approximation">Stirling公式</a>得到</p><p>$$<br>\sum_{i&#x3D;2}^{n} \log i&#x3D;\log (n !)&#x3D;n \log n-n \log e+\Theta(\log n)<br>$$</p><p>于是时间复杂度为 $O(nlogn)$。最好 &#x2F; 平均 &#x2F; 最坏时间复杂度均为 $O(nlogn)$。</p><p>但若考虑数组所有元素均相等，则建堆和原地交换时下滤次数为0，时间复杂度取决于建堆和原地交换时的比较次数，为 $O(n)$，</p><p>※ Stirling公式详细证明过程可参考：<a href="http://episte.math.ntu.edu.tw/articles/mm/mm_17_2_05/index.html">谈Stirling公式</a></p><p>空间复杂度：原地对排序算法中只有常数项变量，$O(1)$。</p><br /><h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] heapSort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    heapify(arr, arr.length - <span class="number">1</span>); <span class="comment">// 构建大顶堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arr.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123; <span class="comment">// i &gt; 0即可，无需写成i &gt;= 0，当n - 1个元素排序时，最后一个元素也已排序</span></span><br><span class="line">        swap(arr, <span class="number">0</span>, i); <span class="comment">// 交换堆顶和当前未排序部分最后一个元素</span></span><br><span class="line">        <span class="comment">// 此时除当前堆顶元素外都是保持堆序的，只需要对该堆顶调用一次下滤操作</span></span><br><span class="line">        siftDown(arr, <span class="number">0</span>, i - <span class="number">1</span>); <span class="comment">// i - 1是未排序部分最后一个元素下标，确保下滤不会超过此范围</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> endIdx)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">hole</span> <span class="operator">=</span> (endIdx - <span class="number">1</span>) / <span class="number">2</span>; hole &gt;= <span class="number">0</span>; hole--) &#123; <span class="comment">// (endIdx - 1) / 2伪最后一个非叶子节点下标</span></span><br><span class="line">        siftDown(arr, hole, endIdx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftDown</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> hole, <span class="type">int</span> endIdx)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> arr[hole]; <span class="comment">// target是要下滤的节点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">child</span> <span class="operator">=</span> hole * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(child &lt;= endIdx) &#123;</span><br><span class="line">        <span class="comment">// 满足第一个条件child &lt; endIdx表示hole有右孩子，不满足则hole无右孩子，跳过</span></span><br><span class="line">        <span class="comment">// 第二个条件arr[child + 1] &gt; arr[child]只在第一个条件成立前提下进行判断（因此不必担心arr[child + 1]越界），</span></span><br><span class="line">        <span class="comment">// 若满足，表示hole有右孩子且右孩子更大，令child为右孩子下标。</span></span><br><span class="line">        <span class="comment">// 因此此if过后使得child是hole的孩子中较大的那个</span></span><br><span class="line">        <span class="keyword">if</span> (child &lt; endIdx &amp;&amp; arr[child + <span class="number">1</span>] &gt; arr[child]) &#123;</span><br><span class="line">            child++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若child大于target，则child上移到当前hole，hole下滤到child位置 </span></span><br><span class="line">        <span class="keyword">if</span> (arr[child] &gt; target) &#123;</span><br><span class="line">            arr[hole] = arr[child];</span><br><span class="line">            hole = child;</span><br><span class="line">            child = hole * <span class="number">2</span> + <span class="number">1</span>; <span class="comment">// 当然也可以写成child = child * 2 + 1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">break</span>; <span class="comment">// 若无需交换hole与child，说明hole已经满足堆序(无需/无法再下滤)，退出while</span></span><br><span class="line">    &#125;</span><br><span class="line">    arr[hole] = target; <span class="comment">// 将target填入hole中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><h3 id="算法描述-7"><a href="#算法描述-7" class="headerlink" title="算法描述"></a>算法描述</h3><p>计数排序是我们介绍的第一种 <strong>非比较排序</strong>，通常 <strong>适用于整数数组</strong>，是一种利用整数特点取得 <strong>线性复杂度</strong> 的非比较排序方法。假设待排序数组 $arr$ 为正整数数组， <strong>朴素</strong> 的计数排序过程如下：</p><ol><li><p>创建一个计数数组 $countArr$ ，其大小为 $arr$ 中的最大值 $max$ 再加 1。</p></li><li><p>遍历 $arr$ ，每读取一个$arr[i]$ ，直接令$countArr[arr[i]]++$。</p></li><li><p>从下标 1 开始遍历 $countArr$ ，依次输出 $counter[i]$ 个 $i$ ，即为排序结果。</p></li></ol><p>朴素做法有两个明显的缺陷，首先是 <strong>无法处理负数</strong>，其次是当元素个数较多，但很多相等元素使得元素分布 <strong>集中在较小范围</strong> 时，$max+1$ 大小的 $countArr$ 中大部分空间是多余的。改进方法很简单，即创建大小为 $max - min + 1$ 的 $countArr$ ，$max$ 和 $min$ 分别是 $arr$ 中最大和最小元素。后续代码均会采用该改进。</p><p>如下<a href="https://tva1.sinaimg.cn/large/008i3skNly1gyr7qbd8iyg307t07fe82.gif">动图</a>展示了 ${4,6,2,1,7,9,5,8,3,1,1}$ 的计数排序过程（不稳定版）。</p><p><img src="https://pic.leetcode-cn.com/1652693288-wsXoKv-count.gif" alt="count.gif"></p><p><strong>稳定性：取决于是否采用稳定性优化版本。</strong></p><p>采用则稳定，不采用则不稳定，稳定优化方法见后。</p><br /><h3 id="稳定性优化"><a href="#稳定性优化" class="headerlink" title="稳定性优化"></a><strong>稳定性优化</strong></h3><p>经过上述改进的计数排序仍存在 <strong>稳定性缺陷</strong>，即通过计数来排序，当遍历到 $countArr[i]$ 时，只是连续地输出 $countArr[i]$ 次 $i + min$ ，稳定性得不到保证 （比如动图中，后放入的 1 会先输出）。要保证稳定，必须使 <strong>先记录的先输出</strong>。可以通过对 $countArr$ 进行 <strong>变形</strong> 来满足稳定性，使得遍历到同一个数字，例如 $k$ 时，能够将不同位置的 $k$ 按他们在 $arr$ 中出现的顺序放入到输出数组中。具体做法如下。</p><ol><li><p>得到 $countArr$ 后，遍历一次 $countArr$ ，使得每一个 $countArr[i]$ 的值都是从 $countArr[0]$ 到 $countArr[i]$ 中值不为 0 的项的值之和（前缀和）。例如对于待排序数组 ${5, 5, 4, 4, 1, 1}$ ，得到大小为 <code>5 - 1 + 1 = 5</code> 的 $countArr$ ，具体为 ${2, 0, 0, 2, 2}$ ，表示有两个1，0个2，0个3，2个4，2个5。按照前述方法将其变形为 ${2, 0, 0, 4, 6}$ ，表示 1 的最大位置为第 2 位 (下标为1)， 4 的最大位置为 4 (下标为 3 )， 5 的最大位置为 6 (下标为 5 )。</p></li><li><p>在输出排序结果时，新建一个大小等于 $arr$ 的 $sortedArr$ 数组，于是 $countArr[arr[i] - min] - 1$ 即为 $arr[i]$ 这个数应当放入 $sortedArr$ 的位置(下标)，即 $sortedArr[countArr[arr[i] - min] - 1] &#x3D; arr[i]$ ，以倒序从 $arr.length$ 遍历到 0 ，每次向 $sortedArr$ 填入一个数字后，令 $countArr[arr[i] - min]–$ 。遍历结束后得到的 $sortedArr$ 即为 $arr$ 的稳定排序结果 (建议实际动手验证这个过程) 。</p></li></ol><br /><h3 id="复杂度分析-7"><a href="#复杂度分析-7" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：朴素版为 $O(max)$，$max$ 为原数组中最大值。改进版为 $O(n + k)$，$n$ 为元素个数， $k$ 计数数组大小。当元素个数较少但最大最小值差值很大时，复杂度取决于 k。</p><p>空间复杂度：不考虑输入数组 $arr$ ，朴素版的 $countArr$ 的大小为 $k+1$ ，故空间复杂度为 $O(k)$。稳定性优化版为 $O(n + k)$， $n$ 为 $sortedArr$ 的大小，等于 $arr$ 的大小。</p><br /><h3 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h3><h4 id="不稳定计数排序"><a href="#不稳定计数排序" class="headerlink" title="不稳定计数排序"></a>不稳定计数排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] countSortUnstable(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> arr[<span class="number">0</span>], max = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        min = Math.min(min, arr[i]);</span><br><span class="line">        max = Math.max(max, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] countArr = <span class="keyword">new</span> <span class="title class_">int</span>[max - min + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        countArr[arr[i] - min]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; countArr.length; i++) &#123; <span class="comment">// 遍历countArr</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; countArr[i]; j++) &#123; <span class="comment">// countArr[i]可能有多个相同数字</span></span><br><span class="line">            arr[index] = i + min; <span class="comment">// 复用了原输入数组arr</span></span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h4 id="稳定计数排序"><a href="#稳定计数排序" class="headerlink" title="稳定计数排序"></a>稳定计数排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] countSort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length, min = arr[<span class="number">0</span>], max = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        min = Math.min(min, arr[i]);</span><br><span class="line">        max = Math.max(max, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] countArr = <span class="keyword">new</span> <span class="title class_">int</span>[max - min + <span class="number">1</span>]; <span class="comment">// arr最多有max-min+1种数字</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        countArr[arr[i] - min]++; <span class="comment">// arr[i]的值出现一次，则countArr[arr[i]-min]加1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; countArr.length; i++) &#123; <span class="comment">// 变形</span></span><br><span class="line">        countArr[i] += countArr[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] sortedArr = <span class="keyword">new</span> <span class="title class_">int</span>[n]; <span class="comment">// 根据sortedArr, nums, countArr三者关系完成sortedArr的输出</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        sortedArr[countArr[arr[i] - min] - <span class="number">1</span>] = arr[i];</span><br><span class="line">        countArr[arr[i] - min]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sortedArr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><h3 id="算法描述-8"><a href="#算法描述-8" class="headerlink" title="算法描述"></a>算法描述</h3><p><strong>非比较排序</strong>，「基」指的是数的位，例如十进制数 123，共有百十个位，共 3 个位。基数排序 <strong>按数字的位进行循环</strong>，每一轮操作都是对<strong>当前位（基数）的计数排序</strong>，使得输出到 $arr$ 后所有数字在截止到当前位上（即去掉未考察的位后）是排序状态，考察完最大位后完成排序。具体过程如下：</p><ol><li><p>遍历待排序数组 $arr$ ，找到最大值，计算其位数，例如 $arr$ 中最大数为 123 ，则 $maxDigitLen &#x3D; 3$ 。</p></li><li><p>数组的数字为 $n$ 进制，就创建大小为 $n$ 的计数数组 $countArr$ ，也可以称为 $n$ 个桶。</p></li><li><p>开始「位」的 $for$ 循环，循环次数等于 $maxDigitLen$ ，每一轮对 <strong>当前所有数字的当前位</strong> 执行一次 <strong>计数排序</strong>。</p></li><li><p>每次计数排序结束后将结果写回 $arr$ 。</p></li><li><p>$for$ 循环结束后返回排序结果 $arr$ 。</p></li></ol><p>如下<a href="https://tva1.sinaimg.cn/large/008i3skNgy1gysb1jsbaog30cc07rwkq.gif">动图</a>演示 ${6674, 1560, 5884, 2977, 2922, 4127, 5390, 7870, 1193, 7163}$ 的基数排序过程。</p><p><strong>也可以不使用计数排序</strong>，而是创建一个二维数组（可看作19个桶）保存每次遍历的中间结果，此写法耗费的空间较大 (每个桶的大小都要等于 $arr$ 大小 +1，空间复杂度为 $O(19n)$ )，是稳定排序，不详细说明，可以参考后续给出的代码实现。</p><ul><li><p>以计数排序为基础的基数排序，每一位循环时都对所有数做该位的计数排序。</p></li><li><p>不以计数排序为基础的基数排序，每一位循环时都将所有数按顺序放入相应的桶中。</p></li></ul><p><img src="https://pic.leetcode-cn.com/1652693343-bsRGEO-radix.gif" alt="radix.gif"></p><br /><p><strong>稳定性：稳定。</strong></p><p>基数排序要求对每一位的排序 (计数排序或非计数排序) 必须是稳定排序，否则无法得到正确结果。例如对 ${25,13,24}$ 执行排序。第一轮针对个位的排序过后得到  ${13,24,25}$ ，若对位的排序不稳定，则第二轮针对十位上的  ${1,2,2}$ 的排序将可能得到 ${13,25,24}$ ，排序结束得到错误结果。因此基于稳定的位排序的基数排序，也一定是稳定的。</p><br /><h3 id="处理负数优化"><a href="#处理负数优化" class="headerlink" title="处理负数优化"></a>处理负数优化</h3><p><strong>处理负数优化</strong>：若存在负数，可以先找到最小值(负数)，对arr中的每个数，都加上此最小值的绝对值，排序完成后再减回去。但加法可能使得 <strong>数字越界</strong>，一种更好的办法是计数排序时 <strong>将countArr的大小扩展为 19</strong>，以[0, 19]对应可能出现的[-9, 9]。因此在每轮求当前基数时，要在原基数结果上 +9 以对应countArr的下标。</p><p>后续代码给出利用计数排序的应用此优化的版本。</p><br /><h3 id="复杂度分析-8"><a href="#复杂度分析-8" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：d为绝对值最大的元素位数，总共进行d轮计数排序，$O(n + k)$ 是计数排序的复杂度，其中k是位的取值范围，如果是非负数，则 k &#x3D; 10 (0<del>9)，如果包含负数，则 k &#x3D; 19 (-9</del>9)。所以总的时间复杂度为 $O(d(n + k))$。</p><p>空间复杂度：</p><p>利用计数排序的基数排序，空间复杂度与计数排序相同，为 $O(n + k)$。</p><p>不利用计数排序的计数排序，将以19个（应用处理负数优化）「桶」的二维数组作为排序过程中的存储空间，故空间复杂度为 $O(19n)$，当n显著大于19时也可认为其空间复杂度为 $O(n)$。</p><br /><h3 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h3><h4 id="以计数排序为基础"><a href="#以计数排序为基础" class="headerlink" title="以计数排序为基础"></a>以计数排序为基础</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] radixSort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Math.abs(arr[<span class="number">0</span>]); <span class="comment">// 找到arr中绝对值最大者</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        max = Math.max(max, Math.abs(arr[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxDigitLen</span> <span class="operator">=</span> <span class="number">0</span>, base = <span class="number">10</span>; <span class="comment">// 最大位数 &amp; 基（几进制就是几）</span></span><br><span class="line">    <span class="keyword">while</span> (max != <span class="number">0</span>) &#123;</span><br><span class="line">        maxDigitLen++;</span><br><span class="line">        max /= base;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在接下来的for中，每一轮都对当前位(基数)执行一次计数排序</span></span><br><span class="line">    <span class="type">int</span>[] sortedArr = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; maxDigitLen; i++) &#123;</span><br><span class="line">        <span class="type">int</span>[] countArr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">19</span>]; <span class="comment">// 处理负数优化</span></span><br><span class="line">        <span class="comment">// 根据每一个数字当前位的数字，累计相应位置的计数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="comment">// 此步处理要注意，当base大于10时，例如base=100时，1234%100=34</span></span><br><span class="line">            <span class="comment">// 还需要再除以(base/10)，得到的3，然后再+9（考虑负数）才是本次的bucketIdx</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">bucketIdx</span> <span class="operator">=</span> (arr[j] % base) / (base / <span class="number">10</span>) + <span class="number">9</span>;</span><br><span class="line">            countArr[bucketIdx]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// countArr变形，得到每个下标所代表的arr中的数的当前位在arr中的最大位置（从1开始）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; countArr.length; j++) &#123;</span><br><span class="line">            countArr[j] += countArr[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 逆序输出保持稳定性</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> arr.length - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">thisBase</span> <span class="operator">=</span> (arr[j] % base) / (base / <span class="number">10</span>) + <span class="number">9</span>;</span><br><span class="line">            <span class="comment">// countArr[thisBase]得到的从1开始计算的位置，转成下标要-1</span></span><br><span class="line">            sortedArr[countArr[thisBase] - <span class="number">1</span>] = arr[j]; </span><br><span class="line">            countArr[thisBase]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 完成当前位的计数排序后将排序结果拷贝回原数组</span></span><br><span class="line">        arr = Arrays.copyOf(sortedArr, sortedArr.length);</span><br><span class="line">        <span class="comment">// base进一位，准备下一轮对下一位的计数排序</span></span><br><span class="line">        base *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h4 id="不以计数排序为基础"><a href="#不以计数排序为基础" class="headerlink" title="不以计数排序为基础"></a>不以计数排序为基础</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] radixSort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="comment">// 找到arr中绝对值最大者</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Math.abs(arr[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        max = Math.max(max, Math.abs(arr[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxDigitLen</span> <span class="operator">=</span> <span class="number">0</span>, base = <span class="number">10</span>; <span class="comment">// 最大位数 &amp; 基</span></span><br><span class="line">    <span class="keyword">while</span> (max != <span class="number">0</span>) &#123;</span><br><span class="line">        maxDigitLen++;</span><br><span class="line">        max /= base;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// arr.length + 1的作用是令每个桶的第0位保存该桶的元素个数。</span></span><br><span class="line">    <span class="type">int</span>[][] buckets = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">19</span>][arr.length + <span class="number">1</span>]; <span class="comment">// 处理负数优化</span></span><br><span class="line">    <span class="comment">// 在每一位上将数组中所有具有该位的数字装入对应桶中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; maxDigitLen; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="comment">// 此步处理要注意，当base大于10时，例如base=100时，1234%100=34</span></span><br><span class="line">            <span class="comment">// 还需要再除以(base/10)，得到的3才是本次的bucketIndex</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">bucketIdx</span> <span class="operator">=</span> (arr[j] % base) / (base / <span class="number">10</span>) + <span class="number">9</span>; <span class="comment">// +9使其可以处理负数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">currentBucketQuantity</span> <span class="operator">=</span> buckets[bucketIdx][<span class="number">0</span>];</span><br><span class="line">            buckets[bucketIdx][currentBucketQuantity + <span class="number">1</span>] = arr[j];</span><br><span class="line">            buckets[bucketIdx][<span class="number">0</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将当前所有桶的数按桶序，桶内按低到高输出为本轮排序结果</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">arrIdx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; buckets.length; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; k &lt;= buckets[j][<span class="number">0</span>]; k++) &#123;</span><br><span class="line">                arr[arrIdx++] = buckets[j][k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 每一轮过后将桶计数归零</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] bucket : buckets) bucket[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        base *= <span class="number">10</span>; <span class="comment">// 调整base</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><h3 id="算法描述-9"><a href="#算法描述-9" class="headerlink" title="算法描述"></a>算法描述</h3><p>桶排序将原数组划分到称为 <strong>「桶」</strong> 的多个区间中，然后对每个桶单独进行排序，之后再按桶序和桶内序输出结果。适合于分布较均匀的数据，具体做法如下。</p><ol><li><p>根据数据规模按照 <strong>一定的方法</strong> 将待排序数组arr划分为多个区间，每个区间称作一个桶。</p></li><li><p>每个桶可以是数组，也可以是泛型容器，用于保存arr中落在该桶范围内的数。</p></li><li><p>对每一个桶都单独排序，需要 <strong>以适当的排序</strong> 方法支持，例如插入排序，快速排序等。</p></li><li><p>所有桶完成排序后，按桶序，桶内序依次输出所有元素，得到arr的排序结果。</p></li></ol><br /><p><strong>稳定性：取决于桶内排序方法的稳定性。</strong></p><br /><h3 id="复杂度分析-9"><a href="#复杂度分析-9" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：找最大最小值和分配桶均耗费 $O(n)$，之后的复杂度取决于每个桶内的排序算法复杂度之和。假设有k个桶，且数据分布均匀，若采用 $O(n^2)$ 的排序算法，那么总排序时间复杂度为 $O(n^2&#x2F;k)$，若采用 $O(nlogn)$ 的排序算法，总排序时间复杂度为 $O(k(n&#x2F;k)log(n&#x2F;k))$，即 $O(nlog(n&#x2F;k))$。若桶内排序采用 $O(nlogn)$ 算法，且k的大小适当，例如 $k &#x3D; n&#x2F;p$，p是一个较小的数例如2，3等。那么整体的时间复杂度约为 $O(n)$。虽然形式上为线性复杂度，但其n的系数较大，<strong>未必优于</strong>$O(nlogn)$的排序算法。</p><p>当所有元素都被分到同一个桶中，达到最大时间复杂度，为 $O(n^2)$ 或 $O(nlogn)$（取决于桶内排序采用的排序方法）。</p><p>空间复杂度：取决于桶的数据结构，若采用静态数组，由于每个桶都需要保证有n个位置，则空间复杂度为 $O(kn)$，若采用泛型容器，则为 $O(n)$。</p><br /><h3 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] bucketSort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> arr[<span class="number">0</span>], max = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        min = Math.min(min, arr[i]);</span><br><span class="line">        max = Math.max(max, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用泛型List存储所有桶，每个桶是一个ArrayList&lt;Integer&gt;，并初始化所有桶。</span></span><br><span class="line">    <span class="comment">// arr.length/3表示设置数组大小三分之一数量的桶</span></span><br><span class="line">    List&lt;ArrayList&lt;Integer&gt;&gt; buckets = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(arr.length / <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        buckets.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历arr，根据元素值将所有元素装入对应值区间的桶中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="comment">// (arr[i] - min)/D为arr[i]元素应该装入的桶的下标，间隔D = (max-min)/(arr.length-1)</span></span><br><span class="line">        <span class="comment">// 虽可写成(arr[i] - min)*(arr.length-1)/(max-min)的形式，但当输入数组取值范围较大且元素较多时</span></span><br><span class="line">        <span class="comment">// (arr[i] - min)*(arr.length-1)可能会超过int上限，因此先做除法求出double类型的D</span></span><br><span class="line">        <span class="comment">// 再做一次除法求出bucketIndex，可以避免计算精度不够高带来的问题</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">interval</span> <span class="operator">=</span> (<span class="type">double</span>)(max - min) / (<span class="type">double</span>)(arr.length - <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">bucketIdx</span> <span class="operator">=</span> (<span class="type">int</span>) ((arr[i] - min) / interval);</span><br><span class="line">        buckets.get(bucketIdx).add(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 桶内排序(调用库函数，从小到大)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; buckets.size(); i++) &#123;</span><br><span class="line">        Collections.sort(buckets.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (ArrayList&lt;Integer&gt; bucket : buckets) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> sortedItem : bucket) &#123;</span><br><span class="line">            arr[index] = sortedItem; <span class="comment">// 复用输入数组arr</span></span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h2 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h2><p>利用 <strong>决策树</strong> 来理解<strong>基于比较的排序</strong>算法的复杂度的理论下界为 $O(nlogn)$。本节内容学习自 Weiss 的 <a href="https://leetcode.cn/link/?target=https://awesome-programming-books.github.io/algorithms/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9AJava%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0.pdf">数据结构与算法分析：Java语言描述</a> 。</p><p>$n$ 个不同元素组成的序列，有 $n!$ 种可能的排列。考虑这样一棵决策树，根处存放着所有 $n!$ 种可能的排序，比较其中两个元素 $a$ 和 $b$ ，只有两种可能 $a &gt; b$ 或者 $a &lt; b$（不考虑等于）。$a$ 和 $b$ 的大小关系确定后，都将去除根处 $n!$ 种排列中的一半。将 $a &gt; b$ 确定后的剩下的一半可能作为根的左子节点，$a &lt; b$ 确定后剩下的另一半可能作为根的右子节点，每次确定某两个元素的大小后，都会剩下一半可能，作为左右子节点加入到决策树中，因此该决策树是一棵叶子节点总数为 $n!$ 的二叉树，决策步数为到达排序状态的序列的叶子节点的深度。</p><p>对于深度为 $d$ (根节点在 0 深度处)的二叉树，其叶子结点数量至多为 $2^d$，当二叉树为 <strong>完美二叉树 (perfect binary tree)</strong> 时达到最大值。于是对应地，具有 $n$ 个叶子节点的二叉树，深度至少为 $⌈logn⌉$ ，当二叉树为 <strong>完全二叉树 (complete binary tree)</strong> 时深度最浅。 于是具有 $n!$ 个叶子节点的二叉树的深度至少为 $⌈log(n!))⌉$，这个深度就是通过比较得到排序结果的最少比较次数。根据 <a href="https://en.wikipedia.org/wiki/Stirling%27s_approximation">Stirling公式</a> 得到如下结果，因此，通过比较来排序的算法的时间复杂度 <strong>下界</strong> 为 $O(nlogn)$。</p><p>$$<br>\sum_{i&#x3D;2}^{n} \log i&#x3D;\log (n !)&#x3D;n \log n-n \log e+\Theta(\log n)<br>$$</p><p><img src="https://pic.leetcode-cn.com/1652693436-DUoJYB-image.png" alt="image.png"></p><br /><h2 id="实战应用"><a href="#实战应用" class="headerlink" title="实战应用"></a>实战应用</h2><p>与元素大小相关的问题基本上都可以用排序来解决，例如从数组中取出前 $k$ 个大(小)，第 $k$ 个大(小)数等。也有通过适当的排序过程获取某些信息的问题，例如求逆序数等。<br>等。</p><table><thead><tr><th>题目</th><th>难度</th><th>题解</th></tr></thead><tbody><tr><td><a href="https://leetcode.cn/problems/sort-an-array/">912. 排序数组</a></td><td>中等</td><td>直球题</td></tr><tr><td><a href="https://leetcode.cn/problems/minimum-moves-to-equal-array-elements-ii/">462. 最少移动次数使数组元素相等 II</a></td><td>中等</td><td><a href="https://leetcode.cn/problems/minimum-moves-to-equal-array-elements-ii/solution/yukiyama-er-fen-cha-zhao-by-yukiyama-jg0d/">题解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">剑指 Offer 51. 数组中的逆序对</a></td><td>困难</td><td><a href="https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/solution/by-yukiyama-elnl/">题解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/minimum-time-difference/">539. 最小时间差</a></td><td>中等</td><td><a href="https://leetcode.cn/problems/minimum-time-difference/solution/-by-yukiyama-togv/">题解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素</a></td><td>中等</td><td><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/solution/by-yukiyama-agaa/">题解</a></td></tr><tr><td>&#x3D;&#x3D;&#x3D;&#x3D; 持续更新中 &#x3D;&#x3D;&#x3D;&#x3D;</td><td></td><td></td></tr></tbody></table><p>🐮🐮🐮 牛啊兄弟，你竟然真的看到这里了。</p><hr><p>【本文更新日志】</p><p>[2022-06-05]</p><ul><li>「实战应用」新增「<a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素</a>」和「<a href="https://leetcode.cn/problems/minimum-time-difference/">539. 最小时间差</a>」题解。</li></ul><p>[2022-05-21]</p><ul><li>更正部分swap相关代码。修改前若swap采用「方法二」的加减法交换或「方法三」的异或交换，将可能出现同元素交换情况，这将导致该元素变为0，详情请看「<a href="#%E4%B8%89%E7%A7%8D%E4%BA%A4%E6%8D%A2%E6%96%B9%E6%B3%95">三种交换方法</a>」一节。</li></ul><p>[2022-05-20] 更新</p><ul><li><p>在「方法二」和「方法三」的swap实现代码中增加一行if，以避免 i &#x3D;&#x3D; j 时的错误。此修改由<a href="/u/lcfgrn/">@lcfgrn</a> (道哥刷题) 指出，非常感谢！🙏 实际上应保证排序过程中不出现自己与自己交换的情形出现，这样就无需if语句了。</p></li><li><p>新增工具推荐：Markdown文章书写工具<a href="https://typoraio.cn/">typora</a>，算法可视化网站<a href="https://visualgo.net/en/sorting">visualgo</a>, gif制作工具<a href="https://getkap.co/">Kap</a>，数学公式输出工具<a href="https://mathpix.com/">Mathpix Snipping Tool</a>。</p></li><li><p>重写「希尔排序」之「Shell增量」代码，<del>并指出网上流传甚广的一种错误写法</del> （是作者搞错了，详情请见「希尔排序」一节）。新增「Knuth增量」、「Hibbard增量」版本的希尔排序代码。</p></li></ul><p>[2022-05-19] 更新</p><ul><li>更新「希尔排序」实现代码的一处错误。原代码缺少一行for，导致对于同一增量，只有一组序列执行了简单插入排序。现已修正，该错误由 <a href="/u/lxy-hub987/">@lxy-hub987</a> (啦啦啦) 同学指出，非常感谢！🎉 详情见评论区相关讨论。</li><li>新增462题解。今天的每日一题<a href="https://leetcode.cn/problems/minimum-moves-to-equal-array-elements-ii/">462. 最少移动次数使数组元素相等 II</a>刚好有一种基于快速排序的做法，且在所有解法中平均时间复杂度最低，为 $O(n)$。顺手把这个解法的题解更新到「实战应用」中了，欢迎各位阅读指正👏。实际上连着两天的每日一题，也都有二分查找的解法，相应的二分查找解法我更新到了<a href="https://leetcode.cn/circle/discuss/ooxfo8/">二分查找从入门到入睡</a>的「实战应用」中，也一并欢迎各位阅读指正👏。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法与数据结构 </tag>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找从入门到入睡</title>
      <link href="/2022/06/07/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E7%9D%A1/"/>
      <url>/2022/06/07/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E7%9D%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="谨以此文献给迷失在二分查找中的青春岁月"><a href="#谨以此文献给迷失在二分查找中的青春岁月" class="headerlink" title="谨以此文献给迷失在二分查找中的青春岁月"></a>谨以此文献给迷失在二分查找中的青春岁月</h1><blockquote><ul><li><p>可在作者的 <a href="https://github.com/iyukiyama/leetcode-posts">github仓库</a> 中获取本文和其他文章的 markdown 源文件及相关代码。</p></li><li><p>欢迎评论或仓库 PR 指出文章错漏或与我讨论相关问题，我将长期维护所有文章。</p></li><li><p>所有文章均用 Typora 完成写作，可使用 Typora 打开文章 md 文件，以获得最佳阅读体验。</p></li></ul></blockquote><p>⚠️ ⚠️ ⚠️ <strong>本文巨长，(可能) 比你见过的所有二分查找解析文都要长，正文两万三千字 (不含题解) ，全面解析二分查找的一切细节。</strong></p><p>❗️ <strong>【NEW】</strong> ❗️</p><ul><li>9-15:  <a href="https://leetcode.cn/circle/discuss/SwgIJV/">红黑树从入门到看开</a></li></ul><hr><blockquote><p>$keyword$ :</p><p>四种二分查找模版 &#x2F; 四要素约束 &#x2F; 左闭右闭 (相错终止) &#x2F; 左闭右开 (相等终止) &#x2F; 左开右闭 (相等终止) &#x2F; 左开右开 (相邻终止) &#x2F; y总模版 &#x2F; 红蓝二分法 &#x2F; $binarySearch$ &#x2F; $lower_bound$ &#x2F; $upper_bound$ &#x2F; $bisect_left$ &#x2F; $bisect_right$ &#x2F; 防止提前溢出 &#x2F; 无限循环产生的原因 &#x2F; 二段性 &#x2F; 最大值最小化 &#x2F; 最小值最大化</p></blockquote><p>没想到第一次尝试在讨论区发文，竟然真的有那么多人会看，看来基础内容的总结分享也是十分有意义的一件事，非常开心👀。我会再更新一些内容，如果大家发现文章中的任何纰漏，<strong>请一定不吝赐教，我会及时修正</strong> 👀，多谢！</p><p>如果你目前对二分查找算法仍有类似下面文字框中的疑惑，这篇文章就是为你准备的，看完并完全理解本文，包括且不仅限于这些疑惑，(基本上) 都将一扫而空。另外经过多次新增内容，文章长度上看起来不像是讲解「二分查找」这种简单算法应该有的规模。不过我想说，作者意在 try best effort to 展示二分查找三种常用模版的全貌，许多情形的代码十分相似，但我都逐一讲解，对于一般介绍「二分查找」文章中涉及的概念，我也尽可能做了覆盖。<strong>总之就是试图（企图）对二分做一个一劳永逸的再不回头的了断</strong>。在最后的「实战应用」中，我列出了数十道二分题目以及题解，以供读者在阅读本文基础上自练自查。作者认为二分算法思想虽简单，但实践上是没办法走捷径的，算法细节多，易出错的特点使得我们 <strong>必须也只能够</strong> 在透彻理解二分过程的基础上，才能够真正写对具体题目的代码。毕竟强如算法泰山 Knuth 也说了，<strong>二分的细节可能让人无法招架</strong>（典出 <a href="https://en.wikipedia.org/wiki/Binary_search_algorithm">Binary Search Algorithm</a>）。</p><blockquote><p>尽管二分查找的基本思想相对简单，但细节可以令人难以招架 … — 高德纳</p></blockquote><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">左右边界初始值为什么有这么多种组合?</span> <span class="string"></span></span><br><span class="line"><span class="attr">(l</span> = <span class="string">0, r = n - 1; l = 0, r = n; l = -1, r = n; 其中 n = nums.length)</span></span><br><span class="line"><span class="attr">「左闭右闭」、「左闭右开」、「左开右开」是个啥？</span></span><br><span class="line"><span class="attr">「模版一」、「模版二」、「模版三」是个啥？</span></span><br><span class="line"><span class="attr">y总模版是个啥？红蓝二分法是个啥？</span></span><br><span class="line"><span class="attr">C++中的lower_bound,</span> <span class="string">upper_bound是个啥？</span></span><br><span class="line"><span class="attr">Python中的bisect_left,</span> <span class="string">bisect_right是个啥？</span></span><br><span class="line"><span class="attr">while</span> <span class="string">中的条件什么时候用 &lt;，什么时候用 &lt;= ?</span></span><br><span class="line"><span class="attr">中间值下标为什么写成</span> <span class="string">l + (r - l) / 2 ？貌似还有其他写法？</span></span><br><span class="line"><span class="attr">左右界更新条件的不等号该写哪一个</span> <span class="string">&lt;, &lt;=, &gt;, &gt;= ?</span></span><br><span class="line"><span class="attr">左右界更新语句该写哪一个</span> <span class="string">l = c + 1 / l = c / r = c - 1 / r = c ？</span></span><br><span class="line"><span class="attr">为什么我写的二分会陷入无限循环？</span></span><br><span class="line"><span class="attr">循环终止时l、r下标的关系是怎么确定的？为什么是确定的？</span></span><br><span class="line"><span class="attr">返回值到底是</span> <span class="string">l 还是 r 还是 l - 1, l + 1, r - 1, r + 1...？</span></span><br><span class="line"><span class="attr">听说二分查找不需要数组有序，只需要具备「二段性」即可，元素大小甚至可以是随机的？really？</span></span><br><span class="line"><span class="attr">所以什么是「二段性」？</span></span><br><span class="line"><span class="attr">据说有些什么「求最大值最小化」问题，属于比较难的二分问题？这又是什么意思？</span></span><br><span class="line"><span class="attr">为什么这么简单的算法思想却这么难写对？这是玄学吗？</span></span><br></pre></td></tr></table></figure><hr><p>yuki的其他文章如下，欢迎阅读指正！</p><blockquote><p>如下所有文章同时也在我的 github <a href="https://github.com/iyukiyama/leetcode-posts">仓库</a> 中维护。</p></blockquote><table><thead><tr><th>文章</th><th>[发布时间] 字数&#x2F;览&#x2F;藏&#x2F;赞 (~2022-10-20)</th></tr></thead><tbody><tr><td><a href="https://leetcode.cn/circle/discuss/eBo9UB/">十大排序从入门到入赘</a>  🔥🔥🔥</td><td>[20220516]  2.5万字&#x2F;64.8k览&#x2F;3.7k藏&#x2F;937赞</td></tr><tr><td><a href="https://leetcode.cn/circle/discuss/ooxfo8/">二分查找从入门到入睡</a> 🔥🔥🔥</td><td>[20220509]  2.3万字&#x2F;38.4k览&#x2F;2.1k藏&#x2F;503赞</td></tr><tr><td><a href="https://leetcode.cn/circle/discuss/qmjuMW/">并查集从入门到出门</a> 🔥🔥</td><td>[20220514]  1.2万字&#x2F;17.9k览&#x2F;1.0k藏&#x2F;321赞</td></tr><tr><td><a href="https://leetcode.cn/circle/discuss/FyPTTM/">图论算法从入门到放下</a> 🔥🔥</td><td>[20220617]  5.6万字&#x2F;19.9k览&#x2F;1.3k藏&#x2F;365赞</td></tr><tr><td>树ADT系列 (预计13篇)</td><td>系列文章，连载中</td></tr><tr><td>3. <a href="https://leetcode.cn/circle/discuss/wPzlSb/">二叉查找树</a></td><td>[20220801]  5千字</td></tr><tr><td>4. <a href="https://leetcode.cn/circle/discuss/zbwD3p/">AVL树</a></td><td>[20220817]  5千字</td></tr><tr><td>5. <a href="https://leetcode.cn/circle/discuss/BCK17f/">splay树</a></td><td>[20220817]  5千字</td></tr><tr><td>6. <a href="https://leetcode.cn/circle/discuss/SwgIJV/">红黑树从入门到看开</a> 🔥🤯🤯🤯</td><td>[20220915]  3万字&#x2F;5.3k览&#x2F;269藏&#x2F;72赞</td></tr><tr><td>10. <a href="https://leetcode.cn/circle/discuss/qGREiN/">树状数组从入门到下车</a> 🔥🤯</td><td>[20220722]  1.4万字&#x2F;5.8k览&#x2F;196藏&#x2F;72赞</td></tr><tr><td>11. <a href="https://leetcode.cn/circle/discuss/H4aMOn/">线段树从入门到急停</a> 🔥🤯</td><td>[20220726]  2.5万字&#x2F;8.7k览&#x2F;481藏&#x2F;138赞</td></tr><tr><td><a href="https://leetcode.cn/circle/discuss/GV0JrV/">图论相关证明系列</a></td><td>系列文章</td></tr><tr><td>1. <a href="https://leetcode.cn/circle/discuss/jJQn7V/">Dijkstra正确性证明</a> 🤯</td><td>[20220531]</td></tr><tr><td>2. <a href="https://leetcode.cn/circle/discuss/VVEc8f/">Prim正确性证明</a> 🤯</td><td>[20220919]</td></tr><tr><td>3. <a href="https://leetcode.cn/circle/discuss/xeEwYl/">Bellman-Ford及SPFA正确性证明</a></td><td>[20220602]</td></tr><tr><td>4. <a href="https://leetcode.cn/circle/discuss/Nbzix4/">Floyd正确性证明</a></td><td>[20220602]</td></tr><tr><td>5. <a href="https://leetcode.cn/circle/discuss/tMIy36/">最大流最小割定理证明</a> 🤯🤯</td><td>[20220719]</td></tr><tr><td>6. <a href="https://leetcode.cn/circle/discuss/tN3sZc/">Edmonds-Karp复杂度证明</a> 🤯🤯</td><td>[20220515]</td></tr><tr><td>7. <a href="https://leetcode.cn/circle/discuss/T9Xa1R/">Dinic复杂度证明</a> 🤯🤯</td><td>[20220531]</td></tr></tbody></table><hr><p>[2022-08-06]</p><ul><li>新增 <a href="https://leetcode.cn/problems/que-shi-de-shu-zi-lcof/">剑指 Offer 53 - II. 0～n-1中缺失的数字</a> 题解。</li></ul><hr><p>[TOC]</p><hr><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><blockquote><p><strong>前言：</strong><br>前一阵在用二分解题时出现了让我相当费解的 <strong>无限循环</strong> 问题，本来以为自己已经彻底理解了二分查找，没想到还是有漏洞，于是花了一些时间研究无限循环问题产生的原因，并重新全面审视二分查找算法，写成本文，作者希望并且也有相信这篇文章能够消除你对二分查找的一切困惑。</p><p>总之如果你还没法坚信自己写的每一份二分代码都是 bug free 的，那本文几乎是必看的。期待与你互相交流，共同进步。</p></blockquote><p><strong>二分查找以其原理极为简单，但细节处理却极易出错而闻名。</strong> 在本文中，我将以 <strong>「循环不变」</strong> 为中心，讨论三种常见的二分查找实现模版，尝试展现「循环不变」原理如何帮助我们跳出二分的「变化」过程，在「不变」的帮助下准确地理解模版代码的工作过程及其正确性，并在此基础上能够应对各种不同的二分场景写出 bug free 的代码。</p><p>在三个模版的介绍中，我将依次给出 <strong>「相等返回」情形</strong> 的写法和四种 <strong>「一般」情形</strong> 的写法，所有情形的实现在模版一和模版三中都是正确无误的，但在模版二中，同样遵循「循环不变」原则的「一般」写法，若不以正确形式给出，就有可能陷入无限循环。我将仔细证明为何看似正确的代码会陷入无限循环，以及如何通过细微的调整将其修正为正确的代码 (受「知心猛男」提醒而得，感谢)。在「模版二」中，我还会介绍一种广受欢迎的「y总模版」，指出其属于本文「模版二」的范畴。该模版采用了「上取整」的中间下标计算方法来避免无限循环，并使得循环结束时有 $l &#x3D; r$ 。</p><br /><h3 id="模版一-相错终止-x2F-左闭右闭"><a href="#模版一-相错终止-x2F-左闭右闭" class="headerlink" title="模版一 (相错终止&#x2F;左闭右闭)"></a>模版一 (相错终止&#x2F;左闭右闭)</h3><h4 id="相等返回情形"><a href="#相等返回情形" class="headerlink" title="相等返回情形"></a>相等返回情形</h4><p>以一道最基本的二分查找题目 <a href="https://leetcode-cn.com/problems/binary-search/">704. 二分查找</a> 为例开始讲解。最常见的模版一实现的代码如下，实际上这是模版一我称之为 <strong>「相等返回」</strong> 的特例，后续给出四种一般情形的模版一代码中，有两种情形能够涵盖「相等返回」。代码中的 $l$、$r$、$c$ 代表搜索空间左界 ($left$)，右界 ($right$) 和中间值 ($center$) 下标。</p><blockquote><p>704-二分查找:</p><p>给定一个 $n$ 个元素有序的（升序）整型数组 $nums$ 和一个目标值 $target$  ，写一个函数搜索 $nums$ 中的 $target$，如果目标值存在返回下标，否则返回 -1。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模版一「相等返回」写法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123; <span class="comment">// 循环条件</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> l + (r - l) / <span class="number">2</span>; <span class="comment">// 中间值坐标</span></span><br><span class="line">            <span class="keyword">if</span>(nums[c] == target) <span class="keyword">return</span> c; <span class="comment">// 相等返回</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[c] &lt; target) l = c + <span class="number">1</span>; <span class="comment">// #1 更新后l左侧元素「必」小于target</span></span><br><span class="line">            <span class="keyword">else</span> r = c - <span class="number">1</span>; <span class="comment">// #2 更新后r右侧元素「必」大于target </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>※ 求中间值下标的语句，不用 <code>int c = (l + r) / 2</code>，而采用<code>int c = l + (r - l) / 2</code> 的写法乃是为了防止「提前溢出」。在Java中有三种常见写法，因该内容不是此处重点，此处不做介绍，请参考「拓展阅读」一节中的「提前溢出」和「二分查找趣闻」。<br>※ 「相错终止&#x2F;相等终止&#x2F;相邻终止」，「左闭右闭&#x2F;左闭右闭&#x2F;左开右开」的名称相关闲话，见「拓展阅读」一节的「关于名称」。</p><br /><h5 id="循环不变与程序正确性"><a href="#循环不变与程序正确性" class="headerlink" title="循环不变与程序正确性"></a>循环不变与程序正确性</h5><p>跟踪循环中变化的细节是困难的，因此我们需要找到一些在整个循环过程中都不会发生变化的「量」或「关系」，以便得到循环结束后某些确定的结论。在这个实现中，   #1 和 #2 两行保证了如下「关系」是 <strong>「循环不变」</strong> 的：</p><ol><li>对于#1行，若进入该分支，则 $l$ 下标更新后其左侧元素「必」 <strong>小于</strong> $target$。</li><li>对于#2行，若进入该分支，则 $r$ 下标更新后其右侧元素「必」 <strong>大于</strong> $target$。</li></ol><p>在程序运行过程中，中间值要么等于 $target$ 直接返回答案，要么执行 #1 或 #2 。基于上述两个不变的关系，若执行 #1，则更新后的 $l$ 左侧元素为 $target$ 的可能性被完全排除，若执行 #2，则更新后的 $r$ 右侧元素为 $target$ 的可能性被完全排除。<strong>再次强调</strong>，这两个「关系」对于更新后任意时刻的 $l$ 和 $r$ 来说都是「不变」的。<strong>同时强调的是「更新后」这一前提</strong>，因为若 $target$ 比 $nums$ 中所有元素都大，则 $r$ 不会经历更新，若 $target$ 比 $nums$ 中所有元素都小，则 $l$ 不会经历更新。不经历更新，就不具有前述两条「循环不变」的关系。例如 $target$ 大于 $nums$ 中所有元素时，$r$ 不更新，最终 $r &#x3D; nums.length - 1$，$l &#x3D; nums.length$,  $l$ 经历过更新，此时说 $l$ 左侧元素必小于 $target$ 是正确的，但 $r$ 右侧元素必大于 $target$ 是不成立的（ $r$ 右侧没有元素）。这一点在「一般」情形中会影响返回时的判断，后续还会说明。不过在这个「相等返回」写法中，显然无需考虑 $l, r$ 是否有过更新。</p><p>程序执行过程中的两种情况：</p><ol><li><p>情况一：<code>nums[c] == target</code>，直接返回正确的结果。</p></li><li><p>情况二：$while$ 因 $l$ 与 $r$ 不满足 $l &lt;&#x3D; r$ 而终止。现在来看循环终止时 $l$ 与 $r$ 的关系。$while$ 的每一次执行，要么 $l$ 比 $c$ 的位置右移一位，要么 $r$ 相比当前 $c$ 的位置左移一位，$while$ 终止条件为 $l &gt; r$，通过几个例子很容易推出终止时 $l$ 与 $r$ 的关系「必」为 $r &#x3D; l - 1$（见后续「相错终止」图示），<strong>即 $while$ 终止时，$r$ 与 $l$ 相邻，$r$ 在 $l$ 左侧一位。</strong>  前述我们已经强调过，对于更新后任意时刻的 $l$，其左侧元素必不存在 $target$，对于更新后任意时刻的 $r$，其右侧元素必不存在 $target$。而 $while$ 终止时 $r$ 的右侧和 $l$ 的左侧 <strong>正好覆盖了所有 $nums$ 的元素</strong>，此时可以 <strong>断言</strong> ：$target$ 必不在 $nums$ 中。若 $target$ 大于 $nums$ 中所有元素，虽然 $r$ 不更新，但最终 $l$ 的左侧覆盖了所有元素。同样地，$target$ 小于 $nums$ 中所有元素时，$l$ 虽不更新，但最终 $r$ 的右侧覆盖了所有元素，断言都能够成立。</p></li></ol><p><img src="https://pic.leetcode-cn.com/1652191521-IILMSo-image.png" alt="image.png"></p><p>至此，通过分析「循环不变」关系，我们确认了上述代码的 <strong>正确性</strong> ，并理解了其正确的根本原因。</p><p>【相错终止】</p><p><img src="https://pic.leetcode-cn.com/1652191543-qsmOcr-image.png" alt="image.png" title="相错终止"></p><br /><h5 id="四要素"><a href="#四要素" class="headerlink" title="四要素"></a>四要素</h5><p>从前文的分析中我们可以总结出二分查找算法中的四要素为：<strong>初始值</strong>、<strong>循环条件</strong>、**$c$ 的计算方式<strong>、</strong>左右界更新语句**。此四要素的有机结合，构成了具体的二分模版形式。下面我们来看看它们是如何配合的。</p><p>在前文中我们写到了 $l$ 或 $r$ 不更新时的场景，分别对应着 $target$ 小于 $nums$ 中所有数和 $target$ 大于 $nums$ 中所有数这两种情况。我们之所以不必关心这两种「边界」情形，本质上是因为已经确保了中间下标 $c$ 覆盖了「搜索空间」中所有可能的下标，也即我们一定不会错过考察 $[0, nums.length -1]$ 下标范围对应的数。更进一步，我们还保证了 $c$ 不会越出搜索空间，即 $c$ <strong>覆盖且仅覆盖了「搜索空间」中所有可能的下标</strong> 。通过「相错终止」示意图可以很清楚地看出这一点。当 $l &#x3D; r &#x3D; 0$ 时，$c &#x3D; 0$ 即取到搜索空间左界，且之后循环终止，$c$ 不会越出左界；当 $l &#x3D; r &#x3D; nums.length - 1$ 时，$c &#x3D; nums.length - 1$ 即取到搜索空间右界，且之后循环终止，$c$ 不会越出右界。现在我们指出如下四要素的 <strong>约束</strong> 。</p><blockquote><p>对于二分查找的任意模版:</p><ul><li><p>$while$ 中的不等号和 $l, r$ 的更新语句决定了二分搜索循环终止时 $l$ 与 $r$ 的位置关系（相错 &#x2F; 相等 &#x2F; 相邻）。</p></li><li><p>$l, r$ 的初始值和 $c$ 的计算方式要使得中间下标 $c$ 覆盖且仅覆盖「搜索空间」中所有可能的下标。</p></li></ul></blockquote><p>现在罗列本文介绍的所有模版的四要素，读者朋友们应当在后续模版学习中实际验证每一种模版四要素的配合，是否都实现了上述「约束」。相信你理解了下表和上述约束的联系后，将不会再对四要素为何如此结合有所疑惑。</p><table><thead><tr><th>模版</th><th>初始值<br />$n : nums.length$</th><th>循环条件</th><th>中间值下标 $c$</th><th>左右界</th></tr></thead><tbody><tr><td>模版一<br />相错终止</td><td>$l &#x3D; 0, r &#x3D; n - 1$ <br />$[l, r]$ <strong>左闭右闭</strong></td><td>$while(l &lt;&#x3D; r)$</td><td>$c &#x3D; l + (r - l) &#x2F; 2$<br />下取整</td><td>$l &#x3D; c + 1$ <br />$r &#x3D; c - 1$</td></tr><tr><td>模版二<br />相等终止</td><td>$l &#x3D; 0, r &#x3D; n$ <br />$[l, r)$ <strong>左闭右开</strong></td><td>$while(l &lt; r)$</td><td>$c &#x3D; l + (r - l) &#x2F; 2$<br />下取整</td><td>$l &#x3D; c + 1$ <br />$r &#x3D; c$</td></tr><tr><td>模版二<br />相等终止</td><td>$l &#x3D;-1, r &#x3D; n - 1$ <br />$(l, r]$ <strong>左开右闭</strong></td><td>$while(l &lt; r)$</td><td>$c &#x3D; l + (r - l+1) &#x2F; 2$<br /><strong>上取整</strong></td><td>$l &#x3D; c$ <br />$r &#x3D; c - 1$</td></tr><tr><td>模版三<br />相邻终止</td><td>$l &#x3D; -1, r &#x3D; n$ <br />$(l, r)$ <strong>左开右开</strong></td><td>$while(l+1 &lt; r)$</td><td>$c &#x3D; l + (r - l) &#x2F; 2$<br />下取整</td><td>$l &#x3D; c$ <br />$r &#x3D; c$</td></tr></tbody></table><br /><h4 id="四种一般情形"><a href="#四种一般情形" class="headerlink" title="四种一般情形"></a>四种一般情形</h4><p>「相等返回」的写法很好理解，现在来看更一般的情形。所谓 <strong>「一般」</strong> 是指要求返回 <strong>大于等于 &#x2F; 大于 &#x2F; 小于等于 &#x2F; 小于</strong> $target$ 的数字下标。其一般性在于这种不等于的要求涵盖了前述等于的情形。这里将与 $target$ 相等的元素的下标称作 <strong>「等于下标」</strong> ，大于 $target$ 的元素中最小的那个的下标称作 <strong>「刚好大于下标」</strong> ，同理有 <strong>「刚好小于小标」</strong> ，为了突出要求的元素不存在这一点，本文规定不存在所要求的元素时返回 -1。实际上你可能在很多资料中看到过返回 <strong>「插入位置」</strong> 这种说法，这是将 $target$ 视作待插入元素，从 <strong>插入后保持序列有序的角度</strong> 来看的。我把五种情形，本文规定的返回值和以「插入位置」视角来看的返回值都罗列如下，以加深对二分查找返回值的理解。</p><table><thead><tr><th>情形</th><th>本文规定的返回值</th><th>「插入位置」返回值</th><th>备注</th></tr></thead><tbody><tr><td>相等返回情形</td><td>有相等元素时返回等于下标<br />否则返回 -1</td><td>有相等元素时返回插入后有序的「插入位置下标」<br />有多个相等元素时，无法保证插入位置是哪一个元素的下标</td><td>704题要求返回等于下标或 -1</td></tr><tr><td>情形1: 大于等于</td><td>有相等元素时返回等于下标<br />否则返回刚好大于下标<br />否则返回 -1</td><td>即返回 <strong>第一个</strong> 满足插入后有序的「插入位置下标」</td><td>704题要求返回等于下标或 -1</td></tr><tr><td>情形2: 大于</td><td>不考虑相等，返回刚好大于下标<br />否则返回 -1</td><td>即返回 <strong>最后一个</strong> 满足插入后有序的「插入位置下标」</td><td>不用于解决704题</td></tr><tr><td>情形3: 小于等于</td><td>有相等元素时返回等于下标<br />否则返回刚好小于下标<br />否则返回 -1</td><td>不适合用「插入位置」理解</td><td>704题要求返回等于下标或 -1</td></tr><tr><td>情形4: 小于</td><td>不考虑相等，返回刚好小于下标<br />否则返回 -1</td><td>不适合用「插入位置」理解</td><td>不用于解决704题</td></tr></tbody></table><p>无论是哪种情形，我们都可以根据「循环不变」原则给出相应的更「一般」的代码。后续我会简单展示 Java &#x2F; C++ &#x2F; Python 的二分查找相关源码。其中 C++ 中的 $lower_bound$ 和 Python 的 $bisect_left$ 就对应「情形1（大于等于）」，$upper_bound$ (C++) 和 $bisect_right$ (Python)对应「情形2（大于）」，只是对返回规则的定义与本文的规定有所不同。函数命名中的 $lower (left) &#x2F; high (right)$ 是从「插入位置」角度来命名的， $lower (left)$ 对应 「第一个」， $high (right)$ 对应「最后一个」。另外，Java 中的 $binarySearch$ 采用的是「相等返回」情形，关于这些我将在「各语言内置二分查找方法(函数)」中说明。</p><br /><h5 id="情形1-大于等于"><a href="#情形1-大于等于" class="headerlink" title="情形1 (大于等于)"></a>情形1 (大于等于)</h5><p>「情形1」代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模版一「一般」情形1: 大于等于</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[c] &lt; target) l = c + <span class="number">1</span>; <span class="comment">// #1 更新后l左侧元素「必」小于target</span></span><br><span class="line">            <span class="keyword">else</span> r = c - <span class="number">1</span>; <span class="comment">// #2 更新后r右侧「必」大于等于target</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// return (l == nums.length || nums[l] != target) ? -1 : l; // 704题的返回，处理:相等/不等</span></span><br><span class="line">        <span class="keyword">return</span> l == nums.length ? -<span class="number">1</span> : l; <span class="comment">// 处理: 相等/刚好大于/不存在</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在理解了「循环不变」原理后，编写这个版本的代码时尝试寻找 $l$ 或 $r$ 更新后是否能有类似 $target$  <strong>必在或必不</strong> 在某个确定的范围的「循环不变」关系。因为情形1要求「大于等于」，考虑其 <strong>「补关系」</strong> ，即若 $nums[c]$ 小于 $target$，那么 $l$ 更新后就有如下「循环不变」关系1。与「相等返回」不同的是，因为没有判等分支， 进入 #2 行的条件是 $nums[c] &gt;&#x3D; target$ ，得到如下「循环不变」关系2。</p><ol><li>对于 #1 行，若进入该分支，则 $l$ 下标更新后其左侧元素「必」 <strong>小于</strong>  $target$ 。</li><li>对于 #2 行，若进入该分支，则 $r$ 下标更新后其右侧元素「必」 <strong>大于等于</strong>  $target$ 。</li></ol><p>同样地，$while$ 终止时有 $r &#x3D; l - 1$，根据本情形的「循环不变」关系，此时 $target$ 必不在 $l$ 左侧，而 $r$ 的右侧必大于等于 $target$，又因为 $nums$ 是单调的，因此 <strong>断言: $l$ 要么是等于下标，要么是刚好大于下标</strong>。稍等，循环不变只保证了左右侧元素与 $target$ 的大小关系，并不保证 $l$ 或 $r$ 最终一定在 $nums$ 的下标范围内。实际上有可能超出一位，即为 $r &#x3D; -1$ ( $nums$ 中所有数都大于等于 $target$ ) 或 $l &#x3D; nums.length$ ( $nums$ 中所有数都小于 $target$ )。因此前述断言还有一个前提，即 $l !&#x3D; nums.length$，这个条件通过思考 $target$ 的 <strong>三种情况</strong> 提炼。</p><ul><li>$nums$ 中所有元素都小于 $target$ 时，$r$ 不更新，最终 $l &#x3D; nums.length$ ，因此当这个关系成立时，返回 -1。</li><li>$nums$ 中存在元素大于等于 $target$ 时，由两条「循环不变」关系（或者下图）可知应返回 $l$ 。</li><li>$nums$ 中所有元素都大于 $target$ 时，$l$ 不更新，$l &#x3D; 0$，此时应当返回下标 0，因此返回 $l$ 。</li></ul><p>于是一个判断即可对应三种情况 (后两种都返回 $l$ )。另外，因为 $r+1 &#x3D; l$，用 $l$ 或 $r+1$ 来返回都是可以的。</p><p><img src="https://pic.leetcode-cn.com/1652191568-jyZSyy-image.png" alt="image.png"></p><p>下面给出余下情形的代码，分析过程是类似的，不再赘述。其中「情形2(大于)」和「情形4(小于)」不考虑「等于」关系，不能用于处理704题，而「情形1(大于等于)」和「情形3(小于等于)」涵盖了「等于」，可以用来处理704题，只需要在返回语句上稍作修改即可，细节请见代码。</p><br /><h5 id="情形2-大于"><a href="#情形2-大于" class="headerlink" title="情形2 (大于)"></a>情形2 (大于)</h5><p>「情形2」考虑 $target$ 的三种情况：</p><ul><li><p>$nums$ 中所有元素都小于 $target$ 时，$r$ 不更新，最终 $l &#x3D; nums.length$，因此当这个关系成立时，返回 -1。</p></li><li><p>$nums$ 中存在元素大于 $target$ 时，由两条「循环不变」关系可知应返回 $l$ ( $r$ 的右侧)。</p></li><li><p>$nums$ 中所有元素都大于 $target$ 时，$l$ 不更新，$l &#x3D; 0$ ，此时应当返回下标0，因此返回 $l$ 。</p></li></ul><p>「情形2」与「情形1」只有一个 ‘&#x3D;’ 字符的差别。事实上这些代码都十分相似，但<strong>差之毫厘谬以千里</strong>，需要谨慎对待。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模版一「一般」情形2: 大于</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[c] &lt;= target) l = c + <span class="number">1</span>; <span class="comment">// #1 更新后l左侧元素「必」小于等于target</span></span><br><span class="line">            <span class="keyword">else</span> r = c - <span class="number">1</span>; <span class="comment">// #2 更新后r右侧「必」大于target</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l == nums.length ? -<span class="number">1</span> : l; <span class="comment">// 处理: 刚好大于/不存在</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h5 id="情形3-小于等于"><a href="#情形3-小于等于" class="headerlink" title="情形3 (小于等于)"></a>情形3 (小于等于)</h5><p>「情形3」考虑 $target$ 的三种情况：</p><ul><li><p>$nums$ 中所有元素都小于 $target$ 时，应当返回最大下标 $nums.length - 1$，$r$ 未更新，仍有 $r &#x3D; nums.length - 1$，因此返回 $r$。</p></li><li><p>$nums$ 中存在元素小于等于 $target$ 时，由两条「循环不变」关系可知应返回 $r$ ( $l$ 的左侧)。</p></li><li><p>$nums$ 中所有元素都大于 $target$ 时，$l$ 不更新，$l &#x3D; 0$ ，此时应当返回 -1，而此时刚好有 $r &#x3D; -1$ ，因此返回 $r$。</p></li></ul><p>三种情况都返回 $r$。但若用此情形处理704题，则需调整，请参考注释行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模版一「一般」情形3: 小于等于</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[c] &lt;= target) l = c + <span class="number">1</span>; <span class="comment">// #1 更新后l左侧「必」小于等于target</span></span><br><span class="line">            <span class="keyword">else</span> r = c - <span class="number">1</span>; <span class="comment">// #2 更新后r右侧「必」大于target</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// return (r == -1 || nums[r] != target) ? -1 : r; // 704题的返回，处理:相等/不等</span></span><br><span class="line">        <span class="keyword">return</span> r; <span class="comment">// 处理: 相等/刚好小于/不存在</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h5 id="情形4-小于"><a href="#情形4-小于" class="headerlink" title="情形4 (小于)"></a>情形4 (小于)</h5><p>「情形4」考虑 $target$ 的三种情况：</p><ul><li><p>$nums$ 中所有元素都小于 $target$ 时，应当返回最大下标 $nums.length - 1$，$r$ 未更新，仍有 $r &#x3D; nums.length - 1$，因此返回 $r$。</p></li><li><p>$nums$ 中存在元素小于 $target$ 时，由两条「循环不变」关系可知应返回 $r$ ( $l$ 的左侧)。</p></li><li><p>$nums$ 中所有元素都大于等于 $target$ 时，$l$ 不更新，$l &#x3D; 0$，此时应当返回 -1，而刚好有 $r &#x3D; -1$，因此返回 $r$。</p></li></ul><p>三种情况都返回 $r$，「情形4」与「情形3」只有一个 ‘&#x3D;’ 字符的差别。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模版一「一般」情形4: 小于</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[c] &lt; target) l = c + <span class="number">1</span>; <span class="comment">// #1 更新后l左侧元素「必」小于target</span></span><br><span class="line">            <span class="keyword">else</span> r = c - <span class="number">1</span>; <span class="comment">// #2 更新后r右侧「必」大于等于target</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r; <span class="comment">// 处理: 相等/刚好小于/不存在</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在来展示一种我认为不太好的写法（如下，以情形1为例），该写法把 $r$ 的更新写在 $l$ 之前，这仅仅是把 $if-else$ 处理调换了位置而已，不影响程序正确性。展示这种写法是想建议大家在书写二分查找代码时保持同一种风格和习惯，这样能够减少思考负担。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模版一「一般」情形1: 大于等于 (「逆习惯」写法)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[c] &gt;= target) r = c - <span class="number">1</span>; <span class="comment">// #1 更新后r右侧「必」大于等于target</span></span><br><span class="line">            <span class="keyword">else</span> l = c + <span class="number">1</span>; <span class="comment">// #2 更新后l左侧元素「必」小于target</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// return (l == nums.length || nums[l] != target) ? -1 : l; // 704题的返回，处理:相等/不等</span></span><br><span class="line">        <span class="keyword">return</span> l == nums.length ? -<span class="number">1</span> : l; <span class="comment">// 处理: 相等/刚好大于/不存在</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h4 id="模版一总结"><a href="#模版一总结" class="headerlink" title="模版一总结"></a>模版一总结</h4><ul><li>核心在于 <strong>「相错终止」</strong> ，即循环终止时有 $r &#x3D; l - 1$。「模版一」的标志是 $while$ 中的 $l &lt;&#x3D; r$ 以及 $l$ 与 $r$ 更新时的 $l &#x3D; c + 1, r &#x3D; c - 1$，二者相辅相成，共同作用实现了「相错终止」。另外 $l$ 与 $r$ 的初始取值的 <strong>「左闭右闭」</strong> 特点也是「模版一」的一个特点。</li><li>通过 $l$ 左侧和 $r$ 右侧的「循环不变」关系，确定 $while$ 终止后的目标下标。在「一般」情形中，要考虑 <strong>不更新导致的越界</strong> 及其对应的返回前判断。</li><li>相等或不等的情形都可以用「一般」版本，但相等情形应当用「相等返回」版本，能够在找到相等元素时立即返回结果，一般版本则一定会穷尽二分过程。</li><li>通过对「模版一」的分析，得到「四要素」相互配合的「重要结论」，此「重要结论」是 <strong>二分查找算法的核心所在</strong> 。</li></ul><br /><h3 id="模版二-相等终止-x2F-左闭右开"><a href="#模版二-相等终止-x2F-左闭右开" class="headerlink" title="模版二 (相等终止&#x2F;左闭右开)"></a>模版二 (相等终止&#x2F;左闭右开)</h3><h4 id="相等返回情形-1"><a href="#相等返回情形-1" class="headerlink" title="相等返回情形"></a>相等返回情形</h4><p>与「模版一」相映，「模版二」的特点在于 <strong>「相等终止」</strong> ，即 $while$ 终止时，$l &#x3D; r$。$l$ 与 $r$ 在 $while$ 循环终止时的关系由循环条件及它们的更新语句 $l &#x3D; c + 1$和 $r &#x3D; c$ 所决定，如同模版一的分析那样，请参考后续「相等终止图示」。在探究这个模版代码的「循环不变」之前，先行强调，如果 $l$ 与 $r$ 的初始值设置为与「模版一」相同，即 $l &#x3D; 0, r &#x3D; nums.length - 1$ ，那么由于 $while$ 的条件是 $l &lt; r$，当 $nums$ 只有一个元素时，将无法进入 $while$，因此为了能够至少进入一次 $while$，模版二中 $r$ 的初始值为 $r &#x3D; nums.length$ 。再有，当 $target$ 大于 $nums$ 中所有元素时，$r &#x3D; nums.length$ 将是这一情况的一个标志，倘若 $r$ 初始值为 $nums.length - 1$，只看 $r$ 的最终取值是无法判断为上述情况的，仍需要比较一次 $target$ 与 $nums$ 中的最后一个元素。更本质地，我们已经在「左右界初始值」一节中说明过，「初始值」的设置需和中间下标 $c$ 配合，使得 $c$ 的取值 <strong>覆盖且仅覆盖「搜索空间」中所有可能的下标</strong>  。要满足这个要求，就必须取为 $l &#x3D; 0, r &#x3D; nums.length$ 。前面已提过，该取值通常被称作 <strong>「左闭右开」</strong> ，而模版一的 $l$ 和 $r$ 的初始取值被称作 <strong>「左闭右闭」</strong> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模版二「相等返回」写法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = nums.length;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[c] == target) <span class="keyword">return</span> c; <span class="comment">// 找到目标值直接返回</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[c] &lt; target) l = c + <span class="number">1</span>; <span class="comment">// #1 更新后l左侧元素「必」小于target </span></span><br><span class="line">            <span class="keyword">else</span> r = c; <span class="comment">// nums[c] &gt; target #2 更新后r及其右侧「必」大于target</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此实现的「循环不变」关系为：</p><ol><li>对于 #1 行，若进入该分支，则 $l$ 下标更新后其左侧元素「必」 <strong>小于</strong> $target$。</li><li>对于 #2 行，若进入该分支，则 $r$ 下标更新后 $r$ 及其右侧元素「必」 <strong>大于</strong> $target$。</li></ol><p>同样地，程序执行过程中有两种情况：</p><ol><li><p>情况一：$nums[c] &#x3D;&#x3D; target$ ，直接返回正确的结果。</p></li><li><p>情况二：$while$ 因 $l$ 与 $r$ 不满足 $l &lt; r$ 而终止，此时 $l &#x3D; r （$见后续「相等终止」图示）。由「循环不变」关系，对于更新后任意时刻的 $l$ ，其左侧元素必小于 $target$，对于更新后任意时刻的 $r$，$r$ 及其右侧的元素必定大于 $target$。</p></li></ol><p><img src="https://pic.leetcode-cn.com/1652423023-cOfgga-image.png" alt="image.png"></p><p><strong>$while$ 终止时，$l &#x3D; r$。</strong> 与「模版一」的「相等返回」分析类似，情况二 $while$ 终止时 $r$ 及其右侧和 $l$ 的左侧 <strong>正好覆盖了所有 $nums$ 的元素</strong> ，此时可以断言：$target$ 必不在 $nums$ 中。若 $target$ 大于 $nums$ 中所有元素，虽然 $r$ 不更新，但最终 $l$ 的左侧覆盖了所有元素 $(l &#x3D; r &#x3D; nums.length)$ 。同样地，$target$ 小于 $nums$ 中所有元素时，$l$ 虽不更新，但最终 $r$ 及其右侧覆盖了所有元素，断言都能够成立。</p><p>【相等终止】</p><p><img src="https://pic.leetcode-cn.com/1652191622-ukjMGh-image.png" alt="image.png" title="相等终止"></p><br /><h4 id="四种一般情形-1"><a href="#四种一般情形-1" class="headerlink" title="四种一般情形"></a>四种一般情形</h4><p>四种一般情形与模版一时所述相同，均依据「循环不变」原则写出，在书写「情形3」代码时我们发现程序陷入 <strong>「无限循环」</strong> ，然后分析该问题发生的原因，并给出正确写法。</p><br /><h5 id="情形1-大于等于-1"><a href="#情形1-大于等于-1" class="headerlink" title="情形1 (大于等于)"></a>情形1 (大于等于)</h5><p>「情形1」考虑 $target$ 的三种情况：</p><ul><li>$nums$ 中所有元素都小于 $target$ 时，$r$ 不更新，最终 $r &#x3D; nums.length$，因此当这个关系成立时，返回 -1。</li><li>$nums$ 中存在元素大于等于 $target$ 时，由两条「循环不变」关系可知应返回 $r$。</li><li>$nums$ 中所有元素都大于 $target$ 时，$l$ 不更新，最终 $l &#x3D; r &#x3D; 0$，我们需要返回下标 0，而此时 $r$ 正好等于 0。</li></ul><p>一条判断对应三种情况(两个分支)。若用于处理 704 题，返回时的判断需做调整，见注释行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模版二「一般」情形1: 大于等于</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = nums.length;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[c] &lt; target) l = c + <span class="number">1</span>; <span class="comment">// #1 更新后l左侧元素「必」小于target </span></span><br><span class="line">            <span class="keyword">else</span> r = c; <span class="comment">// #2 更新后r及r右侧「必」大于等于target</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// return (r != nums.length &amp;&amp; nums[r] == target) ? r : -1; // 704题的返回，处理:相等/不等</span></span><br><span class="line">        <span class="keyword">return</span> r != nums.length ? r : -<span class="number">1</span>; <span class="comment">// 处理:等于/刚好大于/不存在</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h5 id="情形2-大于-1"><a href="#情形2-大于-1" class="headerlink" title="情形2 (大于)"></a>情形2 (大于)</h5><p>「情形2」考虑 $target$ 的三种情况：</p><ul><li>$nums$ 中所有元素都小于等于 $target$ 时，$r$ 不更新，最终 $r &#x3D; nums.length$，因此当这个关系成立时，返回 -1。</li><li>$nums$ 中存在元素大于 $target$ 时，由两条「循环不变」关系可知应返回 $r$。</li><li>$nums$ 中所有元素都大于 $target$ 时，$l$ 不更新，最终 $l &#x3D; r &#x3D; 0$，我们需要返回下标0，而此时 $r$ 正好等于0。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模版二「一般」情形2: 大于</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = nums.length;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[c] &lt;= target) l = c + <span class="number">1</span>; <span class="comment">// #1 更新后l左侧「必」小于等于target </span></span><br><span class="line">            <span class="keyword">else</span> r = c; <span class="comment">// #2 更新后r及其右侧「必」大于target</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r == nums.length ? -<span class="number">1</span> : r; <span class="comment">// 处理:刚好大于/不存在</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h5 id="情形3-小于等于-1"><a href="#情形3-小于等于-1" class="headerlink" title="情形3 (小于等于)"></a>情形3 (小于等于)</h5><h6 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h6><p>此处「情形3」为错误代码，不过多分析，专注于后续的「无限循环」分析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模版二「一般」情形3：小于等于（注意！！！此版本有可能发生无限循环）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = nums.length;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[c] &lt;= target) l = c; <span class="comment">// #1 更新后l及l左侧元素「必」小于等于target </span></span><br><span class="line">            <span class="keyword">else</span> r = c - <span class="number">1</span>; <span class="comment">// #2 更新后r右侧「必」大于target</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// return (r != -1 &amp;&amp; nums[l] == target) ? l : -1; // 704题的返回，处理:相等/不等</span></span><br><span class="line">        <span class="keyword">return</span> r != -<span class="number">1</span> ? l : -<span class="number">1</span>; <span class="comment">// 处理:等于/刚好大于/不存在</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实际运行上述代码后，「情形1」准确无误地返回所有结果，但「情形3」却意外地陷入了<strong>无限循环</strong>。在分析此无限循环现象之前，先提一下这个错误版本的返回语句。可以看到返回语句中竟然用到了 $r$ 和 $l$，之前的分析不是已经指出 $while$ 循环结束后 $r &#x3D; l$ 了吗？这里有必要再推导一次此版本代码的终止情形，如下。</p><p><img src="https://pic.leetcode-cn.com/1652191641-MbDfUh-image.png" alt="image.png"></p><p>可以看到，终止情形有两种，第二种将有可能导致 $r$ 越界，即当 $target$ 小于 $nums$ 中任何一个数时， $l$ 不发生更新 $(l &#x3D;&#x3D; 0)$，最终 $r &#x3D; l - 1$ 终止。正因为存在这样的终止情形，所以返回语句中 $r$ 和 $l$ 才会同时存在。总之虽然从两种终止情形中我们感觉到了一些 <strong>坏味道</strong> ，虽然这版代码看起来没什么问题，但我们已经知道了它可能会陷入无限循环，下面开始分析。</p><br /><h6 id="无限循环的触发条件及证明"><a href="#无限循环的触发条件及证明" class="headerlink" title="无限循环的触发条件及证明"></a>无限循环的触发条件及证明</h6><p>首先，「循环不变」关系在整个程序运行过程中是由 <strong>「因果律」</strong> 所保证的（一旦进入分支，必然更新相应的 $l$ 或 $r$，必然使得 $l$ 或 $r$ 的左或右侧满足对应的「循环不变」关系），问题肯定不会出现在「循环不变」上。接着我们再来审视模版二的代码，并尝试从它与模版一的不同处着手。不难看到除了 $while$ 条件的不同，最大的不同在于 $l$ 和 $r$ 的更新语句。模版一中 $l$ 和 $r$ 的更新都是在 $c$ 的基础上错一位，但模版二中却有 <strong>可能保持与 $c$ 相等。</strong> 循环中的变量只有 $l, r, c$ ，对于「情形1」，如果某一次循环进入 $else$ 分支，使得 $r &#x3D; c$ ，且进入本次循环时 $r$ 原本就等于 $c$，那么 $l$ 与 $r$ 都将保持不变，$c$ 由 $l$ 与 $r$ 得到，那么 $c$ 也会继续保持不变，也就有可能发生无限循环。对于「情形3」也是如此，也有可能因为进入 $l &#x3D; c$ 分支而发生无限循环。我们已经知道「情形1」代码没问题，但「情形3」代码发生无限循环，现在逐个分析。为方便分析，将「情形1」和「情形3」的代码并列如下，左侧为「情形1」，右侧为「情形3」。</p><p><img src="https://pic.leetcode-cn.com/1652191661-eKVltj-image.png" alt="image.png"></p><br /><p><strong>情形1的分析</strong></p><p>发生循环只可能是如下场景：某一次进入 $while$ 时， $c &#x3D; l + (r - l) &#x2F; 2$ ，使得 $nums[c] &gt;&#x3D; target$，进入 $else$ 分支，$r &#x3D; c$ ，且假设此次循环开始时就有 $r &#x3D; c$ ，于是 $l$ 与 $r$ 在此次循环中不变，下一次循环首先计算的 $c$ 也不变，循环产生。但实际运行结果告诉我们，程序没有问题，因此有必要检视上述假设的正确性。我们<strong>首先假设了 $r &#x3D; c$</strong> ，可以将计算 $c$ 时的 $c$ 换成 $r$，有 $r &#x3D; l + (r - l) &#x2F; 2$，我们知道这个式子与 $r &#x3D; (l + r) &#x2F; 2$ 相等，只是为了防止溢出才写成前一种形式。为方便分析换回后一种简单形式。$l + r$ 要么为偶数，要么为奇数：</p><ul><li>$l + r$ 为偶数时，能够被 2 整除，有 $2r &#x3D; l + r$，即 $r &#x3D; l$ 。但 $while$ 条件已经限制了 $l &lt; r$，$l &#x3D; r$ 时不可能进入 $while$ 循环，故 $r &#x3D; c$ 的假设与 $l + r$ 为偶数互相矛盾。</li><li>$l + r$ 为奇数时，我们转换成 $r &#x3D; (l + r - 1) &#x2F; 2$ ，该式结果与奇数情形向下取整的结果相同，得到 $r &#x3D; l - 1$，这显然也是不可能发生的，故 $r &#x3D; c$ 的假设与 $l + r$ 为奇数互相矛盾。</li></ul><p>由此我们得出结论，左侧「情形1」的代码虽然看起来有可能产生循环，<strong>但发生循环的条件根本不可能达到</strong>，因此程序一定能够终止运行，又依据前述「循环不变」的原理，代码的正确性得以保证。</p><br /><p><strong>情形3的分析</strong></p><p>分析过程一致。产生循环的条件是某一次进入 $while$ 时，$c &#x3D; l + (r - l) &#x2F; 2$ ，使得 $nums[c] &lt;&#x3D; target$ ，于是进入 $if$ 分支，$l &#x3D; c$，且假设此次循环开始时 $l &#x3D; c$。检视该假设的正确性，将计算 $c$ 的式子中的 $c$ 换成 $l$，有 $l &#x3D; (l + r) &#x2F; 2$。</p><ul><li>$l + r$ 为偶数时，$l &#x3D; r$，与进入 $while$ 的条件矛盾，故 $l &#x3D; c$ 的假设与 $l + r$ 为偶数互相矛盾。</li><li>$l + r$ 为奇数时，$l &#x3D; r - 1$ 。<strong>破案了，这是可能达到的一种情况！</strong> 也就是说，「情形3」代码在某一次进入 $while$ 时，若 $l &#x3D; r -1$，且 $nums[c] &lt;&#x3D; target$ 时，将发生无限循环。</li></ul><p>举个例子，对于数组 $nums &#x3D; {-1,0,3,5,9,12}$ ，$target &#x3D; 3$ ，以其为输入运行「情形3」代码，程序将在 $l &#x3D; 1, r &#x3D; 2$ （满足 $l &#x3D; r - 1$，且此时 $nums[c] &#x3D; nums[1] &#x3D; 0 &lt;&#x3D; target &#x3D; 3$ ）时开始无限循环。但若 $target &#x3D; 5$ ，则程序正常结束，返回正确的结果（建议实际动手分析一下）。实际上只要 $target$ 大于 $nums$ 中所有数字，则必然发生无限循环，因为 $r$ 不会更新， $l$ 向 $r$ 逐渐靠近后最终一定位于 $r$ 的前一位，即 $l &#x3D; r - 1$，而此时必然有 $nums[c] &lt;&#x3D; target$ ，于是会在这个时候陷入无限循环。</p><br /><h6 id="情形3的正确写法"><a href="#情形3的正确写法" class="headerlink" title="情形3的正确写法"></a>情形3的正确写法</h6><p>上述分析指出，导致陷入无限循环的关键在于 $l &#x3D; c$ 语句，从该语句推导出无限循环发生的条件是有可能出现的。因此对于「情形3」，我们需要稍加改造。改造点自然在 $l &#x3D; c$ 语句上。我们仍旧让这条更新语句为 $l &#x3D; c + 1$，那么条件也要相应地改成 $nums[c] &lt; target$ ，目的是要让这个「循环不变」关系成立：$l$ 更新后其左侧元素「必」小于 $target$ 。然后 $r$ 的更新语句要调整回 $r &#x3D; c$ 。两条「循环不变」关系与「情形1」一样：</p><ol><li>对于 #1 行，若进入该分支，则 $l$ 下标更新后其左侧元素「必」 <strong>小于</strong> $target$ 。</li><li>对于 #2 行，若进入该分支，则 $r$ 下标更新后 $r$ 及其右侧元素「必」 <strong>大于等于</strong> $target$。</li></ol><p><img src="https://pic.leetcode-cn.com/1652191682-fLBgWN-image.png" alt="image.png"></p><p>这时候我们会发现，不是又变回情形一了吗？没错，直到 $while$ 结束前的语句，与情形一是完全一致的（因此终止情形也只有 $l &#x3D; r$ 一种）。当 $while$ 结束后，$l$ 左侧元素必小于 $target$ ，$r$ 及其右侧元素必大于等于 $target$ 。我们只需在返回前调整一下判断，就能返回正确结果了。判断语句经由如下思考后写就。</p><ul><li><p>$nums$ 中所有元素都小于 $target$ 时，$r$ 不更新，最终 $r &#x3D; nums.length$ ，因此当这个关系成立时，返回 $r - 1$。</p></li><li><p>$nums$ 中存在元素小于等于 $target$ 时，由两条「循环不变」关系可知，如果 $nums[r]$ 等于 $target$ ，需要返回 $r$，否则返回 $r - 1$。</p></li><li><p>$nums$ 中所有元素都大于 $target$ 时，$l$ 不更新，最终 $l &#x3D; r &#x3D; 0$，我们需要返回 -1，而此时 $r - 1$正好等于 -1。</p></li></ul><p>可以看到，返回值仍旧是两种情形（$r$ 或 $r-1$）。由此我们写出「模版二」的正确的「情形3」代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模版二「一般」写法之情形3（正确版1）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = nums.length;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[c] &lt; target) l = c + <span class="number">1</span>; <span class="comment">// #1 更新后l左侧元素「必」小于target </span></span><br><span class="line">            <span class="keyword">else</span> r = c; <span class="comment">// #2 更新后r及其右侧「必」大于等于target</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// return (r != nums.length &amp;&amp; nums[r] == target) ? r : -1; // 704题的返回，处理:相等/不等</span></span><br><span class="line">        <span class="keyword">return</span> (r == nums.length || nums[r] != target) ? r - <span class="number">1</span> : r; <span class="comment">// 处理:相等/刚好小于/不存在</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于 $if-else$ 的条件和 $l,r$ 的更新，有必要再多说几句。对于同样的要求， $if-else$ 的条件和 $l, r$ 更新语句可以用不同的配合。为了体现这一点，我再给出「情形3」的另一种正确版本。如下，到 $while$ 结束之前，与上一个版本的写法只有 $if$ 条件中一个 ‘&#x3D;’ 字符的差别。该差别使得两个「循环不变」关系为如下：</p><ol><li>对于 #1 行，若进入该分支，则 $l$ 下标更新后其左侧元素「必」 <strong>小于等于</strong> $target$ 。</li><li>对于 #2 行，若进入该分支，则 $r$ 下标更新后 $r$ 及其其右侧元素「必」 <strong>大于</strong> $target$ 。</li></ol><p>仍旧考虑 $target$ 的三种情况：</p><ul><li>$nums$ 中所有元素都小于 $target$ 时，$r$ 不更新，最终 $r &#x3D; nums.length$，因此当这个关系成立时，返回 $r - 1$。</li><li>$nums$ 中存在元素小于等于 $target$ 时，由两条「循环不变」关系可知应返回 $r - 1$。</li><li>$nums$ 中所有元素都大于 $target$ 时，$l$ 不更新，最终 $l &#x3D; r &#x3D; 0$，我们需要返回 -1，而此时 $r - 1$正好等于 -1。</li></ul><p>三者返回都是相同的 $r - 1$，由此我们得到如下「情形3」的正确版2。如果用来解决704题，见注释行。值得一提的是，若直接返回 $r - 1$，虽是正确的，但形式上却不容易看出 $r &#x3D; 0$ 时返回 -1 对应 $nums$ 中所有元素都大于 $target$ 这一情况，因此我们也可以写成 <code>return r &gt; 0 ? r - 1 : -1;</code> 这样的形式。且若第三种情况要求返回的不是 -1 而是其他的值时，也方便调整。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模版二「一般」写法之情形3(正确版2)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = nums.length;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[c] &lt;= target) l = c + <span class="number">1</span>; <span class="comment">// #1 更新后l左侧元素「必」小于等于target </span></span><br><span class="line">            <span class="keyword">else</span> r = c; <span class="comment">// #2 更新后r及其右侧「必」大于target</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 原先针对 704 的返回有漏洞，该修改（下面一行）来自 Hankai Xia @masterx89 同学，感谢</span></span><br><span class="line">        <span class="comment">// return (r &gt; 0 &amp;&amp; nums[r - 1] == target) ? r - 1 : -1; // 704题的返回，处理:相等/不等</span></span><br><span class="line">        <span class="comment">// return r - 1; // 通过分析target的三种情形得到的统一返回值</span></span><br><span class="line">        <span class="keyword">return</span> r &gt; <span class="number">0</span> ? r - <span class="number">1</span> : -<span class="number">1</span>; <span class="comment">// 但写成此种形式，逻辑更佳 （来自Hankai Xia @masterx89 的建议）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，给出模版二「情形2」和「情形4」的代码如下。同样地，这两种情形不涵盖等于，因此不用于704题。省略详细分析过程，给出 $target$ 的三种情况时对应的返回，由前面的经验，我们能够立即看出代码的正确性。</p><br /><h5 id="情形4-小于-1"><a href="#情形4-小于-1" class="headerlink" title="情形4 (小于)"></a>情形4 (小于)</h5><p>「情形4」考虑 $target$ 的三种情况：</p><ul><li>$nums$ 中所有元素都小于 $target$ 时，$r$ 不更新，最终 $r &#x3D; nums.length$，因此当这个关系成立时，返回 $r - 1$。</li><li>$nums$ 中存在元素小于 $target$ 时，由两条「循环不变」关系可知应返回 $r - 1$ 。</li><li>$nums$ 中所有元素都大于等于 $target$ 时，$l$ 不更新，最终 $l &#x3D; r &#x3D; 0$ ，我们需要返回 -1，而此时 $r - 1$ 正好等于 -1。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模版二「一般」情形4: 小于</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = nums.length;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[c] &lt; target) l = c + <span class="number">1</span>; <span class="comment">// #1 更新后l左侧元素「必」小于target </span></span><br><span class="line">            <span class="keyword">else</span> r = c; <span class="comment">// #2 更新后r及其右侧「必」大于等于target</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r - <span class="number">1</span>; <span class="comment">// 处理:刚好小于/不存在</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h4 id="再论-r-的初始值"><a href="#再论-r-的初始值" class="headerlink" title="再论 r 的初始值"></a>再论 r 的初始值</h4><p>本节开头，介绍「模版二」时提到，$r$ 的初始值 $r &#x3D; nums.length$ 是「模版二」与「模版一」的一大不同。</p><blockquote><p>为统一描述，后续记做 $r &#x3D; n + 1$，$n &#x3D; nums.length - 1$，$n$ 表示搜索空间右界，$r$ 初始为搜索空间右界 + 1。</p></blockquote><p>该取值的主要的原因是当 $target$ 大于 $nums$ 中所有元素时，$r$ 不更新，那么 $r &#x3D; n + 1 (nums.length)$ 将是是判断这一情况的标志。倘若 $r$ 初始值为 $n$ ( $nums.length - 1$ )，循环终止后 $r$ 不变，则无法知道究竟是 $target$ 大于 $nums$ 中的所有元素，还是 $target$ 为最后一个元素。但许多题目的答案保证了搜索空间内必有解，若为此种情形，则 $r$ 的初始值就无需比搜索空间右界大 1。虽然这将导致考察不到 $c &#x3D; n$，但并不影响返回值的正确性，以下简单分析这一点。</p><ul><li><p>「相等返回」情形，需要返回 $c$。若答案为最后一个元素，$l &#x3D; r &#x3D; n$ 时循环终止，虽未能更新 $c &#x3D; n$， 并通过 $nums[c] &#x3D;&#x3D; target$ 来返回 $c$ ，但因为除了此种情况，都会在 $while$ 中返回，只有答案为最后一个元素时才会执行到最后的返回语句，因此可以直接在最后的 $return$ 语句中返回 $nums[r]$ 。</p></li><li><p>「大于等于」&amp; 「大于」情形，需要返回 $r$ 。若答案为最后一个元素，$l &#x3D; r &#x3D; n$ 时循环终止，虽未能更新 $c &#x3D; n$， 并通过 $nums[c] &gt;&#x3D; target$ (大于等于) 或 $nums[c] &gt; target$ (大于) 来更新 $r &#x3D; c &#x3D; n$ ，但 $r$ 不更新时刚好有 $r &#x3D; n$，所以能够返回正确结果。</p></li><li><p>「小于等于」&amp;「小于」情形，需要返回 $r - 1$。若答案为最后一个元素时，将无法通过 $r - 1 (r - 1 &#x3D; n - 1)$ 来返回 $n$ 。但我们可以通过返回前判断是 $nums[r - 1]$ 是否满足要求（根据具体要求），不满足时表示答案为最后一个元素（因为必存在解）。例如要求返回下标时，返回语句大致可以这么写 <code>return nums[r - 1] &lt;= target ? r - 1 : r;</code>。再次强调，题目已经确保搜索空间中存在答案，必有 $r &gt; 0$。</p></li></ul><p>具体例子有 <a href="https://leetcode.cn/problems/find-peak-element/">162. 寻找峰值</a>、<a href="https://leetcode.cn/problems/first-bad-version/">278. 第一个错误的版本</a> 、<a href="https://leetcode.cn/problems/koko-eating-bananas/">875. 爱吃香蕉的珂珂</a>、<a href="https://leetcode.cn/problems/kth-smallest-number-in-multiplication-table/">668. 乘法表中第k小的数</a>、<a href="https://leetcode.cn/problems/minimum-moves-to-equal-array-elements-ii/">462. 最少移动次数使数组元素相等 II</a>，这些题目已经保证搜索空间中必有解，因此采用「模版二」时，初始时 $r &#x3D; n$ 也是正确的（无需写成 $r &#x3D; n + 1$，即常规的搜索空间右界 + 1）。</p><p>通常我们只需要按 $r &#x3D; n + 1$ 的常规初始值来写即可，但在<a href="https://leetcode.cn/problems/find-peak-element/">162. 寻找峰值</a>中有可能导致越界（左界更新条件中出现了 $nums[c + 1]$），因此在 $r &#x3D; n$ 不影响正确性时，写成 $r &#x3D; n$ 可以省去对越界情况的分析。不过若要写下 $r &#x3D; n$，就意味着我们需要思考清楚是否不影响返回值正确性。总之仍要视情况而定。「再论 $r$ 的初始值」主要是想强调，「模版二」解法中你可能会看到 $r &#x3D; n$ 的写法，这未必是错的，也就是说「模版二」并不意味着一定要将 $r$ 初始值设置为 $r &#x3D; n + 1$。</p><br /><h4 id="从「y总模版」到「模版二」之「左开右闭」"><a href="#从「y总模版」到「模版二」之「左开右闭」" class="headerlink" title="从「y总模版」到「模版二」之「左开右闭」"></a>从「y总模版」到「模版二」之「左开右闭」</h4><p>文本发出后不久，常能在评论区看到有人提y总的二分模版，于是我也去学习了一下。y总模版属于本文定义的「模版二」，因此本小节作为「模版二」的子章节介绍，以下分析y总模版及其与本文所述情形的对应关系。</p><blockquote><p>y总的网站名是力扣敏感词，贴上相关链接文章就会被限流（参与人数被置为0），可以搜索一下「y总 二分模版」。</p></blockquote><p>y总提出如下两个模版 (我把他原文中的 $if-else$ 顺序调整成了本文提倡的先更新 $l$ 再更新 $r$ 的形式，$mid$ 改成本文惯用的 $c$，$c$ 的取值写成本文惯用的形式)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// y总的「模版一」</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_1</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> c = l + (r - l) / <span class="number">2</span>; <span class="comment">// y总原文写为 l + r &gt;&gt; 1</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(c)) l = c + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// y总的「模版二」</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_2</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> c = l + (r - l + <span class="number">1</span>) / <span class="number">2</span>; <span class="comment">// y总原文写为 l + r + 1 &gt;&gt; 1</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(c)) l = c;</span><br><span class="line">        <span class="keyword">else</span> r = c - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>容易看出，y总的「模版一」实际上对应的就是「模版二」。通过设置具体的 $check$ 函数来对应具体情形，例如如果是「大于等于」情形，$check$ 函数实际上就是 $nums[c] &lt; target$，其他不再举例。</p><p>我们重点来看看y总的「模版二」。乍一看，这不就是我们在「发生无限循环的条件及证明」中展示过的「情形3错误写法」吗？ $l &#x3D; c$ 的写法可能触发无限循环。不仅如此，我们之前还贴过一张「终止情形」图示，说明该错误写法的终止情形有两种。我们再仔细看，发现 $c$ 的计算方式原来的 <strong>下取整变为了上取整</strong> ，即不再是 $l + (r - l) &#x2F; 2$ （即 $(l+r)&#x2F;2$ 的防提前溢出写法），而是 $l + (r - l + 1) &#x2F; 2$  （即 $(l+r+1)&#x2F;2$ 的防提前溢出写法）。通过这一改变，不仅 <strong>巧妙地杜绝了无限循环的可能</strong> ，同时也保证了 $while$ 循环 <strong>必定终止</strong> 于 $l &#x3D; r$ 这一种情形。现在我们来详细看看这是如何做到的。</p><p>首先分析无限循环的可能。与前述分析一样，产生循环的条件只可能是某一次进入 $while$ 时，$c &#x3D; l+(r-l+1)&#x2F;2$ ，有 $check(c) &#x3D;&#x3D; true$ ，于是进入 $if$ 分支，$l &#x3D; c$，且假设此次循环开始时 $l &#x3D; c$。检视该假设的正确性，将计算 $c$ 的式子中的 $c$ 换成 $l$，有 $l &#x3D; (l + r + 1) &#x2F; 2$。</p><ul><li>$l + r + 1$ 为偶数时，$l &#x3D; r + 1$，与进入 $while$ 的条件矛盾，故 $l &#x3D; c$ 的假设与 $l + r + 1$ 为偶数互相矛盾。</li><li>$l + r + 1$ 为奇数时，$l &#x3D; r$ ，与进入 $while$ 的条件矛盾，故 $l &#x3D; c$ 的假设与 $l + r + 1$ 为奇数互相矛盾。</li></ul><p>通过这一简单分析，我们发现y总的写法确实不会发生无限循环。接下来我们再通过图示的方式来找到 <strong>「循环终止情形」</strong> ，如下， $while$ 确实能够终止于 $l &#x3D; r$ 这一种唯一的情形。</p><p><img src="https://pic.leetcode-cn.com/1654660874-iWmqoS-image.png" alt="image.png"></p><p>y总的两个模版都对应了本文的「模版二」。本文「模版二」中因为保持了 $c$ 的传统计算方式 (下取整)，因此必须避免 $l &#x3D; c$ 来杜绝无限循环，而y总则通过修改 $c$ 的计算方式来克服这一点，并同时保证了终止情形为 $l &#x3D; r$。利用这一写法，我们可以写出如下「模版二」的「情形3(小于等于)」和「情形4(小于)」的又一种实现。</p><p>但需要注意的是，y总方法的初始值为 $l &#x3D; 0, r &#x3D; nums.length - 1$ （我看y总视频总是这么定义的）。当 $nums$ 大小为 1 时，$c &#x3D; 1$，将导致无法进入 $while$ ，因此在返回前需要额外判断一次。实际上可以通过调整 $l &#x3D; -1$ 来避免上述情况，调整后一定能够至少进入一次 $while$ 。更本质原因是，因为 $c$ 上取整，如此取值使得 $c$ 总是在 $(l, r]$ 范围内，能够完整地覆盖且只覆盖搜索空间。这样调整过后实际上就对应了「相等终止」中的 <strong>「左开右闭」</strong> 二分版本。其实「左右界初始值」中的表格已经展示过了。于是我们看到，若将「y总的模版一」初始值定为 $l &#x3D; 0, r &#x3D; nums.length$ ，将「y总模版二」初始值定为 $l &#x3D; -1, r &#x3D; nums.length - 1$ ，则前者是标准的「模版二」之「左闭右开」版本，后者是标准的「模版二」之「左开右闭」版本。下面我们给出后者的五种情形的代码，过程不再赘述。</p><br /><h5 id="相等返回情形-2"><a href="#相等返回情形-2" class="headerlink" title="相等返回情形"></a>相等返回情形</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模版二(左开右闭)相等返回情形</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> -<span class="number">1</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> l + (r - l + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[c] == target) <span class="keyword">return</span> c;</span><br><span class="line">            <span class="keyword">if</span>(nums[c] &lt; target) l = c; <span class="comment">// #1 更新后l及l左侧元素「必」小于target </span></span><br><span class="line">            <span class="keyword">else</span> r = c - <span class="number">1</span>; <span class="comment">// #2 更新后r右侧「必」大于target</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 704题的返回</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h5 id="情形1-大于等于-2"><a href="#情形1-大于等于-2" class="headerlink" title="情形1 (大于等于)"></a>情形1 (大于等于)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模版二(左开右闭)「一般」情形1(大于等于)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> -<span class="number">1</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> l + (r - l + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[c] &lt; target) l = c; <span class="comment">// #1 更新后l及l左侧元素「必」小于target </span></span><br><span class="line">            <span class="keyword">else</span> r = c - <span class="number">1</span>; <span class="comment">// #2 更新后r右侧「必」大于等于target</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// return (r == nums.length - 1 || nums[r + 1] != target) ? -1 : r + 1; // 704题的返回，处理:相等/不等</span></span><br><span class="line">        <span class="keyword">return</span> r == nums.length - <span class="number">1</span> ? -<span class="number">1</span> : r + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h5 id="情形2-大于-2"><a href="#情形2-大于-2" class="headerlink" title="情形2 (大于)"></a>情形2 (大于)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模版二(左开右闭)「一般」情形2(大于)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> -<span class="number">1</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> l + (r - l + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[c] &lt;= target) l = c; <span class="comment">// #1 更新后l及l左侧元素「必」小于等于target </span></span><br><span class="line">            <span class="keyword">else</span> r = c - <span class="number">1</span>; <span class="comment">// #2 更新后r右侧「必」大于target</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r == nums.length ? -<span class="number">1</span> : r + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h5 id="情形3-小于等于-2"><a href="#情形3-小于等于-2" class="headerlink" title="情形3 (小于等于)"></a>情形3 (小于等于)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模版二(左开右闭)「一般」情形3(小于等于)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> -<span class="number">1</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> l + (r - l + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[c] &lt;= target) l = c; <span class="comment">// #1 更新后l及l左侧元素「必」小于等于target </span></span><br><span class="line">            <span class="keyword">else</span> r = c - <span class="number">1</span>; <span class="comment">// #2 更新后r右侧「必」大于target</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// return (l == -1 || nums[l] != target) ? -1 : l; // 704题的返回，处理:相等/不等</span></span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h5 id="情形4-小于-2"><a href="#情形4-小于-2" class="headerlink" title="情形4 (小于)"></a>情形4 (小于)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模版二(左开右闭)「一般」情形4(小于)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> -<span class="number">1</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> l + (r - l + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[c] &lt; target) l = c; <span class="comment">// #1 更新后l及l左侧元素「必」小于target </span></span><br><span class="line">            <span class="keyword">else</span> r = c - <span class="number">1</span>; <span class="comment">// #2 更新后r右侧「必」大于等于target</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h4 id="模版二总结"><a href="#模版二总结" class="headerlink" title="模版二总结"></a>模版二总结</h4><ul><li>核心在于 <strong>「相等终止」</strong>，即循环终止时有 $l &#x3D; r$。「模版二」的标志是  $while$ 中的 $l &lt; r$ 以及 $l$ 与 $r$ 更新时的 $l &#x3D; c + 1, r &#x3D; c$ ，二者相辅相成，共同作用实现了「相等终止」。另外 $l$ 与 $r$ 的初始取值的 <strong>「左闭右开」</strong> 特点也是「模版二」的一个特点。</li><li>通过 $l$ 左侧和 $r$ 右侧的「循环不变」关系，确定 $while$ 终止后的目标下标。</li><li>相等或不等的情形都可以用「一般」版本，但相等情形应当用「相等返回」版本，能够在找到相等元素时立即返回结果，而一般版本则一定会穷尽二分过程。</li><li><strong>必须避免 $l &#x3D; c$ 更新分支的出现</strong>，否则在一定条件下会发生无限循环。</li><li>但若采用y总提出的 $c &#x3D; l +(r - l + 1) &#x2F; 2$ ，则 $l$ 的更新可以是 $l &#x3D; c$。利用此写法时需注意返回前判断。</li><li>我们发现，若规定初始值为 $l &#x3D; -1, r &#x3D; nums.length - 1$ ，那么y总的第二种写法实际上就是标准的「模版二(相等终止)」的 <strong>「左开右闭」</strong> 版本。我们给出了这个版本的五种情形的写法。</li><li>通过比较我们可以感觉到，对于模版二，「左闭右开」更适合于「大于等于」和「大于」情形，而「左开右闭」则更适合于「小于等于」和「小于」情形。</li></ul><br /><h3 id="模版三-相邻终止-x2F-左开右开"><a href="#模版三-相邻终止-x2F-左开右开" class="headerlink" title="模版三 (相邻终止&#x2F;左开右开)"></a>模版三 (相邻终止&#x2F;左开右开)</h3><h4 id="相等返回情形-3"><a href="#相等返回情形-3" class="headerlink" title="相等返回情形"></a>相等返回情形</h4><p>与「模版一」、「模版二」相映，「模版三」的特点在于 <strong>「相邻终止」</strong> ，即 $while$ 终止时，$l &#x3D; r - 1$。$l$ 与 $r$ 在 $while$ 循环终止时的关系由循环条件及它们的更新语句 $l &#x3D; c$ 和 $r &#x3D; c$ 所决定，如同之前的分析那样，请参考后续「相邻终止图示」。该模版的初始值为 $l &#x3D; -1, r &#x3D; nums.length$ ，搜索空间可表为 $(l, r)$ ，因此通常被称作 <strong>「左开右开」</strong>。该取值原因前面已多次提过，略述。</p><blockquote><p>B站up主「五点七边」的介绍的「红蓝二分法」正是本文的「模版三」，力扣 <a href="/u/sui-xin-yuan/">@sui-xin-yuan</a> 随心源大佬也在推广。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模版三「相等返回」写法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> -<span class="number">1</span>, r = nums.length;</span><br><span class="line">        <span class="keyword">while</span>(l + <span class="number">1</span> &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[c] == target) <span class="keyword">return</span> c; <span class="comment">// 找到目标值直接返回</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[c] &lt; target) l = c; <span class="comment">// #1 更新后l及其左侧元素「必」小于target </span></span><br><span class="line">            <span class="keyword">else</span> r = c; <span class="comment">// nums[c] &gt; target #2 更新后r及其右侧「必」大于target</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此实现的「循环不变」关系为：</p><ol><li>对于 #1 行，若进入该分支，则 $l$ 下标更新后 $l$ 及其左侧元素「必」小于 $target$。</li><li>对于 #2 行，若进入该分支，则 $r$ 下标更新后 $r$ 及其右侧元素「必」大于 $target$。</li></ol><p>同样地，程序执行过程中有两种情况：</p><ol><li><p>情况一：$nums[c] &#x3D;&#x3D; target$ ，直接返回正确的结果。</p></li><li><p>情况二：$while$ 因 $l$ 与 $r$ 不满足 $l+1 &lt; r$ 而终止，此时 $l &#x3D; r - 1 （$见后续「相邻终止」图示）。由「循环不变」关系，对于更新后任意时刻的 $l$ ，其左侧元素必小于 $target$，对于更新后任意时刻的 $r$，$r$ 及其右侧的元素必定大于 $target$。</p></li></ol><p><img src="https://pic.leetcode-cn.com/1654664174-OThOwa-image.png" alt="image.png"></p><p><strong>$while$ 终止时，$l &#x3D; r-1$。</strong> 情况二 $while$ 终止时 $r$ 及其右侧和 $l$ 及其的左侧正好覆盖了所有 $nums$ 的元素，此时可以断言：$target$ 必不在 $nums$ 中。若 $target$ 大于 $nums$ 中所有元素，虽然 $r$ 不更新，但最终 $l$ 的左侧覆盖了所有元素 $(l &#x3D; r-1 &#x3D; nums.length-1)$ 。同样地，$target$ 小于 $nums$ 中所有元素时，$l$ 虽不更新，但最终 $r$ 及其右侧覆盖了所有元素 ($r &#x3D; l + 1 &#x3D; 0$) ，断言都能够成立。</p><p>【相邻终止】</p><p><img src="https://pic.leetcode-cn.com/1654603468-HbLGEk-image.png" alt="image.png"></p><br /><h4 id="四种一般情形-2"><a href="#四种一般情形-2" class="headerlink" title="四种一般情形"></a>四种一般情形</h4><h5 id="情形1-大于等于-3"><a href="#情形1-大于等于-3" class="headerlink" title="情形1 (大于等于)"></a>情形1 (大于等于)</h5><p>四种一般情形同之前的描述，现在先讲解如下「情形1」的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模版三「一般」情形1: 大于等于</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> -<span class="number">1</span>, r = nums.length;</span><br><span class="line">        <span class="keyword">while</span>(l + <span class="number">1</span> &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[c] &lt; target) l = c; <span class="comment">// #1 更新后l及其左侧元素「必」小于target</span></span><br><span class="line">            <span class="keyword">else</span> r = c; <span class="comment">// #2 更新后r及其右侧「必」大于等于target</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// return (r == nums.length || nums[r] != target) ? -1 : r; // 704题的返回，处理:相等/不等</span></span><br><span class="line">        <span class="keyword">return</span> r == nums.length ? -<span class="number">1</span> : r; <span class="comment">// 处理: 相等/刚好大于/不存在</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若 $nums[c]$  小于 $target$，那么 $l$ 更新后有如下「循环不变」关系1。与「相等返回」不同的是，因为没有判等分支， 进入 #2 行的条件是 $nums[c] &gt;&#x3D; target$ ，得到如下「循环不变」关系2。</p><ol><li>对于 #1 行，若进入该分支，则 $l$ 下标更新后 $l$ 及其左侧元素「必」小于 $target$ 。</li><li>对于 #2 行，若进入该分支，则 $r$ 下标更新后 $r$ 及其右侧元素「必」大于等于 $target$ 。</li></ol><p>同样地，$while$ 终止时有 $l &#x3D; r - 1$，根据本情形的「循环不变」关系，此时 $target$ 必不在 $l$ 左侧，而 $r$ 的右侧必大于等于 $target$，又因为 $nums$ 是单调的，因此 <strong>断言: $r$ 要么是等于下标，要么是刚好大于下标</strong>。稍等，循环不变只保证了左右侧元素与 $target$ 的大小关系，并不保证 $l$ 或 $r$ 最终一定在 $nums$ 的下标范围内。实际上有可能超出一位，即为 $l &#x3D; -1$ ( $nums$ 中所有数都大于等于 $target$ ) 或 $r &#x3D; nums.length$ ( $nums$ 中所有数都小于 $target$ )。因此前述断言还有一个前提，即 $r !&#x3D; nums.length$，这个条件通过思考 $target$ 的 <strong>三种情况</strong> 提炼。</p><ul><li>$nums$ 中所有元素都小于 $target$ 时，$r$ 不更新，最终 $r &#x3D; nums.length$ ，因此当这个关系成立时，返回 -1。</li><li>$nums$ 中存在元素大于等于 $target$ 时，由两条「循环不变」关系（或者下图）可知应返回 $r$ 。</li><li>$nums$ 中所有元素都大于 $target$ 时，$l$ 不更新，$l &#x3D; -1$，此时应当返回下标 0，而刚好有 $r &#x3D; 0$，因此返回 $r$ 。</li></ul><p>于是一个判断即可对应三种情况 (后两种都返回 $r$ )。另外，因为 $l + 1 &#x3D; r$，用 $l+1$ 或 $r$ 来返回都是可以的。</p><p><img src="https://pic.leetcode-cn.com/1654663279-dLYdZP-image.png" alt="image.png"></p><p>下面给出余下情形的代码，分析过程是类似的，不再赘述。其中「情形2(大于)」和「情形4(小于)」不考虑「等于」关系，不用于处理704题，而「情形1(大于等于)」和「情形3(小于等于)」涵盖了「等于」，可以用来处理704题，只需要在返回值语句上稍作修改即可，细节请见代码。</p><br /><h5 id="情形2-大于-3"><a href="#情形2-大于-3" class="headerlink" title="情形2 (大于)"></a>情形2 (大于)</h5><p>「情形2」考虑 $target$ 的三种情况：</p><ul><li><p>$nums$ 中所有元素都小于等于 $target$ 时，$r$ 不更新，最终 $r &#x3D; nums.length$，因此当这个关系成立时，返回 -1。</p></li><li><p>$nums$ 中存在元素大于 $target$ 时，由两条「循环不变」关系可知应返回 $r$ ( $l$ 的右侧)。</p></li><li><p>$nums$ 中所有元素都大于 $target$ 时，$l$ 不更新，$l &#x3D; -1$ ，此时应当返回下标 0，而刚好有 $r &#x3D; 0$，返回 $r$ 。</p></li></ul><p>「情形2」与「情形1」只有一个 ‘&#x3D;’ 字符的差别。事实上这些代码都十分相似，但<strong>差之毫厘谬以千里</strong>，需要谨慎对待。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模版三「一般」情形2: 大于</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> -<span class="number">1</span>, r = nums.length;</span><br><span class="line">        <span class="keyword">while</span>(l + <span class="number">1</span> &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[c] &lt;= target) l = c; <span class="comment">// #1 更新后l及其左侧元素「必」小于等于target</span></span><br><span class="line">            <span class="keyword">else</span> r = c; <span class="comment">// #2 更新后r及其右侧「必」大于target</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r == nums.length ? -<span class="number">1</span> : r; <span class="comment">// 处理: 相等/刚好大于/不存在</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h5 id="情形3-小于等于-3"><a href="#情形3-小于等于-3" class="headerlink" title="情形3 (小于等于)"></a>情形3 (小于等于)</h5><p>「情形3」考虑 $target$ 的三种情况：</p><ul><li><p>$nums$ 中所有元素都小于 $target$ 时，应当返回最大下标 $nums.length - 1$，$r$ 未更新，有 $r &#x3D; nums.length$，此时 $l &#x3D; nums.length - 1$， 因此返回 $l$。</p></li><li><p>$nums$ 中存在元素小于等于 $target$ 时，由两条「循环不变」关系可知应返回 $l$ ( $r$ 的左侧)。</p></li><li><p>$nums$ 中所有元素都大于 $target$ 时，$l$ 不更新，$l &#x3D; -1$ ，此时应当返回 -1，因此返回 $l$。</p></li></ul><p>三种情况都返回 $l$。但若用此情形处理704题，则需调整，请参考注释行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模版三「一般」情形3: 小于等于</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> -<span class="number">1</span>, r = nums.length;</span><br><span class="line">        <span class="keyword">while</span>(l + <span class="number">1</span> &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[c] &lt;= target) l = c; <span class="comment">// #1 更新后l及其左侧元素「必」小于等于target</span></span><br><span class="line">            <span class="keyword">else</span> r = c; <span class="comment">// #2 更新后r及其右侧「必」大于target</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// return (l == -1 || nums[l] != target) ? -1 : l; // 704题的返回，处理:相等/不等</span></span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h5 id="情形4-小于-3"><a href="#情形4-小于-3" class="headerlink" title="情形4 (小于)"></a>情形4 (小于)</h5><p>「情形4」考虑 $target$ 的三种情况：</p><ul><li><p>$nums$ 中所有元素都小于 $target$ 时，应当返回最大下标 $nums.length - 1$，$r$ 未更新，有 $r &#x3D; nums.length$，此时 $l &#x3D; nums.length - 1$， 因此返回 $l$。</p></li><li><p>$nums$ 中存在元素小于 $target$ 时，由两条「循环不变」关系可知应返回 $l$ ( $r$ 的左侧)。</p></li><li><p>$nums$ 中所有元素都大于等于 $target$ 时，$l$ 不更新，$l &#x3D; -1$ ，此时应当返回 -1，因此返回 $l$。</p></li></ul><p>三种情况都返回 $l$，「情形4」与「情形3」只有一个 ‘&#x3D;’ 字符的差别。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模版三「一般」情形4: 小于</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> -<span class="number">1</span>, r = nums.length;</span><br><span class="line">        <span class="keyword">while</span>(l + <span class="number">1</span> &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[c] &lt; target) l = c; <span class="comment">// #1 更新后l及其左侧元素「必」小于target</span></span><br><span class="line">            <span class="keyword">else</span> r = c; <span class="comment">// #2 更新后r及其右侧「必」大于等于target</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h4 id="模版三总结"><a href="#模版三总结" class="headerlink" title="模版三总结"></a>模版三总结</h4><ul><li>核心在于 <strong>「相邻终止」</strong> ，即循环终止时有 $l &#x3D; r - 1$。「模版三」的标志是 $while$ 中的 $l + 1&lt; r$ 以及 $l$ 与 $r$ 更新时的 $l &#x3D; c, r &#x3D; c$，二者相辅相成，共同作用实现了「相邻终止」。另外 $l$ 与 $r$ 的初始取值的 <strong>「左开右开」</strong> 也是「模版三」的一个特点。</li><li>通过 $l$ 左侧和 $r$ 右侧的「循环不变」关系，确定 $while$ 终止后的目标下标。在「一般」情形中，要考虑 <strong>不更新导致的越界</strong> 及其对应的返回前判断。</li><li>相等或不等的情形都可以用「一般」版本，但相等情形应当用「相等返回」版本，能够在找到相等元素时立即返回结果，一般版本则一定会穷尽二分过程。</li></ul><br /><h3 id="各语言内置二分查找方法-函数"><a href="#各语言内置二分查找方法-函数" class="headerlink" title="各语言内置二分查找方法(函数)"></a>各语言内置二分查找方法(函数)</h3><p>简单介绍 Java &#x2F; C++ &#x2F; Python 中的二分查找相关方法(函数)。就模版而言，Java 和 C++ 的二分方法(函数)采用了「模版一」，Python 采用了「模版二」，就具体实现而言，不同语言的二分方法 (函数) 对返回值定义了不同的规则。首先总结如下。</p><table><thead><tr><th>语言</th><th>方法(函数)</th><th>模版情形</th><th>返回值</th><th>备注</th></tr></thead><tbody><tr><td>Java</td><td><a href="http://hg.openjdk.java.net/jdk8u/jdk8u/jdk/file/be44bff34df4/src/share/classes/java/util/Arrays.java">$binarySearch$</a></td><td>模版一<br />相等返回</td><td>找到返回「等于」下标<br />否则返回 $-n$，$n$ 表示作为第 $n$ 个元素插入</td><td></td></tr><tr><td>C++</td><td><a href="https://en.cppreference.com/w/cpp/algorithm/binary_search">$binary_search$</a></td><td>模版一<br />大于等于</td><td>找到返回 $true$ ，否则返回 $false$</td><td>调用 $lower_bound$</td></tr><tr><td></td><td><a href="https://en.cppreference.com/w/cpp/algorithm/lower_bound">$lower_bound$</a></td><td>模版一<br />大于等于</td><td>找到返回「大于等于」下标<br />否则返回 $nums.length$</td><td>即返回第一个满足插入后有序的「插入位置下标」</td></tr><tr><td></td><td><a href="https://en.cppreference.com/w/cpp/algorithm/upper_bound">$upper_bound$</a></td><td>模版一<br />大于</td><td>找到返回「大于」下标<br />否则返回 $nums.length$</td><td>即返回最后一个满足插入后有序的「插入位置下标」</td></tr><tr><td>Python</td><td><a href="https://github.com/python/cpython/blob/3.10/Lib/bisect.py">$bisect$</a></td><td>模版二<br />大于</td><td>找到返回「大于」下标<br />否则返回 $nums.length$</td><td>调用 $bisect_right$ <br />即返回最后一个满足插入后有序的「插入位置下标」</td></tr><tr><td></td><td><a href="https://github.com/python/cpython/blob/3.10/Lib/bisect.py">$bisect_left$</a></td><td>模版二<br />大于等于</td><td>找到返回「大于等于」下标<br />否则返回 $nums.length$</td><td>即返回第一个满足插入后有序的「插入位置下标」</td></tr><tr><td></td><td><a href="https://github.com/python/cpython/blob/3.10/Lib/bisect.py">$bisect_right$</a></td><td>模版二<br />大于</td><td>找到返回「大于」下标<br />否则返回 $nums.length$</td><td>即返回最后一个满足插入后有序的「插入位置下标」</td></tr></tbody></table><br /><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>JDK中内置的二分方法为 <a href="http://hg.openjdk.java.net/jdk8u/jdk8u/jdk/file/be44bff34df4/src/share/classes/java/util/Arrays.java">$binarySearch$</a> 。内部调用了如下方法，可以看到使用的是「模版一」的「相等返回」写法。只在 $return$ 上与我们给出的版本有差异。这个返回的意思是：</p><ul><li>若找到等于 $key$ 的元素，返回该元素下标（若有多个相等元素，返回其中之一的下标，不保证是哪一个）。</li><li>若找不到，则想象将 $key$ 作为第 $n$ 个元素插入 (从第1个开始算起)，返回 $-n$。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch0</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> fromIndex, <span class="type">int</span> toIndex,</span></span><br><span class="line"><span class="params">                                 <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> fromIndex;</span><br><span class="line">    <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> toIndex - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (low + high) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">midVal</span> <span class="operator">=</span> a[mid];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (midVal &lt; key)</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (midVal &gt; key)</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> mid; <span class="comment">// key found</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -(low + <span class="number">1</span>);  <span class="comment">// key not found.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><p>$STL$ 中的二分查找函数为 <a href="https://en.cppreference.com/w/cpp/algorithm/lower_bound">$lower_bound$</a> &#x2F; <a href="https://en.cppreference.com/w/cpp/algorithm/upper_bound">$upper_bound$</a> &#x2F; <a href="https://en.cppreference.com/w/cpp/algorithm/binary_search">$binary_search$</a>。</p><p>如下 <a href="https://en.cppreference.com/w/cpp/algorithm/lower_bound">$lower_bound$</a> 返回「大于等于」$val$ 的元素下标，采用的是「模版一」的「情形1(大于等于)」，与我们给出的版本的区别在 $return$ 语句上，该函数不做判断，也就是说当 $val$ 大于所有元素时，返回最后一个元素下标 +1（即等同于我们的 $nums.length$ ）。</p><p>※ <a href="https://www.cplusplus.com/reference/iterator/distance/">$distance$ </a> 函数返回从 $first$ (包括) 到 $last$ (包括) 的元素总数，所以 $count &gt; 0$ 其实就等同于 $l &lt;&#x3D; r$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">  <span class="function">ForwardIterator <span class="title">lower_bound</span> <span class="params">(ForwardIterator first, ForwardIterator last, <span class="type">const</span> T&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ForwardIterator it;</span><br><span class="line">  iterator_traits&lt;ForwardIterator&gt;::difference_type count, step;</span><br><span class="line">  count = <span class="built_in">distance</span>(first,last);</span><br><span class="line">  <span class="keyword">while</span> (count&gt;<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    it = first; step=count/<span class="number">2</span>; <span class="built_in">advance</span> (it,step);</span><br><span class="line">    <span class="keyword">if</span> (*it&lt;val) &#123;                 <span class="comment">// or: if (comp(*it,val)), for version (2)</span></span><br><span class="line">      first=++it;</span><br><span class="line">      count-=step+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> count=step;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://en.cppreference.com/w/cpp/algorithm/upper_bound">$upper_bound$</a> 返回「大于」$val$ 的元素下标，采用的是「模版一」的「情形2(大于)」，与我们给出的版本的区别在 $return$ 语句上，该函数不做判断，也就是说当 $val$ 大于所有元素时，返回最后一个元素下标 +1（即类似 $nums.length$ ）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">  <span class="function">ForwardIterator <span class="title">upper_bound</span> <span class="params">(ForwardIterator first, ForwardIterator last, <span class="type">const</span> T&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ForwardIterator it;</span><br><span class="line">  iterator_traits&lt;ForwardIterator&gt;::difference_type count, step;</span><br><span class="line">  count = std::<span class="built_in">distance</span>(first,last);</span><br><span class="line">  <span class="keyword">while</span> (count&gt;<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    it = first; step=count/<span class="number">2</span>; std::<span class="built_in">advance</span> (it,step);</span><br><span class="line">    <span class="keyword">if</span> (!(val&lt;*it))                 <span class="comment">// or: if (!comp(val,*it)), for version (2)</span></span><br><span class="line">      &#123; first=++it; count-=step+<span class="number">1</span>;  &#125;</span><br><span class="line">    <span class="keyword">else</span> count=step;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://en.cppreference.com/w/cpp/algorithm/binary_search">$binary_search$ </a> 调用 $lower_bound$ ，若找到返回 $true$ ，不存在返回 $false$ 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ForwardIt, <span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">binary_search</span><span class="params">(ForwardIt first, ForwardIt last, <span class="type">const</span> T&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    first = std::<span class="built_in">lower_bound</span>(first, last, value);</span><br><span class="line">    <span class="keyword">return</span> (!(first == last) &amp;&amp; !(value &lt; *first));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><p>Python 中的二分函数为 <a href="https://github.com/python/cpython/blob/3.10/Lib/bisect.py">$bisect_left$</a> &#x2F; <a href="https://github.com/python/cpython/blob/3.10/Lib/bisect.py">$bisect_right$</a> &#x2F; <a href="https://github.com/python/cpython/blob/3.10/Lib/bisect.py">$bisect$</a> 。</p><p>如下 <a href="https://github.com/python/cpython/blob/3.10/Lib/bisect.py">$bisect_left$</a> 返回「大于等于」$x$ 的元素下标，若所有元素都小于 $x$ ，返回最后一个元素下标 +1（即类似 $nums.length$ ），与 C++ 中的 $lower_bound$ 一致，但使用的是「模版二」的情形1写法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bisect_left</span>(<span class="params">a, x, lo=<span class="number">0</span>, hi=<span class="literal">None</span>, *, key=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Return the index where to insert item x in list a, assuming a is sorted.</span></span><br><span class="line"><span class="string">    The return value i is such that all e in a[:i] have e &lt; x, and all e in</span></span><br><span class="line"><span class="string">    a[i:] have e &gt;= x.  So if x already appears in the list, a.insert(i, x) will</span></span><br><span class="line"><span class="string">    insert just before the leftmost x already there.</span></span><br><span class="line"><span class="string">    Optional args lo (default 0) and hi (default len(a)) bound the</span></span><br><span class="line"><span class="string">    slice of a to be searched.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> lo &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&#x27;lo must be non-negative&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> hi <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        hi = <span class="built_in">len</span>(a)</span><br><span class="line">    <span class="comment"># Note, the comparison uses &quot;&lt;&quot; to match the</span></span><br><span class="line">    <span class="comment"># __lt__() logic in list.sort() and in heapq.</span></span><br><span class="line">    <span class="keyword">if</span> key <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">            mid = (lo + hi) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> a[mid] &lt; x:</span><br><span class="line">                lo = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hi = mid</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">            mid = (lo + hi) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> key(a[mid]) &lt; x:</span><br><span class="line">                lo = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hi = mid</span><br><span class="line">    <span class="keyword">return</span> lo</span><br></pre></td></tr></table></figure><p><a href="https://github.com/python/cpython/blob/3.10/Lib/bisect.py">$bisect_right$</a> 返回「大于」$x$ 的元素下标，若都小于 $x$ ，返回最后一个元素下标 +1（即类似 $nums.length$ ），与 C++ 中的 $upper_bound$ 一致，但使用的是「模版二」的情形2写法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bisect_right</span>(<span class="params">a, x, lo=<span class="number">0</span>, hi=<span class="literal">None</span>, *, key=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Return the index where to insert item x in list a, assuming a is sorted.</span></span><br><span class="line"><span class="string">    The return value i is such that all e in a[:i] have e &lt;= x, and all e in</span></span><br><span class="line"><span class="string">    a[i:] have e &gt; x.  So if x already appears in the list, a.insert(i, x) will</span></span><br><span class="line"><span class="string">    insert just after the rightmost x already there.</span></span><br><span class="line"><span class="string">    Optional args lo (default 0) and hi (default len(a)) bound the</span></span><br><span class="line"><span class="string">    slice of a to be searched.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> lo &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&#x27;lo must be non-negative&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> hi <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        hi = <span class="built_in">len</span>(a)</span><br><span class="line">    <span class="comment"># Note, the comparison uses &quot;&lt;&quot; to match the</span></span><br><span class="line">    <span class="comment"># __lt__() logic in list.sort() and in heapq.</span></span><br><span class="line">    <span class="keyword">if</span> key <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">            mid = (lo + hi) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> x &lt; a[mid]:</span><br><span class="line">                hi = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                lo = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">            mid = (lo + hi) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> x &lt; key(a[mid]):</span><br><span class="line">                hi = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                lo = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> lo</span><br></pre></td></tr></table></figure><p>在 $bisect_right$ 的代码中可看到如下语句，说明 <a href="https://github.com/python/cpython/blob/3.10/Lib/bisect.py">$bisect$</a> 调用了 $bisect_right$ 函数。 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create aliases</span></span><br><span class="line">bisect = bisect_right</span><br></pre></td></tr></table></figure><br /><h3 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h3><h4 id="提前溢出"><a href="#提前溢出" class="headerlink" title="提前溢出"></a>提前溢出</h4><p>关于求中间值坐标的写法。</p><ul><li>最简单的写法是 $c &#x3D; (l + r) &#x2F; 2$，但直接相加会使得 $l + r$ 大于 $2^{31} -1 (2147483647)$ 时（提前）溢出，例如 $l &#x3D; 1, r &#x3D; 2^{31}-1$，计算 $c$ 时， $l + r &#x3D; 2^{31} (2147483648)$ 导致溢出。但原本应该有 $c &#x3D; 1073741824$ ，$l, r, c$ 都不应该溢出，只是因为 $l + r$ 导致了（提前）溢出。</li><li>因此改写成先减后加的形式 $c &#x3D; l + (r - l) &#x2F; 2$。这是较常见的形式。</li><li>很多人会用 <code>&gt;&gt;</code> 代替除法，写成 $c &#x3D; l + ((r - l) &gt;&gt; 1)$ 也是可以的。</li><li>值得一提的是 JDK 中采用的是 $c &#x3D; (l + r) &gt;&gt;&gt; 1$ 的写法。<ul><li><code>&gt;&gt;&gt; </code> 是无符号右移运算符 (<a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/op3.html">Unsigned right shift operator</a>) ，与 <code>&gt;&gt;</code> 的区别在于右移的时不考虑符号位，总是从左侧补 0，$l + r$ 不溢出的时候符号位本来就是0，与 <code>&gt;&gt;</code> 效果相同。 $l + r$ 溢出时最高位符号位从 0 进位成了 1，经过 <code>&gt;&gt;&gt;</code> 的移位，最高位又变回了 0，这是一种利用位运算的 trick，可以参考<a href="https://stackoverflow.com/questions/13785210/why-in-java-high-low-2-is-wrong-but-high-low-1-is-not">这里</a>。</li><li>需要注意的是若采用此种写法，<strong>要保证 $(l + r)$ 为非负整数</strong> 。因为若 $(l + r)$ 为负数，经过高位补 0 后将得到错误的正数。通常情况下，$l$ 与 $r$ 代表下标，不会出现负数情况，但有的题目要在包含正负数的范围内，对这些 <strong>「数值」（而非下标）</strong> 进行二分查找， $l$ 和 $r$ 表示可能为正也可能为负的「数值」，此时就不用能 <code>&gt;&gt;&gt;</code> 的写法。例如<a href="https://leetcode.cn/problems/minimum-moves-to-equal-array-elements-ii/">462. 最少移动次数使数组元素相等 II</a> 题就不能采用 <code>&gt;&gt;&gt;</code> 写法。</li></ul></li></ul><br /><h4 id="二分查找趣闻"><a href="#二分查找趣闻" class="headerlink" title="二分查找趣闻"></a>二分查找趣闻</h4><p>Java 传奇开发人员Joshua Bloch 2006年在 Google 任职时写过一篇博文<a href="https://ai.googleblog.com/2006/06/extra-extra-read-all-about-it-nearly.html">Extra, Extra - Read All About It: Nearly All Binary Searches and Mergesorts are Broken</a>，主要讲的是求中间值下标的「提前溢出」问题。Joshua Bloch 聊了这么几个事。</p><ul><li><p>他在CMU刚读博的第一堂算法课上，老师 Jon Bentley (「编程珠玑」作者，$k-d$ 树发明人) 让大家写二分查找，结果大部分人的实现都是错误的。</p></li><li><p>到 2006 年的时候，Joshua Bloch 才知道「编程珠玑」中的二分查找实现存在上述整数溢出的问题，此时距离该书出版已经过去了 21 年。</p></li><li><p>直到那时，同样的 bug 在他实现的 JDK 的 $binarySearch$ 里也已经存在了 9 年之久。就因为中间值下标的计算语句是 <code>int mid =(low + high) / 2;</code> 。</p></li><li><p>他提出归并排序以及其他一些分治算法都要重新审视是否存在同样的问题。</p></li><li><p>Joshua Bloch 因此怅然良久，发出了一些 bug 与我们永存，对待代码要有敬畏之心之类的感慨。</p></li></ul><p>※ Extra, Extra即“号外！号外！”，可见当时 Joshua Bloch 写这篇文章的时候确实是心有戚戚不吐不快。</p><br /><h4 id="关于命名"><a href="#关于命名" class="headerlink" title="关于命名"></a>关于命名</h4><h5 id="三大模版"><a href="#三大模版" class="headerlink" title="三大模版"></a>三大模版</h5><p>「模版一」、「模版二」和「模版三」是约定俗成的命名，并不必然与某种确定的模式相绑定。但大部分资料，包括本文所述的三种模版，都有如下特点。</p><ul><li>「模版一」是基于 <strong>「相错终止」</strong> 而言的， **$while$ 循环结束时一定有 $r &#x3D; l - 1$**，这是「模版一」的标志。</li><li>「模版二」是基于 <strong>「相等终止」</strong> 而言的， <strong>$while$ 循环结束时一定有 $r &#x3D; l$</strong> ，这是「模版二」的标志。</li><li>「模版三」是基于 <strong>「相邻终止」</strong> 而言的， <strong>$while$ 循环结束时一定有 $l&#x3D;r-1$</strong> ，这是「模版三」的标志。</li></ul><p>「相错终止」、「相等终止」和「相邻终止」是我为了方便行文起的名字，实际上用 <strong>「左闭右闭」</strong> 来指代「模版一」， <strong>「左闭右开」</strong> 来指代「模版二」以及 <strong>「左开右开」</strong> 来指代「模版三」是目前通用的说法。但并不准确，我们已经介绍过，「模版二」也有「左开右闭」的写法 ( $c$ 上取整)。</p><p>所谓「闭开」指的是初始时 $l$ 与 $r$ 的取值范围。</p><ul><li>左闭右闭: 左右界初始取值为 $l &#x3D; 0, r &#x3D; nums.length - 1$，搜索空间表示为 $[l, r]$ ， <strong>在形式上两边闭</strong> ，故名。</li><li>左闭右开: 左右界初始取值 $l &#x3D; 0, r &#x3D; nums.length$ ，搜索空间表示为 $[l, r)$ ， <strong>在形式上为左闭右开</strong> ，故名。</li><li>左开右闭: 左右界初始取值 $l &#x3D; -1, r &#x3D; nums.length-1$ ，搜索空间表示为 $(l, r]$ ， <strong>在形式上为左开右闭</strong> ，故名。</li><li>左开右开: 左右界初始取值 $l&#x3D;-1, r &#x3D; nums.length$ ，搜索空间表示为 $(l, r)$ ， <strong>在形式上为左开右开</strong> ，故名。</li></ul><p>我提出的命名主要是想强调 $while$ 终止时 $l$ 与 $r$ 的位置关系，使用不同模版解决各类二分问题时，我们应当时刻记住 $l$ 与 $r$ 的最终位置关系，「相错」、「相等」以及「相邻」能很好的表达相应的位置关系。</p><br /><h5 id="二段性"><a href="#二段性" class="headerlink" title="二段性"></a>二段性</h5><p>因为正文内容基于输入数组具有「有序性」的704题介绍，因此对于二分查找更本质的「二段性」概念未在正文中正式的介绍。关于 <strong>「二段性」</strong> ，在「实战应用」一节的题解中，你会看到有些题目的数组并不具备有序性，但丝毫不妨碍以二分查找处理。这是因为，只要数组能够根据特定的条件（其实就是「循环不变」）被分为两半，且搜索空间为其中的一半，循环地如此二分下去，直到穷尽原搜索空间，<strong>最终必能确定答案</strong>（存在与否，及若存在是哪个）。这就是「二段性」，更严谨点说是 <strong>「输入序列对于答案可被二分至穷尽」</strong> 这一本质特征。最典型的莫过于 <a href="https://leetcode.cn/problems/find-peak-element/">162. 寻找峰值</a> ，只要至少存在一个数，其左右两边的数小于它，而其他数的大小和顺序可以是任意的。看起来十分反直觉，但仍可通过「循环不变」知道其满足上述本质特征，了解到这一点后就不会觉得有多特别了。另外，关于「二段性」的名字，不知是何人何时开始称呼的，个人感觉值得推敲，「段」字是名词，属于静态描述，而且隐隐约约让人觉得「段」内元素有某些相同的性质，因为它们属于同一段。个人倾向于「可二分性」或略称「二分性」，「分」是动词，属于动态描述，（也许）更能准确地指出「输入序列对于答案可二分至穷尽」这一本质。这当然只是一点愚见，我们还是用行之有年的「二段性」指称之。</p><br /><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>介绍了二分查找中常用的三种模版，指出「相错终止」、「相等终止」、「相邻终止」分别为三种模版的标志。</li><li>三种模版对应的 $l,r$ 初始值通常也是固定的，并指出了为何如此赋值。但我们在「再论 $r$ 的初始值」中指出，通常的初始取值并非强制，而是可以灵活调整的。例如y总模版在「相等终止」意义上被归为「模版二」，但其搜索空间形式为「左闭右闭」。</li><li>指出「循环不变」关系是分析二分算法正确性的关键，并展现 $while$ 条件及 $l,r$ 的如何配合以穷尽搜索空间，并使得循环终止时 $l$ 与 $r$ 有确定的位置关系。用图示展示了这一确定关系推理过程。</li><li>以 <a href="https://leetcode-cn.com/problems/binary-search/">704. 二分查找</a> 为例展示了所有模版的「相等返回」情形和「一般」情形的写法。并在这一过程中细致地分析了各种实现中的「循环不变」关系，指出如何通过这些不变的关系得到正确的答案。</li><li>在模版二中，从 $l$ 与 $r$ 可能的更新语句出发（ $r &#x3D; c, l &#x3D; c$ ），指出其发生无限循环的潜在可能，并证明了发生条件。这一点指导我们在「模版二」的实现中，要避免 $l &#x3D; c$ 更新分支的出现。我们给出了避免无限循环的正确版本。</li><li>对于上一条，y总模版给出了通过修改 $c$ 的计算方式避免无限循环的另一种方案。</li><li>同一个模版的同一种情形，存在多种写法。</li><li>介绍了 Java, C++, Python 中相关二分查找方法(函数)，并指出它们分别对应本文介绍的哪种模版的哪种情形。</li><li>谈论了模版命名、开闭区间含义及「二段性」内涵。</li><li>在「实战应用」中给出了数十道难度不同的二分题的题解，展示用不同模版不同方法解题的过程。</li></ul><br /><h3 id="实战应用"><a href="#实战应用" class="headerlink" title="实战应用"></a>实战应用</h3><p>本节给出如下二分查找题目，在理解本文内容后，应当不难做出。「题解」一列中给出了相应的题解以供读者自查。</p><table><thead><tr><th>题目</th><th>难度</th><th>题解</th></tr></thead><tbody><tr><td><a href="https://leetcode.cn/problems/binary-search/">704. 二分查找</a></td><td>简单</td><td><a href="https://leetcode.cn/problems/binary-search/solution/yukiyama-by-yukiyama-1pp9/">题解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/sqrtx/">69. x 的平方根 </a></td><td>简单</td><td><a href="https://leetcode.cn/problems/sqrtx/solution/by-yukiyama-g4ei/">题解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/guess-number-higher-or-lower/">374. 猜数字大小</a></td><td>简单</td><td><a href="https://leetcode.cn/problems/guess-number-higher-or-lower/solution/by-yukiyama-3zw3/">题解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/que-shi-de-shu-zi-lcof/">剑指 Offer 53 - II. 0～n-1中缺失的数字</a></td><td>简单</td><td><a href="https://leetcode.cn/problems/que-shi-de-shu-zi-lcof/solution/by-yukiyama-raz4/">题解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/">33. 搜索旋转排序数组</a></td><td>中等</td><td><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/solution/yukiyama-by-yukiyama-ovlz/">题解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/">153. 寻找旋转排序数组中的最小值</a></td><td>中等</td><td><a href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/solution/-by-yukiyama-rdkj/">题解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/">154. 寻找旋转排序数组中的最小值 II</a></td><td>困难</td><td><a href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/solution/yukiyama-by-yukiyama-7gcq/">题解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array-ii/">81. 搜索旋转排序数组 II</a></td><td>中等</td><td><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array-ii/solution/-by-yukiyama-y8ed/">题解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/first-bad-version/">278. 第一个错误的版本</a></td><td>简单</td><td><a href="https://leetcode.cn/problems/first-bad-version/solution/yukiyama-by-yukiyama-upvn/">题解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/find-peak-element/">162. 寻找峰值</a></td><td>中等</td><td><a href="https://leetcode.cn/problems/find-peak-element/solution/by-yukiyama-ilib/">题解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></td><td>中等</td><td><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/solution/by-yukiyama-k4v4/">题解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/search-insert-position/">35. 搜索插入位置</a></td><td>简单</td><td><a href="https://leetcode.cn/problems/search-insert-position/solution/by-yukiyama-65rj/">题解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/search-a-2d-matrix/">74. 搜索二维矩阵</a></td><td>中等</td><td><a href="https://leetcode.cn/problems/search-a-2d-matrix/solution/by-yukiyama-8q8c/">题解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/find-k-closest-elements/">658. 找到 K 个最接近的元素</a></td><td>中等</td><td><a href="https://leetcode.cn/problems/find-k-closest-elements/solution/by-yukiyama-xpb1/">题解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/divide-two-integers/">29. 两数相除</a></td><td>中等</td><td><a href="https://leetcode.cn/problems/divide-two-integers/solution/by-yukiyama-qtjy/">题解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/koko-eating-bananas/">875. 爱吃香蕉的珂珂</a></td><td>中等</td><td><a href="https://leetcode.cn/problems/koko-eating-bananas/solution/by-yukiyama-2zkw/">题解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/kth-smallest-number-in-multiplication-table/">668. 乘法表中第k小的数</a></td><td>困难</td><td><a href="https://leetcode.cn/problems/kth-smallest-number-in-multiplication-table/solution/-by-yukiyama-m8e9/">题解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/minimum-moves-to-equal-array-elements-ii/">462. 最少移动次数使数组元素相等 II</a></td><td>中等</td><td><a href="https://leetcode.cn/problems/minimum-moves-to-equal-array-elements-ii/solution/yukiyama-er-fen-cha-zhao-by-yukiyama-jg0d/">题解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/find-right-interval/">436. 寻找右区间</a></td><td>中等</td><td><a href="https://leetcode.cn/problems/find-right-interval/solution/by-yukiyama-cn7c/">题解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/random-pick-with-weight/">528. 按权重随机选择</a></td><td>中等</td><td><a href="https://leetcode.cn/problems/random-pick-with-weight/solution/by-yukiyama-e11f/">题解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/random-point-in-non-overlapping-rectangles/">497. 非重叠矩形中的随机点</a></td><td>中等</td><td><a href="https://leetcode.cn/problems/random-point-in-non-overlapping-rectangles/solution/by-yukiyama-ssbv/">题解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/search-a-2d-matrix-ii/">240. 搜索二维矩阵 II</a></td><td>中等</td><td><a href="https://leetcode.cn/problems/search-a-2d-matrix-ii/solution/by-yukiyama-wefb/">题解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/">4. 寻找两个正序数组的中位数</a></td><td>困难</td><td><a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/solution/yukiyama-by-yukiyama-t1ja/">题解</a></td></tr><tr><td>&#x3D;&#x3D;&#x3D;&#x3D; 不断更新中 &#x3D;&#x3D;&#x3D;&#x3D;</td><td></td><td></td></tr></tbody></table><br /><p>🐮🐮🐮<br>牛啊兄弟，你竟然真的看到这里了。</p><hr><p><strong>文章更新日志</strong></p><p>[2022-08-02]</p><ul><li>新增 <a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/">4. 寻找两个正序数组的中位数</a> 题解。</li></ul><p>[2022-07-28]</p><ul><li>新增 <a href="https://leetcode.cn/problems/search-a-2d-matrix-ii/">240. 搜索二维矩阵 II</a> 题解。</li></ul><p>[2022-07-15]</p><ul><li>修改一处笔误，详见评论区。感谢 <a href="/u/hezk/">@hezk</a> (@时光、若刻) 🙏 。</li></ul><p>[2022-06-17]</p><ul><li>修改若干处 $l$ 误写成 $i$ 的错误。感谢 <a href="https://leetcode.cn/u/wang-sun/">@wang-sun</a> (@王孙) 指出 (听我说谢谢你，因为有你。。。🙏</li></ul><p>[2022-06-14]</p><ul><li>修改若干处 $l$ 误写成 $1$ 的错误。感谢 <a href="https://leetcode.cn/u/wsdydeni/">@wsdydeni</a> (@无伤大雅的你呀) 指出 (听我说谢谢你，因为有你。。。🙏</li></ul><p>[2022-06-10]</p><ul><li>在「实战应用」中新增 <a href="https://leetcode.cn/problems/random-pick-with-weight/solution/by-yukiyama-e11f/">528. 按权重随机选择</a> 和 <a href="https://leetcode.cn/problems/random-point-in-non-overlapping-rectangles/solution/by-yukiyama-ssbv/">497. 非重叠矩形中的随机点</a> 的二分题解。</li></ul><p>[2022-06-09]</p><ul><li>灵佬 <a href="/u/endlesscheng/">@endlesscheng</a> (@灵茶山艾府) 指出「y总模版」以上取整计算中点下标 $c$ 的写法，实际就对应了「模版二」的「左开右闭」的版本。现已补充该版本不同情形的代码。感谢灵佬！另外，为了强调 <strong>「左右界初始值」</strong> 和 <strong>「$c$ 的计算方式」</strong> 要满足 $c$ 覆盖且仅覆盖搜索空间，<strong>「$while$ 循环条件」</strong> 和 <strong>「左右界更新语句」</strong> 确定循环终止时 $l$ 与 $r$ 的关系这两点，在「模版一」中新增了「四要素」一节。</li></ul><p>[2022-06-07]</p><ul><li><p>新增了<a href="#%E6%A8%A1%E7%89%88%E4%B8%89" title="相邻终止/左开右开">「模版三」</a>一节（实际上也就是B站up主「五点七边」介绍的，<a href="/u/sui-xin-yuan/">@sui-xin-yuan</a> 随心源大佬大力推广的「红蓝二分法」）。至此，「三大模版」以及「y总模版」均被网罗于本文中。后续我会再找时间把目前列出的二分题解，也加上y总写法和模版三写法。</p></li><li><p>在「模版二」一节中新增「<a href="#y%E6%80%BB%E6%A8%A1%E7%89%88%E5%88%86%E6%9E%90">y总模版分析</a>」小节分析y总的二分模版。指出y总模版对应本文的「模版二」，并分析其第二种写法是如何利用 $c &#x3D; l +(r - l + 1) &#x2F; 2$ 来避免无限循环以及保证 $while$ 终止时必有 $l &#x3D; r$ 。</p></li></ul><p>[2022-06-05]</p><ul><li>更新了「实战应用」的展现方式，以表格形式给出数十道二分题目的题解。</li></ul><p>[2022-05-20]</p><ul><li><p>在「模版二」中新增 「<a href="#%E5%86%8D%E8%AE%BAr%E7%9A%84%E5%88%9D%E5%A7%8B%E5%80%BC">再论 r 的初始值</a>」，分析并指出使用「模版二」时，何种情况可以不必使 r 初始时为 r &#x3D; nums.length，而是设置为与「模版一」一样的 r &#x3D; nums.length - 1。</p></li><li><p>为优化阅读体验，更改了文章部分布局。将本文的更新日志挪至文末，将「提前溢出」、「二分查找趣闻」、「关于名称」合入「拓展阅读」一节中，并将该节移至「总结」一节之后。</p></li><li><p>在「实战应用」中增加今日每日一题题解。（绝了，连着三天二分题，这是官方在给我这篇文章引流吗 😂😂😂，感谢官方！）</p><ul><li><p>5&#x2F;18: <a href="https://leetcode.cn/problems/kth-smallest-number-in-multiplication-table/">668. 乘法表中第k小的数</a></p></li><li><p>5&#x2F;19: <a href="https://leetcode.cn/problems/minimum-moves-to-equal-array-elements-ii/">462. 最少移动次数使数组元素相等 II</a></p></li><li><p>5&#x2F;20: <a href="https://leetcode.cn/problems/find-right-interval/">436. 寻找右区间</a></p></li><li><p>「实战应用」目前累计有这些二分题目，推荐看完本文后集中做掉：<br>704&#x2F;69&#x2F;374&#x2F;33&#x2F;153&#x2F;154&#x2F;81&#x2F;278&#x2F;162&#x2F;34&#x2F;35&#x2F;74&#x2F;658&#x2F;29&#x2F;875&#x2F;668&#x2F;442&#x2F;436</p></li></ul></li></ul><p>[2022-05-19]</p><ul><li><p>更正「实战应用」的81题代码的一条注释。由 <a href="/u/yi-xing-dai-ma-qiao-yi-tian/">@yi-xing-dai-ma-qiao-yi-tian</a> (@一行代码敲一天) 同学发现，感谢🙏。详情请见回复。</p></li><li><p>新增这两日的668&#x2F;462题题解。没想到昨天和今天连着两天都是二分查找的题目（5&#x2F;18: <a href="https://leetcode.cn/problems/kth-smallest-number-in-multiplication-table/">668. 乘法表中第k小的数</a>, 5&#x2F;19: <a href="https://leetcode.cn/problems/minimum-moves-to-equal-array-elements-ii/">462. 最少移动次数使数组元素相等 II</a>），难怪这篇文章眼看着就要掉出热议区前五，又被大家给捞上来了哈哈。这两题有些难度，但如果你看过本文，并且确实吃透了，那么独立做出的概率是很大的，yuki我作为一个资深小白，读题后很快就出思路，也都顺利AC（见「实战应用」）。<strong>趁热在「实战应用」中更新了这两题的题解</strong>，欢迎大家查看指正👏。（462另有「中位数」解法，可基于快速排序思想实现平均 $O(n)$ 的时间复杂度，该解法已更新到<a href="https://leetcode.cn/circle/discuss/eBo9UB/">十大排序从入门到入赘</a> 一文的「实战应用」中。）</p></li></ul><p>[2022-05-17]</p><ul><li><p>经 <a href="/u/masterx89/">@masterx89</a> (HanKai Xia) 同学指正，修改「模版二「一般」写法之情形3(正确版2)」代码中的返回值。原代码功能上正确，但存在无意义的赘行。详情可见评论区，感谢 HanKai Xia 同学！</p></li><li><p>修改了我原先对「左闭右闭」、「左闭右开」命名的错误看法。该错误看法如下。</p></li></ul><blockquote><p><del>不过我对「左闭右闭」、「左闭右开」的称呼不太满意，二者的搜索空间其实是一致的，我尝试去理解这个名称的时候，结合网上的一些说法，我想大概是因为「左闭右闭」的取值范围为 [l, r]（其中 r &#x3D; n - 1, n &#x3D; nums.length），写起来像表示实数范围的左闭右闭区间（虽然这个区间取值是离散的整数）。而「左闭右开」表示为 [l, n)，表示 初始 r &#x3D; n，但 c 取不到 n 值。我觉得很没有道理，因为前者的 c 同样取不到 n，而且二者形式上也不统一，你总不能把后者写成 [l, r)，那就更不对了，总之这是个令我感到困惑的称呼。</del> </p></blockquote><p>[2022-05-15]</p><ul><li><p>新增「二段性」的解释，并阐述一点个人对该名称的看法。「二段性」的内涵为「输入序列对于答案可二分至穷尽」，并指出此为二分查找的本质。</p></li><li><p>新增若干题目及题解。</p></li></ul><p>[2022-05-13]</p><ul><li><p>已更新这些二分题目的解析：704&#x2F;69&#x2F;374&#x2F;33&#x2F;153&#x2F;154&#x2F;81&#x2F;278&#x2F;162&#x2F;34&#x2F;35&#x2F;74&#x2F;658&#x2F;29&#x2F;875。仍在持续增加中。</p></li><li><p>修正 <a href="/u/peaceful-pasteurtdn/">@peaceful-pasteurtdn</a> (@JamesMay) 发现的「模版二」之「相等返回」情形代码瑕疵，删去了多余的返回前判断（此种场景中只要target不存在，最后可以直接返回 -1而无需判断）。同时修改了该处代码下的一段描述和一张示意图。详情可见评论区，感谢 JamesMay 同学。</p></li></ul><p>[2022-05-12]</p><ul><li><p>文章标题从「深度剖析二分查找」变更为「二分查找从入门到入睡」，主要想表达，学习这篇文章后，二分查找不再成为一看就会一写就废的顽疾，遇到二分，从容应对，而后可缓缓睡矣。</p></li><li><p>新增「实战应用」一节，展示在理解本文的基础上如何轻松解题，使得“该背哪个模版？”，“该用哪个模版？”将不再成为我们解决二分问题时的考虑。该节仍在更新中，我尽量多增加一些题目。</p></li></ul><p>[2022-05-11]</p><ul><li><p>增加了「二分查找趣闻」，介绍了Joshua Bloch写的一篇非常有趣的博文，博文中写了二分查找算法的一些趣事和求中间值下标溢出bug的历史，抒发了他对二分查找乃至对待程序，对待bug的一些感悟。强烈推荐大家看一看<a href="https://ai.googleblog.com/2006/06/extra-extra-read-all-about-it-nearly.html">这篇博文</a>。</p></li><li><p>增加了「各语言内置二分查找方法(函数)」一节，通过源码指出Java中的binarySearch, C++中的lower_bound &amp; upper_bound, 以及Python中的bisect_left &amp; bisect_right方法(函数)分别对应我们介绍的哪个模版的哪种情形。</p></li><li><p>增加「左闭右闭」、「左闭右开」的描述。</p></li><li><p>增加中间值下标防溢出的三种写法及解释。</p></li><li><p>修改若干错别字。</p></li></ul><p>[2022-05-10]</p><ul><li>经<a href="/u/mochi-ds/">@mochi-ds</a> (@知心猛男) 指正，大幅更正了本文之前宣称「模版二」无法适用于「情形3」和「情形4」的相关内容（可以适用）。详情可见评论区，非常感谢「知心猛男」的指正。</li></ul><br />]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法与数据结构 </tag>
            
            <tag> 二分查找 </tag>
            
            <tag> 循环不变 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
